commit b9f3ef09e1e516e4f70421ab12e36633da960558
Author: Gyu-Ho Lee <gyuhox@gmail.com>
Date:   Mon Oct 10 11:02:13 2016 -0700

    vendor: clean up dependencies (remove unused ones)

diff --git a/cmd/vendor/github.com/cpuguy83/go-md2man/md2man.go b/cmd/vendor/github.com/cpuguy83/go-md2man/md2man.go
deleted file mode 100644
index 1dc70f4..0000000
--- a/cmd/vendor/github.com/cpuguy83/go-md2man/md2man.go
+++ /dev/null
@@ -1,44 +0,0 @@
-package main
-
-import (
-	"flag"
-	"fmt"
-	"io/ioutil"
-	"os"
-
-	"github.com/cpuguy83/go-md2man/md2man"
-)
-
-var inFilePath = flag.String("in", "", "Path to file to be processed")
-var outFilePath = flag.String("out", "", "Path to output processed file")
-
-func main() {
-	flag.Parse()
-
-	inFile, err := os.Open(*inFilePath)
-	if err != nil {
-		fmt.Println(err)
-		os.Exit(1)
-	}
-	defer inFile.Close()
-
-	doc, err := ioutil.ReadAll(inFile)
-	if err != nil {
-		fmt.Println(err)
-		os.Exit(1)
-	}
-
-	out := md2man.Render(doc)
-
-	outFile, err := os.Create(*outFilePath)
-	if err != nil {
-		fmt.Println(err)
-		os.Exit(1)
-	}
-	defer outFile.Close()
-	_, err = outFile.Write(out)
-	if err != nil {
-		fmt.Println(err)
-		os.Exit(1)
-	}
-}
diff --git a/cmd/vendor/github.com/golang/groupcache/byteview.go b/cmd/vendor/github.com/golang/groupcache/byteview.go
deleted file mode 100644
index 035a9ee..0000000
--- a/cmd/vendor/github.com/golang/groupcache/byteview.go
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
-Copyright 2012 Google Inc.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package groupcache
-
-import (
-	"bytes"
-	"errors"
-	"io"
-	"strings"
-)
-
-// A ByteView holds an immutable view of bytes.
-// Internally it wraps either a []byte or a string,
-// but that detail is invisible to callers.
-//
-// A ByteView is meant to be used as a value type, not
-// a pointer (like a time.Time).
-type ByteView struct {
-	// If b is non-nil, b is used, else s is used.
-	b []byte
-	s string
-}
-
-// Len returns the view's length.
-func (v ByteView) Len() int {
-	if v.b != nil {
-		return len(v.b)
-	}
-	return len(v.s)
-}
-
-// ByteSlice returns a copy of the data as a byte slice.
-func (v ByteView) ByteSlice() []byte {
-	if v.b != nil {
-		return cloneBytes(v.b)
-	}
-	return []byte(v.s)
-}
-
-// String returns the data as a string, making a copy if necessary.
-func (v ByteView) String() string {
-	if v.b != nil {
-		return string(v.b)
-	}
-	return v.s
-}
-
-// At returns the byte at index i.
-func (v ByteView) At(i int) byte {
-	if v.b != nil {
-		return v.b[i]
-	}
-	return v.s[i]
-}
-
-// Slice slices the view between the provided from and to indices.
-func (v ByteView) Slice(from, to int) ByteView {
-	if v.b != nil {
-		return ByteView{b: v.b[from:to]}
-	}
-	return ByteView{s: v.s[from:to]}
-}
-
-// SliceFrom slices the view from the provided index until the end.
-func (v ByteView) SliceFrom(from int) ByteView {
-	if v.b != nil {
-		return ByteView{b: v.b[from:]}
-	}
-	return ByteView{s: v.s[from:]}
-}
-
-// Copy copies b into dest and returns the number of bytes copied.
-func (v ByteView) Copy(dest []byte) int {
-	if v.b != nil {
-		return copy(dest, v.b)
-	}
-	return copy(dest, v.s)
-}
-
-// Equal returns whether the bytes in b are the same as the bytes in
-// b2.
-func (v ByteView) Equal(b2 ByteView) bool {
-	if b2.b == nil {
-		return v.EqualString(b2.s)
-	}
-	return v.EqualBytes(b2.b)
-}
-
-// EqualString returns whether the bytes in b are the same as the bytes
-// in s.
-func (v ByteView) EqualString(s string) bool {
-	if v.b == nil {
-		return v.s == s
-	}
-	l := v.Len()
-	if len(s) != l {
-		return false
-	}
-	for i, bi := range v.b {
-		if bi != s[i] {
-			return false
-		}
-	}
-	return true
-}
-
-// EqualBytes returns whether the bytes in b are the same as the bytes
-// in b2.
-func (v ByteView) EqualBytes(b2 []byte) bool {
-	if v.b != nil {
-		return bytes.Equal(v.b, b2)
-	}
-	l := v.Len()
-	if len(b2) != l {
-		return false
-	}
-	for i, bi := range b2 {
-		if bi != v.s[i] {
-			return false
-		}
-	}
-	return true
-}
-
-// Reader returns an io.ReadSeeker for the bytes in v.
-func (v ByteView) Reader() io.ReadSeeker {
-	if v.b != nil {
-		return bytes.NewReader(v.b)
-	}
-	return strings.NewReader(v.s)
-}
-
-// ReadAt implements io.ReaderAt on the bytes in v.
-func (v ByteView) ReadAt(p []byte, off int64) (n int, err error) {
-	if off < 0 {
-		return 0, errors.New("view: invalid offset")
-	}
-	if off >= int64(v.Len()) {
-		return 0, io.EOF
-	}
-	n = v.SliceFrom(int(off)).Copy(p)
-	if n < len(p) {
-		err = io.EOF
-	}
-	return
-}
diff --git a/cmd/vendor/github.com/golang/groupcache/groupcache.go b/cmd/vendor/github.com/golang/groupcache/groupcache.go
deleted file mode 100644
index 9499dbb..0000000
--- a/cmd/vendor/github.com/golang/groupcache/groupcache.go
+++ /dev/null
@@ -1,489 +0,0 @@
-/*
-Copyright 2012 Google Inc.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-// Package groupcache provides a data loading mechanism with caching
-// and de-duplication that works across a set of peer processes.
-//
-// Each data Get first consults its local cache, otherwise delegates
-// to the requested key's canonical owner, which then checks its cache
-// or finally gets the data.  In the common case, many concurrent
-// cache misses across a set of peers for the same key result in just
-// one cache fill.
-package groupcache
-
-import (
-	"errors"
-	"math/rand"
-	"strconv"
-	"sync"
-	"sync/atomic"
-
-	pb "github.com/golang/groupcache/groupcachepb"
-	"github.com/golang/groupcache/lru"
-	"github.com/golang/groupcache/singleflight"
-)
-
-// A Getter loads data for a key.
-type Getter interface {
-	// Get returns the value identified by key, populating dest.
-	//
-	// The returned data must be unversioned. That is, key must
-	// uniquely describe the loaded data, without an implicit
-	// current time, and without relying on cache expiration
-	// mechanisms.
-	Get(ctx Context, key string, dest Sink) error
-}
-
-// A GetterFunc implements Getter with a function.
-type GetterFunc func(ctx Context, key string, dest Sink) error
-
-func (f GetterFunc) Get(ctx Context, key string, dest Sink) error {
-	return f(ctx, key, dest)
-}
-
-var (
-	mu     sync.RWMutex
-	groups = make(map[string]*Group)
-
-	initPeerServerOnce sync.Once
-	initPeerServer     func()
-)
-
-// GetGroup returns the named group previously created with NewGroup, or
-// nil if there's no such group.
-func GetGroup(name string) *Group {
-	mu.RLock()
-	g := groups[name]
-	mu.RUnlock()
-	return g
-}
-
-// NewGroup creates a coordinated group-aware Getter from a Getter.
-//
-// The returned Getter tries (but does not guarantee) to run only one
-// Get call at once for a given key across an entire set of peer
-// processes. Concurrent callers both in the local process and in
-// other processes receive copies of the answer once the original Get
-// completes.
-//
-// The group name must be unique for each getter.
-func NewGroup(name string, cacheBytes int64, getter Getter) *Group {
-	return newGroup(name, cacheBytes, getter, nil)
-}
-
-// If peers is nil, the peerPicker is called via a sync.Once to initialize it.
-func newGroup(name string, cacheBytes int64, getter Getter, peers PeerPicker) *Group {
-	if getter == nil {
-		panic("nil Getter")
-	}
-	mu.Lock()
-	defer mu.Unlock()
-	initPeerServerOnce.Do(callInitPeerServer)
-	if _, dup := groups[name]; dup {
-		panic("duplicate registration of group " + name)
-	}
-	g := &Group{
-		name:       name,
-		getter:     getter,
-		peers:      peers,
-		cacheBytes: cacheBytes,
-		loadGroup:  &singleflight.Group{},
-	}
-	if fn := newGroupHook; fn != nil {
-		fn(g)
-	}
-	groups[name] = g
-	return g
-}
-
-// newGroupHook, if non-nil, is called right after a new group is created.
-var newGroupHook func(*Group)
-
-// RegisterNewGroupHook registers a hook that is run each time
-// a group is created.
-func RegisterNewGroupHook(fn func(*Group)) {
-	if newGroupHook != nil {
-		panic("RegisterNewGroupHook called more than once")
-	}
-	newGroupHook = fn
-}
-
-// RegisterServerStart registers a hook that is run when the first
-// group is created.
-func RegisterServerStart(fn func()) {
-	if initPeerServer != nil {
-		panic("RegisterServerStart called more than once")
-	}
-	initPeerServer = fn
-}
-
-func callInitPeerServer() {
-	if initPeerServer != nil {
-		initPeerServer()
-	}
-}
-
-// A Group is a cache namespace and associated data loaded spread over
-// a group of 1 or more machines.
-type Group struct {
-	name       string
-	getter     Getter
-	peersOnce  sync.Once
-	peers      PeerPicker
-	cacheBytes int64 // limit for sum of mainCache and hotCache size
-
-	// mainCache is a cache of the keys for which this process
-	// (amongst its peers) is authoritative. That is, this cache
-	// contains keys which consistent hash on to this process's
-	// peer number.
-	mainCache cache
-
-	// hotCache contains keys/values for which this peer is not
-	// authoritative (otherwise they would be in mainCache), but
-	// are popular enough to warrant mirroring in this process to
-	// avoid going over the network to fetch from a peer.  Having
-	// a hotCache avoids network hotspotting, where a peer's
-	// network card could become the bottleneck on a popular key.
-	// This cache is used sparingly to maximize the total number
-	// of key/value pairs that can be stored globally.
-	hotCache cache
-
-	// loadGroup ensures that each key is only fetched once
-	// (either locally or remotely), regardless of the number of
-	// concurrent callers.
-	loadGroup flightGroup
-
-	// Stats are statistics on the group.
-	Stats Stats
-}
-
-// flightGroup is defined as an interface which flightgroup.Group
-// satisfies.  We define this so that we may test with an alternate
-// implementation.
-type flightGroup interface {
-	// Done is called when Do is done.
-	Do(key string, fn func() (interface{}, error)) (interface{}, error)
-}
-
-// Stats are per-group statistics.
-type Stats struct {
-	Gets           AtomicInt // any Get request, including from peers
-	CacheHits      AtomicInt // either cache was good
-	PeerLoads      AtomicInt // either remote load or remote cache hit (not an error)
-	PeerErrors     AtomicInt
-	Loads          AtomicInt // (gets - cacheHits)
-	LoadsDeduped   AtomicInt // after singleflight
-	LocalLoads     AtomicInt // total good local loads
-	LocalLoadErrs  AtomicInt // total bad local loads
-	ServerRequests AtomicInt // gets that came over the network from peers
-}
-
-// Name returns the name of the group.
-func (g *Group) Name() string {
-	return g.name
-}
-
-func (g *Group) initPeers() {
-	if g.peers == nil {
-		g.peers = getPeers()
-	}
-}
-
-func (g *Group) Get(ctx Context, key string, dest Sink) error {
-	g.peersOnce.Do(g.initPeers)
-	g.Stats.Gets.Add(1)
-	if dest == nil {
-		return errors.New("groupcache: nil dest Sink")
-	}
-	value, cacheHit := g.lookupCache(key)
-
-	if cacheHit {
-		g.Stats.CacheHits.Add(1)
-		return setSinkView(dest, value)
-	}
-
-	// Optimization to avoid double unmarshalling or copying: keep
-	// track of whether the dest was already populated. One caller
-	// (if local) will set this; the losers will not. The common
-	// case will likely be one caller.
-	destPopulated := false
-	value, destPopulated, err := g.load(ctx, key, dest)
-	if err != nil {
-		return err
-	}
-	if destPopulated {
-		return nil
-	}
-	return setSinkView(dest, value)
-}
-
-// load loads key either by invoking the getter locally or by sending it to another machine.
-func (g *Group) load(ctx Context, key string, dest Sink) (value ByteView, destPopulated bool, err error) {
-	g.Stats.Loads.Add(1)
-	viewi, err := g.loadGroup.Do(key, func() (interface{}, error) {
-		// Check the cache again because singleflight can only dedup calls
-		// that overlap concurrently.  It's possible for 2 concurrent
-		// requests to miss the cache, resulting in 2 load() calls.  An
-		// unfortunate goroutine scheduling would result in this callback
-		// being run twice, serially.  If we don't check the cache again,
-		// cache.nbytes would be incremented below even though there will
-		// be only one entry for this key.
-		//
-		// Consider the following serialized event ordering for two
-		// goroutines in which this callback gets called twice for hte
-		// same key:
-		// 1: Get("key")
-		// 2: Get("key")
-		// 1: lookupCache("key")
-		// 2: lookupCache("key")
-		// 1: load("key")
-		// 2: load("key")
-		// 1: loadGroup.Do("key", fn)
-		// 1: fn()
-		// 2: loadGroup.Do("key", fn)
-		// 2: fn()
-		if value, cacheHit := g.lookupCache(key); cacheHit {
-			g.Stats.CacheHits.Add(1)
-			return value, nil
-		}
-		g.Stats.LoadsDeduped.Add(1)
-		var value ByteView
-		var err error
-		if peer, ok := g.peers.PickPeer(key); ok {
-			value, err = g.getFromPeer(ctx, peer, key)
-			if err == nil {
-				g.Stats.PeerLoads.Add(1)
-				return value, nil
-			}
-			g.Stats.PeerErrors.Add(1)
-			// TODO(bradfitz): log the peer's error? keep
-			// log of the past few for /groupcachez?  It's
-			// probably boring (normal task movement), so not
-			// worth logging I imagine.
-		}
-		value, err = g.getLocally(ctx, key, dest)
-		if err != nil {
-			g.Stats.LocalLoadErrs.Add(1)
-			return nil, err
-		}
-		g.Stats.LocalLoads.Add(1)
-		destPopulated = true // only one caller of load gets this return value
-		g.populateCache(key, value, &g.mainCache)
-		return value, nil
-	})
-	if err == nil {
-		value = viewi.(ByteView)
-	}
-	return
-}
-
-func (g *Group) getLocally(ctx Context, key string, dest Sink) (ByteView, error) {
-	err := g.getter.Get(ctx, key, dest)
-	if err != nil {
-		return ByteView{}, err
-	}
-	return dest.view()
-}
-
-func (g *Group) getFromPeer(ctx Context, peer ProtoGetter, key string) (ByteView, error) {
-	req := &pb.GetRequest{
-		Group: &g.name,
-		Key:   &key,
-	}
-	res := &pb.GetResponse{}
-	err := peer.Get(ctx, req, res)
-	if err != nil {
-		return ByteView{}, err
-	}
-	value := ByteView{b: res.Value}
-	// TODO(bradfitz): use res.MinuteQps or something smart to
-	// conditionally populate hotCache.  For now just do it some
-	// percentage of the time.
-	if rand.Intn(10) == 0 {
-		g.populateCache(key, value, &g.hotCache)
-	}
-	return value, nil
-}
-
-func (g *Group) lookupCache(key string) (value ByteView, ok bool) {
-	if g.cacheBytes <= 0 {
-		return
-	}
-	value, ok = g.mainCache.get(key)
-	if ok {
-		return
-	}
-	value, ok = g.hotCache.get(key)
-	return
-}
-
-func (g *Group) populateCache(key string, value ByteView, cache *cache) {
-	if g.cacheBytes <= 0 {
-		return
-	}
-	cache.add(key, value)
-
-	// Evict items from cache(s) if necessary.
-	for {
-		mainBytes := g.mainCache.bytes()
-		hotBytes := g.hotCache.bytes()
-		if mainBytes+hotBytes <= g.cacheBytes {
-			return
-		}
-
-		// TODO(bradfitz): this is good-enough-for-now logic.
-		// It should be something based on measurements and/or
-		// respecting the costs of different resources.
-		victim := &g.mainCache
-		if hotBytes > mainBytes/8 {
-			victim = &g.hotCache
-		}
-		victim.removeOldest()
-	}
-}
-
-// CacheType represents a type of cache.
-type CacheType int
-
-const (
-	// The MainCache is the cache for items that this peer is the
-	// owner for.
-	MainCache CacheType = iota + 1
-
-	// The HotCache is the cache for items that seem popular
-	// enough to replicate to this node, even though it's not the
-	// owner.
-	HotCache
-)
-
-// CacheStats returns stats about the provided cache within the group.
-func (g *Group) CacheStats(which CacheType) CacheStats {
-	switch which {
-	case MainCache:
-		return g.mainCache.stats()
-	case HotCache:
-		return g.hotCache.stats()
-	default:
-		return CacheStats{}
-	}
-}
-
-// cache is a wrapper around an *lru.Cache that adds synchronization,
-// makes values always be ByteView, and counts the size of all keys and
-// values.
-type cache struct {
-	mu         sync.RWMutex
-	nbytes     int64 // of all keys and values
-	lru        *lru.Cache
-	nhit, nget int64
-	nevict     int64 // number of evictions
-}
-
-func (c *cache) stats() CacheStats {
-	c.mu.RLock()
-	defer c.mu.RUnlock()
-	return CacheStats{
-		Bytes:     c.nbytes,
-		Items:     c.itemsLocked(),
-		Gets:      c.nget,
-		Hits:      c.nhit,
-		Evictions: c.nevict,
-	}
-}
-
-func (c *cache) add(key string, value ByteView) {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	if c.lru == nil {
-		c.lru = &lru.Cache{
-			OnEvicted: func(key lru.Key, value interface{}) {
-				val := value.(ByteView)
-				c.nbytes -= int64(len(key.(string))) + int64(val.Len())
-				c.nevict++
-			},
-		}
-	}
-	c.lru.Add(key, value)
-	c.nbytes += int64(len(key)) + int64(value.Len())
-}
-
-func (c *cache) get(key string) (value ByteView, ok bool) {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	c.nget++
-	if c.lru == nil {
-		return
-	}
-	vi, ok := c.lru.Get(key)
-	if !ok {
-		return
-	}
-	c.nhit++
-	return vi.(ByteView), true
-}
-
-func (c *cache) removeOldest() {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	if c.lru != nil {
-		c.lru.RemoveOldest()
-	}
-}
-
-func (c *cache) bytes() int64 {
-	c.mu.RLock()
-	defer c.mu.RUnlock()
-	return c.nbytes
-}
-
-func (c *cache) items() int64 {
-	c.mu.RLock()
-	defer c.mu.RUnlock()
-	return c.itemsLocked()
-}
-
-func (c *cache) itemsLocked() int64 {
-	if c.lru == nil {
-		return 0
-	}
-	return int64(c.lru.Len())
-}
-
-// An AtomicInt is an int64 to be accessed atomically.
-type AtomicInt int64
-
-// Add atomically adds n to i.
-func (i *AtomicInt) Add(n int64) {
-	atomic.AddInt64((*int64)(i), n)
-}
-
-// Get atomically gets the value of i.
-func (i *AtomicInt) Get() int64 {
-	return atomic.LoadInt64((*int64)(i))
-}
-
-func (i *AtomicInt) String() string {
-	return strconv.FormatInt(i.Get(), 10)
-}
-
-// CacheStats are returned by stats accessors on Group.
-type CacheStats struct {
-	Bytes     int64
-	Items     int64
-	Gets      int64
-	Hits      int64
-	Evictions int64
-}
diff --git a/cmd/vendor/github.com/golang/groupcache/http.go b/cmd/vendor/github.com/golang/groupcache/http.go
deleted file mode 100644
index 14eb345..0000000
--- a/cmd/vendor/github.com/golang/groupcache/http.go
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
-Copyright 2013 Google Inc.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package groupcache
-
-import (
-	"bytes"
-	"fmt"
-	"io"
-	"net/http"
-	"net/url"
-	"strings"
-	"sync"
-
-	"github.com/golang/groupcache/consistenthash"
-	pb "github.com/golang/groupcache/groupcachepb"
-	"github.com/golang/protobuf/proto"
-)
-
-const defaultBasePath = "/_groupcache/"
-
-const defaultReplicas = 50
-
-// HTTPPool implements PeerPicker for a pool of HTTP peers.
-type HTTPPool struct {
-	// Context optionally specifies a context for the server to use when it
-	// receives a request.
-	// If nil, the server uses a nil Context.
-	Context func(*http.Request) Context
-
-	// Transport optionally specifies an http.RoundTripper for the client
-	// to use when it makes a request.
-	// If nil, the client uses http.DefaultTransport.
-	Transport func(Context) http.RoundTripper
-
-	// this peer's base URL, e.g. "https://example.net:8000"
-	self string
-
-	// opts specifies the options.
-	opts HTTPPoolOptions
-
-	mu          sync.Mutex // guards peers and httpGetters
-	peers       *consistenthash.Map
-	httpGetters map[string]*httpGetter // keyed by e.g. "http://10.0.0.2:8008"
-}
-
-// HTTPPoolOptions are the configurations of a HTTPPool.
-type HTTPPoolOptions struct {
-	// BasePath specifies the HTTP path that will serve groupcache requests.
-	// If blank, it defaults to "/_groupcache/".
-	BasePath string
-
-	// Replicas specifies the number of key replicas on the consistent hash.
-	// If blank, it defaults to 50.
-	Replicas int
-
-	// HashFn specifies the hash function of the consistent hash.
-	// If blank, it defaults to crc32.ChecksumIEEE.
-	HashFn consistenthash.Hash
-}
-
-// NewHTTPPool initializes an HTTP pool of peers, and registers itself as a PeerPicker.
-// For convenience, it also registers itself as an http.Handler with http.DefaultServeMux.
-// The self argument be a valid base URL that points to the current server,
-// for example "http://example.net:8000".
-func NewHTTPPool(self string) *HTTPPool {
-	p := NewHTTPPoolOpts(self, nil)
-	http.Handle(p.opts.BasePath, p)
-	return p
-}
-
-var httpPoolMade bool
-
-// NewHTTPPoolOpts initializes an HTTP pool of peers with the given options.
-// Unlike NewHTTPPool, this function does not register the created pool as an HTTP handler.
-// The returned *HTTPPool implements http.Handler and must be registered using http.Handle.
-func NewHTTPPoolOpts(self string, o *HTTPPoolOptions) *HTTPPool {
-	if httpPoolMade {
-		panic("groupcache: NewHTTPPool must be called only once")
-	}
-	httpPoolMade = true
-
-	p := &HTTPPool{
-		self:        self,
-		httpGetters: make(map[string]*httpGetter),
-	}
-	if o != nil {
-		p.opts = *o
-	}
-	if p.opts.BasePath == "" {
-		p.opts.BasePath = defaultBasePath
-	}
-	if p.opts.Replicas == 0 {
-		p.opts.Replicas = defaultReplicas
-	}
-	p.peers = consistenthash.New(p.opts.Replicas, p.opts.HashFn)
-
-	RegisterPeerPicker(func() PeerPicker { return p })
-	return p
-}
-
-// Set updates the pool's list of peers.
-// Each peer value should be a valid base URL,
-// for example "http://example.net:8000".
-func (p *HTTPPool) Set(peers ...string) {
-	p.mu.Lock()
-	defer p.mu.Unlock()
-	p.peers = consistenthash.New(p.opts.Replicas, p.opts.HashFn)
-	p.peers.Add(peers...)
-	p.httpGetters = make(map[string]*httpGetter, len(peers))
-	for _, peer := range peers {
-		p.httpGetters[peer] = &httpGetter{transport: p.Transport, baseURL: peer + p.opts.BasePath}
-	}
-}
-
-func (p *HTTPPool) PickPeer(key string) (ProtoGetter, bool) {
-	p.mu.Lock()
-	defer p.mu.Unlock()
-	if p.peers.IsEmpty() {
-		return nil, false
-	}
-	if peer := p.peers.Get(key); peer != p.self {
-		return p.httpGetters[peer], true
-	}
-	return nil, false
-}
-
-func (p *HTTPPool) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-	// Parse request.
-	if !strings.HasPrefix(r.URL.Path, p.opts.BasePath) {
-		panic("HTTPPool serving unexpected path: " + r.URL.Path)
-	}
-	parts := strings.SplitN(r.URL.Path[len(p.opts.BasePath):], "/", 2)
-	if len(parts) != 2 {
-		http.Error(w, "bad request", http.StatusBadRequest)
-		return
-	}
-	groupName := parts[0]
-	key := parts[1]
-
-	// Fetch the value for this group/key.
-	group := GetGroup(groupName)
-	if group == nil {
-		http.Error(w, "no such group: "+groupName, http.StatusNotFound)
-		return
-	}
-	var ctx Context
-	if p.Context != nil {
-		ctx = p.Context(r)
-	}
-
-	group.Stats.ServerRequests.Add(1)
-	var value []byte
-	err := group.Get(ctx, key, AllocatingByteSliceSink(&value))
-	if err != nil {
-		http.Error(w, err.Error(), http.StatusInternalServerError)
-		return
-	}
-
-	// Write the value to the response body as a proto message.
-	body, err := proto.Marshal(&pb.GetResponse{Value: value})
-	if err != nil {
-		http.Error(w, err.Error(), http.StatusInternalServerError)
-		return
-	}
-	w.Header().Set("Content-Type", "application/x-protobuf")
-	w.Write(body)
-}
-
-type httpGetter struct {
-	transport func(Context) http.RoundTripper
-	baseURL   string
-}
-
-var bufferPool = sync.Pool{
-	New: func() interface{} { return new(bytes.Buffer) },
-}
-
-func (h *httpGetter) Get(context Context, in *pb.GetRequest, out *pb.GetResponse) error {
-	u := fmt.Sprintf(
-		"%v%v/%v",
-		h.baseURL,
-		url.QueryEscape(in.GetGroup()),
-		url.QueryEscape(in.GetKey()),
-	)
-	req, err := http.NewRequest("GET", u, nil)
-	if err != nil {
-		return err
-	}
-	tr := http.DefaultTransport
-	if h.transport != nil {
-		tr = h.transport(context)
-	}
-	res, err := tr.RoundTrip(req)
-	if err != nil {
-		return err
-	}
-	defer res.Body.Close()
-	if res.StatusCode != http.StatusOK {
-		return fmt.Errorf("server returned: %v", res.Status)
-	}
-	b := bufferPool.Get().(*bytes.Buffer)
-	b.Reset()
-	defer bufferPool.Put(b)
-	_, err = io.Copy(b, res.Body)
-	if err != nil {
-		return fmt.Errorf("reading response body: %v", err)
-	}
-	err = proto.Unmarshal(b.Bytes(), out)
-	if err != nil {
-		return fmt.Errorf("decoding response body: %v", err)
-	}
-	return nil
-}
diff --git a/cmd/vendor/github.com/golang/groupcache/peers.go b/cmd/vendor/github.com/golang/groupcache/peers.go
deleted file mode 100644
index a74a79b..0000000
--- a/cmd/vendor/github.com/golang/groupcache/peers.go
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
-Copyright 2012 Google Inc.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-// peers.go defines how processes find and communicate with their peers.
-
-package groupcache
-
-import (
-	pb "github.com/golang/groupcache/groupcachepb"
-)
-
-// Context is an opaque value passed through calls to the
-// ProtoGetter. It may be nil if your ProtoGetter implementation does
-// not require a context.
-type Context interface{}
-
-// ProtoGetter is the interface that must be implemented by a peer.
-type ProtoGetter interface {
-	Get(context Context, in *pb.GetRequest, out *pb.GetResponse) error
-}
-
-// PeerPicker is the interface that must be implemented to locate
-// the peer that owns a specific key.
-type PeerPicker interface {
-	// PickPeer returns the peer that owns the specific key
-	// and true to indicate that a remote peer was nominated.
-	// It returns nil, false if the key owner is the current peer.
-	PickPeer(key string) (peer ProtoGetter, ok bool)
-}
-
-// NoPeers is an implementation of PeerPicker that never finds a peer.
-type NoPeers struct{}
-
-func (NoPeers) PickPeer(key string) (peer ProtoGetter, ok bool) { return }
-
-var (
-	portPicker func() PeerPicker
-)
-
-// RegisterPeerPicker registers the peer initialization function.
-// It is called once, when the first group is created.
-func RegisterPeerPicker(fn func() PeerPicker) {
-	if portPicker != nil {
-		panic("RegisterPeerPicker called more than once")
-	}
-	portPicker = fn
-}
-
-func getPeers() PeerPicker {
-	if portPicker == nil {
-		return NoPeers{}
-	}
-	pk := portPicker()
-	if pk == nil {
-		pk = NoPeers{}
-	}
-	return pk
-}
diff --git a/cmd/vendor/github.com/golang/groupcache/sinks.go b/cmd/vendor/github.com/golang/groupcache/sinks.go
deleted file mode 100644
index cb42b41..0000000
--- a/cmd/vendor/github.com/golang/groupcache/sinks.go
+++ /dev/null
@@ -1,322 +0,0 @@
-/*
-Copyright 2012 Google Inc.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package groupcache
-
-import (
-	"errors"
-
-	"github.com/golang/protobuf/proto"
-)
-
-// A Sink receives data from a Get call.
-//
-// Implementation of Getter must call exactly one of the Set methods
-// on success.
-type Sink interface {
-	// SetString sets the value to s.
-	SetString(s string) error
-
-	// SetBytes sets the value to the contents of v.
-	// The caller retains ownership of v.
-	SetBytes(v []byte) error
-
-	// SetProto sets the value to the encoded version of m.
-	// The caller retains ownership of m.
-	SetProto(m proto.Message) error
-
-	// view returns a frozen view of the bytes for caching.
-	view() (ByteView, error)
-}
-
-func cloneBytes(b []byte) []byte {
-	c := make([]byte, len(b))
-	copy(c, b)
-	return c
-}
-
-func setSinkView(s Sink, v ByteView) error {
-	// A viewSetter is a Sink that can also receive its value from
-	// a ByteView. This is a fast path to minimize copies when the
-	// item was already cached locally in memory (where it's
-	// cached as a ByteView)
-	type viewSetter interface {
-		setView(v ByteView) error
-	}
-	if vs, ok := s.(viewSetter); ok {
-		return vs.setView(v)
-	}
-	if v.b != nil {
-		return s.SetBytes(v.b)
-	}
-	return s.SetString(v.s)
-}
-
-// StringSink returns a Sink that populates the provided string pointer.
-func StringSink(sp *string) Sink {
-	return &stringSink{sp: sp}
-}
-
-type stringSink struct {
-	sp *string
-	v  ByteView
-	// TODO(bradfitz): track whether any Sets were called.
-}
-
-func (s *stringSink) view() (ByteView, error) {
-	// TODO(bradfitz): return an error if no Set was called
-	return s.v, nil
-}
-
-func (s *stringSink) SetString(v string) error {
-	s.v.b = nil
-	s.v.s = v
-	*s.sp = v
-	return nil
-}
-
-func (s *stringSink) SetBytes(v []byte) error {
-	return s.SetString(string(v))
-}
-
-func (s *stringSink) SetProto(m proto.Message) error {
-	b, err := proto.Marshal(m)
-	if err != nil {
-		return err
-	}
-	s.v.b = b
-	*s.sp = string(b)
-	return nil
-}
-
-// ByteViewSink returns a Sink that populates a ByteView.
-func ByteViewSink(dst *ByteView) Sink {
-	if dst == nil {
-		panic("nil dst")
-	}
-	return &byteViewSink{dst: dst}
-}
-
-type byteViewSink struct {
-	dst *ByteView
-
-	// if this code ever ends up tracking that at least one set*
-	// method was called, don't make it an error to call set
-	// methods multiple times. Lorry's payload.go does that, and
-	// it makes sense. The comment at the top of this file about
-	// "exactly one of the Set methods" is overly strict. We
-	// really care about at least once (in a handler), but if
-	// multiple handlers fail (or multiple functions in a program
-	// using a Sink), it's okay to re-use the same one.
-}
-
-func (s *byteViewSink) setView(v ByteView) error {
-	*s.dst = v
-	return nil
-}
-
-func (s *byteViewSink) view() (ByteView, error) {
-	return *s.dst, nil
-}
-
-func (s *byteViewSink) SetProto(m proto.Message) error {
-	b, err := proto.Marshal(m)
-	if err != nil {
-		return err
-	}
-	*s.dst = ByteView{b: b}
-	return nil
-}
-
-func (s *byteViewSink) SetBytes(b []byte) error {
-	*s.dst = ByteView{b: cloneBytes(b)}
-	return nil
-}
-
-func (s *byteViewSink) SetString(v string) error {
-	*s.dst = ByteView{s: v}
-	return nil
-}
-
-// ProtoSink returns a sink that unmarshals binary proto values into m.
-func ProtoSink(m proto.Message) Sink {
-	return &protoSink{
-		dst: m,
-	}
-}
-
-type protoSink struct {
-	dst proto.Message // authorative value
-	typ string
-
-	v ByteView // encoded
-}
-
-func (s *protoSink) view() (ByteView, error) {
-	return s.v, nil
-}
-
-func (s *protoSink) SetBytes(b []byte) error {
-	err := proto.Unmarshal(b, s.dst)
-	if err != nil {
-		return err
-	}
-	s.v.b = cloneBytes(b)
-	s.v.s = ""
-	return nil
-}
-
-func (s *protoSink) SetString(v string) error {
-	b := []byte(v)
-	err := proto.Unmarshal(b, s.dst)
-	if err != nil {
-		return err
-	}
-	s.v.b = b
-	s.v.s = ""
-	return nil
-}
-
-func (s *protoSink) SetProto(m proto.Message) error {
-	b, err := proto.Marshal(m)
-	if err != nil {
-		return err
-	}
-	// TODO(bradfitz): optimize for same-task case more and write
-	// right through? would need to document ownership rules at
-	// the same time. but then we could just assign *dst = *m
-	// here. This works for now:
-	err = proto.Unmarshal(b, s.dst)
-	if err != nil {
-		return err
-	}
-	s.v.b = b
-	s.v.s = ""
-	return nil
-}
-
-// AllocatingByteSliceSink returns a Sink that allocates
-// a byte slice to hold the received value and assigns
-// it to *dst. The memory is not retained by groupcache.
-func AllocatingByteSliceSink(dst *[]byte) Sink {
-	return &allocBytesSink{dst: dst}
-}
-
-type allocBytesSink struct {
-	dst *[]byte
-	v   ByteView
-}
-
-func (s *allocBytesSink) view() (ByteView, error) {
-	return s.v, nil
-}
-
-func (s *allocBytesSink) setView(v ByteView) error {
-	if v.b != nil {
-		*s.dst = cloneBytes(v.b)
-	} else {
-		*s.dst = []byte(v.s)
-	}
-	s.v = v
-	return nil
-}
-
-func (s *allocBytesSink) SetProto(m proto.Message) error {
-	b, err := proto.Marshal(m)
-	if err != nil {
-		return err
-	}
-	return s.setBytesOwned(b)
-}
-
-func (s *allocBytesSink) SetBytes(b []byte) error {
-	return s.setBytesOwned(cloneBytes(b))
-}
-
-func (s *allocBytesSink) setBytesOwned(b []byte) error {
-	if s.dst == nil {
-		return errors.New("nil AllocatingByteSliceSink *[]byte dst")
-	}
-	*s.dst = cloneBytes(b) // another copy, protecting the read-only s.v.b view
-	s.v.b = b
-	s.v.s = ""
-	return nil
-}
-
-func (s *allocBytesSink) SetString(v string) error {
-	if s.dst == nil {
-		return errors.New("nil AllocatingByteSliceSink *[]byte dst")
-	}
-	*s.dst = []byte(v)
-	s.v.b = nil
-	s.v.s = v
-	return nil
-}
-
-// TruncatingByteSliceSink returns a Sink that writes up to len(*dst)
-// bytes to *dst. If more bytes are available, they're silently
-// truncated. If fewer bytes are available than len(*dst), *dst
-// is shrunk to fit the number of bytes available.
-func TruncatingByteSliceSink(dst *[]byte) Sink {
-	return &truncBytesSink{dst: dst}
-}
-
-type truncBytesSink struct {
-	dst *[]byte
-	v   ByteView
-}
-
-func (s *truncBytesSink) view() (ByteView, error) {
-	return s.v, nil
-}
-
-func (s *truncBytesSink) SetProto(m proto.Message) error {
-	b, err := proto.Marshal(m)
-	if err != nil {
-		return err
-	}
-	return s.setBytesOwned(b)
-}
-
-func (s *truncBytesSink) SetBytes(b []byte) error {
-	return s.setBytesOwned(cloneBytes(b))
-}
-
-func (s *truncBytesSink) setBytesOwned(b []byte) error {
-	if s.dst == nil {
-		return errors.New("nil TruncatingByteSliceSink *[]byte dst")
-	}
-	n := copy(*s.dst, b)
-	if n < len(*s.dst) {
-		*s.dst = (*s.dst)[:n]
-	}
-	s.v.b = b
-	s.v.s = ""
-	return nil
-}
-
-func (s *truncBytesSink) SetString(v string) error {
-	if s.dst == nil {
-		return errors.New("nil TruncatingByteSliceSink *[]byte dst")
-	}
-	n := copy(*s.dst, v)
-	if n < len(*s.dst) {
-		*s.dst = (*s.dst)[:n]
-	}
-	s.v.b = nil
-	s.v.s = v
-	return nil
-}
diff --git a/glide.lock b/glide.lock
index a3b41fe..279d694 100644
--- a/glide.lock
+++ b/glide.lock
@@ -1,5 +1,5 @@
-hash: 0e7d50c7716873a35f2d14542747525a35af1e5bb734b3696bc1ff78d30107b4
-updated: 2016-09-23T12:52:52.300796603-07:00
+hash: 8363b260167c451ce8e3863fe01e234808b4598d1025ceefb8bdb11fb0ce83ca
+updated: 2016-10-10T10:59:55.934552225-07:00
 imports:
 - name: bitbucket.org/ww/goautoneg
   version: 75cd24fc2f2c2a2088577d12123ddee5f54e0675
@@ -100,10 +100,6 @@ imports:
   version: 1c44ec8d3f1552cac48999f9306da23c4d8a288b
 - name: github.com/spf13/pflag
   version: 08b1a584251b5b62f458943640fc8ebd4d50aaa5
-- name: github.com/stretchr/testify
-  version: 9cc77fa25329013ce07362c7742952ff887361f2
-  subpackages:
-  - assert
 - name: github.com/ugorji/go
   version: f1f1a805ed361a0e078bb537e4ea78cd37dcf065
   subpackages:
@@ -148,4 +144,9 @@ imports:
   version: 29ad9b62f9e0274422d738242b94a5b89440bfa6
 - name: gopkg.in/yaml.v2
   version: 53feefa2559fb8dfa8d81baad31be332c97d6c77
-testImports: []
+testImports:
+- name: github.com/stretchr/testify
+  version: ""
+  repo: https://github.com/stretchr/testify.git
+  subpackages:
+  - assert
diff --git a/glide.yaml b/glide.yaml
index 03eba77..895e966 100644
--- a/glide.yaml
+++ b/glide.yaml
@@ -98,10 +98,6 @@ import:
   version: 1c44ec8d3f1552cac48999f9306da23c4d8a288b
 - package: github.com/spf13/pflag
   version: 08b1a584251b5b62f458943640fc8ebd4d50aaa5
-- package: github.com/stretchr/testify
-  version: 9cc77fa25329013ce07362c7742952ff887361f2
-  subpackages:
-  - assert
 - package: github.com/ugorji/go
   version: f1f1a805ed361a0e078bb537e4ea78cd37dcf065
   subpackages:
@@ -146,3 +142,10 @@ import:
   version: 29ad9b62f9e0274422d738242b94a5b89440bfa6
 - package: gopkg.in/yaml.v2
   version: 53feefa2559fb8dfa8d81baad31be332c97d6c77
+testImport:
+- package: github.com/stretchr/testify
+  repo: https://github.com/stretchr/testify.git
+  version: 976c720a22c8eb4eb6a0b4348ad85ad12491a506
+  subpackages:
+  - assert
+
