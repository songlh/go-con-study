commit 880835c02c2106a0084f18ab7720f21193371a9e
Author: Gyuho Lee <gyuhox@gmail.com>
Date:   Fri Jan 26 11:06:22 2018 -0800

    *: move "store" to "internal/store"
    
    Signed-off-by: Gyuho Lee <gyuhox@gmail.com>

diff --git a/etcdctl/ctlv3/command/migrate_command.go b/etcdctl/ctlv3/command/migrate_command.go
index f9e28eb..f7db0be 100644
--- a/etcdctl/ctlv3/command/migrate_command.go
+++ b/etcdctl/ctlv3/command/migrate_command.go
@@ -31,13 +31,13 @@ import (
 	pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
 	"github.com/coreos/etcd/etcdserver/membership"
 	"github.com/coreos/etcd/internal/raftsnap"
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/mvcc"
 	"github.com/coreos/etcd/mvcc/backend"
 	"github.com/coreos/etcd/mvcc/mvccpb"
 	"github.com/coreos/etcd/pkg/pbutil"
 	"github.com/coreos/etcd/pkg/types"
 	"github.com/coreos/etcd/raft/raftpb"
-	"github.com/coreos/etcd/store"
 	"github.com/coreos/etcd/wal"
 	"github.com/coreos/etcd/wal/walpb"
 	"github.com/gogo/protobuf/proto"
diff --git a/etcdserver/api/v2http/client.go b/etcdserver/api/v2http/client.go
index 6aaf3db..f40c410 100644
--- a/etcdserver/api/v2http/client.go
+++ b/etcdserver/api/v2http/client.go
@@ -36,8 +36,8 @@ import (
 	"github.com/coreos/etcd/etcdserver/etcdserverpb"
 	"github.com/coreos/etcd/etcdserver/membership"
 	"github.com/coreos/etcd/etcdserver/stats"
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/pkg/types"
-	"github.com/coreos/etcd/store"
 
 	"github.com/jonboulle/clockwork"
 )
diff --git a/etcdserver/api/v2http/client_test.go b/etcdserver/api/v2http/client_test.go
index 44448d0..fa6c2d3 100644
--- a/etcdserver/api/v2http/client_test.go
+++ b/etcdserver/api/v2http/client_test.go
@@ -35,10 +35,10 @@ import (
 	"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
 	"github.com/coreos/etcd/etcdserver/etcdserverpb"
 	"github.com/coreos/etcd/etcdserver/membership"
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/pkg/testutil"
 	"github.com/coreos/etcd/pkg/types"
 	"github.com/coreos/etcd/raft/raftpb"
-	"github.com/coreos/etcd/store"
 
 	"github.com/coreos/go-semver/semver"
 	"github.com/jonboulle/clockwork"
diff --git a/etcdserver/api/v2v3/store.go b/etcdserver/api/v2v3/store.go
index 444f93f..5585065 100644
--- a/etcdserver/api/v2v3/store.go
+++ b/etcdserver/api/v2v3/store.go
@@ -24,8 +24,8 @@ import (
 	"github.com/coreos/etcd/clientv3"
 	"github.com/coreos/etcd/clientv3/concurrency"
 	etcdErr "github.com/coreos/etcd/error"
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/mvcc/mvccpb"
-	"github.com/coreos/etcd/store"
 )
 
 // store implements the Store interface for V2 using
diff --git a/etcdserver/api/v2v3/watcher.go b/etcdserver/api/v2v3/watcher.go
index 1c2680e..b421d0c 100644
--- a/etcdserver/api/v2v3/watcher.go
+++ b/etcdserver/api/v2v3/watcher.go
@@ -20,7 +20,7 @@ import (
 
 	"github.com/coreos/etcd/clientv3"
 	etcdErr "github.com/coreos/etcd/error"
-	"github.com/coreos/etcd/store"
+	"github.com/coreos/etcd/internal/store"
 )
 
 func (s *v2v3Store) Watch(prefix string, recursive, stream bool, sinceIndex uint64) (store.Watcher, error) {
diff --git a/etcdserver/apply_v2.go b/etcdserver/apply_v2.go
index aefe19d..4607d09 100644
--- a/etcdserver/apply_v2.go
+++ b/etcdserver/apply_v2.go
@@ -21,8 +21,8 @@ import (
 
 	"github.com/coreos/etcd/etcdserver/api"
 	"github.com/coreos/etcd/etcdserver/membership"
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/pkg/pbutil"
-	"github.com/coreos/etcd/store"
 	"github.com/coreos/go-semver/semver"
 )
 
diff --git a/etcdserver/auth/auth_test.go b/etcdserver/auth/auth_test.go
index ad32260..b484cc1 100644
--- a/etcdserver/auth/auth_test.go
+++ b/etcdserver/auth/auth_test.go
@@ -23,7 +23,7 @@ import (
 	etcderr "github.com/coreos/etcd/error"
 	"github.com/coreos/etcd/etcdserver"
 	"github.com/coreos/etcd/etcdserver/etcdserverpb"
-	etcdstore "github.com/coreos/etcd/store"
+	etcdstore "github.com/coreos/etcd/internal/store"
 )
 
 type fakeDoer struct{}
diff --git a/etcdserver/membership/cluster.go b/etcdserver/membership/cluster.go
index 4f0b157..4aa9396 100644
--- a/etcdserver/membership/cluster.go
+++ b/etcdserver/membership/cluster.go
@@ -27,12 +27,12 @@ import (
 	"sync"
 	"time"
 
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/mvcc/backend"
 	"github.com/coreos/etcd/pkg/netutil"
 	"github.com/coreos/etcd/pkg/types"
 	"github.com/coreos/etcd/raft"
 	"github.com/coreos/etcd/raft/raftpb"
-	"github.com/coreos/etcd/store"
 	"github.com/coreos/etcd/version"
 
 	"github.com/coreos/go-semver/semver"
diff --git a/etcdserver/membership/cluster_test.go b/etcdserver/membership/cluster_test.go
index c2ffd25..baf55a5 100644
--- a/etcdserver/membership/cluster_test.go
+++ b/etcdserver/membership/cluster_test.go
@@ -21,11 +21,11 @@ import (
 	"reflect"
 	"testing"
 
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/pkg/mock/mockstore"
 	"github.com/coreos/etcd/pkg/testutil"
 	"github.com/coreos/etcd/pkg/types"
 	"github.com/coreos/etcd/raft/raftpb"
-	"github.com/coreos/etcd/store"
 )
 
 func TestClusterMember(t *testing.T) {
diff --git a/etcdserver/membership/store.go b/etcdserver/membership/store.go
index d3f8f24..5e878a4 100644
--- a/etcdserver/membership/store.go
+++ b/etcdserver/membership/store.go
@@ -19,9 +19,9 @@ import (
 	"fmt"
 	"path"
 
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/mvcc/backend"
 	"github.com/coreos/etcd/pkg/types"
-	"github.com/coreos/etcd/store"
 
 	"github.com/coreos/go-semver/semver"
 )
diff --git a/etcdserver/server.go b/etcdserver/server.go
index b1f49eb..c3ad2d4 100644
--- a/etcdserver/server.go
+++ b/etcdserver/server.go
@@ -39,6 +39,7 @@ import (
 	"github.com/coreos/etcd/internal/compactor"
 	"github.com/coreos/etcd/internal/discovery"
 	"github.com/coreos/etcd/internal/raftsnap"
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/lease"
 	"github.com/coreos/etcd/lease/leasehttp"
 	"github.com/coreos/etcd/mvcc"
@@ -53,7 +54,6 @@ import (
 	"github.com/coreos/etcd/raft"
 	"github.com/coreos/etcd/raft/raftpb"
 	"github.com/coreos/etcd/rafthttp"
-	"github.com/coreos/etcd/store"
 	"github.com/coreos/etcd/version"
 	"github.com/coreos/etcd/wal"
 
diff --git a/etcdserver/server_test.go b/etcdserver/server_test.go
index 6ae4f6d..231fecc 100644
--- a/etcdserver/server_test.go
+++ b/etcdserver/server_test.go
@@ -29,6 +29,7 @@ import (
 	pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
 	"github.com/coreos/etcd/etcdserver/membership"
 	"github.com/coreos/etcd/internal/raftsnap"
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/lease"
 	"github.com/coreos/etcd/mvcc"
 	"github.com/coreos/etcd/mvcc/backend"
@@ -44,7 +45,6 @@ import (
 	"github.com/coreos/etcd/raft"
 	"github.com/coreos/etcd/raft/raftpb"
 	"github.com/coreos/etcd/rafthttp"
-	"github.com/coreos/etcd/store"
 )
 
 // TestDoLocalAction tests requests which do not need to go through raft to be applied,
diff --git a/etcdserver/v2_server.go b/etcdserver/v2_server.go
index 4b027f1..986959f 100644
--- a/etcdserver/v2_server.go
+++ b/etcdserver/v2_server.go
@@ -19,7 +19,7 @@ import (
 	"time"
 
 	pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
-	"github.com/coreos/etcd/store"
+	"github.com/coreos/etcd/internal/store"
 )
 
 type RequestV2 pb.Request
diff --git a/internal/store/doc.go b/internal/store/doc.go
new file mode 100644
index 0000000..612df92
--- /dev/null
+++ b/internal/store/doc.go
@@ -0,0 +1,16 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package store defines etcd's in-memory key/value store.
+package store
diff --git a/internal/store/event.go b/internal/store/event.go
new file mode 100644
index 0000000..efcddb0
--- /dev/null
+++ b/internal/store/event.go
@@ -0,0 +1,71 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+const (
+	Get              = "get"
+	Create           = "create"
+	Set              = "set"
+	Update           = "update"
+	Delete           = "delete"
+	CompareAndSwap   = "compareAndSwap"
+	CompareAndDelete = "compareAndDelete"
+	Expire           = "expire"
+)
+
+type Event struct {
+	Action    string      `json:"action"`
+	Node      *NodeExtern `json:"node,omitempty"`
+	PrevNode  *NodeExtern `json:"prevNode,omitempty"`
+	EtcdIndex uint64      `json:"-"`
+	Refresh   bool        `json:"refresh,omitempty"`
+}
+
+func newEvent(action string, key string, modifiedIndex, createdIndex uint64) *Event {
+	n := &NodeExtern{
+		Key:           key,
+		ModifiedIndex: modifiedIndex,
+		CreatedIndex:  createdIndex,
+	}
+
+	return &Event{
+		Action: action,
+		Node:   n,
+	}
+}
+
+func (e *Event) IsCreated() bool {
+	if e.Action == Create {
+		return true
+	}
+	return e.Action == Set && e.PrevNode == nil
+}
+
+func (e *Event) Index() uint64 {
+	return e.Node.ModifiedIndex
+}
+
+func (e *Event) Clone() *Event {
+	return &Event{
+		Action:    e.Action,
+		EtcdIndex: e.EtcdIndex,
+		Node:      e.Node.Clone(),
+		PrevNode:  e.PrevNode.Clone(),
+	}
+}
+
+func (e *Event) SetRefresh() {
+	e.Refresh = true
+}
diff --git a/internal/store/event_history.go b/internal/store/event_history.go
new file mode 100644
index 0000000..235d87a
--- /dev/null
+++ b/internal/store/event_history.go
@@ -0,0 +1,129 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"fmt"
+	"path"
+	"strings"
+	"sync"
+
+	etcdErr "github.com/coreos/etcd/error"
+)
+
+type EventHistory struct {
+	Queue      eventQueue
+	StartIndex uint64
+	LastIndex  uint64
+	rwl        sync.RWMutex
+}
+
+func newEventHistory(capacity int) *EventHistory {
+	return &EventHistory{
+		Queue: eventQueue{
+			Capacity: capacity,
+			Events:   make([]*Event, capacity),
+		},
+	}
+}
+
+// addEvent function adds event into the eventHistory
+func (eh *EventHistory) addEvent(e *Event) *Event {
+	eh.rwl.Lock()
+	defer eh.rwl.Unlock()
+
+	eh.Queue.insert(e)
+
+	eh.LastIndex = e.Index()
+
+	eh.StartIndex = eh.Queue.Events[eh.Queue.Front].Index()
+
+	return e
+}
+
+// scan enumerates events from the index history and stops at the first point
+// where the key matches.
+func (eh *EventHistory) scan(key string, recursive bool, index uint64) (*Event, *etcdErr.Error) {
+	eh.rwl.RLock()
+	defer eh.rwl.RUnlock()
+
+	// index should be after the event history's StartIndex
+	if index < eh.StartIndex {
+		return nil,
+			etcdErr.NewError(etcdErr.EcodeEventIndexCleared,
+				fmt.Sprintf("the requested history has been cleared [%v/%v]",
+					eh.StartIndex, index), 0)
+	}
+
+	// the index should come before the size of the queue minus the duplicate count
+	if index > eh.LastIndex { // future index
+		return nil, nil
+	}
+
+	offset := index - eh.StartIndex
+	i := (eh.Queue.Front + int(offset)) % eh.Queue.Capacity
+
+	for {
+		e := eh.Queue.Events[i]
+
+		if !e.Refresh {
+			ok := (e.Node.Key == key)
+
+			if recursive {
+				// add tailing slash
+				nkey := path.Clean(key)
+				if nkey[len(nkey)-1] != '/' {
+					nkey = nkey + "/"
+				}
+
+				ok = ok || strings.HasPrefix(e.Node.Key, nkey)
+			}
+
+			if (e.Action == Delete || e.Action == Expire) && e.PrevNode != nil && e.PrevNode.Dir {
+				ok = ok || strings.HasPrefix(key, e.PrevNode.Key)
+			}
+
+			if ok {
+				return e, nil
+			}
+		}
+
+		i = (i + 1) % eh.Queue.Capacity
+
+		if i == eh.Queue.Back {
+			return nil, nil
+		}
+	}
+}
+
+// clone will be protected by a stop-world lock
+// do not need to obtain internal lock
+func (eh *EventHistory) clone() *EventHistory {
+	clonedQueue := eventQueue{
+		Capacity: eh.Queue.Capacity,
+		Events:   make([]*Event, eh.Queue.Capacity),
+		Size:     eh.Queue.Size,
+		Front:    eh.Queue.Front,
+		Back:     eh.Queue.Back,
+	}
+
+	copy(clonedQueue.Events, eh.Queue.Events)
+	return &EventHistory{
+		StartIndex: eh.StartIndex,
+		Queue:      clonedQueue,
+		LastIndex:  eh.LastIndex,
+	}
+
+}
diff --git a/internal/store/event_queue.go b/internal/store/event_queue.go
new file mode 100644
index 0000000..767b835
--- /dev/null
+++ b/internal/store/event_queue.go
@@ -0,0 +1,34 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+type eventQueue struct {
+	Events   []*Event
+	Size     int
+	Front    int
+	Back     int
+	Capacity int
+}
+
+func (eq *eventQueue) insert(e *Event) {
+	eq.Events[eq.Back] = e
+	eq.Back = (eq.Back + 1) % eq.Capacity
+
+	if eq.Size == eq.Capacity { //dequeue
+		eq.Front = (eq.Front + 1) % eq.Capacity
+	} else {
+		eq.Size++
+	}
+}
diff --git a/internal/store/event_test.go b/internal/store/event_test.go
new file mode 100644
index 0000000..ba3c06c
--- /dev/null
+++ b/internal/store/event_test.go
@@ -0,0 +1,162 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"testing"
+
+	etcdErr "github.com/coreos/etcd/error"
+)
+
+// TestEventQueue tests a queue with capacity = 100
+// Add 200 events into that queue, and test if the
+// previous 100 events have been swapped out.
+func TestEventQueue(t *testing.T) {
+
+	eh := newEventHistory(100)
+
+	// Add
+	for i := 0; i < 200; i++ {
+		e := newEvent(Create, "/foo", uint64(i), uint64(i))
+		eh.addEvent(e)
+	}
+
+	// Test
+	j := 100
+	i := eh.Queue.Front
+	n := eh.Queue.Size
+	for ; n > 0; n-- {
+		e := eh.Queue.Events[i]
+		if e.Index() != uint64(j) {
+			t.Fatalf("queue error!")
+		}
+		j++
+		i = (i + 1) % eh.Queue.Capacity
+	}
+}
+
+func TestScanHistory(t *testing.T) {
+	eh := newEventHistory(100)
+
+	// Add
+	eh.addEvent(newEvent(Create, "/foo", 1, 1))
+	eh.addEvent(newEvent(Create, "/foo/bar", 2, 2))
+	eh.addEvent(newEvent(Create, "/foo/foo", 3, 3))
+	eh.addEvent(newEvent(Create, "/foo/bar/bar", 4, 4))
+	eh.addEvent(newEvent(Create, "/foo/foo/foo", 5, 5))
+
+	// Delete a dir
+	de := newEvent(Delete, "/foo", 6, 6)
+	de.PrevNode = newDir(nil, "/foo", 1, nil, Permanent).Repr(false, false, nil)
+	eh.addEvent(de)
+
+	e, err := eh.scan("/foo", false, 1)
+	if err != nil || e.Index() != 1 {
+		t.Fatalf("scan error [/foo] [1] %d (%v)", e.Index(), err)
+	}
+
+	e, err = eh.scan("/foo/bar", false, 1)
+
+	if err != nil || e.Index() != 2 {
+		t.Fatalf("scan error [/foo/bar] [2] %d (%v)", e.Index(), err)
+	}
+
+	e, err = eh.scan("/foo/bar", true, 3)
+
+	if err != nil || e.Index() != 4 {
+		t.Fatalf("scan error [/foo/bar/bar] [4] %d (%v)", e.Index(), err)
+	}
+
+	e, err = eh.scan("/foo/foo/foo", false, 6)
+	if err != nil || e.Index() != 6 {
+		t.Fatalf("scan error [/foo/foo/foo] [6] %d (%v)", e.Index(), err)
+	}
+
+	e, _ = eh.scan("/foo/bar", true, 7)
+	if e != nil {
+		t.Fatalf("bad index shoud reuturn nil")
+	}
+}
+
+func TestEventIndexHistoryCleared(t *testing.T) {
+	eh := newEventHistory(5)
+
+	// Add
+	eh.addEvent(newEvent(Create, "/foo", 1, 1))
+	eh.addEvent(newEvent(Create, "/foo/bar", 2, 2))
+	eh.addEvent(newEvent(Create, "/foo/foo", 3, 3))
+	eh.addEvent(newEvent(Create, "/foo/bar/bar", 4, 4))
+	eh.addEvent(newEvent(Create, "/foo/foo/foo", 5, 5))
+
+	// Add a new event which will replace/de-queue the first entry
+	eh.addEvent(newEvent(Create, "/foo/bar/bar/bar", 6, 6))
+
+	// test for the event which has been replaced.
+	_, err := eh.scan("/foo", false, 1)
+	if err == nil || err.ErrorCode != etcdErr.EcodeEventIndexCleared {
+		t.Fatalf("scan error cleared index should return err with %d got (%v)", etcdErr.EcodeEventIndexCleared, err)
+	}
+}
+
+// TestFullEventQueue tests a queue with capacity = 10
+// Add 1000 events into that queue, and test if scanning
+// works still for previous events.
+func TestFullEventQueue(t *testing.T) {
+
+	eh := newEventHistory(10)
+
+	// Add
+	for i := 0; i < 1000; i++ {
+		ce := newEvent(Create, "/foo", uint64(i), uint64(i))
+		eh.addEvent(ce)
+		e, err := eh.scan("/foo", true, uint64(i-1))
+		if i > 0 {
+			if e == nil || err != nil {
+				t.Fatalf("scan error [/foo] [%v] %v", i-1, i)
+			}
+		}
+	}
+}
+
+func TestCloneEvent(t *testing.T) {
+	e1 := &Event{
+		Action:    Create,
+		EtcdIndex: 1,
+		Node:      nil,
+		PrevNode:  nil,
+	}
+	e2 := e1.Clone()
+	if e2.Action != Create {
+		t.Fatalf("Action=%q, want %q", e2.Action, Create)
+	}
+	if e2.EtcdIndex != e1.EtcdIndex {
+		t.Fatalf("EtcdIndex=%d, want %d", e2.EtcdIndex, e1.EtcdIndex)
+	}
+	// Changing the cloned node should not affect the original
+	e2.Action = Delete
+	e2.EtcdIndex = uint64(5)
+	if e1.Action != Create {
+		t.Fatalf("Action=%q, want %q", e1.Action, Create)
+	}
+	if e1.EtcdIndex != uint64(1) {
+		t.Fatalf("EtcdIndex=%d, want %d", e1.EtcdIndex, uint64(1))
+	}
+	if e2.Action != Delete {
+		t.Fatalf("Action=%q, want %q", e2.Action, Delete)
+	}
+	if e2.EtcdIndex != uint64(5) {
+		t.Fatalf("EtcdIndex=%d, want %d", e2.EtcdIndex, uint64(5))
+	}
+}
diff --git a/internal/store/heap_test.go b/internal/store/heap_test.go
new file mode 100644
index 0000000..0ff4961
--- /dev/null
+++ b/internal/store/heap_test.go
@@ -0,0 +1,94 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"fmt"
+	"testing"
+	"time"
+)
+
+func TestHeapPushPop(t *testing.T) {
+	h := newTtlKeyHeap()
+
+	// add from older expire time to earlier expire time
+	// the path is equal to ttl from now
+	for i := 0; i < 10; i++ {
+		path := fmt.Sprintf("%v", 10-i)
+		m := time.Duration(10 - i)
+		n := newKV(nil, path, path, 0, nil, time.Now().Add(time.Second*m))
+		h.push(n)
+	}
+
+	min := time.Now()
+
+	for i := 0; i < 10; i++ {
+		node := h.pop()
+		if node.ExpireTime.Before(min) {
+			t.Fatal("heap sort wrong!")
+		}
+		min = node.ExpireTime
+	}
+
+}
+
+func TestHeapUpdate(t *testing.T) {
+	h := newTtlKeyHeap()
+
+	kvs := make([]*node, 10)
+
+	// add from older expire time to earlier expire time
+	// the path is equal to ttl from now
+	for i := range kvs {
+		path := fmt.Sprintf("%v", 10-i)
+		m := time.Duration(10 - i)
+		n := newKV(nil, path, path, 0, nil, time.Now().Add(time.Second*m))
+		kvs[i] = n
+		h.push(n)
+	}
+
+	// Path 7
+	kvs[3].ExpireTime = time.Now().Add(time.Second * 11)
+
+	// Path 5
+	kvs[5].ExpireTime = time.Now().Add(time.Second * 12)
+
+	h.update(kvs[3])
+	h.update(kvs[5])
+
+	min := time.Now()
+
+	for i := 0; i < 10; i++ {
+		node := h.pop()
+		if node.ExpireTime.Before(min) {
+			t.Fatal("heap sort wrong!")
+		}
+		min = node.ExpireTime
+
+		if i == 8 {
+			if node.Path != "7" {
+				t.Fatal("heap sort wrong!", node.Path)
+			}
+		}
+
+		if i == 9 {
+			if node.Path != "5" {
+				t.Fatal("heap sort wrong!")
+			}
+		}
+
+	}
+
+}
diff --git a/internal/store/metrics.go b/internal/store/metrics.go
new file mode 100644
index 0000000..077c0fa
--- /dev/null
+++ b/internal/store/metrics.go
@@ -0,0 +1,132 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"github.com/prometheus/client_golang/prometheus"
+)
+
+// Set of raw Prometheus metrics.
+// Labels
+// * action = declared in event.go
+// * outcome = Outcome
+// Do not increment directly, use Report* methods.
+var (
+	readCounter = prometheus.NewCounterVec(
+		prometheus.CounterOpts{
+			Namespace: "etcd_debugging",
+			Subsystem: "store",
+			Name:      "reads_total",
+			Help:      "Total number of reads action by (get/getRecursive), local to this member.",
+		}, []string{"action"})
+
+	writeCounter = prometheus.NewCounterVec(
+		prometheus.CounterOpts{
+			Namespace: "etcd_debugging",
+			Subsystem: "store",
+			Name:      "writes_total",
+			Help:      "Total number of writes (e.g. set/compareAndDelete) seen by this member.",
+		}, []string{"action"})
+
+	readFailedCounter = prometheus.NewCounterVec(
+		prometheus.CounterOpts{
+			Namespace: "etcd_debugging",
+			Subsystem: "store",
+			Name:      "reads_failed_total",
+			Help:      "Failed read actions by (get/getRecursive), local to this member.",
+		}, []string{"action"})
+
+	writeFailedCounter = prometheus.NewCounterVec(
+		prometheus.CounterOpts{
+			Namespace: "etcd_debugging",
+			Subsystem: "store",
+			Name:      "writes_failed_total",
+			Help:      "Failed write actions (e.g. set/compareAndDelete), seen by this member.",
+		}, []string{"action"})
+
+	expireCounter = prometheus.NewCounter(
+		prometheus.CounterOpts{
+			Namespace: "etcd_debugging",
+			Subsystem: "store",
+			Name:      "expires_total",
+			Help:      "Total number of expired keys.",
+		})
+
+	watchRequests = prometheus.NewCounter(
+		prometheus.CounterOpts{
+			Namespace: "etcd_debugging",
+			Subsystem: "store",
+			Name:      "watch_requests_total",
+			Help:      "Total number of incoming watch requests (new or reestablished).",
+		})
+
+	watcherCount = prometheus.NewGauge(
+		prometheus.GaugeOpts{
+			Namespace: "etcd_debugging",
+			Subsystem: "store",
+			Name:      "watchers",
+			Help:      "Count of currently active watchers.",
+		})
+)
+
+const (
+	GetRecursive = "getRecursive"
+)
+
+func init() {
+	if prometheus.Register(readCounter) != nil {
+		// Tests will try to double register since the tests use both
+		// store and store_test packages; ignore second attempts.
+		return
+	}
+	prometheus.MustRegister(writeCounter)
+	prometheus.MustRegister(expireCounter)
+	prometheus.MustRegister(watchRequests)
+	prometheus.MustRegister(watcherCount)
+}
+
+func reportReadSuccess(read_action string) {
+	readCounter.WithLabelValues(read_action).Inc()
+}
+
+func reportReadFailure(read_action string) {
+	readCounter.WithLabelValues(read_action).Inc()
+	readFailedCounter.WithLabelValues(read_action).Inc()
+}
+
+func reportWriteSuccess(write_action string) {
+	writeCounter.WithLabelValues(write_action).Inc()
+}
+
+func reportWriteFailure(write_action string) {
+	writeCounter.WithLabelValues(write_action).Inc()
+	writeFailedCounter.WithLabelValues(write_action).Inc()
+}
+
+func reportExpiredKey() {
+	expireCounter.Inc()
+}
+
+func reportWatchRequest() {
+	watchRequests.Inc()
+}
+
+func reportWatcherAdded() {
+	watcherCount.Inc()
+}
+
+func reportWatcherRemoved() {
+	watcherCount.Dec()
+}
diff --git a/internal/store/node.go b/internal/store/node.go
new file mode 100644
index 0000000..c3c8743
--- /dev/null
+++ b/internal/store/node.go
@@ -0,0 +1,395 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"path"
+	"sort"
+	"time"
+
+	etcdErr "github.com/coreos/etcd/error"
+	"github.com/jonboulle/clockwork"
+)
+
+// explanations of Compare function result
+const (
+	CompareMatch = iota
+	CompareIndexNotMatch
+	CompareValueNotMatch
+	CompareNotMatch
+)
+
+var Permanent time.Time
+
+// node is the basic element in the store system.
+// A key-value pair will have a string value
+// A directory will have a children map
+type node struct {
+	Path string
+
+	CreatedIndex  uint64
+	ModifiedIndex uint64
+
+	Parent *node `json:"-"` // should not encode this field! avoid circular dependency.
+
+	ExpireTime time.Time
+	Value      string           // for key-value pair
+	Children   map[string]*node // for directory
+
+	// A reference to the store this node is attached to.
+	store *store
+}
+
+// newKV creates a Key-Value pair
+func newKV(store *store, nodePath string, value string, createdIndex uint64, parent *node, expireTime time.Time) *node {
+	return &node{
+		Path:          nodePath,
+		CreatedIndex:  createdIndex,
+		ModifiedIndex: createdIndex,
+		Parent:        parent,
+		store:         store,
+		ExpireTime:    expireTime,
+		Value:         value,
+	}
+}
+
+// newDir creates a directory
+func newDir(store *store, nodePath string, createdIndex uint64, parent *node, expireTime time.Time) *node {
+	return &node{
+		Path:          nodePath,
+		CreatedIndex:  createdIndex,
+		ModifiedIndex: createdIndex,
+		Parent:        parent,
+		ExpireTime:    expireTime,
+		Children:      make(map[string]*node),
+		store:         store,
+	}
+}
+
+// IsHidden function checks if the node is a hidden node. A hidden node
+// will begin with '_'
+// A hidden node will not be shown via get command under a directory
+// For example if we have /foo/_hidden and /foo/notHidden, get "/foo"
+// will only return /foo/notHidden
+func (n *node) IsHidden() bool {
+	_, name := path.Split(n.Path)
+
+	return name[0] == '_'
+}
+
+// IsPermanent function checks if the node is a permanent one.
+func (n *node) IsPermanent() bool {
+	// we use a uninitialized time.Time to indicate the node is a
+	// permanent one.
+	// the uninitialized time.Time should equal zero.
+	return n.ExpireTime.IsZero()
+}
+
+// IsDir function checks whether the node is a directory.
+// If the node is a directory, the function will return true.
+// Otherwise the function will return false.
+func (n *node) IsDir() bool {
+	return n.Children != nil
+}
+
+// Read function gets the value of the node.
+// If the receiver node is not a key-value pair, a "Not A File" error will be returned.
+func (n *node) Read() (string, *etcdErr.Error) {
+	if n.IsDir() {
+		return "", etcdErr.NewError(etcdErr.EcodeNotFile, "", n.store.CurrentIndex)
+	}
+
+	return n.Value, nil
+}
+
+// Write function set the value of the node to the given value.
+// If the receiver node is a directory, a "Not A File" error will be returned.
+func (n *node) Write(value string, index uint64) *etcdErr.Error {
+	if n.IsDir() {
+		return etcdErr.NewError(etcdErr.EcodeNotFile, "", n.store.CurrentIndex)
+	}
+
+	n.Value = value
+	n.ModifiedIndex = index
+
+	return nil
+}
+
+func (n *node) expirationAndTTL(clock clockwork.Clock) (*time.Time, int64) {
+	if !n.IsPermanent() {
+		/* compute ttl as:
+		   ceiling( (expireTime - timeNow) / nanosecondsPerSecond )
+		   which ranges from 1..n
+		   rather than as:
+		   ( (expireTime - timeNow) / nanosecondsPerSecond ) + 1
+		   which ranges 1..n+1
+		*/
+		ttlN := n.ExpireTime.Sub(clock.Now())
+		ttl := ttlN / time.Second
+		if (ttlN % time.Second) > 0 {
+			ttl++
+		}
+		t := n.ExpireTime.UTC()
+		return &t, int64(ttl)
+	}
+	return nil, 0
+}
+
+// List function return a slice of nodes under the receiver node.
+// If the receiver node is not a directory, a "Not A Directory" error will be returned.
+func (n *node) List() ([]*node, *etcdErr.Error) {
+	if !n.IsDir() {
+		return nil, etcdErr.NewError(etcdErr.EcodeNotDir, "", n.store.CurrentIndex)
+	}
+
+	nodes := make([]*node, len(n.Children))
+
+	i := 0
+	for _, node := range n.Children {
+		nodes[i] = node
+		i++
+	}
+
+	return nodes, nil
+}
+
+// GetChild function returns the child node under the directory node.
+// On success, it returns the file node
+func (n *node) GetChild(name string) (*node, *etcdErr.Error) {
+	if !n.IsDir() {
+		return nil, etcdErr.NewError(etcdErr.EcodeNotDir, n.Path, n.store.CurrentIndex)
+	}
+
+	child, ok := n.Children[name]
+
+	if ok {
+		return child, nil
+	}
+
+	return nil, nil
+}
+
+// Add function adds a node to the receiver node.
+// If the receiver is not a directory, a "Not A Directory" error will be returned.
+// If there is an existing node with the same name under the directory, a "Already Exist"
+// error will be returned
+func (n *node) Add(child *node) *etcdErr.Error {
+	if !n.IsDir() {
+		return etcdErr.NewError(etcdErr.EcodeNotDir, "", n.store.CurrentIndex)
+	}
+
+	_, name := path.Split(child.Path)
+
+	if _, ok := n.Children[name]; ok {
+		return etcdErr.NewError(etcdErr.EcodeNodeExist, "", n.store.CurrentIndex)
+	}
+
+	n.Children[name] = child
+
+	return nil
+}
+
+// Remove function remove the node.
+func (n *node) Remove(dir, recursive bool, callback func(path string)) *etcdErr.Error {
+	if !n.IsDir() { // key-value pair
+		_, name := path.Split(n.Path)
+
+		// find its parent and remove the node from the map
+		if n.Parent != nil && n.Parent.Children[name] == n {
+			delete(n.Parent.Children, name)
+		}
+
+		if callback != nil {
+			callback(n.Path)
+		}
+
+		if !n.IsPermanent() {
+			n.store.ttlKeyHeap.remove(n)
+		}
+
+		return nil
+	}
+
+	if !dir {
+		// cannot delete a directory without dir set to true
+		return etcdErr.NewError(etcdErr.EcodeNotFile, n.Path, n.store.CurrentIndex)
+	}
+
+	if len(n.Children) != 0 && !recursive {
+		// cannot delete a directory if it is not empty and the operation
+		// is not recursive
+		return etcdErr.NewError(etcdErr.EcodeDirNotEmpty, n.Path, n.store.CurrentIndex)
+	}
+
+	for _, child := range n.Children { // delete all children
+		child.Remove(true, true, callback)
+	}
+
+	// delete self
+	_, name := path.Split(n.Path)
+	if n.Parent != nil && n.Parent.Children[name] == n {
+		delete(n.Parent.Children, name)
+
+		if callback != nil {
+			callback(n.Path)
+		}
+
+		if !n.IsPermanent() {
+			n.store.ttlKeyHeap.remove(n)
+		}
+	}
+
+	return nil
+}
+
+func (n *node) Repr(recursive, sorted bool, clock clockwork.Clock) *NodeExtern {
+	if n.IsDir() {
+		node := &NodeExtern{
+			Key:           n.Path,
+			Dir:           true,
+			ModifiedIndex: n.ModifiedIndex,
+			CreatedIndex:  n.CreatedIndex,
+		}
+		node.Expiration, node.TTL = n.expirationAndTTL(clock)
+
+		if !recursive {
+			return node
+		}
+
+		children, _ := n.List()
+		node.Nodes = make(NodeExterns, len(children))
+
+		// we do not use the index in the children slice directly
+		// we need to skip the hidden one
+		i := 0
+
+		for _, child := range children {
+
+			if child.IsHidden() { // get will not list hidden node
+				continue
+			}
+
+			node.Nodes[i] = child.Repr(recursive, sorted, clock)
+
+			i++
+		}
+
+		// eliminate hidden nodes
+		node.Nodes = node.Nodes[:i]
+		if sorted {
+			sort.Sort(node.Nodes)
+		}
+
+		return node
+	}
+
+	// since n.Value could be changed later, so we need to copy the value out
+	value := n.Value
+	node := &NodeExtern{
+		Key:           n.Path,
+		Value:         &value,
+		ModifiedIndex: n.ModifiedIndex,
+		CreatedIndex:  n.CreatedIndex,
+	}
+	node.Expiration, node.TTL = n.expirationAndTTL(clock)
+	return node
+}
+
+func (n *node) UpdateTTL(expireTime time.Time) {
+	if !n.IsPermanent() {
+		if expireTime.IsZero() {
+			// from ttl to permanent
+			n.ExpireTime = expireTime
+			// remove from ttl heap
+			n.store.ttlKeyHeap.remove(n)
+			return
+		}
+
+		// update ttl
+		n.ExpireTime = expireTime
+		// update ttl heap
+		n.store.ttlKeyHeap.update(n)
+		return
+	}
+
+	if expireTime.IsZero() {
+		return
+	}
+
+	// from permanent to ttl
+	n.ExpireTime = expireTime
+	// push into ttl heap
+	n.store.ttlKeyHeap.push(n)
+}
+
+// Compare function compares node index and value with provided ones.
+// second result value explains result and equals to one of Compare.. constants
+func (n *node) Compare(prevValue string, prevIndex uint64) (ok bool, which int) {
+	indexMatch := (prevIndex == 0 || n.ModifiedIndex == prevIndex)
+	valueMatch := (prevValue == "" || n.Value == prevValue)
+	ok = valueMatch && indexMatch
+	switch {
+	case valueMatch && indexMatch:
+		which = CompareMatch
+	case indexMatch && !valueMatch:
+		which = CompareValueNotMatch
+	case valueMatch && !indexMatch:
+		which = CompareIndexNotMatch
+	default:
+		which = CompareNotMatch
+	}
+	return ok, which
+}
+
+// Clone function clone the node recursively and return the new node.
+// If the node is a directory, it will clone all the content under this directory.
+// If the node is a key-value pair, it will clone the pair.
+func (n *node) Clone() *node {
+	if !n.IsDir() {
+		newkv := newKV(n.store, n.Path, n.Value, n.CreatedIndex, n.Parent, n.ExpireTime)
+		newkv.ModifiedIndex = n.ModifiedIndex
+		return newkv
+	}
+
+	clone := newDir(n.store, n.Path, n.CreatedIndex, n.Parent, n.ExpireTime)
+	clone.ModifiedIndex = n.ModifiedIndex
+
+	for key, child := range n.Children {
+		clone.Children[key] = child.Clone()
+	}
+
+	return clone
+}
+
+// recoverAndclean function help to do recovery.
+// Two things need to be done: 1. recovery structure; 2. delete expired nodes
+//
+// If the node is a directory, it will help recover children's parent pointer and recursively
+// call this function on its children.
+// We check the expire last since we need to recover the whole structure first and add all the
+// notifications into the event history.
+func (n *node) recoverAndclean() {
+	if n.IsDir() {
+		for _, child := range n.Children {
+			child.Parent = n
+			child.store = n.store
+			child.recoverAndclean()
+		}
+	}
+
+	if !n.ExpireTime.IsZero() {
+		n.store.ttlKeyHeap.push(n)
+	}
+}
diff --git a/internal/store/node_extern.go b/internal/store/node_extern.go
new file mode 100644
index 0000000..7ba870c
--- /dev/null
+++ b/internal/store/node_extern.go
@@ -0,0 +1,116 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"sort"
+	"time"
+
+	"github.com/jonboulle/clockwork"
+)
+
+// NodeExtern is the external representation of the
+// internal node with additional fields
+// PrevValue is the previous value of the node
+// TTL is time to live in second
+type NodeExtern struct {
+	Key           string      `json:"key,omitempty"`
+	Value         *string     `json:"value,omitempty"`
+	Dir           bool        `json:"dir,omitempty"`
+	Expiration    *time.Time  `json:"expiration,omitempty"`
+	TTL           int64       `json:"ttl,omitempty"`
+	Nodes         NodeExterns `json:"nodes,omitempty"`
+	ModifiedIndex uint64      `json:"modifiedIndex,omitempty"`
+	CreatedIndex  uint64      `json:"createdIndex,omitempty"`
+}
+
+func (eNode *NodeExtern) loadInternalNode(n *node, recursive, sorted bool, clock clockwork.Clock) {
+	if n.IsDir() { // node is a directory
+		eNode.Dir = true
+
+		children, _ := n.List()
+		eNode.Nodes = make(NodeExterns, len(children))
+
+		// we do not use the index in the children slice directly
+		// we need to skip the hidden one
+		i := 0
+
+		for _, child := range children {
+			if child.IsHidden() { // get will not return hidden nodes
+				continue
+			}
+
+			eNode.Nodes[i] = child.Repr(recursive, sorted, clock)
+			i++
+		}
+
+		// eliminate hidden nodes
+		eNode.Nodes = eNode.Nodes[:i]
+
+		if sorted {
+			sort.Sort(eNode.Nodes)
+		}
+
+	} else { // node is a file
+		value, _ := n.Read()
+		eNode.Value = &value
+	}
+
+	eNode.Expiration, eNode.TTL = n.expirationAndTTL(clock)
+}
+
+func (eNode *NodeExtern) Clone() *NodeExtern {
+	if eNode == nil {
+		return nil
+	}
+	nn := &NodeExtern{
+		Key:           eNode.Key,
+		Dir:           eNode.Dir,
+		TTL:           eNode.TTL,
+		ModifiedIndex: eNode.ModifiedIndex,
+		CreatedIndex:  eNode.CreatedIndex,
+	}
+	if eNode.Value != nil {
+		s := *eNode.Value
+		nn.Value = &s
+	}
+	if eNode.Expiration != nil {
+		t := *eNode.Expiration
+		nn.Expiration = &t
+	}
+	if eNode.Nodes != nil {
+		nn.Nodes = make(NodeExterns, len(eNode.Nodes))
+		for i, n := range eNode.Nodes {
+			nn.Nodes[i] = n.Clone()
+		}
+	}
+	return nn
+}
+
+type NodeExterns []*NodeExtern
+
+// interfaces for sorting
+
+func (ns NodeExterns) Len() int {
+	return len(ns)
+}
+
+func (ns NodeExterns) Less(i, j int) bool {
+	return ns[i].Key < ns[j].Key
+}
+
+func (ns NodeExterns) Swap(i, j int) {
+	ns[i], ns[j] = ns[j], ns[i]
+}
diff --git a/internal/store/node_extern_test.go b/internal/store/node_extern_test.go
new file mode 100644
index 0000000..7875e47
--- /dev/null
+++ b/internal/store/node_extern_test.go
@@ -0,0 +1,108 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"reflect"
+	"testing"
+	"time"
+	"unsafe"
+
+	"github.com/coreos/etcd/pkg/testutil"
+)
+
+func TestNodeExternClone(t *testing.T) {
+	var eNode *NodeExtern
+	if g := eNode.Clone(); g != nil {
+		t.Fatalf("nil.Clone=%v, want nil", g)
+	}
+
+	const (
+		key string = "/foo/bar"
+		ttl int64  = 123456789
+		ci  uint64 = 123
+		mi  uint64 = 321
+	)
+	var (
+		val    = "some_data"
+		valp   = &val
+		exp    = time.Unix(12345, 67890)
+		expp   = &exp
+		child  = NodeExtern{}
+		childp = &child
+		childs = []*NodeExtern{childp}
+	)
+
+	eNode = &NodeExtern{
+		Key:           key,
+		TTL:           ttl,
+		CreatedIndex:  ci,
+		ModifiedIndex: mi,
+		Value:         valp,
+		Expiration:    expp,
+		Nodes:         childs,
+	}
+
+	gNode := eNode.Clone()
+	// Check the clone is as expected
+	testutil.AssertEqual(t, gNode.Key, key)
+	testutil.AssertEqual(t, gNode.TTL, ttl)
+	testutil.AssertEqual(t, gNode.CreatedIndex, ci)
+	testutil.AssertEqual(t, gNode.ModifiedIndex, mi)
+	// values should be the same
+	testutil.AssertEqual(t, *gNode.Value, val)
+	testutil.AssertEqual(t, *gNode.Expiration, exp)
+	testutil.AssertEqual(t, len(gNode.Nodes), len(childs))
+	testutil.AssertEqual(t, *gNode.Nodes[0], child)
+	// but pointers should differ
+	if gNode.Value == eNode.Value {
+		t.Fatalf("expected value pointers to differ, but got same!")
+	}
+	if gNode.Expiration == eNode.Expiration {
+		t.Fatalf("expected expiration pointers to differ, but got same!")
+	}
+	if sameSlice(gNode.Nodes, eNode.Nodes) {
+		t.Fatalf("expected nodes pointers to differ, but got same!")
+	}
+	// Original should be the same
+	testutil.AssertEqual(t, eNode.Key, key)
+	testutil.AssertEqual(t, eNode.TTL, ttl)
+	testutil.AssertEqual(t, eNode.CreatedIndex, ci)
+	testutil.AssertEqual(t, eNode.ModifiedIndex, mi)
+	testutil.AssertEqual(t, eNode.Value, valp)
+	testutil.AssertEqual(t, eNode.Expiration, expp)
+	if !sameSlice(eNode.Nodes, childs) {
+		t.Fatalf("expected nodes pointer to same, but got different!")
+	}
+	// Change the clone and ensure the original is not affected
+	gNode.Key = "/baz"
+	gNode.TTL = 0
+	gNode.Nodes[0].Key = "uno"
+	testutil.AssertEqual(t, eNode.Key, key)
+	testutil.AssertEqual(t, eNode.TTL, ttl)
+	testutil.AssertEqual(t, eNode.CreatedIndex, ci)
+	testutil.AssertEqual(t, eNode.ModifiedIndex, mi)
+	testutil.AssertEqual(t, *eNode.Nodes[0], child)
+	// Change the original and ensure the clone is not affected
+	eNode.Key = "/wuf"
+	testutil.AssertEqual(t, eNode.Key, "/wuf")
+	testutil.AssertEqual(t, gNode.Key, "/baz")
+}
+
+func sameSlice(a, b []*NodeExtern) bool {
+	ah := (*reflect.SliceHeader)(unsafe.Pointer(&a))
+	bh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+	return *ah == *bh
+}
diff --git a/internal/store/node_test.go b/internal/store/node_test.go
new file mode 100644
index 0000000..96fde8a
--- /dev/null
+++ b/internal/store/node_test.go
@@ -0,0 +1,246 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"testing"
+	"time"
+
+	"github.com/jonboulle/clockwork"
+)
+
+var (
+	key, val   = "foo", "bar"
+	val1, val2 = "bar1", "bar2"
+	expiration = time.Minute
+)
+
+func TestNewKVIs(t *testing.T) {
+	nd := newTestNode()
+
+	if nd.IsHidden() {
+		t.Errorf("nd.Hidden() = %v, want = false", nd.IsHidden())
+	}
+
+	if nd.IsPermanent() {
+		t.Errorf("nd.IsPermanent() = %v, want = false", nd.IsPermanent())
+	}
+
+	if nd.IsDir() {
+		t.Errorf("nd.IsDir() = %v, want = false", nd.IsDir())
+	}
+}
+
+func TestNewKVReadWriteCompare(t *testing.T) {
+	nd := newTestNode()
+
+	if v, err := nd.Read(); v != val || err != nil {
+		t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val)
+	}
+
+	if err := nd.Write(val1, nd.CreatedIndex+1); err != nil {
+		t.Errorf("nd.Write error = %v, want = nil", err)
+	} else {
+		if v, err := nd.Read(); v != val1 || err != nil {
+			t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val1)
+		}
+	}
+	if err := nd.Write(val2, nd.CreatedIndex+2); err != nil {
+		t.Errorf("nd.Write error = %v, want = nil", err)
+	} else {
+		if v, err := nd.Read(); v != val2 || err != nil {
+			t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val2)
+		}
+	}
+
+	if ok, which := nd.Compare(val2, 2); !ok || which != 0 {
+		t.Errorf("ok = %v and which = %d, want ok = true and which = 0", ok, which)
+	}
+}
+
+func TestNewKVExpiration(t *testing.T) {
+	nd := newTestNode()
+
+	if _, ttl := nd.expirationAndTTL(clockwork.NewFakeClock()); ttl > expiration.Nanoseconds() {
+		t.Errorf("ttl = %d, want %d < %d", ttl, ttl, expiration.Nanoseconds())
+	}
+
+	newExpiration := time.Hour
+	nd.UpdateTTL(time.Now().Add(newExpiration))
+	if _, ttl := nd.expirationAndTTL(clockwork.NewFakeClock()); ttl > newExpiration.Nanoseconds() {
+		t.Errorf("ttl = %d, want %d < %d", ttl, ttl, newExpiration.Nanoseconds())
+	}
+	if ns, err := nd.List(); ns != nil || err == nil {
+		t.Errorf("nodes = %v and err = %v, want nodes = nil and err != nil", ns, err)
+	}
+
+	en := nd.Repr(false, false, clockwork.NewFakeClock())
+	if en.Key != nd.Path {
+		t.Errorf("en.Key = %s, want = %s", en.Key, nd.Path)
+	}
+	if *(en.Value) != nd.Value {
+		t.Errorf("*(en.Key) = %s, want = %s", *(en.Value), nd.Value)
+	}
+}
+
+func TestNewKVListReprCompareClone(t *testing.T) {
+	nd := newTestNode()
+
+	if ns, err := nd.List(); ns != nil || err == nil {
+		t.Errorf("nodes = %v and err = %v, want nodes = nil and err != nil", ns, err)
+	}
+
+	en := nd.Repr(false, false, clockwork.NewFakeClock())
+	if en.Key != nd.Path {
+		t.Errorf("en.Key = %s, want = %s", en.Key, nd.Path)
+	}
+	if *(en.Value) != nd.Value {
+		t.Errorf("*(en.Key) = %s, want = %s", *(en.Value), nd.Value)
+	}
+
+	cn := nd.Clone()
+	if cn.Path != nd.Path {
+		t.Errorf("cn.Path = %s, want = %s", cn.Path, nd.Path)
+	}
+	if cn.Value != nd.Value {
+		t.Errorf("cn.Value = %s, want = %s", cn.Value, nd.Value)
+	}
+}
+
+func TestNewKVRemove(t *testing.T) {
+	nd := newTestNode()
+
+	if v, err := nd.Read(); v != val || err != nil {
+		t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val)
+	}
+
+	if err := nd.Write(val1, nd.CreatedIndex+1); err != nil {
+		t.Errorf("nd.Write error = %v, want = nil", err)
+	} else {
+		if v, err := nd.Read(); v != val1 || err != nil {
+			t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val1)
+		}
+	}
+	if err := nd.Write(val2, nd.CreatedIndex+2); err != nil {
+		t.Errorf("nd.Write error = %v, want = nil", err)
+	} else {
+		if v, err := nd.Read(); v != val2 || err != nil {
+			t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val2)
+		}
+	}
+
+	if err := nd.Remove(false, false, nil); err != nil {
+		t.Errorf("nd.Remove err = %v, want = nil", err)
+	} else {
+		// still readable
+		if v, err := nd.Read(); v != val2 || err != nil {
+			t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val2)
+		}
+		if len(nd.store.ttlKeyHeap.array) != 0 {
+			t.Errorf("len(nd.store.ttlKeyHeap.array) = %d, want = 0", len(nd.store.ttlKeyHeap.array))
+		}
+		if len(nd.store.ttlKeyHeap.keyMap) != 0 {
+			t.Errorf("len(nd.store.ttlKeyHeap.keyMap) = %d, want = 0", len(nd.store.ttlKeyHeap.keyMap))
+		}
+	}
+}
+
+func TestNewDirIs(t *testing.T) {
+	nd, _ := newTestNodeDir()
+	if nd.IsHidden() {
+		t.Errorf("nd.Hidden() = %v, want = false", nd.IsHidden())
+	}
+
+	if nd.IsPermanent() {
+		t.Errorf("nd.IsPermanent() = %v, want = false", nd.IsPermanent())
+	}
+
+	if !nd.IsDir() {
+		t.Errorf("nd.IsDir() = %v, want = true", nd.IsDir())
+	}
+}
+
+func TestNewDirReadWriteListReprClone(t *testing.T) {
+	nd, _ := newTestNodeDir()
+
+	if _, err := nd.Read(); err == nil {
+		t.Errorf("err = %v, want err != nil", err)
+	}
+
+	if err := nd.Write(val, nd.CreatedIndex+1); err == nil {
+		t.Errorf("err = %v, want err != nil", err)
+	}
+
+	if ns, err := nd.List(); ns == nil && err != nil {
+		t.Errorf("nodes = %v and err = %v, want nodes = nil and err == nil", ns, err)
+	}
+
+	en := nd.Repr(false, false, clockwork.NewFakeClock())
+	if en.Key != nd.Path {
+		t.Errorf("en.Key = %s, want = %s", en.Key, nd.Path)
+	}
+
+	cn := nd.Clone()
+	if cn.Path != nd.Path {
+		t.Errorf("cn.Path = %s, want = %s", cn.Path, nd.Path)
+	}
+}
+
+func TestNewDirExpirationTTL(t *testing.T) {
+	nd, _ := newTestNodeDir()
+
+	if _, ttl := nd.expirationAndTTL(clockwork.NewFakeClock()); ttl > expiration.Nanoseconds() {
+		t.Errorf("ttl = %d, want %d < %d", ttl, ttl, expiration.Nanoseconds())
+	}
+
+	newExpiration := time.Hour
+	nd.UpdateTTL(time.Now().Add(newExpiration))
+	if _, ttl := nd.expirationAndTTL(clockwork.NewFakeClock()); ttl > newExpiration.Nanoseconds() {
+		t.Errorf("ttl = %d, want %d < %d", ttl, ttl, newExpiration.Nanoseconds())
+	}
+}
+
+func TestNewDirChild(t *testing.T) {
+	nd, child := newTestNodeDir()
+
+	if err := nd.Add(child); err != nil {
+		t.Errorf("nd.Add(child) err = %v, want = nil", err)
+	} else {
+		if len(nd.Children) == 0 {
+			t.Errorf("len(nd.Children) = %d, want = 1", len(nd.Children))
+		}
+	}
+
+	if err := child.Remove(true, true, nil); err != nil {
+		t.Errorf("child.Remove err = %v, want = nil", err)
+	} else {
+		if len(nd.Children) != 0 {
+			t.Errorf("len(nd.Children) = %d, want = 0", len(nd.Children))
+		}
+	}
+}
+
+func newTestNode() *node {
+	nd := newKV(newStore(), key, val, 0, nil, time.Now().Add(expiration))
+	return nd
+}
+
+func newTestNodeDir() (*node, *node) {
+	s := newStore()
+	nd := newDir(s, key, 0, nil, time.Now().Add(expiration))
+	cKey, cVal := "hello", "world"
+	child := newKV(s, cKey, cVal, 0, nd, time.Now().Add(expiration))
+	return nd, child
+}
diff --git a/internal/store/stats.go b/internal/store/stats.go
new file mode 100644
index 0000000..ce464dd
--- /dev/null
+++ b/internal/store/stats.go
@@ -0,0 +1,145 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"encoding/json"
+	"sync/atomic"
+)
+
+const (
+	SetSuccess = iota
+	SetFail
+	DeleteSuccess
+	DeleteFail
+	CreateSuccess
+	CreateFail
+	UpdateSuccess
+	UpdateFail
+	CompareAndSwapSuccess
+	CompareAndSwapFail
+	GetSuccess
+	GetFail
+	ExpireCount
+	CompareAndDeleteSuccess
+	CompareAndDeleteFail
+)
+
+type Stats struct {
+	// Number of get requests
+
+	GetSuccess uint64 `json:"getsSuccess"`
+	GetFail    uint64 `json:"getsFail"`
+
+	// Number of sets requests
+
+	SetSuccess uint64 `json:"setsSuccess"`
+	SetFail    uint64 `json:"setsFail"`
+
+	// Number of delete requests
+
+	DeleteSuccess uint64 `json:"deleteSuccess"`
+	DeleteFail    uint64 `json:"deleteFail"`
+
+	// Number of update requests
+
+	UpdateSuccess uint64 `json:"updateSuccess"`
+	UpdateFail    uint64 `json:"updateFail"`
+
+	// Number of create requests
+
+	CreateSuccess uint64 `json:"createSuccess"`
+	CreateFail    uint64 `json:"createFail"`
+
+	// Number of testAndSet requests
+
+	CompareAndSwapSuccess uint64 `json:"compareAndSwapSuccess"`
+	CompareAndSwapFail    uint64 `json:"compareAndSwapFail"`
+
+	// Number of compareAndDelete requests
+
+	CompareAndDeleteSuccess uint64 `json:"compareAndDeleteSuccess"`
+	CompareAndDeleteFail    uint64 `json:"compareAndDeleteFail"`
+
+	ExpireCount uint64 `json:"expireCount"`
+
+	Watchers uint64 `json:"watchers"`
+}
+
+func newStats() *Stats {
+	s := new(Stats)
+	return s
+}
+
+func (s *Stats) clone() *Stats {
+	return &Stats{
+		GetSuccess:              s.GetSuccess,
+		GetFail:                 s.GetFail,
+		SetSuccess:              s.SetSuccess,
+		SetFail:                 s.SetFail,
+		DeleteSuccess:           s.DeleteSuccess,
+		DeleteFail:              s.DeleteFail,
+		UpdateSuccess:           s.UpdateSuccess,
+		UpdateFail:              s.UpdateFail,
+		CreateSuccess:           s.CreateSuccess,
+		CreateFail:              s.CreateFail,
+		CompareAndSwapSuccess:   s.CompareAndSwapSuccess,
+		CompareAndSwapFail:      s.CompareAndSwapFail,
+		CompareAndDeleteSuccess: s.CompareAndDeleteSuccess,
+		CompareAndDeleteFail:    s.CompareAndDeleteFail,
+		ExpireCount:             s.ExpireCount,
+		Watchers:                s.Watchers,
+	}
+}
+
+func (s *Stats) toJson() []byte {
+	b, _ := json.Marshal(s)
+	return b
+}
+
+func (s *Stats) Inc(field int) {
+	switch field {
+	case SetSuccess:
+		atomic.AddUint64(&s.SetSuccess, 1)
+	case SetFail:
+		atomic.AddUint64(&s.SetFail, 1)
+	case CreateSuccess:
+		atomic.AddUint64(&s.CreateSuccess, 1)
+	case CreateFail:
+		atomic.AddUint64(&s.CreateFail, 1)
+	case DeleteSuccess:
+		atomic.AddUint64(&s.DeleteSuccess, 1)
+	case DeleteFail:
+		atomic.AddUint64(&s.DeleteFail, 1)
+	case GetSuccess:
+		atomic.AddUint64(&s.GetSuccess, 1)
+	case GetFail:
+		atomic.AddUint64(&s.GetFail, 1)
+	case UpdateSuccess:
+		atomic.AddUint64(&s.UpdateSuccess, 1)
+	case UpdateFail:
+		atomic.AddUint64(&s.UpdateFail, 1)
+	case CompareAndSwapSuccess:
+		atomic.AddUint64(&s.CompareAndSwapSuccess, 1)
+	case CompareAndSwapFail:
+		atomic.AddUint64(&s.CompareAndSwapFail, 1)
+	case CompareAndDeleteSuccess:
+		atomic.AddUint64(&s.CompareAndDeleteSuccess, 1)
+	case CompareAndDeleteFail:
+		atomic.AddUint64(&s.CompareAndDeleteFail, 1)
+	case ExpireCount:
+		atomic.AddUint64(&s.ExpireCount, 1)
+	}
+}
diff --git a/internal/store/stats_test.go b/internal/store/stats_test.go
new file mode 100644
index 0000000..ec105a5
--- /dev/null
+++ b/internal/store/stats_test.go
@@ -0,0 +1,112 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"testing"
+	"time"
+
+	"github.com/coreos/etcd/pkg/testutil"
+)
+
+// Ensure that a successful Get is recorded in the stats.
+func TestStoreStatsGetSuccess(t *testing.T) {
+	s := newStore()
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Get("/foo", false, false)
+	testutil.AssertEqual(t, uint64(1), s.Stats.GetSuccess, "")
+}
+
+// Ensure that a failed Get is recorded in the stats.
+func TestStoreStatsGetFail(t *testing.T) {
+	s := newStore()
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Get("/no_such_key", false, false)
+	testutil.AssertEqual(t, uint64(1), s.Stats.GetFail, "")
+}
+
+// Ensure that a successful Create is recorded in the stats.
+func TestStoreStatsCreateSuccess(t *testing.T) {
+	s := newStore()
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
+	testutil.AssertEqual(t, uint64(1), s.Stats.CreateSuccess, "")
+}
+
+// Ensure that a failed Create is recorded in the stats.
+func TestStoreStatsCreateFail(t *testing.T) {
+	s := newStore()
+	s.Create("/foo", true, "", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
+	testutil.AssertEqual(t, uint64(1), s.Stats.CreateFail, "")
+}
+
+// Ensure that a successful Update is recorded in the stats.
+func TestStoreStatsUpdateSuccess(t *testing.T) {
+	s := newStore()
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Update("/foo", "baz", TTLOptionSet{ExpireTime: Permanent})
+	testutil.AssertEqual(t, uint64(1), s.Stats.UpdateSuccess, "")
+}
+
+// Ensure that a failed Update is recorded in the stats.
+func TestStoreStatsUpdateFail(t *testing.T) {
+	s := newStore()
+	s.Update("/foo", "bar", TTLOptionSet{ExpireTime: Permanent})
+	testutil.AssertEqual(t, uint64(1), s.Stats.UpdateFail, "")
+}
+
+// Ensure that a successful CAS is recorded in the stats.
+func TestStoreStatsCompareAndSwapSuccess(t *testing.T) {
+	s := newStore()
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
+	s.CompareAndSwap("/foo", "bar", 0, "baz", TTLOptionSet{ExpireTime: Permanent})
+	testutil.AssertEqual(t, uint64(1), s.Stats.CompareAndSwapSuccess, "")
+}
+
+// Ensure that a failed CAS is recorded in the stats.
+func TestStoreStatsCompareAndSwapFail(t *testing.T) {
+	s := newStore()
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
+	s.CompareAndSwap("/foo", "wrong_value", 0, "baz", TTLOptionSet{ExpireTime: Permanent})
+	testutil.AssertEqual(t, uint64(1), s.Stats.CompareAndSwapFail, "")
+}
+
+// Ensure that a successful Delete is recorded in the stats.
+func TestStoreStatsDeleteSuccess(t *testing.T) {
+	s := newStore()
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Delete("/foo", false, false)
+	testutil.AssertEqual(t, uint64(1), s.Stats.DeleteSuccess, "")
+}
+
+// Ensure that a failed Delete is recorded in the stats.
+func TestStoreStatsDeleteFail(t *testing.T) {
+	s := newStore()
+	s.Delete("/foo", false, false)
+	testutil.AssertEqual(t, uint64(1), s.Stats.DeleteFail, "")
+}
+
+//Ensure that the number of expirations is recorded in the stats.
+func TestStoreStatsExpireCount(t *testing.T) {
+	s := newStore()
+	fc := newFakeClock()
+	s.clock = fc
+
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
+	testutil.AssertEqual(t, uint64(0), s.Stats.ExpireCount, "")
+	fc.Advance(600 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+	testutil.AssertEqual(t, uint64(1), s.Stats.ExpireCount, "")
+}
diff --git a/internal/store/store.go b/internal/store/store.go
new file mode 100644
index 0000000..edf7f21
--- /dev/null
+++ b/internal/store/store.go
@@ -0,0 +1,791 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"encoding/json"
+	"fmt"
+	"path"
+	"strconv"
+	"strings"
+	"sync"
+	"time"
+
+	etcdErr "github.com/coreos/etcd/error"
+	"github.com/coreos/etcd/pkg/types"
+	"github.com/jonboulle/clockwork"
+)
+
+// The default version to set when the store is first initialized.
+const defaultVersion = 2
+
+var minExpireTime time.Time
+
+func init() {
+	minExpireTime, _ = time.Parse(time.RFC3339, "2000-01-01T00:00:00Z")
+}
+
+type Store interface {
+	Version() int
+	Index() uint64
+
+	Get(nodePath string, recursive, sorted bool) (*Event, error)
+	Set(nodePath string, dir bool, value string, expireOpts TTLOptionSet) (*Event, error)
+	Update(nodePath string, newValue string, expireOpts TTLOptionSet) (*Event, error)
+	Create(nodePath string, dir bool, value string, unique bool,
+		expireOpts TTLOptionSet) (*Event, error)
+	CompareAndSwap(nodePath string, prevValue string, prevIndex uint64,
+		value string, expireOpts TTLOptionSet) (*Event, error)
+	Delete(nodePath string, dir, recursive bool) (*Event, error)
+	CompareAndDelete(nodePath string, prevValue string, prevIndex uint64) (*Event, error)
+
+	Watch(prefix string, recursive, stream bool, sinceIndex uint64) (Watcher, error)
+
+	Save() ([]byte, error)
+	Recovery(state []byte) error
+
+	Clone() Store
+	SaveNoCopy() ([]byte, error)
+
+	JsonStats() []byte
+	DeleteExpiredKeys(cutoff time.Time)
+
+	HasTTLKeys() bool
+}
+
+type TTLOptionSet struct {
+	ExpireTime time.Time
+	Refresh    bool
+}
+
+type store struct {
+	Root           *node
+	WatcherHub     *watcherHub
+	CurrentIndex   uint64
+	Stats          *Stats
+	CurrentVersion int
+	ttlKeyHeap     *ttlKeyHeap  // need to recovery manually
+	worldLock      sync.RWMutex // stop the world lock
+	clock          clockwork.Clock
+	readonlySet    types.Set
+}
+
+// New creates a store where the given namespaces will be created as initial directories.
+func New(namespaces ...string) Store {
+	s := newStore(namespaces...)
+	s.clock = clockwork.NewRealClock()
+	return s
+}
+
+func newStore(namespaces ...string) *store {
+	s := new(store)
+	s.CurrentVersion = defaultVersion
+	s.Root = newDir(s, "/", s.CurrentIndex, nil, Permanent)
+	for _, namespace := range namespaces {
+		s.Root.Add(newDir(s, namespace, s.CurrentIndex, s.Root, Permanent))
+	}
+	s.Stats = newStats()
+	s.WatcherHub = newWatchHub(1000)
+	s.ttlKeyHeap = newTtlKeyHeap()
+	s.readonlySet = types.NewUnsafeSet(append(namespaces, "/")...)
+	return s
+}
+
+// Version retrieves current version of the store.
+func (s *store) Version() int {
+	return s.CurrentVersion
+}
+
+// Index retrieves the current index of the store.
+func (s *store) Index() uint64 {
+	s.worldLock.RLock()
+	defer s.worldLock.RUnlock()
+	return s.CurrentIndex
+}
+
+// Get returns a get event.
+// If recursive is true, it will return all the content under the node path.
+// If sorted is true, it will sort the content by keys.
+func (s *store) Get(nodePath string, recursive, sorted bool) (*Event, error) {
+	var err *etcdErr.Error
+
+	s.worldLock.RLock()
+	defer s.worldLock.RUnlock()
+
+	defer func() {
+		if err == nil {
+			s.Stats.Inc(GetSuccess)
+			if recursive {
+				reportReadSuccess(GetRecursive)
+			} else {
+				reportReadSuccess(Get)
+			}
+			return
+		}
+
+		s.Stats.Inc(GetFail)
+		if recursive {
+			reportReadFailure(GetRecursive)
+		} else {
+			reportReadFailure(Get)
+		}
+	}()
+
+	n, err := s.internalGet(nodePath)
+	if err != nil {
+		return nil, err
+	}
+
+	e := newEvent(Get, nodePath, n.ModifiedIndex, n.CreatedIndex)
+	e.EtcdIndex = s.CurrentIndex
+	e.Node.loadInternalNode(n, recursive, sorted, s.clock)
+
+	return e, nil
+}
+
+// Create creates the node at nodePath. Create will help to create intermediate directories with no ttl.
+// If the node has already existed, create will fail.
+// If any node on the path is a file, create will fail.
+func (s *store) Create(nodePath string, dir bool, value string, unique bool, expireOpts TTLOptionSet) (*Event, error) {
+	var err *etcdErr.Error
+
+	s.worldLock.Lock()
+	defer s.worldLock.Unlock()
+
+	defer func() {
+		if err == nil {
+			s.Stats.Inc(CreateSuccess)
+			reportWriteSuccess(Create)
+			return
+		}
+
+		s.Stats.Inc(CreateFail)
+		reportWriteFailure(Create)
+	}()
+
+	e, err := s.internalCreate(nodePath, dir, value, unique, false, expireOpts.ExpireTime, Create)
+	if err != nil {
+		return nil, err
+	}
+
+	e.EtcdIndex = s.CurrentIndex
+	s.WatcherHub.notify(e)
+
+	return e, nil
+}
+
+// Set creates or replace the node at nodePath.
+func (s *store) Set(nodePath string, dir bool, value string, expireOpts TTLOptionSet) (*Event, error) {
+	var err *etcdErr.Error
+
+	s.worldLock.Lock()
+	defer s.worldLock.Unlock()
+
+	defer func() {
+		if err == nil {
+			s.Stats.Inc(SetSuccess)
+			reportWriteSuccess(Set)
+			return
+		}
+
+		s.Stats.Inc(SetFail)
+		reportWriteFailure(Set)
+	}()
+
+	// Get prevNode value
+	n, getErr := s.internalGet(nodePath)
+	if getErr != nil && getErr.ErrorCode != etcdErr.EcodeKeyNotFound {
+		err = getErr
+		return nil, err
+	}
+
+	if expireOpts.Refresh {
+		if getErr != nil {
+			err = getErr
+			return nil, err
+		} else {
+			value = n.Value
+		}
+	}
+
+	// Set new value
+	e, err := s.internalCreate(nodePath, dir, value, false, true, expireOpts.ExpireTime, Set)
+	if err != nil {
+		return nil, err
+	}
+	e.EtcdIndex = s.CurrentIndex
+
+	// Put prevNode into event
+	if getErr == nil {
+		prev := newEvent(Get, nodePath, n.ModifiedIndex, n.CreatedIndex)
+		prev.Node.loadInternalNode(n, false, false, s.clock)
+		e.PrevNode = prev.Node
+	}
+
+	if !expireOpts.Refresh {
+		s.WatcherHub.notify(e)
+	} else {
+		e.SetRefresh()
+		s.WatcherHub.add(e)
+	}
+
+	return e, nil
+}
+
+// returns user-readable cause of failed comparison
+func getCompareFailCause(n *node, which int, prevValue string, prevIndex uint64) string {
+	switch which {
+	case CompareIndexNotMatch:
+		return fmt.Sprintf("[%v != %v]", prevIndex, n.ModifiedIndex)
+	case CompareValueNotMatch:
+		return fmt.Sprintf("[%v != %v]", prevValue, n.Value)
+	default:
+		return fmt.Sprintf("[%v != %v] [%v != %v]", prevValue, n.Value, prevIndex, n.ModifiedIndex)
+	}
+}
+
+func (s *store) CompareAndSwap(nodePath string, prevValue string, prevIndex uint64,
+	value string, expireOpts TTLOptionSet) (*Event, error) {
+
+	var err *etcdErr.Error
+
+	s.worldLock.Lock()
+	defer s.worldLock.Unlock()
+
+	defer func() {
+		if err == nil {
+			s.Stats.Inc(CompareAndSwapSuccess)
+			reportWriteSuccess(CompareAndSwap)
+			return
+		}
+
+		s.Stats.Inc(CompareAndSwapFail)
+		reportWriteFailure(CompareAndSwap)
+	}()
+
+	nodePath = path.Clean(path.Join("/", nodePath))
+	// we do not allow the user to change "/"
+	if s.readonlySet.Contains(nodePath) {
+		return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", s.CurrentIndex)
+	}
+
+	n, err := s.internalGet(nodePath)
+	if err != nil {
+		return nil, err
+	}
+	if n.IsDir() { // can only compare and swap file
+		err = etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, s.CurrentIndex)
+		return nil, err
+	}
+
+	// If both of the prevValue and prevIndex are given, we will test both of them.
+	// Command will be executed, only if both of the tests are successful.
+	if ok, which := n.Compare(prevValue, prevIndex); !ok {
+		cause := getCompareFailCause(n, which, prevValue, prevIndex)
+		err = etcdErr.NewError(etcdErr.EcodeTestFailed, cause, s.CurrentIndex)
+		return nil, err
+	}
+
+	if expireOpts.Refresh {
+		value = n.Value
+	}
+
+	// update etcd index
+	s.CurrentIndex++
+
+	e := newEvent(CompareAndSwap, nodePath, s.CurrentIndex, n.CreatedIndex)
+	e.EtcdIndex = s.CurrentIndex
+	e.PrevNode = n.Repr(false, false, s.clock)
+	eNode := e.Node
+
+	// if test succeed, write the value
+	n.Write(value, s.CurrentIndex)
+	n.UpdateTTL(expireOpts.ExpireTime)
+
+	// copy the value for safety
+	valueCopy := value
+	eNode.Value = &valueCopy
+	eNode.Expiration, eNode.TTL = n.expirationAndTTL(s.clock)
+
+	if !expireOpts.Refresh {
+		s.WatcherHub.notify(e)
+	} else {
+		e.SetRefresh()
+		s.WatcherHub.add(e)
+	}
+
+	return e, nil
+}
+
+// Delete deletes the node at the given path.
+// If the node is a directory, recursive must be true to delete it.
+func (s *store) Delete(nodePath string, dir, recursive bool) (*Event, error) {
+	var err *etcdErr.Error
+
+	s.worldLock.Lock()
+	defer s.worldLock.Unlock()
+
+	defer func() {
+		if err == nil {
+			s.Stats.Inc(DeleteSuccess)
+			reportWriteSuccess(Delete)
+			return
+		}
+
+		s.Stats.Inc(DeleteFail)
+		reportWriteFailure(Delete)
+	}()
+
+	nodePath = path.Clean(path.Join("/", nodePath))
+	// we do not allow the user to change "/"
+	if s.readonlySet.Contains(nodePath) {
+		return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", s.CurrentIndex)
+	}
+
+	// recursive implies dir
+	if recursive {
+		dir = true
+	}
+
+	n, err := s.internalGet(nodePath)
+	if err != nil { // if the node does not exist, return error
+		return nil, err
+	}
+
+	nextIndex := s.CurrentIndex + 1
+	e := newEvent(Delete, nodePath, nextIndex, n.CreatedIndex)
+	e.EtcdIndex = nextIndex
+	e.PrevNode = n.Repr(false, false, s.clock)
+	eNode := e.Node
+
+	if n.IsDir() {
+		eNode.Dir = true
+	}
+
+	callback := func(path string) { // notify function
+		// notify the watchers with deleted set true
+		s.WatcherHub.notifyWatchers(e, path, true)
+	}
+
+	err = n.Remove(dir, recursive, callback)
+	if err != nil {
+		return nil, err
+	}
+
+	// update etcd index
+	s.CurrentIndex++
+
+	s.WatcherHub.notify(e)
+
+	return e, nil
+}
+
+func (s *store) CompareAndDelete(nodePath string, prevValue string, prevIndex uint64) (*Event, error) {
+	var err *etcdErr.Error
+
+	s.worldLock.Lock()
+	defer s.worldLock.Unlock()
+
+	defer func() {
+		if err == nil {
+			s.Stats.Inc(CompareAndDeleteSuccess)
+			reportWriteSuccess(CompareAndDelete)
+			return
+		}
+
+		s.Stats.Inc(CompareAndDeleteFail)
+		reportWriteFailure(CompareAndDelete)
+	}()
+
+	nodePath = path.Clean(path.Join("/", nodePath))
+
+	n, err := s.internalGet(nodePath)
+	if err != nil { // if the node does not exist, return error
+		return nil, err
+	}
+	if n.IsDir() { // can only compare and delete file
+		return nil, etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, s.CurrentIndex)
+	}
+
+	// If both of the prevValue and prevIndex are given, we will test both of them.
+	// Command will be executed, only if both of the tests are successful.
+	if ok, which := n.Compare(prevValue, prevIndex); !ok {
+		cause := getCompareFailCause(n, which, prevValue, prevIndex)
+		return nil, etcdErr.NewError(etcdErr.EcodeTestFailed, cause, s.CurrentIndex)
+	}
+
+	// update etcd index
+	s.CurrentIndex++
+
+	e := newEvent(CompareAndDelete, nodePath, s.CurrentIndex, n.CreatedIndex)
+	e.EtcdIndex = s.CurrentIndex
+	e.PrevNode = n.Repr(false, false, s.clock)
+
+	callback := func(path string) { // notify function
+		// notify the watchers with deleted set true
+		s.WatcherHub.notifyWatchers(e, path, true)
+	}
+
+	err = n.Remove(false, false, callback)
+	if err != nil {
+		return nil, err
+	}
+
+	s.WatcherHub.notify(e)
+
+	return e, nil
+}
+
+func (s *store) Watch(key string, recursive, stream bool, sinceIndex uint64) (Watcher, error) {
+	s.worldLock.RLock()
+	defer s.worldLock.RUnlock()
+
+	key = path.Clean(path.Join("/", key))
+	if sinceIndex == 0 {
+		sinceIndex = s.CurrentIndex + 1
+	}
+	// WatcherHub does not know about the current index, so we need to pass it in
+	w, err := s.WatcherHub.watch(key, recursive, stream, sinceIndex, s.CurrentIndex)
+	if err != nil {
+		return nil, err
+	}
+
+	return w, nil
+}
+
+// walk walks all the nodePath and apply the walkFunc on each directory
+func (s *store) walk(nodePath string, walkFunc func(prev *node, component string) (*node, *etcdErr.Error)) (*node, *etcdErr.Error) {
+	components := strings.Split(nodePath, "/")
+
+	curr := s.Root
+	var err *etcdErr.Error
+
+	for i := 1; i < len(components); i++ {
+		if len(components[i]) == 0 { // ignore empty string
+			return curr, nil
+		}
+
+		curr, err = walkFunc(curr, components[i])
+		if err != nil {
+			return nil, err
+		}
+	}
+
+	return curr, nil
+}
+
+// Update updates the value/ttl of the node.
+// If the node is a file, the value and the ttl can be updated.
+// If the node is a directory, only the ttl can be updated.
+func (s *store) Update(nodePath string, newValue string, expireOpts TTLOptionSet) (*Event, error) {
+	var err *etcdErr.Error
+
+	s.worldLock.Lock()
+	defer s.worldLock.Unlock()
+
+	defer func() {
+		if err == nil {
+			s.Stats.Inc(UpdateSuccess)
+			reportWriteSuccess(Update)
+			return
+		}
+
+		s.Stats.Inc(UpdateFail)
+		reportWriteFailure(Update)
+	}()
+
+	nodePath = path.Clean(path.Join("/", nodePath))
+	// we do not allow the user to change "/"
+	if s.readonlySet.Contains(nodePath) {
+		return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", s.CurrentIndex)
+	}
+
+	currIndex, nextIndex := s.CurrentIndex, s.CurrentIndex+1
+
+	n, err := s.internalGet(nodePath)
+	if err != nil { // if the node does not exist, return error
+		return nil, err
+	}
+	if n.IsDir() && len(newValue) != 0 {
+		// if the node is a directory, we cannot update value to non-empty
+		return nil, etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, currIndex)
+	}
+
+	if expireOpts.Refresh {
+		newValue = n.Value
+	}
+
+	e := newEvent(Update, nodePath, nextIndex, n.CreatedIndex)
+	e.EtcdIndex = nextIndex
+	e.PrevNode = n.Repr(false, false, s.clock)
+	eNode := e.Node
+
+	n.Write(newValue, nextIndex)
+
+	if n.IsDir() {
+		eNode.Dir = true
+	} else {
+		// copy the value for safety
+		newValueCopy := newValue
+		eNode.Value = &newValueCopy
+	}
+
+	// update ttl
+	n.UpdateTTL(expireOpts.ExpireTime)
+
+	eNode.Expiration, eNode.TTL = n.expirationAndTTL(s.clock)
+
+	if !expireOpts.Refresh {
+		s.WatcherHub.notify(e)
+	} else {
+		e.SetRefresh()
+		s.WatcherHub.add(e)
+	}
+
+	s.CurrentIndex = nextIndex
+
+	return e, nil
+}
+
+func (s *store) internalCreate(nodePath string, dir bool, value string, unique, replace bool,
+	expireTime time.Time, action string) (*Event, *etcdErr.Error) {
+
+	currIndex, nextIndex := s.CurrentIndex, s.CurrentIndex+1
+
+	if unique { // append unique item under the node path
+		nodePath += "/" + fmt.Sprintf("%020s", strconv.FormatUint(nextIndex, 10))
+	}
+
+	nodePath = path.Clean(path.Join("/", nodePath))
+
+	// we do not allow the user to change "/"
+	if s.readonlySet.Contains(nodePath) {
+		return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", currIndex)
+	}
+
+	// Assume expire times that are way in the past are
+	// This can occur when the time is serialized to JS
+	if expireTime.Before(minExpireTime) {
+		expireTime = Permanent
+	}
+
+	dirName, nodeName := path.Split(nodePath)
+
+	// walk through the nodePath, create dirs and get the last directory node
+	d, err := s.walk(dirName, s.checkDir)
+
+	if err != nil {
+		s.Stats.Inc(SetFail)
+		reportWriteFailure(action)
+		err.Index = currIndex
+		return nil, err
+	}
+
+	e := newEvent(action, nodePath, nextIndex, nextIndex)
+	eNode := e.Node
+
+	n, _ := d.GetChild(nodeName)
+
+	// force will try to replace an existing file
+	if n != nil {
+		if replace {
+			if n.IsDir() {
+				return nil, etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, currIndex)
+			}
+			e.PrevNode = n.Repr(false, false, s.clock)
+
+			n.Remove(false, false, nil)
+		} else {
+			return nil, etcdErr.NewError(etcdErr.EcodeNodeExist, nodePath, currIndex)
+		}
+	}
+
+	if !dir { // create file
+		// copy the value for safety
+		valueCopy := value
+		eNode.Value = &valueCopy
+
+		n = newKV(s, nodePath, value, nextIndex, d, expireTime)
+
+	} else { // create directory
+		eNode.Dir = true
+
+		n = newDir(s, nodePath, nextIndex, d, expireTime)
+	}
+
+	// we are sure d is a directory and does not have the children with name n.Name
+	d.Add(n)
+
+	// node with TTL
+	if !n.IsPermanent() {
+		s.ttlKeyHeap.push(n)
+
+		eNode.Expiration, eNode.TTL = n.expirationAndTTL(s.clock)
+	}
+
+	s.CurrentIndex = nextIndex
+
+	return e, nil
+}
+
+// InternalGet gets the node of the given nodePath.
+func (s *store) internalGet(nodePath string) (*node, *etcdErr.Error) {
+	nodePath = path.Clean(path.Join("/", nodePath))
+
+	walkFunc := func(parent *node, name string) (*node, *etcdErr.Error) {
+
+		if !parent.IsDir() {
+			err := etcdErr.NewError(etcdErr.EcodeNotDir, parent.Path, s.CurrentIndex)
+			return nil, err
+		}
+
+		child, ok := parent.Children[name]
+		if ok {
+			return child, nil
+		}
+
+		return nil, etcdErr.NewError(etcdErr.EcodeKeyNotFound, path.Join(parent.Path, name), s.CurrentIndex)
+	}
+
+	f, err := s.walk(nodePath, walkFunc)
+
+	if err != nil {
+		return nil, err
+	}
+	return f, nil
+}
+
+// DeleteExpiredKeys will delete all expired keys
+func (s *store) DeleteExpiredKeys(cutoff time.Time) {
+	s.worldLock.Lock()
+	defer s.worldLock.Unlock()
+
+	for {
+		node := s.ttlKeyHeap.top()
+		if node == nil || node.ExpireTime.After(cutoff) {
+			break
+		}
+
+		s.CurrentIndex++
+		e := newEvent(Expire, node.Path, s.CurrentIndex, node.CreatedIndex)
+		e.EtcdIndex = s.CurrentIndex
+		e.PrevNode = node.Repr(false, false, s.clock)
+		if node.IsDir() {
+			e.Node.Dir = true
+		}
+
+		callback := func(path string) { // notify function
+			// notify the watchers with deleted set true
+			s.WatcherHub.notifyWatchers(e, path, true)
+		}
+
+		s.ttlKeyHeap.pop()
+		node.Remove(true, true, callback)
+
+		reportExpiredKey()
+		s.Stats.Inc(ExpireCount)
+
+		s.WatcherHub.notify(e)
+	}
+
+}
+
+// checkDir will check whether the component is a directory under parent node.
+// If it is a directory, this function will return the pointer to that node.
+// If it does not exist, this function will create a new directory and return the pointer to that node.
+// If it is a file, this function will return error.
+func (s *store) checkDir(parent *node, dirName string) (*node, *etcdErr.Error) {
+	node, ok := parent.Children[dirName]
+
+	if ok {
+		if node.IsDir() {
+			return node, nil
+		}
+
+		return nil, etcdErr.NewError(etcdErr.EcodeNotDir, node.Path, s.CurrentIndex)
+	}
+
+	n := newDir(s, path.Join(parent.Path, dirName), s.CurrentIndex+1, parent, Permanent)
+
+	parent.Children[dirName] = n
+
+	return n, nil
+}
+
+// Save saves the static state of the store system.
+// It will not be able to save the state of watchers.
+// It will not save the parent field of the node. Or there will
+// be cyclic dependencies issue for the json package.
+func (s *store) Save() ([]byte, error) {
+	b, err := json.Marshal(s.Clone())
+	if err != nil {
+		return nil, err
+	}
+
+	return b, nil
+}
+
+func (s *store) SaveNoCopy() ([]byte, error) {
+	b, err := json.Marshal(s)
+	if err != nil {
+		return nil, err
+	}
+
+	return b, nil
+}
+
+func (s *store) Clone() Store {
+	s.worldLock.Lock()
+
+	clonedStore := newStore()
+	clonedStore.CurrentIndex = s.CurrentIndex
+	clonedStore.Root = s.Root.Clone()
+	clonedStore.WatcherHub = s.WatcherHub.clone()
+	clonedStore.Stats = s.Stats.clone()
+	clonedStore.CurrentVersion = s.CurrentVersion
+
+	s.worldLock.Unlock()
+	return clonedStore
+}
+
+// Recovery recovers the store system from a static state
+// It needs to recover the parent field of the nodes.
+// It needs to delete the expired nodes since the saved time and also
+// needs to create monitoring go routines.
+func (s *store) Recovery(state []byte) error {
+	s.worldLock.Lock()
+	defer s.worldLock.Unlock()
+	err := json.Unmarshal(state, s)
+
+	if err != nil {
+		return err
+	}
+
+	s.ttlKeyHeap = newTtlKeyHeap()
+
+	s.Root.recoverAndclean()
+	return nil
+}
+
+func (s *store) JsonStats() []byte {
+	s.Stats.Watchers = uint64(s.WatcherHub.count)
+	return s.Stats.toJson()
+}
+
+func (s *store) HasTTLKeys() bool {
+	s.worldLock.RLock()
+	defer s.worldLock.RUnlock()
+	return s.ttlKeyHeap.Len() != 0
+}
diff --git a/internal/store/store_bench_test.go b/internal/store/store_bench_test.go
new file mode 100644
index 0000000..f84309c
--- /dev/null
+++ b/internal/store/store_bench_test.go
@@ -0,0 +1,218 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"encoding/json"
+	"fmt"
+	"runtime"
+	"testing"
+)
+
+func BenchmarkStoreSet128Bytes(b *testing.B) {
+	benchStoreSet(b, 128, nil)
+}
+
+func BenchmarkStoreSet1024Bytes(b *testing.B) {
+	benchStoreSet(b, 1024, nil)
+}
+
+func BenchmarkStoreSet4096Bytes(b *testing.B) {
+	benchStoreSet(b, 4096, nil)
+}
+
+func BenchmarkStoreSetWithJson128Bytes(b *testing.B) {
+	benchStoreSet(b, 128, json.Marshal)
+}
+
+func BenchmarkStoreSetWithJson1024Bytes(b *testing.B) {
+	benchStoreSet(b, 1024, json.Marshal)
+}
+
+func BenchmarkStoreSetWithJson4096Bytes(b *testing.B) {
+	benchStoreSet(b, 4096, json.Marshal)
+}
+
+func BenchmarkStoreDelete(b *testing.B) {
+	b.StopTimer()
+
+	s := newStore()
+	kvs, _ := generateNRandomKV(b.N, 128)
+
+	memStats := new(runtime.MemStats)
+	runtime.GC()
+	runtime.ReadMemStats(memStats)
+
+	for i := 0; i < b.N; i++ {
+		_, err := s.Set(kvs[i][0], false, kvs[i][1], TTLOptionSet{ExpireTime: Permanent})
+		if err != nil {
+			panic(err)
+		}
+	}
+
+	setMemStats := new(runtime.MemStats)
+	runtime.GC()
+	runtime.ReadMemStats(setMemStats)
+
+	b.StartTimer()
+
+	for i := range kvs {
+		s.Delete(kvs[i][0], false, false)
+	}
+
+	b.StopTimer()
+
+	// clean up
+	e, err := s.Get("/", false, false)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, n := range e.Node.Nodes {
+		_, err := s.Delete(n.Key, true, true)
+		if err != nil {
+			panic(err)
+		}
+	}
+	s.WatcherHub.EventHistory = nil
+
+	deleteMemStats := new(runtime.MemStats)
+	runtime.GC()
+	runtime.ReadMemStats(deleteMemStats)
+
+	fmt.Printf("\nBefore set Alloc: %v; After set Alloc: %v, After delete Alloc: %v\n",
+		memStats.Alloc/1000, setMemStats.Alloc/1000, deleteMemStats.Alloc/1000)
+}
+
+func BenchmarkWatch(b *testing.B) {
+	b.StopTimer()
+	s := newStore()
+	kvs, _ := generateNRandomKV(b.N, 128)
+	b.StartTimer()
+
+	memStats := new(runtime.MemStats)
+	runtime.GC()
+	runtime.ReadMemStats(memStats)
+
+	for i := 0; i < b.N; i++ {
+		w, _ := s.Watch(kvs[i][0], false, false, 0)
+
+		e := newEvent("set", kvs[i][0], uint64(i+1), uint64(i+1))
+		s.WatcherHub.notify(e)
+		<-w.EventChan()
+		s.CurrentIndex++
+	}
+
+	s.WatcherHub.EventHistory = nil
+	afterMemStats := new(runtime.MemStats)
+	runtime.GC()
+	runtime.ReadMemStats(afterMemStats)
+	fmt.Printf("\nBefore Alloc: %v; After Alloc: %v\n",
+		memStats.Alloc/1000, afterMemStats.Alloc/1000)
+}
+
+func BenchmarkWatchWithSet(b *testing.B) {
+	b.StopTimer()
+	s := newStore()
+	kvs, _ := generateNRandomKV(b.N, 128)
+	b.StartTimer()
+
+	for i := 0; i < b.N; i++ {
+		w, _ := s.Watch(kvs[i][0], false, false, 0)
+
+		s.Set(kvs[i][0], false, "test", TTLOptionSet{ExpireTime: Permanent})
+		<-w.EventChan()
+	}
+}
+
+func BenchmarkWatchWithSetBatch(b *testing.B) {
+	b.StopTimer()
+	s := newStore()
+	kvs, _ := generateNRandomKV(b.N, 128)
+	b.StartTimer()
+
+	watchers := make([]Watcher, b.N)
+
+	for i := 0; i < b.N; i++ {
+		watchers[i], _ = s.Watch(kvs[i][0], false, false, 0)
+	}
+
+	for i := 0; i < b.N; i++ {
+		s.Set(kvs[i][0], false, "test", TTLOptionSet{ExpireTime: Permanent})
+	}
+
+	for i := 0; i < b.N; i++ {
+		<-watchers[i].EventChan()
+	}
+
+}
+
+func BenchmarkWatchOneKey(b *testing.B) {
+	s := newStore()
+	watchers := make([]Watcher, b.N)
+
+	for i := 0; i < b.N; i++ {
+		watchers[i], _ = s.Watch("/foo", false, false, 0)
+	}
+
+	s.Set("/foo", false, "", TTLOptionSet{ExpireTime: Permanent})
+
+	for i := 0; i < b.N; i++ {
+		<-watchers[i].EventChan()
+	}
+}
+
+func benchStoreSet(b *testing.B, valueSize int, process func(interface{}) ([]byte, error)) {
+	s := newStore()
+	b.StopTimer()
+	kvs, size := generateNRandomKV(b.N, valueSize)
+	b.StartTimer()
+
+	for i := 0; i < b.N; i++ {
+		resp, err := s.Set(kvs[i][0], false, kvs[i][1], TTLOptionSet{ExpireTime: Permanent})
+		if err != nil {
+			panic(err)
+		}
+
+		if process != nil {
+			_, err = process(resp)
+			if err != nil {
+				panic(err)
+			}
+		}
+	}
+
+	b.StopTimer()
+	memStats := new(runtime.MemStats)
+	runtime.GC()
+	runtime.ReadMemStats(memStats)
+	fmt.Printf("\nAlloc: %vKB; Data: %vKB; Kvs: %v; Alloc/Data:%v\n",
+		memStats.Alloc/1000, size/1000, b.N, memStats.Alloc/size)
+}
+
+func generateNRandomKV(n int, valueSize int) ([][]string, uint64) {
+	var size uint64
+	kvs := make([][]string, n)
+	bytes := make([]byte, valueSize)
+
+	for i := 0; i < n; i++ {
+		kvs[i] = make([]string, 2)
+		kvs[i][0] = fmt.Sprintf("/%010d/%010d/%010d", n, n, n)
+		kvs[i][1] = string(bytes)
+		size = size + uint64(len(kvs[i][0])) + uint64(len(kvs[i][1]))
+	}
+
+	return kvs, size
+}
diff --git a/internal/store/store_test.go b/internal/store/store_test.go
new file mode 100644
index 0000000..4e89ee8
--- /dev/null
+++ b/internal/store/store_test.go
@@ -0,0 +1,862 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store_test
+
+import (
+	"testing"
+	"time"
+
+	etcdErr "github.com/coreos/etcd/error"
+	"github.com/coreos/etcd/internal/store"
+	"github.com/coreos/etcd/pkg/testutil"
+)
+
+type StoreCloser interface {
+	store.Store
+	Close()
+}
+
+func TestNewStoreWithNamespaces(t *testing.T) {
+	s := newTestStore(t, "/0", "/1")
+	defer s.Close()
+
+	_, err := s.Get("/0", false, false)
+	testutil.AssertNil(t, err)
+	_, err = s.Get("/1", false, false)
+	testutil.AssertNil(t, err)
+}
+
+// Ensure that the store can retrieve an existing value.
+func TestStoreGetValue(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	var eidx uint64 = 1
+	e, err := s.Get("/foo", false, false)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "get")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertEqual(t, *e.Node.Value, "bar")
+}
+
+// Ensure that the store can retrieve a directory in sorted order.
+func TestStoreGetSorted(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	s.Create("/foo/x", false, "0", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	s.Create("/foo/z", false, "0", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	s.Create("/foo/y", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	s.Create("/foo/y/a", false, "0", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	s.Create("/foo/y/b", false, "0", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	var eidx uint64 = 6
+	e, err := s.Get("/foo", true, true)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+
+	var yNodes store.NodeExterns
+	sortedStrings := []string{"/foo/x", "/foo/y", "/foo/z"}
+	for i := range e.Node.Nodes {
+		node := e.Node.Nodes[i]
+		if node.Key != sortedStrings[i] {
+			t.Errorf("expect key = %s, got key = %s", sortedStrings[i], node.Key)
+		}
+		if node.Key == "/foo/y" {
+			yNodes = node.Nodes
+		}
+	}
+
+	sortedStrings = []string{"/foo/y/a", "/foo/y/b"}
+	for i := range yNodes {
+		node := yNodes[i]
+		if node.Key != sortedStrings[i] {
+			t.Errorf("expect key = %s, got key = %s", sortedStrings[i], node.Key)
+		}
+	}
+}
+
+func TestSet(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	// Set /foo=""
+	var eidx uint64 = 1
+	e, err := s.Set("/foo", false, "", store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "set")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertFalse(t, e.Node.Dir)
+	testutil.AssertEqual(t, *e.Node.Value, "")
+	testutil.AssertNil(t, e.Node.Nodes)
+	testutil.AssertNil(t, e.Node.Expiration)
+	testutil.AssertEqual(t, e.Node.TTL, int64(0))
+	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(1))
+
+	// Set /foo="bar"
+	eidx = 2
+	e, err = s.Set("/foo", false, "bar", store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "set")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertFalse(t, e.Node.Dir)
+	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	testutil.AssertNil(t, e.Node.Nodes)
+	testutil.AssertNil(t, e.Node.Expiration)
+	testutil.AssertEqual(t, e.Node.TTL, int64(0))
+	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(2))
+	// check prevNode
+	testutil.AssertNotNil(t, e.PrevNode)
+	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
+	testutil.AssertEqual(t, *e.PrevNode.Value, "")
+	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
+	// Set /foo="baz" (for testing prevNode)
+	eidx = 3
+	e, err = s.Set("/foo", false, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "set")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertFalse(t, e.Node.Dir)
+	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	testutil.AssertNil(t, e.Node.Nodes)
+	testutil.AssertNil(t, e.Node.Expiration)
+	testutil.AssertEqual(t, e.Node.TTL, int64(0))
+	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(3))
+	// check prevNode
+	testutil.AssertNotNil(t, e.PrevNode)
+	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
+	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(2))
+
+	// Set /dir as a directory
+	eidx = 4
+	e, err = s.Set("/dir", true, "", store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "set")
+	testutil.AssertEqual(t, e.Node.Key, "/dir")
+	testutil.AssertTrue(t, e.Node.Dir)
+	testutil.AssertNil(t, e.Node.Value)
+	testutil.AssertNil(t, e.Node.Nodes)
+	testutil.AssertNil(t, e.Node.Expiration)
+	testutil.AssertEqual(t, e.Node.TTL, int64(0))
+	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(4))
+}
+
+// Ensure that the store can create a new key if it doesn't already exist.
+func TestStoreCreateValue(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	// Create /foo=bar
+	var eidx uint64 = 1
+	e, err := s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "create")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertFalse(t, e.Node.Dir)
+	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	testutil.AssertNil(t, e.Node.Nodes)
+	testutil.AssertNil(t, e.Node.Expiration)
+	testutil.AssertEqual(t, e.Node.TTL, int64(0))
+	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(1))
+
+	// Create /empty=""
+	eidx = 2
+	e, err = s.Create("/empty", false, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "create")
+	testutil.AssertEqual(t, e.Node.Key, "/empty")
+	testutil.AssertFalse(t, e.Node.Dir)
+	testutil.AssertEqual(t, *e.Node.Value, "")
+	testutil.AssertNil(t, e.Node.Nodes)
+	testutil.AssertNil(t, e.Node.Expiration)
+	testutil.AssertEqual(t, e.Node.TTL, int64(0))
+	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(2))
+
+}
+
+// Ensure that the store can create a new directory if it doesn't already exist.
+func TestStoreCreateDirectory(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	var eidx uint64 = 1
+	e, err := s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "create")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertTrue(t, e.Node.Dir)
+}
+
+// Ensure that the store fails to create a key if it already exists.
+func TestStoreCreateFailsIfExists(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	// create /foo as dir
+	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+
+	// create /foo as dir again
+	e, _err := s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	err := _err.(*etcdErr.Error)
+	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeNodeExist)
+	testutil.AssertEqual(t, err.Message, "Key already exists")
+	testutil.AssertEqual(t, err.Cause, "/foo")
+	testutil.AssertEqual(t, err.Index, uint64(1))
+	testutil.AssertNil(t, e)
+}
+
+// Ensure that the store can update a key if it already exists.
+func TestStoreUpdateValue(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	// create /foo=bar
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	// update /foo="bzr"
+	var eidx uint64 = 2
+	e, err := s.Update("/foo", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "update")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertFalse(t, e.Node.Dir)
+	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	testutil.AssertEqual(t, e.Node.TTL, int64(0))
+	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(2))
+	// check prevNode
+	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
+	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+	testutil.AssertEqual(t, e.PrevNode.TTL, int64(0))
+	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
+
+	e, _ = s.Get("/foo", false, false)
+	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+
+	// update /foo=""
+	eidx = 3
+	e, err = s.Update("/foo", "", store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "update")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertFalse(t, e.Node.Dir)
+	testutil.AssertEqual(t, *e.Node.Value, "")
+	testutil.AssertEqual(t, e.Node.TTL, int64(0))
+	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(3))
+	// check prevNode
+	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
+	testutil.AssertEqual(t, *e.PrevNode.Value, "baz")
+	testutil.AssertEqual(t, e.PrevNode.TTL, int64(0))
+	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(2))
+
+	e, _ = s.Get("/foo", false, false)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, *e.Node.Value, "")
+}
+
+// Ensure that the store cannot update a directory.
+func TestStoreUpdateFailsIfDirectory(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e, _err := s.Update("/foo", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	err := _err.(*etcdErr.Error)
+	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeNotFile)
+	testutil.AssertEqual(t, err.Message, "Not a file")
+	testutil.AssertEqual(t, err.Cause, "/foo")
+	testutil.AssertNil(t, e)
+}
+
+// Ensure that the store can delete a value.
+func TestStoreDeleteValue(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	var eidx uint64 = 2
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e, err := s.Delete("/foo", false, false)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "delete")
+	// check prevNode
+	testutil.AssertNotNil(t, e.PrevNode)
+	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
+	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+}
+
+// Ensure that the store can delete a directory if recursive is specified.
+func TestStoreDeleteDirectory(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	// create directory /foo
+	var eidx uint64 = 2
+	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	// delete /foo with dir = true and recursive = false
+	// this should succeed, since the directory is empty
+	e, err := s.Delete("/foo", true, false)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "delete")
+	// check prevNode
+	testutil.AssertNotNil(t, e.PrevNode)
+	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
+	testutil.AssertEqual(t, e.PrevNode.Dir, true)
+
+	// create directory /foo and directory /foo/bar
+	_, err = s.Create("/foo/bar", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	// delete /foo with dir = true and recursive = false
+	// this should fail, since the directory is not empty
+	_, err = s.Delete("/foo", true, false)
+	testutil.AssertNotNil(t, err)
+
+	// delete /foo with dir=false and recursive = true
+	// this should succeed, since recursive implies dir=true
+	// and recursively delete should be able to delete all
+	// items under the given directory
+	e, err = s.Delete("/foo", false, true)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.Action, "delete")
+
+}
+
+// Ensure that the store cannot delete a directory if both of recursive
+// and dir are not specified.
+func TestStoreDeleteDirectoryFailsIfNonRecursiveAndDir(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e, _err := s.Delete("/foo", false, false)
+	err := _err.(*etcdErr.Error)
+	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeNotFile)
+	testutil.AssertEqual(t, err.Message, "Not a file")
+	testutil.AssertNil(t, e)
+}
+
+func TestRootRdOnly(t *testing.T) {
+	s := newTestStore(t, "/0")
+	defer s.Close()
+
+	for _, tt := range []string{"/", "/0"} {
+		_, err := s.Set(tt, true, "", store.TTLOptionSet{ExpireTime: store.Permanent})
+		testutil.AssertNotNil(t, err)
+
+		_, err = s.Delete(tt, true, true)
+		testutil.AssertNotNil(t, err)
+
+		_, err = s.Create(tt, true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+		testutil.AssertNotNil(t, err)
+
+		_, err = s.Update(tt, "", store.TTLOptionSet{ExpireTime: store.Permanent})
+		testutil.AssertNotNil(t, err)
+
+		_, err = s.CompareAndSwap(tt, "", 0, "", store.TTLOptionSet{ExpireTime: store.Permanent})
+		testutil.AssertNotNil(t, err)
+	}
+}
+
+func TestStoreCompareAndDeletePrevValue(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	var eidx uint64 = 2
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e, err := s.CompareAndDelete("/foo", "bar", 0)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "compareAndDelete")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+
+	// check prevNode
+	testutil.AssertNotNil(t, e.PrevNode)
+	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
+	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
+	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
+}
+
+func TestStoreCompareAndDeletePrevValueFailsIfNotMatch(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	var eidx uint64 = 1
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e, _err := s.CompareAndDelete("/foo", "baz", 0)
+	err := _err.(*etcdErr.Error)
+	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeTestFailed)
+	testutil.AssertEqual(t, err.Message, "Compare failed")
+	testutil.AssertNil(t, e)
+	e, _ = s.Get("/foo", false, false)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, *e.Node.Value, "bar")
+}
+
+func TestStoreCompareAndDeletePrevIndex(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	var eidx uint64 = 2
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e, err := s.CompareAndDelete("/foo", "", 1)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "compareAndDelete")
+	// check prevNode
+	testutil.AssertNotNil(t, e.PrevNode)
+	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
+	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
+	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
+}
+
+func TestStoreCompareAndDeletePrevIndexFailsIfNotMatch(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	var eidx uint64 = 1
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e, _err := s.CompareAndDelete("/foo", "", 100)
+	testutil.AssertNotNil(t, _err)
+	err := _err.(*etcdErr.Error)
+	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeTestFailed)
+	testutil.AssertEqual(t, err.Message, "Compare failed")
+	testutil.AssertNil(t, e)
+	e, _ = s.Get("/foo", false, false)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, *e.Node.Value, "bar")
+}
+
+// Ensure that the store cannot delete a directory.
+func TestStoreCompareAndDeleteDirectoryFail(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	_, _err := s.CompareAndDelete("/foo", "", 0)
+	testutil.AssertNotNil(t, _err)
+	err := _err.(*etcdErr.Error)
+	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeNotFile)
+}
+
+// Ensure that the store can conditionally update a key if it has a previous value.
+func TestStoreCompareAndSwapPrevValue(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+
+	var eidx uint64 = 2
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e, err := s.CompareAndSwap("/foo", "bar", 0, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "compareAndSwap")
+	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	// check prevNode
+	testutil.AssertNotNil(t, e.PrevNode)
+	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
+	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
+	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
+
+	e, _ = s.Get("/foo", false, false)
+	testutil.AssertEqual(t, *e.Node.Value, "baz")
+}
+
+// Ensure that the store cannot conditionally update a key if it has the wrong previous value.
+func TestStoreCompareAndSwapPrevValueFailsIfNotMatch(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 1
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e, _err := s.CompareAndSwap("/foo", "wrong_value", 0, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	err := _err.(*etcdErr.Error)
+	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeTestFailed)
+	testutil.AssertEqual(t, err.Message, "Compare failed")
+	testutil.AssertNil(t, e)
+	e, _ = s.Get("/foo", false, false)
+	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+}
+
+// Ensure that the store can conditionally update a key if it has a previous index.
+func TestStoreCompareAndSwapPrevIndex(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 2
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e, err := s.CompareAndSwap("/foo", "", 1, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "compareAndSwap")
+	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	// check prevNode
+	testutil.AssertNotNil(t, e.PrevNode)
+	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
+	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
+	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
+
+	e, _ = s.Get("/foo", false, false)
+	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+}
+
+// Ensure that the store cannot conditionally update a key if it has the wrong previous index.
+func TestStoreCompareAndSwapPrevIndexFailsIfNotMatch(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 1
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e, _err := s.CompareAndSwap("/foo", "", 100, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	err := _err.(*etcdErr.Error)
+	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeTestFailed)
+	testutil.AssertEqual(t, err.Message, "Compare failed")
+	testutil.AssertNil(t, e)
+	e, _ = s.Get("/foo", false, false)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, *e.Node.Value, "bar")
+}
+
+// Ensure that the store can watch for key creation.
+func TestStoreWatchCreate(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 0
+	w, _ := s.Watch("/foo", false, false, 0)
+	c := w.EventChan()
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	eidx = 1
+	e := timeoutSelect(t, c)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "create")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	select {
+	case e = <-w.EventChan():
+		testutil.AssertNil(t, e)
+	case <-time.After(100 * time.Millisecond):
+	}
+}
+
+// Ensure that the store can watch for recursive key creation.
+func TestStoreWatchRecursiveCreate(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 0
+	w, err := s.Watch("/foo", true, false, 0)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	eidx = 1
+	s.Create("/foo/bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "create")
+	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
+}
+
+// Ensure that the store can watch for key updates.
+func TestStoreWatchUpdate(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 1
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	w, _ := s.Watch("/foo", false, false, 0)
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	eidx = 2
+	s.Update("/foo", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "update")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+}
+
+// Ensure that the store can watch for recursive key updates.
+func TestStoreWatchRecursiveUpdate(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 1
+	s.Create("/foo/bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	w, err := s.Watch("/foo", true, false, 0)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	eidx = 2
+	s.Update("/foo/bar", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "update")
+	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
+}
+
+// Ensure that the store can watch for key deletions.
+func TestStoreWatchDelete(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 1
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	w, _ := s.Watch("/foo", false, false, 0)
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	eidx = 2
+	s.Delete("/foo", false, false)
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "delete")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+}
+
+// Ensure that the store can watch for recursive key deletions.
+func TestStoreWatchRecursiveDelete(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 1
+	s.Create("/foo/bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	w, err := s.Watch("/foo", true, false, 0)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	eidx = 2
+	s.Delete("/foo/bar", false, false)
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "delete")
+	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
+}
+
+// Ensure that the store can watch for CAS updates.
+func TestStoreWatchCompareAndSwap(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 1
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	w, _ := s.Watch("/foo", false, false, 0)
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	eidx = 2
+	s.CompareAndSwap("/foo", "bar", 0, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "compareAndSwap")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+}
+
+// Ensure that the store can watch for recursive CAS updates.
+func TestStoreWatchRecursiveCompareAndSwap(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 1
+	s.Create("/foo/bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	w, _ := s.Watch("/foo", true, false, 0)
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	eidx = 2
+	s.CompareAndSwap("/foo/bar", "baz", 0, "bat", store.TTLOptionSet{ExpireTime: store.Permanent})
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "compareAndSwap")
+	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
+}
+
+// Ensure that the store can watch in streaming mode.
+func TestStoreWatchStream(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 1
+	w, _ := s.Watch("/foo", false, true, 0)
+	// first modification
+	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "create")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	select {
+	case e = <-w.EventChan():
+		testutil.AssertNil(t, e)
+	case <-time.After(100 * time.Millisecond):
+	}
+	// second modification
+	eidx = 2
+	s.Update("/foo", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	e = timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "update")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	select {
+	case e = <-w.EventChan():
+		testutil.AssertNil(t, e)
+	case <-time.After(100 * time.Millisecond):
+	}
+}
+
+// Ensure that the store can watch for hidden keys as long as it's an exact path match.
+func TestStoreWatchCreateWithHiddenKey(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 1
+	w, _ := s.Watch("/_foo", false, false, 0)
+	s.Create("/_foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "create")
+	testutil.AssertEqual(t, e.Node.Key, "/_foo")
+	select {
+	case e = <-w.EventChan():
+		testutil.AssertNil(t, e)
+	case <-time.After(100 * time.Millisecond):
+	}
+}
+
+// Ensure that the store doesn't see hidden key creates without an exact path match in recursive mode.
+func TestStoreWatchRecursiveCreateWithHiddenKey(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	w, _ := s.Watch("/foo", true, false, 0)
+	s.Create("/foo/_bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	e := nbselect(w.EventChan())
+	testutil.AssertNil(t, e)
+	w, _ = s.Watch("/foo", true, false, 0)
+	s.Create("/foo/_baz", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	select {
+	case e = <-w.EventChan():
+		testutil.AssertNil(t, e)
+	case <-time.After(100 * time.Millisecond):
+	}
+	s.Create("/foo/_baz/quux", false, "quux", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	select {
+	case e = <-w.EventChan():
+		testutil.AssertNil(t, e)
+	case <-time.After(100 * time.Millisecond):
+	}
+}
+
+// Ensure that the store doesn't see hidden key updates.
+func TestStoreWatchUpdateWithHiddenKey(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	s.Create("/_foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	w, _ := s.Watch("/_foo", false, false, 0)
+	s.Update("/_foo", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.Action, "update")
+	testutil.AssertEqual(t, e.Node.Key, "/_foo")
+	e = nbselect(w.EventChan())
+	testutil.AssertNil(t, e)
+}
+
+// Ensure that the store doesn't see hidden key updates without an exact path match in recursive mode.
+func TestStoreWatchRecursiveUpdateWithHiddenKey(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	s.Create("/foo/_bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	w, _ := s.Watch("/foo", true, false, 0)
+	s.Update("/foo/_bar", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
+	e := nbselect(w.EventChan())
+	testutil.AssertNil(t, e)
+}
+
+// Ensure that the store can watch for key deletions.
+func TestStoreWatchDeleteWithHiddenKey(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 2
+	s.Create("/_foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	w, _ := s.Watch("/_foo", false, false, 0)
+	s.Delete("/_foo", false, false)
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "delete")
+	testutil.AssertEqual(t, e.Node.Key, "/_foo")
+	e = nbselect(w.EventChan())
+	testutil.AssertNil(t, e)
+}
+
+// Ensure that the store doesn't see hidden key deletes without an exact path match in recursive mode.
+func TestStoreWatchRecursiveDeleteWithHiddenKey(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	s.Create("/foo/_bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	w, _ := s.Watch("/foo", true, false, 0)
+	s.Delete("/foo/_bar", false, false)
+	e := nbselect(w.EventChan())
+	testutil.AssertNil(t, e)
+}
+
+// Ensure that the store does see hidden key creates if watching deeper than a hidden key in recursive mode.
+func TestStoreWatchRecursiveCreateDeeperThanHiddenKey(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 1
+	w, _ := s.Watch("/_foo/bar", true, false, 0)
+	s.Create("/_foo/bar/baz", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+
+	e := timeoutSelect(t, w.EventChan())
+	testutil.AssertNotNil(t, e)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "create")
+	testutil.AssertEqual(t, e.Node.Key, "/_foo/bar/baz")
+}
+
+// Ensure that slow consumers are handled properly.
+//
+// Since Watcher.EventChan() has a buffer of size 100 we can only queue 100
+// event per watcher. If the consumer cannot consume the event on time and
+// another event arrives, the channel is closed and event is discarded.
+// This test ensures that after closing the channel, the store can continue
+// to operate correctly.
+func TestStoreWatchSlowConsumer(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	s.Watch("/foo", true, true, 0) // stream must be true
+	// Fill watch channel with 100 events
+	for i := 1; i <= 100; i++ {
+		s.Set("/foo", false, string(i), store.TTLOptionSet{ExpireTime: store.Permanent}) // ok
+	}
+	// testutil.AssertEqual(t, s.WatcherHub.count, int64(1))
+	s.Set("/foo", false, "101", store.TTLOptionSet{ExpireTime: store.Permanent}) // ok
+	// remove watcher
+	// testutil.AssertEqual(t, s.WatcherHub.count, int64(0))
+	s.Set("/foo", false, "102", store.TTLOptionSet{ExpireTime: store.Permanent}) // must not panic
+}
+
+// Performs a non-blocking select on an event channel.
+func nbselect(c <-chan *store.Event) *store.Event {
+	select {
+	case e := <-c:
+		return e
+	default:
+		return nil
+	}
+}
+
+// Performs a non-blocking select on an event channel.
+func timeoutSelect(t *testing.T, c <-chan *store.Event) *store.Event {
+	select {
+	case e := <-c:
+		return e
+	case <-time.After(time.Second):
+		t.Errorf("timed out waiting on event")
+		return nil
+	}
+}
diff --git a/internal/store/store_ttl_test.go b/internal/store/store_ttl_test.go
new file mode 100644
index 0000000..89d76e7
--- /dev/null
+++ b/internal/store/store_ttl_test.go
@@ -0,0 +1,360 @@
+// Copyright 2017 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"testing"
+	"time"
+
+	etcdErr "github.com/coreos/etcd/error"
+	"github.com/coreos/etcd/pkg/testutil"
+	"github.com/jonboulle/clockwork"
+)
+
+// Ensure that any TTL <= minExpireTime becomes Permanent
+func TestMinExpireTime(t *testing.T) {
+	s := newStore()
+	fc := clockwork.NewFakeClock()
+	s.clock = fc
+	// FakeClock starts at 0, so minExpireTime should be far in the future.. but just in case
+	testutil.AssertTrue(t, minExpireTime.After(fc.Now()), "minExpireTime should be ahead of FakeClock!")
+	s.Create("/foo", false, "Y", false, TTLOptionSet{ExpireTime: fc.Now().Add(3 * time.Second)})
+	fc.Advance(5 * time.Second)
+	// Ensure it hasn't expired
+	s.DeleteExpiredKeys(fc.Now())
+	var eidx uint64 = 1
+	e, err := s.Get("/foo", true, false)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "get")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertEqual(t, e.Node.TTL, int64(0))
+}
+
+// Ensure that the store can recursively retrieve a directory listing.
+// Note that hidden files should not be returned.
+func TestStoreGetDirectory(t *testing.T) {
+	s := newStore()
+	fc := newFakeClock()
+	s.clock = fc
+	s.Create("/foo", true, "", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Create("/foo/bar", false, "X", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Create("/foo/_hidden", false, "*", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Create("/foo/baz", true, "", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Create("/foo/baz/bat", false, "Y", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Create("/foo/baz/_hidden", false, "*", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Create("/foo/baz/ttl", false, "Y", false, TTLOptionSet{ExpireTime: fc.Now().Add(time.Second * 3)})
+	var eidx uint64 = 7
+	e, err := s.Get("/foo", true, false)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "get")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertEqual(t, len(e.Node.Nodes), 2)
+	var bazNodes NodeExterns
+	for _, node := range e.Node.Nodes {
+		switch node.Key {
+		case "/foo/bar":
+			testutil.AssertEqual(t, *node.Value, "X")
+			testutil.AssertEqual(t, node.Dir, false)
+		case "/foo/baz":
+			testutil.AssertEqual(t, node.Dir, true)
+			testutil.AssertEqual(t, len(node.Nodes), 2)
+			bazNodes = node.Nodes
+		default:
+			t.Errorf("key = %s, not matched", node.Key)
+		}
+	}
+	for _, node := range bazNodes {
+		switch node.Key {
+		case "/foo/baz/bat":
+			testutil.AssertEqual(t, *node.Value, "Y")
+			testutil.AssertEqual(t, node.Dir, false)
+		case "/foo/baz/ttl":
+			testutil.AssertEqual(t, *node.Value, "Y")
+			testutil.AssertEqual(t, node.Dir, false)
+			testutil.AssertEqual(t, node.TTL, int64(3))
+		default:
+			t.Errorf("key = %s, not matched", node.Key)
+		}
+	}
+}
+
+// Ensure that the store can update the TTL on a value.
+func TestStoreUpdateValueTTL(t *testing.T) {
+	s := newStore()
+	fc := newFakeClock()
+	s.clock = fc
+
+	var eidx uint64 = 2
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
+	_, err := s.Update("/foo", "baz", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
+	testutil.AssertNil(t, err)
+	e, _ := s.Get("/foo", false, false)
+	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	fc.Advance(600 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+	e, err = s.Get("/foo", false, false)
+	testutil.AssertNil(t, e)
+	testutil.AssertEqual(t, err.(*etcdErr.Error).ErrorCode, etcdErr.EcodeKeyNotFound)
+}
+
+// Ensure that the store can update the TTL on a directory.
+func TestStoreUpdateDirTTL(t *testing.T) {
+	s := newStore()
+	fc := newFakeClock()
+	s.clock = fc
+
+	var eidx uint64 = 3
+	s.Create("/foo", true, "", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Create("/foo/bar", false, "baz", false, TTLOptionSet{ExpireTime: Permanent})
+	e, err := s.Update("/foo", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.Node.Dir, true)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	e, _ = s.Get("/foo/bar", false, false)
+	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+
+	fc.Advance(600 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+	e, err = s.Get("/foo/bar", false, false)
+	testutil.AssertNil(t, e)
+	testutil.AssertEqual(t, err.(*etcdErr.Error).ErrorCode, etcdErr.EcodeKeyNotFound)
+}
+
+// Ensure that the store can watch for key expiration.
+func TestStoreWatchExpire(t *testing.T) {
+	s := newStore()
+	fc := newFakeClock()
+	s.clock = fc
+
+	var eidx uint64 = 3
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(400 * time.Millisecond)})
+	s.Create("/foofoo", false, "barbarbar", false, TTLOptionSet{ExpireTime: fc.Now().Add(450 * time.Millisecond)})
+	s.Create("/foodir", true, "", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
+
+	w, _ := s.Watch("/", true, false, 0)
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	c := w.EventChan()
+	e := nbselect(c)
+	testutil.AssertNil(t, e)
+	fc.Advance(600 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+	eidx = 4
+	e = nbselect(c)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "expire")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	w, _ = s.Watch("/", true, false, 5)
+	eidx = 6
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	e = nbselect(w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "expire")
+	testutil.AssertEqual(t, e.Node.Key, "/foofoo")
+	w, _ = s.Watch("/", true, false, 6)
+	e = nbselect(w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "expire")
+	testutil.AssertEqual(t, e.Node.Key, "/foodir")
+	testutil.AssertEqual(t, e.Node.Dir, true)
+}
+
+// Ensure that the store can watch for key expiration when refreshing.
+func TestStoreWatchExpireRefresh(t *testing.T) {
+	s := newStore()
+	fc := newFakeClock()
+	s.clock = fc
+
+	var eidx uint64 = 2
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
+	s.Create("/foofoo", false, "barbarbar", false, TTLOptionSet{ExpireTime: fc.Now().Add(1200 * time.Millisecond), Refresh: true})
+
+	// Make sure we set watch updates when Refresh is true for newly created keys
+	w, _ := s.Watch("/", true, false, 0)
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	c := w.EventChan()
+	e := nbselect(c)
+	testutil.AssertNil(t, e)
+	fc.Advance(600 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+	eidx = 3
+	e = nbselect(c)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "expire")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+
+	s.Update("/foofoo", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
+	w, _ = s.Watch("/", true, false, 4)
+	fc.Advance(700 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+	eidx = 5 // We should skip 4 because a TTL update should occur with no watch notification if set `TTLOptionSet.Refresh` to true
+	testutil.AssertEqual(t, w.StartIndex(), eidx-1)
+	e = nbselect(w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "expire")
+	testutil.AssertEqual(t, e.Node.Key, "/foofoo")
+}
+
+// Ensure that the store can watch for key expiration when refreshing with an empty value.
+func TestStoreWatchExpireEmptyRefresh(t *testing.T) {
+	s := newStore()
+	fc := newFakeClock()
+	s.clock = fc
+
+	var eidx uint64
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
+	// Should be no-op
+	fc.Advance(200 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+
+	s.Update("/foo", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
+	w, _ := s.Watch("/", true, false, 2)
+	fc.Advance(700 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+	eidx = 3 // We should skip 2 because a TTL update should occur with no watch notification if set `TTLOptionSet.Refresh` to true
+	testutil.AssertEqual(t, w.StartIndex(), eidx-1)
+	e := nbselect(w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "expire")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+}
+
+// Update TTL of a key (set TTLOptionSet.Refresh to false) and send notification
+func TestStoreWatchNoRefresh(t *testing.T) {
+	s := newStore()
+	fc := newFakeClock()
+	s.clock = fc
+
+	var eidx uint64
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
+	// Should be no-op
+	fc.Advance(200 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+
+	// Update key's TTL with setting `TTLOptionSet.Refresh` to false will cause an update event
+	s.Update("/foo", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: false})
+	w, _ := s.Watch("/", true, false, 2)
+	fc.Advance(700 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+	eidx = 2
+	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	e := nbselect(w.EventChan())
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, e.Action, "update")
+	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+}
+
+// Ensure that the store can update the TTL on a value with refresh.
+func TestStoreRefresh(t *testing.T) {
+	s := newStore()
+	fc := newFakeClock()
+	s.clock = fc
+
+	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
+	s.Create("/bar", true, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
+	_, err := s.Update("/foo", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
+	testutil.AssertNil(t, err)
+
+	_, err = s.Set("/foo", false, "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
+	testutil.AssertNil(t, err)
+
+	_, err = s.Update("/bar", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
+	testutil.AssertNil(t, err)
+
+	_, err = s.CompareAndSwap("/foo", "bar", 0, "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
+	testutil.AssertNil(t, err)
+}
+
+// Ensure that the store can recover from a previously saved state that includes an expiring key.
+func TestStoreRecoverWithExpiration(t *testing.T) {
+	s := newStore()
+	s.clock = newFakeClock()
+
+	fc := newFakeClock()
+
+	var eidx uint64 = 4
+	s.Create("/foo", true, "", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Create("/foo/x", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
+	s.Create("/foo/y", false, "baz", false, TTLOptionSet{ExpireTime: fc.Now().Add(5 * time.Millisecond)})
+	b, err := s.Save()
+	testutil.AssertNil(t, err)
+
+	time.Sleep(10 * time.Millisecond)
+
+	s2 := newStore()
+	s2.clock = fc
+
+	s2.Recovery(b)
+
+	fc.Advance(600 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+
+	e, err := s.Get("/foo/x", false, false)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertEqual(t, *e.Node.Value, "bar")
+
+	e, err = s.Get("/foo/y", false, false)
+	testutil.AssertNotNil(t, err)
+	testutil.AssertNil(t, e)
+}
+
+// Ensure that the store doesn't see expirations of hidden keys.
+func TestStoreWatchExpireWithHiddenKey(t *testing.T) {
+	s := newStore()
+	fc := newFakeClock()
+	s.clock = fc
+
+	s.Create("/_foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
+	s.Create("/foofoo", false, "barbarbar", false, TTLOptionSet{ExpireTime: fc.Now().Add(1000 * time.Millisecond)})
+
+	w, _ := s.Watch("/", true, false, 0)
+	c := w.EventChan()
+	e := nbselect(c)
+	testutil.AssertNil(t, e)
+	fc.Advance(600 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+	e = nbselect(c)
+	testutil.AssertNil(t, e)
+	fc.Advance(600 * time.Millisecond)
+	s.DeleteExpiredKeys(fc.Now())
+	e = nbselect(c)
+	testutil.AssertEqual(t, e.Action, "expire")
+	testutil.AssertEqual(t, e.Node.Key, "/foofoo")
+}
+
+// newFakeClock creates a new FakeClock that has been advanced to at least minExpireTime
+func newFakeClock() clockwork.FakeClock {
+	fc := clockwork.NewFakeClock()
+	for minExpireTime.After(fc.Now()) {
+		fc.Advance((0x1 << 62) * time.Nanosecond)
+	}
+	return fc
+}
+
+// Performs a non-blocking select on an event channel.
+func nbselect(c <-chan *Event) *Event {
+	select {
+	case e := <-c:
+		return e
+	default:
+		return nil
+	}
+}
diff --git a/internal/store/store_v2_test.go b/internal/store/store_v2_test.go
new file mode 100644
index 0000000..3498401
--- /dev/null
+++ b/internal/store/store_v2_test.go
@@ -0,0 +1,62 @@
+// Copyright 2017 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !v2v3
+
+package store_test
+
+import (
+	"testing"
+
+	"github.com/coreos/etcd/internal/store"
+	"github.com/coreos/etcd/pkg/testutil"
+)
+
+type v2TestStore struct {
+	store.Store
+}
+
+func (s *v2TestStore) Close() {}
+
+func newTestStore(t *testing.T, ns ...string) StoreCloser {
+	return &v2TestStore{store.New(ns...)}
+}
+
+// Ensure that the store can recover from a previously saved state.
+func TestStoreRecover(t *testing.T) {
+	s := newTestStore(t)
+	defer s.Close()
+	var eidx uint64 = 4
+	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	s.Create("/foo/x", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	s.Update("/foo/x", "barbar", store.TTLOptionSet{ExpireTime: store.Permanent})
+	s.Create("/foo/y", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
+	b, err := s.Save()
+	testutil.AssertNil(t, err)
+
+	s2 := newTestStore(t)
+	s2.Recovery(b)
+
+	e, err := s.Get("/foo/x", false, false)
+	testutil.AssertEqual(t, e.Node.CreatedIndex, uint64(2))
+	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(3))
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, *e.Node.Value, "barbar")
+
+	e, err = s.Get("/foo/y", false, false)
+	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	testutil.AssertNil(t, err)
+	testutil.AssertEqual(t, *e.Node.Value, "baz")
+}
diff --git a/internal/store/store_v2v3_test.go b/internal/store/store_v2v3_test.go
new file mode 100644
index 0000000..ea0dbc3
--- /dev/null
+++ b/internal/store/store_v2v3_test.go
@@ -0,0 +1,52 @@
+// Copyright 2017 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build v2v3
+
+package store_test
+
+import (
+	"io/ioutil"
+	"testing"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/coreos/etcd/etcdserver/api/v2v3"
+	"github.com/coreos/etcd/integration"
+	"github.com/coreos/etcd/internal/store"
+
+	"github.com/coreos/pkg/capnslog"
+	"google.golang.org/grpc/grpclog"
+)
+
+func init() {
+	capnslog.SetGlobalLogLevel(capnslog.CRITICAL)
+	clientv3.SetLogger(grpclog.NewLoggerV2(ioutil.Discard, ioutil.Discard, ioutil.Discard))
+}
+
+type v2v3TestStore struct {
+	store.Store
+	clus *integration.ClusterV3
+	t    *testing.T
+}
+
+func (s *v2v3TestStore) Close() { s.clus.Terminate(s.t) }
+
+func newTestStore(t *testing.T, ns ...string) StoreCloser {
+	clus := integration.NewClusterV3(t, &integration.ClusterConfig{Size: 1})
+	return &v2v3TestStore{
+		v2v3.NewStore(clus.Client(0), "/v2/"),
+		clus,
+		t,
+	}
+}
diff --git a/internal/store/ttl_key_heap.go b/internal/store/ttl_key_heap.go
new file mode 100644
index 0000000..21ae9b7
--- /dev/null
+++ b/internal/store/ttl_key_heap.go
@@ -0,0 +1,99 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"container/heap"
+)
+
+// An TTLKeyHeap is a min-heap of TTLKeys order by expiration time
+type ttlKeyHeap struct {
+	array  []*node
+	keyMap map[*node]int
+}
+
+func newTtlKeyHeap() *ttlKeyHeap {
+	h := &ttlKeyHeap{keyMap: make(map[*node]int)}
+	heap.Init(h)
+	return h
+}
+
+func (h ttlKeyHeap) Len() int {
+	return len(h.array)
+}
+
+func (h ttlKeyHeap) Less(i, j int) bool {
+	return h.array[i].ExpireTime.Before(h.array[j].ExpireTime)
+}
+
+func (h ttlKeyHeap) Swap(i, j int) {
+	// swap node
+	h.array[i], h.array[j] = h.array[j], h.array[i]
+
+	// update map
+	h.keyMap[h.array[i]] = i
+	h.keyMap[h.array[j]] = j
+}
+
+func (h *ttlKeyHeap) Push(x interface{}) {
+	n, _ := x.(*node)
+	h.keyMap[n] = len(h.array)
+	h.array = append(h.array, n)
+}
+
+func (h *ttlKeyHeap) Pop() interface{} {
+	old := h.array
+	n := len(old)
+	x := old[n-1]
+	// Set slice element to nil, so GC can recycle the node.
+	// This is due to golang GC doesn't support partial recycling:
+	// https://github.com/golang/go/issues/9618
+	old[n-1] = nil
+	h.array = old[0 : n-1]
+	delete(h.keyMap, x)
+	return x
+}
+
+func (h *ttlKeyHeap) top() *node {
+	if h.Len() != 0 {
+		return h.array[0]
+	}
+	return nil
+}
+
+func (h *ttlKeyHeap) pop() *node {
+	x := heap.Pop(h)
+	n, _ := x.(*node)
+	return n
+}
+
+func (h *ttlKeyHeap) push(x interface{}) {
+	heap.Push(h, x)
+}
+
+func (h *ttlKeyHeap) update(n *node) {
+	index, ok := h.keyMap[n]
+	if ok {
+		heap.Remove(h, index)
+		heap.Push(h, n)
+	}
+}
+
+func (h *ttlKeyHeap) remove(n *node) {
+	index, ok := h.keyMap[n]
+	if ok {
+		heap.Remove(h, index)
+	}
+}
diff --git a/internal/store/watcher.go b/internal/store/watcher.go
new file mode 100644
index 0000000..a236ec7
--- /dev/null
+++ b/internal/store/watcher.go
@@ -0,0 +1,95 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+type Watcher interface {
+	EventChan() chan *Event
+	StartIndex() uint64 // The EtcdIndex at which the Watcher was created
+	Remove()
+}
+
+type watcher struct {
+	eventChan  chan *Event
+	stream     bool
+	recursive  bool
+	sinceIndex uint64
+	startIndex uint64
+	hub        *watcherHub
+	removed    bool
+	remove     func()
+}
+
+func (w *watcher) EventChan() chan *Event {
+	return w.eventChan
+}
+
+func (w *watcher) StartIndex() uint64 {
+	return w.startIndex
+}
+
+// notify function notifies the watcher. If the watcher interests in the given path,
+// the function will return true.
+func (w *watcher) notify(e *Event, originalPath bool, deleted bool) bool {
+	// watcher is interested the path in three cases and under one condition
+	// the condition is that the event happens after the watcher's sinceIndex
+
+	// 1. the path at which the event happens is the path the watcher is watching at.
+	// For example if the watcher is watching at "/foo" and the event happens at "/foo",
+	// the watcher must be interested in that event.
+
+	// 2. the watcher is a recursive watcher, it interests in the event happens after
+	// its watching path. For example if watcher A watches at "/foo" and it is a recursive
+	// one, it will interest in the event happens at "/foo/bar".
+
+	// 3. when we delete a directory, we need to force notify all the watchers who watches
+	// at the file we need to delete.
+	// For example a watcher is watching at "/foo/bar". And we deletes "/foo". The watcher
+	// should get notified even if "/foo" is not the path it is watching.
+	if (w.recursive || originalPath || deleted) && e.Index() >= w.sinceIndex {
+		// We cannot block here if the eventChan capacity is full, otherwise
+		// etcd will hang. eventChan capacity is full when the rate of
+		// notifications are higher than our send rate.
+		// If this happens, we close the channel.
+		select {
+		case w.eventChan <- e:
+		default:
+			// We have missed a notification. Remove the watcher.
+			// Removing the watcher also closes the eventChan.
+			w.remove()
+		}
+		return true
+	}
+	return false
+}
+
+// Remove removes the watcher from watcherHub
+// The actual remove function is guaranteed to only be executed once
+func (w *watcher) Remove() {
+	w.hub.mutex.Lock()
+	defer w.hub.mutex.Unlock()
+
+	close(w.eventChan)
+	if w.remove != nil {
+		w.remove()
+	}
+}
+
+// nopWatcher is a watcher that receives nothing, always blocking.
+type nopWatcher struct{}
+
+func NewNopWatcher() Watcher                 { return &nopWatcher{} }
+func (w *nopWatcher) EventChan() chan *Event { return nil }
+func (w *nopWatcher) StartIndex() uint64     { return 0 }
+func (w *nopWatcher) Remove()                {}
diff --git a/internal/store/watcher_hub.go b/internal/store/watcher_hub.go
new file mode 100644
index 0000000..13c23e3
--- /dev/null
+++ b/internal/store/watcher_hub.go
@@ -0,0 +1,200 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"container/list"
+	"path"
+	"strings"
+	"sync"
+	"sync/atomic"
+
+	etcdErr "github.com/coreos/etcd/error"
+)
+
+// A watcherHub contains all subscribed watchers
+// watchers is a map with watched path as key and watcher as value
+// EventHistory keeps the old events for watcherHub. It is used to help
+// watcher to get a continuous event history. Or a watcher might miss the
+// event happens between the end of the first watch command and the start
+// of the second command.
+type watcherHub struct {
+	// count must be the first element to keep 64-bit alignment for atomic
+	// access
+
+	count int64 // current number of watchers.
+
+	mutex        sync.Mutex
+	watchers     map[string]*list.List
+	EventHistory *EventHistory
+}
+
+// newWatchHub creates a watcherHub. The capacity determines how many events we will
+// keep in the eventHistory.
+// Typically, we only need to keep a small size of history[smaller than 20K].
+// Ideally, it should smaller than 20K/s[max throughput] * 2 * 50ms[RTT] = 2000
+func newWatchHub(capacity int) *watcherHub {
+	return &watcherHub{
+		watchers:     make(map[string]*list.List),
+		EventHistory: newEventHistory(capacity),
+	}
+}
+
+// Watch function returns a Watcher.
+// If recursive is true, the first change after index under key will be sent to the event channel of the watcher.
+// If recursive is false, the first change after index at key will be sent to the event channel of the watcher.
+// If index is zero, watch will start from the current index + 1.
+func (wh *watcherHub) watch(key string, recursive, stream bool, index, storeIndex uint64) (Watcher, *etcdErr.Error) {
+	reportWatchRequest()
+	event, err := wh.EventHistory.scan(key, recursive, index)
+
+	if err != nil {
+		err.Index = storeIndex
+		return nil, err
+	}
+
+	w := &watcher{
+		eventChan:  make(chan *Event, 100), // use a buffered channel
+		recursive:  recursive,
+		stream:     stream,
+		sinceIndex: index,
+		startIndex: storeIndex,
+		hub:        wh,
+	}
+
+	wh.mutex.Lock()
+	defer wh.mutex.Unlock()
+	// If the event exists in the known history, append the EtcdIndex and return immediately
+	if event != nil {
+		ne := event.Clone()
+		ne.EtcdIndex = storeIndex
+		w.eventChan <- ne
+		return w, nil
+	}
+
+	l, ok := wh.watchers[key]
+
+	var elem *list.Element
+
+	if ok { // add the new watcher to the back of the list
+		elem = l.PushBack(w)
+	} else { // create a new list and add the new watcher
+		l = list.New()
+		elem = l.PushBack(w)
+		wh.watchers[key] = l
+	}
+
+	w.remove = func() {
+		if w.removed { // avoid removing it twice
+			return
+		}
+		w.removed = true
+		l.Remove(elem)
+		atomic.AddInt64(&wh.count, -1)
+		reportWatcherRemoved()
+		if l.Len() == 0 {
+			delete(wh.watchers, key)
+		}
+	}
+
+	atomic.AddInt64(&wh.count, 1)
+	reportWatcherAdded()
+
+	return w, nil
+}
+
+func (wh *watcherHub) add(e *Event) {
+	wh.EventHistory.addEvent(e)
+}
+
+// notify function accepts an event and notify to the watchers.
+func (wh *watcherHub) notify(e *Event) {
+	e = wh.EventHistory.addEvent(e) // add event into the eventHistory
+
+	segments := strings.Split(e.Node.Key, "/")
+
+	currPath := "/"
+
+	// walk through all the segments of the path and notify the watchers
+	// if the path is "/foo/bar", it will notify watchers with path "/",
+	// "/foo" and "/foo/bar"
+
+	for _, segment := range segments {
+		currPath = path.Join(currPath, segment)
+		// notify the watchers who interests in the changes of current path
+		wh.notifyWatchers(e, currPath, false)
+	}
+}
+
+func (wh *watcherHub) notifyWatchers(e *Event, nodePath string, deleted bool) {
+	wh.mutex.Lock()
+	defer wh.mutex.Unlock()
+
+	l, ok := wh.watchers[nodePath]
+	if ok {
+		curr := l.Front()
+
+		for curr != nil {
+			next := curr.Next() // save reference to the next one in the list
+
+			w, _ := curr.Value.(*watcher)
+
+			originalPath := (e.Node.Key == nodePath)
+			if (originalPath || !isHidden(nodePath, e.Node.Key)) && w.notify(e, originalPath, deleted) {
+				if !w.stream { // do not remove the stream watcher
+					// if we successfully notify a watcher
+					// we need to remove the watcher from the list
+					// and decrease the counter
+					w.removed = true
+					l.Remove(curr)
+					atomic.AddInt64(&wh.count, -1)
+					reportWatcherRemoved()
+				}
+			}
+
+			curr = next // update current to the next element in the list
+		}
+
+		if l.Len() == 0 {
+			// if we have notified all watcher in the list
+			// we can delete the list
+			delete(wh.watchers, nodePath)
+		}
+	}
+}
+
+// clone function clones the watcherHub and return the cloned one.
+// only clone the static content. do not clone the current watchers.
+func (wh *watcherHub) clone() *watcherHub {
+	clonedHistory := wh.EventHistory.clone()
+
+	return &watcherHub{
+		EventHistory: clonedHistory,
+	}
+}
+
+// isHidden checks to see if key path is considered hidden to watch path i.e. the
+// last element is hidden or it's within a hidden directory
+func isHidden(watchPath, keyPath string) bool {
+	// When deleting a directory, watchPath might be deeper than the actual keyPath
+	// For example, when deleting /foo we also need to notify watchers on /foo/bar.
+	if len(watchPath) > len(keyPath) {
+		return false
+	}
+	// if watch path is just a "/", after path will start without "/"
+	// add a "/" to deal with the special case when watchPath is "/"
+	afterPath := path.Clean("/" + keyPath[len(watchPath):])
+	return strings.Contains(afterPath, "/_")
+}
diff --git a/internal/store/watcher_hub_test.go b/internal/store/watcher_hub_test.go
new file mode 100644
index 0000000..314ff4f
--- /dev/null
+++ b/internal/store/watcher_hub_test.go
@@ -0,0 +1,66 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"testing"
+)
+
+// TestIsHidden tests isHidden functions.
+func TestIsHidden(t *testing.T) {
+	// watch at "/"
+	// key is "/_foo", hidden to "/"
+	// expected: hidden = true
+	watch := "/"
+	key := "/_foo"
+	hidden := isHidden(watch, key)
+	if !hidden {
+		t.Fatalf("%v should be hidden to %v\n", key, watch)
+	}
+
+	// watch at "/_foo"
+	// key is "/_foo", not hidden to "/_foo"
+	// expected: hidden = false
+	watch = "/_foo"
+	hidden = isHidden(watch, key)
+	if hidden {
+		t.Fatalf("%v should not be hidden to %v\n", key, watch)
+	}
+
+	// watch at "/_foo/"
+	// key is "/_foo/foo", not hidden to "/_foo"
+	key = "/_foo/foo"
+	hidden = isHidden(watch, key)
+	if hidden {
+		t.Fatalf("%v should not be hidden to %v\n", key, watch)
+	}
+
+	// watch at "/_foo/"
+	// key is "/_foo/_foo", hidden to "/_foo"
+	key = "/_foo/_foo"
+	hidden = isHidden(watch, key)
+	if !hidden {
+		t.Fatalf("%v should be hidden to %v\n", key, watch)
+	}
+
+	// watch at "/_foo/foo"
+	// key is "/_foo"
+	watch = "_foo/foo"
+	key = "/_foo/"
+	hidden = isHidden(watch, key)
+	if hidden {
+		t.Fatalf("%v should not be hidden to %v\n", key, watch)
+	}
+}
diff --git a/internal/store/watcher_test.go b/internal/store/watcher_test.go
new file mode 100644
index 0000000..f7344fa
--- /dev/null
+++ b/internal/store/watcher_test.go
@@ -0,0 +1,92 @@
+// Copyright 2015 The etcd Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package store
+
+import (
+	"testing"
+)
+
+func TestWatcher(t *testing.T) {
+	s := newStore()
+	wh := s.WatcherHub
+	w, err := wh.watch("/foo", true, false, 1, 1)
+	if err != nil {
+		t.Fatalf("%v", err)
+	}
+	c := w.EventChan()
+
+	select {
+	case <-c:
+		t.Fatal("should not receive from channel before send the event")
+	default:
+		// do nothing
+	}
+
+	e := newEvent(Create, "/foo/bar", 1, 1)
+
+	wh.notify(e)
+
+	re := <-c
+
+	if e != re {
+		t.Fatal("recv != send")
+	}
+
+	w, _ = wh.watch("/foo", false, false, 2, 1)
+	c = w.EventChan()
+
+	e = newEvent(Create, "/foo/bar", 2, 2)
+
+	wh.notify(e)
+
+	select {
+	case re = <-c:
+		t.Fatal("should not receive from channel if not recursive ", re)
+	default:
+		// do nothing
+	}
+
+	e = newEvent(Create, "/foo", 3, 3)
+
+	wh.notify(e)
+
+	re = <-c
+
+	if e != re {
+		t.Fatal("recv != send")
+	}
+
+	// ensure we are doing exact matching rather than prefix matching
+	w, _ = wh.watch("/fo", true, false, 1, 1)
+	c = w.EventChan()
+
+	select {
+	case re = <-c:
+		t.Fatal("should not receive from channel:", re)
+	default:
+		// do nothing
+	}
+
+	e = newEvent(Create, "/fo/bar", 3, 3)
+
+	wh.notify(e)
+
+	re = <-c
+
+	if e != re {
+		t.Fatal("recv != send")
+	}
+
+}
diff --git a/pkg/mock/mockstore/store_recorder.go b/pkg/mock/mockstore/store_recorder.go
index 4dad19e..f295e55 100644
--- a/pkg/mock/mockstore/store_recorder.go
+++ b/pkg/mock/mockstore/store_recorder.go
@@ -17,8 +17,8 @@ package mockstore
 import (
 	"time"
 
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/pkg/testutil"
-	"github.com/coreos/etcd/store"
 )
 
 // StoreRecorder provides a Store interface with a testutil.Recorder
diff --git a/snapshot/v3_snapshot.go b/snapshot/v3_snapshot.go
index 045f953..0ed46c7 100644
--- a/snapshot/v3_snapshot.go
+++ b/snapshot/v3_snapshot.go
@@ -31,6 +31,7 @@ import (
 	"github.com/coreos/etcd/etcdserver/etcdserverpb"
 	"github.com/coreos/etcd/etcdserver/membership"
 	"github.com/coreos/etcd/internal/raftsnap"
+	"github.com/coreos/etcd/internal/store"
 	"github.com/coreos/etcd/lease"
 	"github.com/coreos/etcd/mvcc"
 	"github.com/coreos/etcd/mvcc/backend"
@@ -39,7 +40,6 @@ import (
 	"github.com/coreos/etcd/pkg/types"
 	"github.com/coreos/etcd/raft"
 	"github.com/coreos/etcd/raft/raftpb"
-	"github.com/coreos/etcd/store"
 	"github.com/coreos/etcd/wal"
 	"github.com/coreos/etcd/wal/walpb"
 
diff --git a/store/doc.go b/store/doc.go
deleted file mode 100644
index 612df92..0000000
--- a/store/doc.go
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Package store defines etcd's in-memory key/value store.
-package store
diff --git a/store/event.go b/store/event.go
deleted file mode 100644
index efcddb0..0000000
--- a/store/event.go
+++ /dev/null
@@ -1,71 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-const (
-	Get              = "get"
-	Create           = "create"
-	Set              = "set"
-	Update           = "update"
-	Delete           = "delete"
-	CompareAndSwap   = "compareAndSwap"
-	CompareAndDelete = "compareAndDelete"
-	Expire           = "expire"
-)
-
-type Event struct {
-	Action    string      `json:"action"`
-	Node      *NodeExtern `json:"node,omitempty"`
-	PrevNode  *NodeExtern `json:"prevNode,omitempty"`
-	EtcdIndex uint64      `json:"-"`
-	Refresh   bool        `json:"refresh,omitempty"`
-}
-
-func newEvent(action string, key string, modifiedIndex, createdIndex uint64) *Event {
-	n := &NodeExtern{
-		Key:           key,
-		ModifiedIndex: modifiedIndex,
-		CreatedIndex:  createdIndex,
-	}
-
-	return &Event{
-		Action: action,
-		Node:   n,
-	}
-}
-
-func (e *Event) IsCreated() bool {
-	if e.Action == Create {
-		return true
-	}
-	return e.Action == Set && e.PrevNode == nil
-}
-
-func (e *Event) Index() uint64 {
-	return e.Node.ModifiedIndex
-}
-
-func (e *Event) Clone() *Event {
-	return &Event{
-		Action:    e.Action,
-		EtcdIndex: e.EtcdIndex,
-		Node:      e.Node.Clone(),
-		PrevNode:  e.PrevNode.Clone(),
-	}
-}
-
-func (e *Event) SetRefresh() {
-	e.Refresh = true
-}
diff --git a/store/event_history.go b/store/event_history.go
deleted file mode 100644
index 235d87a..0000000
--- a/store/event_history.go
+++ /dev/null
@@ -1,129 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"fmt"
-	"path"
-	"strings"
-	"sync"
-
-	etcdErr "github.com/coreos/etcd/error"
-)
-
-type EventHistory struct {
-	Queue      eventQueue
-	StartIndex uint64
-	LastIndex  uint64
-	rwl        sync.RWMutex
-}
-
-func newEventHistory(capacity int) *EventHistory {
-	return &EventHistory{
-		Queue: eventQueue{
-			Capacity: capacity,
-			Events:   make([]*Event, capacity),
-		},
-	}
-}
-
-// addEvent function adds event into the eventHistory
-func (eh *EventHistory) addEvent(e *Event) *Event {
-	eh.rwl.Lock()
-	defer eh.rwl.Unlock()
-
-	eh.Queue.insert(e)
-
-	eh.LastIndex = e.Index()
-
-	eh.StartIndex = eh.Queue.Events[eh.Queue.Front].Index()
-
-	return e
-}
-
-// scan enumerates events from the index history and stops at the first point
-// where the key matches.
-func (eh *EventHistory) scan(key string, recursive bool, index uint64) (*Event, *etcdErr.Error) {
-	eh.rwl.RLock()
-	defer eh.rwl.RUnlock()
-
-	// index should be after the event history's StartIndex
-	if index < eh.StartIndex {
-		return nil,
-			etcdErr.NewError(etcdErr.EcodeEventIndexCleared,
-				fmt.Sprintf("the requested history has been cleared [%v/%v]",
-					eh.StartIndex, index), 0)
-	}
-
-	// the index should come before the size of the queue minus the duplicate count
-	if index > eh.LastIndex { // future index
-		return nil, nil
-	}
-
-	offset := index - eh.StartIndex
-	i := (eh.Queue.Front + int(offset)) % eh.Queue.Capacity
-
-	for {
-		e := eh.Queue.Events[i]
-
-		if !e.Refresh {
-			ok := (e.Node.Key == key)
-
-			if recursive {
-				// add tailing slash
-				nkey := path.Clean(key)
-				if nkey[len(nkey)-1] != '/' {
-					nkey = nkey + "/"
-				}
-
-				ok = ok || strings.HasPrefix(e.Node.Key, nkey)
-			}
-
-			if (e.Action == Delete || e.Action == Expire) && e.PrevNode != nil && e.PrevNode.Dir {
-				ok = ok || strings.HasPrefix(key, e.PrevNode.Key)
-			}
-
-			if ok {
-				return e, nil
-			}
-		}
-
-		i = (i + 1) % eh.Queue.Capacity
-
-		if i == eh.Queue.Back {
-			return nil, nil
-		}
-	}
-}
-
-// clone will be protected by a stop-world lock
-// do not need to obtain internal lock
-func (eh *EventHistory) clone() *EventHistory {
-	clonedQueue := eventQueue{
-		Capacity: eh.Queue.Capacity,
-		Events:   make([]*Event, eh.Queue.Capacity),
-		Size:     eh.Queue.Size,
-		Front:    eh.Queue.Front,
-		Back:     eh.Queue.Back,
-	}
-
-	copy(clonedQueue.Events, eh.Queue.Events)
-	return &EventHistory{
-		StartIndex: eh.StartIndex,
-		Queue:      clonedQueue,
-		LastIndex:  eh.LastIndex,
-	}
-
-}
diff --git a/store/event_queue.go b/store/event_queue.go
deleted file mode 100644
index 767b835..0000000
--- a/store/event_queue.go
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-type eventQueue struct {
-	Events   []*Event
-	Size     int
-	Front    int
-	Back     int
-	Capacity int
-}
-
-func (eq *eventQueue) insert(e *Event) {
-	eq.Events[eq.Back] = e
-	eq.Back = (eq.Back + 1) % eq.Capacity
-
-	if eq.Size == eq.Capacity { //dequeue
-		eq.Front = (eq.Front + 1) % eq.Capacity
-	} else {
-		eq.Size++
-	}
-}
diff --git a/store/event_test.go b/store/event_test.go
deleted file mode 100644
index ba3c06c..0000000
--- a/store/event_test.go
+++ /dev/null
@@ -1,162 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"testing"
-
-	etcdErr "github.com/coreos/etcd/error"
-)
-
-// TestEventQueue tests a queue with capacity = 100
-// Add 200 events into that queue, and test if the
-// previous 100 events have been swapped out.
-func TestEventQueue(t *testing.T) {
-
-	eh := newEventHistory(100)
-
-	// Add
-	for i := 0; i < 200; i++ {
-		e := newEvent(Create, "/foo", uint64(i), uint64(i))
-		eh.addEvent(e)
-	}
-
-	// Test
-	j := 100
-	i := eh.Queue.Front
-	n := eh.Queue.Size
-	for ; n > 0; n-- {
-		e := eh.Queue.Events[i]
-		if e.Index() != uint64(j) {
-			t.Fatalf("queue error!")
-		}
-		j++
-		i = (i + 1) % eh.Queue.Capacity
-	}
-}
-
-func TestScanHistory(t *testing.T) {
-	eh := newEventHistory(100)
-
-	// Add
-	eh.addEvent(newEvent(Create, "/foo", 1, 1))
-	eh.addEvent(newEvent(Create, "/foo/bar", 2, 2))
-	eh.addEvent(newEvent(Create, "/foo/foo", 3, 3))
-	eh.addEvent(newEvent(Create, "/foo/bar/bar", 4, 4))
-	eh.addEvent(newEvent(Create, "/foo/foo/foo", 5, 5))
-
-	// Delete a dir
-	de := newEvent(Delete, "/foo", 6, 6)
-	de.PrevNode = newDir(nil, "/foo", 1, nil, Permanent).Repr(false, false, nil)
-	eh.addEvent(de)
-
-	e, err := eh.scan("/foo", false, 1)
-	if err != nil || e.Index() != 1 {
-		t.Fatalf("scan error [/foo] [1] %d (%v)", e.Index(), err)
-	}
-
-	e, err = eh.scan("/foo/bar", false, 1)
-
-	if err != nil || e.Index() != 2 {
-		t.Fatalf("scan error [/foo/bar] [2] %d (%v)", e.Index(), err)
-	}
-
-	e, err = eh.scan("/foo/bar", true, 3)
-
-	if err != nil || e.Index() != 4 {
-		t.Fatalf("scan error [/foo/bar/bar] [4] %d (%v)", e.Index(), err)
-	}
-
-	e, err = eh.scan("/foo/foo/foo", false, 6)
-	if err != nil || e.Index() != 6 {
-		t.Fatalf("scan error [/foo/foo/foo] [6] %d (%v)", e.Index(), err)
-	}
-
-	e, _ = eh.scan("/foo/bar", true, 7)
-	if e != nil {
-		t.Fatalf("bad index shoud reuturn nil")
-	}
-}
-
-func TestEventIndexHistoryCleared(t *testing.T) {
-	eh := newEventHistory(5)
-
-	// Add
-	eh.addEvent(newEvent(Create, "/foo", 1, 1))
-	eh.addEvent(newEvent(Create, "/foo/bar", 2, 2))
-	eh.addEvent(newEvent(Create, "/foo/foo", 3, 3))
-	eh.addEvent(newEvent(Create, "/foo/bar/bar", 4, 4))
-	eh.addEvent(newEvent(Create, "/foo/foo/foo", 5, 5))
-
-	// Add a new event which will replace/de-queue the first entry
-	eh.addEvent(newEvent(Create, "/foo/bar/bar/bar", 6, 6))
-
-	// test for the event which has been replaced.
-	_, err := eh.scan("/foo", false, 1)
-	if err == nil || err.ErrorCode != etcdErr.EcodeEventIndexCleared {
-		t.Fatalf("scan error cleared index should return err with %d got (%v)", etcdErr.EcodeEventIndexCleared, err)
-	}
-}
-
-// TestFullEventQueue tests a queue with capacity = 10
-// Add 1000 events into that queue, and test if scanning
-// works still for previous events.
-func TestFullEventQueue(t *testing.T) {
-
-	eh := newEventHistory(10)
-
-	// Add
-	for i := 0; i < 1000; i++ {
-		ce := newEvent(Create, "/foo", uint64(i), uint64(i))
-		eh.addEvent(ce)
-		e, err := eh.scan("/foo", true, uint64(i-1))
-		if i > 0 {
-			if e == nil || err != nil {
-				t.Fatalf("scan error [/foo] [%v] %v", i-1, i)
-			}
-		}
-	}
-}
-
-func TestCloneEvent(t *testing.T) {
-	e1 := &Event{
-		Action:    Create,
-		EtcdIndex: 1,
-		Node:      nil,
-		PrevNode:  nil,
-	}
-	e2 := e1.Clone()
-	if e2.Action != Create {
-		t.Fatalf("Action=%q, want %q", e2.Action, Create)
-	}
-	if e2.EtcdIndex != e1.EtcdIndex {
-		t.Fatalf("EtcdIndex=%d, want %d", e2.EtcdIndex, e1.EtcdIndex)
-	}
-	// Changing the cloned node should not affect the original
-	e2.Action = Delete
-	e2.EtcdIndex = uint64(5)
-	if e1.Action != Create {
-		t.Fatalf("Action=%q, want %q", e1.Action, Create)
-	}
-	if e1.EtcdIndex != uint64(1) {
-		t.Fatalf("EtcdIndex=%d, want %d", e1.EtcdIndex, uint64(1))
-	}
-	if e2.Action != Delete {
-		t.Fatalf("Action=%q, want %q", e2.Action, Delete)
-	}
-	if e2.EtcdIndex != uint64(5) {
-		t.Fatalf("EtcdIndex=%d, want %d", e2.EtcdIndex, uint64(5))
-	}
-}
diff --git a/store/heap_test.go b/store/heap_test.go
deleted file mode 100644
index 0ff4961..0000000
--- a/store/heap_test.go
+++ /dev/null
@@ -1,94 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"fmt"
-	"testing"
-	"time"
-)
-
-func TestHeapPushPop(t *testing.T) {
-	h := newTtlKeyHeap()
-
-	// add from older expire time to earlier expire time
-	// the path is equal to ttl from now
-	for i := 0; i < 10; i++ {
-		path := fmt.Sprintf("%v", 10-i)
-		m := time.Duration(10 - i)
-		n := newKV(nil, path, path, 0, nil, time.Now().Add(time.Second*m))
-		h.push(n)
-	}
-
-	min := time.Now()
-
-	for i := 0; i < 10; i++ {
-		node := h.pop()
-		if node.ExpireTime.Before(min) {
-			t.Fatal("heap sort wrong!")
-		}
-		min = node.ExpireTime
-	}
-
-}
-
-func TestHeapUpdate(t *testing.T) {
-	h := newTtlKeyHeap()
-
-	kvs := make([]*node, 10)
-
-	// add from older expire time to earlier expire time
-	// the path is equal to ttl from now
-	for i := range kvs {
-		path := fmt.Sprintf("%v", 10-i)
-		m := time.Duration(10 - i)
-		n := newKV(nil, path, path, 0, nil, time.Now().Add(time.Second*m))
-		kvs[i] = n
-		h.push(n)
-	}
-
-	// Path 7
-	kvs[3].ExpireTime = time.Now().Add(time.Second * 11)
-
-	// Path 5
-	kvs[5].ExpireTime = time.Now().Add(time.Second * 12)
-
-	h.update(kvs[3])
-	h.update(kvs[5])
-
-	min := time.Now()
-
-	for i := 0; i < 10; i++ {
-		node := h.pop()
-		if node.ExpireTime.Before(min) {
-			t.Fatal("heap sort wrong!")
-		}
-		min = node.ExpireTime
-
-		if i == 8 {
-			if node.Path != "7" {
-				t.Fatal("heap sort wrong!", node.Path)
-			}
-		}
-
-		if i == 9 {
-			if node.Path != "5" {
-				t.Fatal("heap sort wrong!")
-			}
-		}
-
-	}
-
-}
diff --git a/store/metrics.go b/store/metrics.go
deleted file mode 100644
index 077c0fa..0000000
--- a/store/metrics.go
+++ /dev/null
@@ -1,132 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"github.com/prometheus/client_golang/prometheus"
-)
-
-// Set of raw Prometheus metrics.
-// Labels
-// * action = declared in event.go
-// * outcome = Outcome
-// Do not increment directly, use Report* methods.
-var (
-	readCounter = prometheus.NewCounterVec(
-		prometheus.CounterOpts{
-			Namespace: "etcd_debugging",
-			Subsystem: "store",
-			Name:      "reads_total",
-			Help:      "Total number of reads action by (get/getRecursive), local to this member.",
-		}, []string{"action"})
-
-	writeCounter = prometheus.NewCounterVec(
-		prometheus.CounterOpts{
-			Namespace: "etcd_debugging",
-			Subsystem: "store",
-			Name:      "writes_total",
-			Help:      "Total number of writes (e.g. set/compareAndDelete) seen by this member.",
-		}, []string{"action"})
-
-	readFailedCounter = prometheus.NewCounterVec(
-		prometheus.CounterOpts{
-			Namespace: "etcd_debugging",
-			Subsystem: "store",
-			Name:      "reads_failed_total",
-			Help:      "Failed read actions by (get/getRecursive), local to this member.",
-		}, []string{"action"})
-
-	writeFailedCounter = prometheus.NewCounterVec(
-		prometheus.CounterOpts{
-			Namespace: "etcd_debugging",
-			Subsystem: "store",
-			Name:      "writes_failed_total",
-			Help:      "Failed write actions (e.g. set/compareAndDelete), seen by this member.",
-		}, []string{"action"})
-
-	expireCounter = prometheus.NewCounter(
-		prometheus.CounterOpts{
-			Namespace: "etcd_debugging",
-			Subsystem: "store",
-			Name:      "expires_total",
-			Help:      "Total number of expired keys.",
-		})
-
-	watchRequests = prometheus.NewCounter(
-		prometheus.CounterOpts{
-			Namespace: "etcd_debugging",
-			Subsystem: "store",
-			Name:      "watch_requests_total",
-			Help:      "Total number of incoming watch requests (new or reestablished).",
-		})
-
-	watcherCount = prometheus.NewGauge(
-		prometheus.GaugeOpts{
-			Namespace: "etcd_debugging",
-			Subsystem: "store",
-			Name:      "watchers",
-			Help:      "Count of currently active watchers.",
-		})
-)
-
-const (
-	GetRecursive = "getRecursive"
-)
-
-func init() {
-	if prometheus.Register(readCounter) != nil {
-		// Tests will try to double register since the tests use both
-		// store and store_test packages; ignore second attempts.
-		return
-	}
-	prometheus.MustRegister(writeCounter)
-	prometheus.MustRegister(expireCounter)
-	prometheus.MustRegister(watchRequests)
-	prometheus.MustRegister(watcherCount)
-}
-
-func reportReadSuccess(read_action string) {
-	readCounter.WithLabelValues(read_action).Inc()
-}
-
-func reportReadFailure(read_action string) {
-	readCounter.WithLabelValues(read_action).Inc()
-	readFailedCounter.WithLabelValues(read_action).Inc()
-}
-
-func reportWriteSuccess(write_action string) {
-	writeCounter.WithLabelValues(write_action).Inc()
-}
-
-func reportWriteFailure(write_action string) {
-	writeCounter.WithLabelValues(write_action).Inc()
-	writeFailedCounter.WithLabelValues(write_action).Inc()
-}
-
-func reportExpiredKey() {
-	expireCounter.Inc()
-}
-
-func reportWatchRequest() {
-	watchRequests.Inc()
-}
-
-func reportWatcherAdded() {
-	watcherCount.Inc()
-}
-
-func reportWatcherRemoved() {
-	watcherCount.Dec()
-}
diff --git a/store/node.go b/store/node.go
deleted file mode 100644
index c3c8743..0000000
--- a/store/node.go
+++ /dev/null
@@ -1,395 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"path"
-	"sort"
-	"time"
-
-	etcdErr "github.com/coreos/etcd/error"
-	"github.com/jonboulle/clockwork"
-)
-
-// explanations of Compare function result
-const (
-	CompareMatch = iota
-	CompareIndexNotMatch
-	CompareValueNotMatch
-	CompareNotMatch
-)
-
-var Permanent time.Time
-
-// node is the basic element in the store system.
-// A key-value pair will have a string value
-// A directory will have a children map
-type node struct {
-	Path string
-
-	CreatedIndex  uint64
-	ModifiedIndex uint64
-
-	Parent *node `json:"-"` // should not encode this field! avoid circular dependency.
-
-	ExpireTime time.Time
-	Value      string           // for key-value pair
-	Children   map[string]*node // for directory
-
-	// A reference to the store this node is attached to.
-	store *store
-}
-
-// newKV creates a Key-Value pair
-func newKV(store *store, nodePath string, value string, createdIndex uint64, parent *node, expireTime time.Time) *node {
-	return &node{
-		Path:          nodePath,
-		CreatedIndex:  createdIndex,
-		ModifiedIndex: createdIndex,
-		Parent:        parent,
-		store:         store,
-		ExpireTime:    expireTime,
-		Value:         value,
-	}
-}
-
-// newDir creates a directory
-func newDir(store *store, nodePath string, createdIndex uint64, parent *node, expireTime time.Time) *node {
-	return &node{
-		Path:          nodePath,
-		CreatedIndex:  createdIndex,
-		ModifiedIndex: createdIndex,
-		Parent:        parent,
-		ExpireTime:    expireTime,
-		Children:      make(map[string]*node),
-		store:         store,
-	}
-}
-
-// IsHidden function checks if the node is a hidden node. A hidden node
-// will begin with '_'
-// A hidden node will not be shown via get command under a directory
-// For example if we have /foo/_hidden and /foo/notHidden, get "/foo"
-// will only return /foo/notHidden
-func (n *node) IsHidden() bool {
-	_, name := path.Split(n.Path)
-
-	return name[0] == '_'
-}
-
-// IsPermanent function checks if the node is a permanent one.
-func (n *node) IsPermanent() bool {
-	// we use a uninitialized time.Time to indicate the node is a
-	// permanent one.
-	// the uninitialized time.Time should equal zero.
-	return n.ExpireTime.IsZero()
-}
-
-// IsDir function checks whether the node is a directory.
-// If the node is a directory, the function will return true.
-// Otherwise the function will return false.
-func (n *node) IsDir() bool {
-	return n.Children != nil
-}
-
-// Read function gets the value of the node.
-// If the receiver node is not a key-value pair, a "Not A File" error will be returned.
-func (n *node) Read() (string, *etcdErr.Error) {
-	if n.IsDir() {
-		return "", etcdErr.NewError(etcdErr.EcodeNotFile, "", n.store.CurrentIndex)
-	}
-
-	return n.Value, nil
-}
-
-// Write function set the value of the node to the given value.
-// If the receiver node is a directory, a "Not A File" error will be returned.
-func (n *node) Write(value string, index uint64) *etcdErr.Error {
-	if n.IsDir() {
-		return etcdErr.NewError(etcdErr.EcodeNotFile, "", n.store.CurrentIndex)
-	}
-
-	n.Value = value
-	n.ModifiedIndex = index
-
-	return nil
-}
-
-func (n *node) expirationAndTTL(clock clockwork.Clock) (*time.Time, int64) {
-	if !n.IsPermanent() {
-		/* compute ttl as:
-		   ceiling( (expireTime - timeNow) / nanosecondsPerSecond )
-		   which ranges from 1..n
-		   rather than as:
-		   ( (expireTime - timeNow) / nanosecondsPerSecond ) + 1
-		   which ranges 1..n+1
-		*/
-		ttlN := n.ExpireTime.Sub(clock.Now())
-		ttl := ttlN / time.Second
-		if (ttlN % time.Second) > 0 {
-			ttl++
-		}
-		t := n.ExpireTime.UTC()
-		return &t, int64(ttl)
-	}
-	return nil, 0
-}
-
-// List function return a slice of nodes under the receiver node.
-// If the receiver node is not a directory, a "Not A Directory" error will be returned.
-func (n *node) List() ([]*node, *etcdErr.Error) {
-	if !n.IsDir() {
-		return nil, etcdErr.NewError(etcdErr.EcodeNotDir, "", n.store.CurrentIndex)
-	}
-
-	nodes := make([]*node, len(n.Children))
-
-	i := 0
-	for _, node := range n.Children {
-		nodes[i] = node
-		i++
-	}
-
-	return nodes, nil
-}
-
-// GetChild function returns the child node under the directory node.
-// On success, it returns the file node
-func (n *node) GetChild(name string) (*node, *etcdErr.Error) {
-	if !n.IsDir() {
-		return nil, etcdErr.NewError(etcdErr.EcodeNotDir, n.Path, n.store.CurrentIndex)
-	}
-
-	child, ok := n.Children[name]
-
-	if ok {
-		return child, nil
-	}
-
-	return nil, nil
-}
-
-// Add function adds a node to the receiver node.
-// If the receiver is not a directory, a "Not A Directory" error will be returned.
-// If there is an existing node with the same name under the directory, a "Already Exist"
-// error will be returned
-func (n *node) Add(child *node) *etcdErr.Error {
-	if !n.IsDir() {
-		return etcdErr.NewError(etcdErr.EcodeNotDir, "", n.store.CurrentIndex)
-	}
-
-	_, name := path.Split(child.Path)
-
-	if _, ok := n.Children[name]; ok {
-		return etcdErr.NewError(etcdErr.EcodeNodeExist, "", n.store.CurrentIndex)
-	}
-
-	n.Children[name] = child
-
-	return nil
-}
-
-// Remove function remove the node.
-func (n *node) Remove(dir, recursive bool, callback func(path string)) *etcdErr.Error {
-	if !n.IsDir() { // key-value pair
-		_, name := path.Split(n.Path)
-
-		// find its parent and remove the node from the map
-		if n.Parent != nil && n.Parent.Children[name] == n {
-			delete(n.Parent.Children, name)
-		}
-
-		if callback != nil {
-			callback(n.Path)
-		}
-
-		if !n.IsPermanent() {
-			n.store.ttlKeyHeap.remove(n)
-		}
-
-		return nil
-	}
-
-	if !dir {
-		// cannot delete a directory without dir set to true
-		return etcdErr.NewError(etcdErr.EcodeNotFile, n.Path, n.store.CurrentIndex)
-	}
-
-	if len(n.Children) != 0 && !recursive {
-		// cannot delete a directory if it is not empty and the operation
-		// is not recursive
-		return etcdErr.NewError(etcdErr.EcodeDirNotEmpty, n.Path, n.store.CurrentIndex)
-	}
-
-	for _, child := range n.Children { // delete all children
-		child.Remove(true, true, callback)
-	}
-
-	// delete self
-	_, name := path.Split(n.Path)
-	if n.Parent != nil && n.Parent.Children[name] == n {
-		delete(n.Parent.Children, name)
-
-		if callback != nil {
-			callback(n.Path)
-		}
-
-		if !n.IsPermanent() {
-			n.store.ttlKeyHeap.remove(n)
-		}
-	}
-
-	return nil
-}
-
-func (n *node) Repr(recursive, sorted bool, clock clockwork.Clock) *NodeExtern {
-	if n.IsDir() {
-		node := &NodeExtern{
-			Key:           n.Path,
-			Dir:           true,
-			ModifiedIndex: n.ModifiedIndex,
-			CreatedIndex:  n.CreatedIndex,
-		}
-		node.Expiration, node.TTL = n.expirationAndTTL(clock)
-
-		if !recursive {
-			return node
-		}
-
-		children, _ := n.List()
-		node.Nodes = make(NodeExterns, len(children))
-
-		// we do not use the index in the children slice directly
-		// we need to skip the hidden one
-		i := 0
-
-		for _, child := range children {
-
-			if child.IsHidden() { // get will not list hidden node
-				continue
-			}
-
-			node.Nodes[i] = child.Repr(recursive, sorted, clock)
-
-			i++
-		}
-
-		// eliminate hidden nodes
-		node.Nodes = node.Nodes[:i]
-		if sorted {
-			sort.Sort(node.Nodes)
-		}
-
-		return node
-	}
-
-	// since n.Value could be changed later, so we need to copy the value out
-	value := n.Value
-	node := &NodeExtern{
-		Key:           n.Path,
-		Value:         &value,
-		ModifiedIndex: n.ModifiedIndex,
-		CreatedIndex:  n.CreatedIndex,
-	}
-	node.Expiration, node.TTL = n.expirationAndTTL(clock)
-	return node
-}
-
-func (n *node) UpdateTTL(expireTime time.Time) {
-	if !n.IsPermanent() {
-		if expireTime.IsZero() {
-			// from ttl to permanent
-			n.ExpireTime = expireTime
-			// remove from ttl heap
-			n.store.ttlKeyHeap.remove(n)
-			return
-		}
-
-		// update ttl
-		n.ExpireTime = expireTime
-		// update ttl heap
-		n.store.ttlKeyHeap.update(n)
-		return
-	}
-
-	if expireTime.IsZero() {
-		return
-	}
-
-	// from permanent to ttl
-	n.ExpireTime = expireTime
-	// push into ttl heap
-	n.store.ttlKeyHeap.push(n)
-}
-
-// Compare function compares node index and value with provided ones.
-// second result value explains result and equals to one of Compare.. constants
-func (n *node) Compare(prevValue string, prevIndex uint64) (ok bool, which int) {
-	indexMatch := (prevIndex == 0 || n.ModifiedIndex == prevIndex)
-	valueMatch := (prevValue == "" || n.Value == prevValue)
-	ok = valueMatch && indexMatch
-	switch {
-	case valueMatch && indexMatch:
-		which = CompareMatch
-	case indexMatch && !valueMatch:
-		which = CompareValueNotMatch
-	case valueMatch && !indexMatch:
-		which = CompareIndexNotMatch
-	default:
-		which = CompareNotMatch
-	}
-	return ok, which
-}
-
-// Clone function clone the node recursively and return the new node.
-// If the node is a directory, it will clone all the content under this directory.
-// If the node is a key-value pair, it will clone the pair.
-func (n *node) Clone() *node {
-	if !n.IsDir() {
-		newkv := newKV(n.store, n.Path, n.Value, n.CreatedIndex, n.Parent, n.ExpireTime)
-		newkv.ModifiedIndex = n.ModifiedIndex
-		return newkv
-	}
-
-	clone := newDir(n.store, n.Path, n.CreatedIndex, n.Parent, n.ExpireTime)
-	clone.ModifiedIndex = n.ModifiedIndex
-
-	for key, child := range n.Children {
-		clone.Children[key] = child.Clone()
-	}
-
-	return clone
-}
-
-// recoverAndclean function help to do recovery.
-// Two things need to be done: 1. recovery structure; 2. delete expired nodes
-//
-// If the node is a directory, it will help recover children's parent pointer and recursively
-// call this function on its children.
-// We check the expire last since we need to recover the whole structure first and add all the
-// notifications into the event history.
-func (n *node) recoverAndclean() {
-	if n.IsDir() {
-		for _, child := range n.Children {
-			child.Parent = n
-			child.store = n.store
-			child.recoverAndclean()
-		}
-	}
-
-	if !n.ExpireTime.IsZero() {
-		n.store.ttlKeyHeap.push(n)
-	}
-}
diff --git a/store/node_extern.go b/store/node_extern.go
deleted file mode 100644
index 7ba870c..0000000
--- a/store/node_extern.go
+++ /dev/null
@@ -1,116 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"sort"
-	"time"
-
-	"github.com/jonboulle/clockwork"
-)
-
-// NodeExtern is the external representation of the
-// internal node with additional fields
-// PrevValue is the previous value of the node
-// TTL is time to live in second
-type NodeExtern struct {
-	Key           string      `json:"key,omitempty"`
-	Value         *string     `json:"value,omitempty"`
-	Dir           bool        `json:"dir,omitempty"`
-	Expiration    *time.Time  `json:"expiration,omitempty"`
-	TTL           int64       `json:"ttl,omitempty"`
-	Nodes         NodeExterns `json:"nodes,omitempty"`
-	ModifiedIndex uint64      `json:"modifiedIndex,omitempty"`
-	CreatedIndex  uint64      `json:"createdIndex,omitempty"`
-}
-
-func (eNode *NodeExtern) loadInternalNode(n *node, recursive, sorted bool, clock clockwork.Clock) {
-	if n.IsDir() { // node is a directory
-		eNode.Dir = true
-
-		children, _ := n.List()
-		eNode.Nodes = make(NodeExterns, len(children))
-
-		// we do not use the index in the children slice directly
-		// we need to skip the hidden one
-		i := 0
-
-		for _, child := range children {
-			if child.IsHidden() { // get will not return hidden nodes
-				continue
-			}
-
-			eNode.Nodes[i] = child.Repr(recursive, sorted, clock)
-			i++
-		}
-
-		// eliminate hidden nodes
-		eNode.Nodes = eNode.Nodes[:i]
-
-		if sorted {
-			sort.Sort(eNode.Nodes)
-		}
-
-	} else { // node is a file
-		value, _ := n.Read()
-		eNode.Value = &value
-	}
-
-	eNode.Expiration, eNode.TTL = n.expirationAndTTL(clock)
-}
-
-func (eNode *NodeExtern) Clone() *NodeExtern {
-	if eNode == nil {
-		return nil
-	}
-	nn := &NodeExtern{
-		Key:           eNode.Key,
-		Dir:           eNode.Dir,
-		TTL:           eNode.TTL,
-		ModifiedIndex: eNode.ModifiedIndex,
-		CreatedIndex:  eNode.CreatedIndex,
-	}
-	if eNode.Value != nil {
-		s := *eNode.Value
-		nn.Value = &s
-	}
-	if eNode.Expiration != nil {
-		t := *eNode.Expiration
-		nn.Expiration = &t
-	}
-	if eNode.Nodes != nil {
-		nn.Nodes = make(NodeExterns, len(eNode.Nodes))
-		for i, n := range eNode.Nodes {
-			nn.Nodes[i] = n.Clone()
-		}
-	}
-	return nn
-}
-
-type NodeExterns []*NodeExtern
-
-// interfaces for sorting
-
-func (ns NodeExterns) Len() int {
-	return len(ns)
-}
-
-func (ns NodeExterns) Less(i, j int) bool {
-	return ns[i].Key < ns[j].Key
-}
-
-func (ns NodeExterns) Swap(i, j int) {
-	ns[i], ns[j] = ns[j], ns[i]
-}
diff --git a/store/node_extern_test.go b/store/node_extern_test.go
deleted file mode 100644
index 7875e47..0000000
--- a/store/node_extern_test.go
+++ /dev/null
@@ -1,108 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"reflect"
-	"testing"
-	"time"
-	"unsafe"
-
-	"github.com/coreos/etcd/pkg/testutil"
-)
-
-func TestNodeExternClone(t *testing.T) {
-	var eNode *NodeExtern
-	if g := eNode.Clone(); g != nil {
-		t.Fatalf("nil.Clone=%v, want nil", g)
-	}
-
-	const (
-		key string = "/foo/bar"
-		ttl int64  = 123456789
-		ci  uint64 = 123
-		mi  uint64 = 321
-	)
-	var (
-		val    = "some_data"
-		valp   = &val
-		exp    = time.Unix(12345, 67890)
-		expp   = &exp
-		child  = NodeExtern{}
-		childp = &child
-		childs = []*NodeExtern{childp}
-	)
-
-	eNode = &NodeExtern{
-		Key:           key,
-		TTL:           ttl,
-		CreatedIndex:  ci,
-		ModifiedIndex: mi,
-		Value:         valp,
-		Expiration:    expp,
-		Nodes:         childs,
-	}
-
-	gNode := eNode.Clone()
-	// Check the clone is as expected
-	testutil.AssertEqual(t, gNode.Key, key)
-	testutil.AssertEqual(t, gNode.TTL, ttl)
-	testutil.AssertEqual(t, gNode.CreatedIndex, ci)
-	testutil.AssertEqual(t, gNode.ModifiedIndex, mi)
-	// values should be the same
-	testutil.AssertEqual(t, *gNode.Value, val)
-	testutil.AssertEqual(t, *gNode.Expiration, exp)
-	testutil.AssertEqual(t, len(gNode.Nodes), len(childs))
-	testutil.AssertEqual(t, *gNode.Nodes[0], child)
-	// but pointers should differ
-	if gNode.Value == eNode.Value {
-		t.Fatalf("expected value pointers to differ, but got same!")
-	}
-	if gNode.Expiration == eNode.Expiration {
-		t.Fatalf("expected expiration pointers to differ, but got same!")
-	}
-	if sameSlice(gNode.Nodes, eNode.Nodes) {
-		t.Fatalf("expected nodes pointers to differ, but got same!")
-	}
-	// Original should be the same
-	testutil.AssertEqual(t, eNode.Key, key)
-	testutil.AssertEqual(t, eNode.TTL, ttl)
-	testutil.AssertEqual(t, eNode.CreatedIndex, ci)
-	testutil.AssertEqual(t, eNode.ModifiedIndex, mi)
-	testutil.AssertEqual(t, eNode.Value, valp)
-	testutil.AssertEqual(t, eNode.Expiration, expp)
-	if !sameSlice(eNode.Nodes, childs) {
-		t.Fatalf("expected nodes pointer to same, but got different!")
-	}
-	// Change the clone and ensure the original is not affected
-	gNode.Key = "/baz"
-	gNode.TTL = 0
-	gNode.Nodes[0].Key = "uno"
-	testutil.AssertEqual(t, eNode.Key, key)
-	testutil.AssertEqual(t, eNode.TTL, ttl)
-	testutil.AssertEqual(t, eNode.CreatedIndex, ci)
-	testutil.AssertEqual(t, eNode.ModifiedIndex, mi)
-	testutil.AssertEqual(t, *eNode.Nodes[0], child)
-	// Change the original and ensure the clone is not affected
-	eNode.Key = "/wuf"
-	testutil.AssertEqual(t, eNode.Key, "/wuf")
-	testutil.AssertEqual(t, gNode.Key, "/baz")
-}
-
-func sameSlice(a, b []*NodeExtern) bool {
-	ah := (*reflect.SliceHeader)(unsafe.Pointer(&a))
-	bh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
-	return *ah == *bh
-}
diff --git a/store/node_test.go b/store/node_test.go
deleted file mode 100644
index 96fde8a..0000000
--- a/store/node_test.go
+++ /dev/null
@@ -1,246 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"testing"
-	"time"
-
-	"github.com/jonboulle/clockwork"
-)
-
-var (
-	key, val   = "foo", "bar"
-	val1, val2 = "bar1", "bar2"
-	expiration = time.Minute
-)
-
-func TestNewKVIs(t *testing.T) {
-	nd := newTestNode()
-
-	if nd.IsHidden() {
-		t.Errorf("nd.Hidden() = %v, want = false", nd.IsHidden())
-	}
-
-	if nd.IsPermanent() {
-		t.Errorf("nd.IsPermanent() = %v, want = false", nd.IsPermanent())
-	}
-
-	if nd.IsDir() {
-		t.Errorf("nd.IsDir() = %v, want = false", nd.IsDir())
-	}
-}
-
-func TestNewKVReadWriteCompare(t *testing.T) {
-	nd := newTestNode()
-
-	if v, err := nd.Read(); v != val || err != nil {
-		t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val)
-	}
-
-	if err := nd.Write(val1, nd.CreatedIndex+1); err != nil {
-		t.Errorf("nd.Write error = %v, want = nil", err)
-	} else {
-		if v, err := nd.Read(); v != val1 || err != nil {
-			t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val1)
-		}
-	}
-	if err := nd.Write(val2, nd.CreatedIndex+2); err != nil {
-		t.Errorf("nd.Write error = %v, want = nil", err)
-	} else {
-		if v, err := nd.Read(); v != val2 || err != nil {
-			t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val2)
-		}
-	}
-
-	if ok, which := nd.Compare(val2, 2); !ok || which != 0 {
-		t.Errorf("ok = %v and which = %d, want ok = true and which = 0", ok, which)
-	}
-}
-
-func TestNewKVExpiration(t *testing.T) {
-	nd := newTestNode()
-
-	if _, ttl := nd.expirationAndTTL(clockwork.NewFakeClock()); ttl > expiration.Nanoseconds() {
-		t.Errorf("ttl = %d, want %d < %d", ttl, ttl, expiration.Nanoseconds())
-	}
-
-	newExpiration := time.Hour
-	nd.UpdateTTL(time.Now().Add(newExpiration))
-	if _, ttl := nd.expirationAndTTL(clockwork.NewFakeClock()); ttl > newExpiration.Nanoseconds() {
-		t.Errorf("ttl = %d, want %d < %d", ttl, ttl, newExpiration.Nanoseconds())
-	}
-	if ns, err := nd.List(); ns != nil || err == nil {
-		t.Errorf("nodes = %v and err = %v, want nodes = nil and err != nil", ns, err)
-	}
-
-	en := nd.Repr(false, false, clockwork.NewFakeClock())
-	if en.Key != nd.Path {
-		t.Errorf("en.Key = %s, want = %s", en.Key, nd.Path)
-	}
-	if *(en.Value) != nd.Value {
-		t.Errorf("*(en.Key) = %s, want = %s", *(en.Value), nd.Value)
-	}
-}
-
-func TestNewKVListReprCompareClone(t *testing.T) {
-	nd := newTestNode()
-
-	if ns, err := nd.List(); ns != nil || err == nil {
-		t.Errorf("nodes = %v and err = %v, want nodes = nil and err != nil", ns, err)
-	}
-
-	en := nd.Repr(false, false, clockwork.NewFakeClock())
-	if en.Key != nd.Path {
-		t.Errorf("en.Key = %s, want = %s", en.Key, nd.Path)
-	}
-	if *(en.Value) != nd.Value {
-		t.Errorf("*(en.Key) = %s, want = %s", *(en.Value), nd.Value)
-	}
-
-	cn := nd.Clone()
-	if cn.Path != nd.Path {
-		t.Errorf("cn.Path = %s, want = %s", cn.Path, nd.Path)
-	}
-	if cn.Value != nd.Value {
-		t.Errorf("cn.Value = %s, want = %s", cn.Value, nd.Value)
-	}
-}
-
-func TestNewKVRemove(t *testing.T) {
-	nd := newTestNode()
-
-	if v, err := nd.Read(); v != val || err != nil {
-		t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val)
-	}
-
-	if err := nd.Write(val1, nd.CreatedIndex+1); err != nil {
-		t.Errorf("nd.Write error = %v, want = nil", err)
-	} else {
-		if v, err := nd.Read(); v != val1 || err != nil {
-			t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val1)
-		}
-	}
-	if err := nd.Write(val2, nd.CreatedIndex+2); err != nil {
-		t.Errorf("nd.Write error = %v, want = nil", err)
-	} else {
-		if v, err := nd.Read(); v != val2 || err != nil {
-			t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val2)
-		}
-	}
-
-	if err := nd.Remove(false, false, nil); err != nil {
-		t.Errorf("nd.Remove err = %v, want = nil", err)
-	} else {
-		// still readable
-		if v, err := nd.Read(); v != val2 || err != nil {
-			t.Errorf("value = %s and err = %v, want value = %s and err = nil", v, err, val2)
-		}
-		if len(nd.store.ttlKeyHeap.array) != 0 {
-			t.Errorf("len(nd.store.ttlKeyHeap.array) = %d, want = 0", len(nd.store.ttlKeyHeap.array))
-		}
-		if len(nd.store.ttlKeyHeap.keyMap) != 0 {
-			t.Errorf("len(nd.store.ttlKeyHeap.keyMap) = %d, want = 0", len(nd.store.ttlKeyHeap.keyMap))
-		}
-	}
-}
-
-func TestNewDirIs(t *testing.T) {
-	nd, _ := newTestNodeDir()
-	if nd.IsHidden() {
-		t.Errorf("nd.Hidden() = %v, want = false", nd.IsHidden())
-	}
-
-	if nd.IsPermanent() {
-		t.Errorf("nd.IsPermanent() = %v, want = false", nd.IsPermanent())
-	}
-
-	if !nd.IsDir() {
-		t.Errorf("nd.IsDir() = %v, want = true", nd.IsDir())
-	}
-}
-
-func TestNewDirReadWriteListReprClone(t *testing.T) {
-	nd, _ := newTestNodeDir()
-
-	if _, err := nd.Read(); err == nil {
-		t.Errorf("err = %v, want err != nil", err)
-	}
-
-	if err := nd.Write(val, nd.CreatedIndex+1); err == nil {
-		t.Errorf("err = %v, want err != nil", err)
-	}
-
-	if ns, err := nd.List(); ns == nil && err != nil {
-		t.Errorf("nodes = %v and err = %v, want nodes = nil and err == nil", ns, err)
-	}
-
-	en := nd.Repr(false, false, clockwork.NewFakeClock())
-	if en.Key != nd.Path {
-		t.Errorf("en.Key = %s, want = %s", en.Key, nd.Path)
-	}
-
-	cn := nd.Clone()
-	if cn.Path != nd.Path {
-		t.Errorf("cn.Path = %s, want = %s", cn.Path, nd.Path)
-	}
-}
-
-func TestNewDirExpirationTTL(t *testing.T) {
-	nd, _ := newTestNodeDir()
-
-	if _, ttl := nd.expirationAndTTL(clockwork.NewFakeClock()); ttl > expiration.Nanoseconds() {
-		t.Errorf("ttl = %d, want %d < %d", ttl, ttl, expiration.Nanoseconds())
-	}
-
-	newExpiration := time.Hour
-	nd.UpdateTTL(time.Now().Add(newExpiration))
-	if _, ttl := nd.expirationAndTTL(clockwork.NewFakeClock()); ttl > newExpiration.Nanoseconds() {
-		t.Errorf("ttl = %d, want %d < %d", ttl, ttl, newExpiration.Nanoseconds())
-	}
-}
-
-func TestNewDirChild(t *testing.T) {
-	nd, child := newTestNodeDir()
-
-	if err := nd.Add(child); err != nil {
-		t.Errorf("nd.Add(child) err = %v, want = nil", err)
-	} else {
-		if len(nd.Children) == 0 {
-			t.Errorf("len(nd.Children) = %d, want = 1", len(nd.Children))
-		}
-	}
-
-	if err := child.Remove(true, true, nil); err != nil {
-		t.Errorf("child.Remove err = %v, want = nil", err)
-	} else {
-		if len(nd.Children) != 0 {
-			t.Errorf("len(nd.Children) = %d, want = 0", len(nd.Children))
-		}
-	}
-}
-
-func newTestNode() *node {
-	nd := newKV(newStore(), key, val, 0, nil, time.Now().Add(expiration))
-	return nd
-}
-
-func newTestNodeDir() (*node, *node) {
-	s := newStore()
-	nd := newDir(s, key, 0, nil, time.Now().Add(expiration))
-	cKey, cVal := "hello", "world"
-	child := newKV(s, cKey, cVal, 0, nd, time.Now().Add(expiration))
-	return nd, child
-}
diff --git a/store/stats.go b/store/stats.go
deleted file mode 100644
index ce464dd..0000000
--- a/store/stats.go
+++ /dev/null
@@ -1,145 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"encoding/json"
-	"sync/atomic"
-)
-
-const (
-	SetSuccess = iota
-	SetFail
-	DeleteSuccess
-	DeleteFail
-	CreateSuccess
-	CreateFail
-	UpdateSuccess
-	UpdateFail
-	CompareAndSwapSuccess
-	CompareAndSwapFail
-	GetSuccess
-	GetFail
-	ExpireCount
-	CompareAndDeleteSuccess
-	CompareAndDeleteFail
-)
-
-type Stats struct {
-	// Number of get requests
-
-	GetSuccess uint64 `json:"getsSuccess"`
-	GetFail    uint64 `json:"getsFail"`
-
-	// Number of sets requests
-
-	SetSuccess uint64 `json:"setsSuccess"`
-	SetFail    uint64 `json:"setsFail"`
-
-	// Number of delete requests
-
-	DeleteSuccess uint64 `json:"deleteSuccess"`
-	DeleteFail    uint64 `json:"deleteFail"`
-
-	// Number of update requests
-
-	UpdateSuccess uint64 `json:"updateSuccess"`
-	UpdateFail    uint64 `json:"updateFail"`
-
-	// Number of create requests
-
-	CreateSuccess uint64 `json:"createSuccess"`
-	CreateFail    uint64 `json:"createFail"`
-
-	// Number of testAndSet requests
-
-	CompareAndSwapSuccess uint64 `json:"compareAndSwapSuccess"`
-	CompareAndSwapFail    uint64 `json:"compareAndSwapFail"`
-
-	// Number of compareAndDelete requests
-
-	CompareAndDeleteSuccess uint64 `json:"compareAndDeleteSuccess"`
-	CompareAndDeleteFail    uint64 `json:"compareAndDeleteFail"`
-
-	ExpireCount uint64 `json:"expireCount"`
-
-	Watchers uint64 `json:"watchers"`
-}
-
-func newStats() *Stats {
-	s := new(Stats)
-	return s
-}
-
-func (s *Stats) clone() *Stats {
-	return &Stats{
-		GetSuccess:              s.GetSuccess,
-		GetFail:                 s.GetFail,
-		SetSuccess:              s.SetSuccess,
-		SetFail:                 s.SetFail,
-		DeleteSuccess:           s.DeleteSuccess,
-		DeleteFail:              s.DeleteFail,
-		UpdateSuccess:           s.UpdateSuccess,
-		UpdateFail:              s.UpdateFail,
-		CreateSuccess:           s.CreateSuccess,
-		CreateFail:              s.CreateFail,
-		CompareAndSwapSuccess:   s.CompareAndSwapSuccess,
-		CompareAndSwapFail:      s.CompareAndSwapFail,
-		CompareAndDeleteSuccess: s.CompareAndDeleteSuccess,
-		CompareAndDeleteFail:    s.CompareAndDeleteFail,
-		ExpireCount:             s.ExpireCount,
-		Watchers:                s.Watchers,
-	}
-}
-
-func (s *Stats) toJson() []byte {
-	b, _ := json.Marshal(s)
-	return b
-}
-
-func (s *Stats) Inc(field int) {
-	switch field {
-	case SetSuccess:
-		atomic.AddUint64(&s.SetSuccess, 1)
-	case SetFail:
-		atomic.AddUint64(&s.SetFail, 1)
-	case CreateSuccess:
-		atomic.AddUint64(&s.CreateSuccess, 1)
-	case CreateFail:
-		atomic.AddUint64(&s.CreateFail, 1)
-	case DeleteSuccess:
-		atomic.AddUint64(&s.DeleteSuccess, 1)
-	case DeleteFail:
-		atomic.AddUint64(&s.DeleteFail, 1)
-	case GetSuccess:
-		atomic.AddUint64(&s.GetSuccess, 1)
-	case GetFail:
-		atomic.AddUint64(&s.GetFail, 1)
-	case UpdateSuccess:
-		atomic.AddUint64(&s.UpdateSuccess, 1)
-	case UpdateFail:
-		atomic.AddUint64(&s.UpdateFail, 1)
-	case CompareAndSwapSuccess:
-		atomic.AddUint64(&s.CompareAndSwapSuccess, 1)
-	case CompareAndSwapFail:
-		atomic.AddUint64(&s.CompareAndSwapFail, 1)
-	case CompareAndDeleteSuccess:
-		atomic.AddUint64(&s.CompareAndDeleteSuccess, 1)
-	case CompareAndDeleteFail:
-		atomic.AddUint64(&s.CompareAndDeleteFail, 1)
-	case ExpireCount:
-		atomic.AddUint64(&s.ExpireCount, 1)
-	}
-}
diff --git a/store/stats_test.go b/store/stats_test.go
deleted file mode 100644
index ec105a5..0000000
--- a/store/stats_test.go
+++ /dev/null
@@ -1,112 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"testing"
-	"time"
-
-	"github.com/coreos/etcd/pkg/testutil"
-)
-
-// Ensure that a successful Get is recorded in the stats.
-func TestStoreStatsGetSuccess(t *testing.T) {
-	s := newStore()
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Get("/foo", false, false)
-	testutil.AssertEqual(t, uint64(1), s.Stats.GetSuccess, "")
-}
-
-// Ensure that a failed Get is recorded in the stats.
-func TestStoreStatsGetFail(t *testing.T) {
-	s := newStore()
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Get("/no_such_key", false, false)
-	testutil.AssertEqual(t, uint64(1), s.Stats.GetFail, "")
-}
-
-// Ensure that a successful Create is recorded in the stats.
-func TestStoreStatsCreateSuccess(t *testing.T) {
-	s := newStore()
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.CreateSuccess, "")
-}
-
-// Ensure that a failed Create is recorded in the stats.
-func TestStoreStatsCreateFail(t *testing.T) {
-	s := newStore()
-	s.Create("/foo", true, "", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.CreateFail, "")
-}
-
-// Ensure that a successful Update is recorded in the stats.
-func TestStoreStatsUpdateSuccess(t *testing.T) {
-	s := newStore()
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Update("/foo", "baz", TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.UpdateSuccess, "")
-}
-
-// Ensure that a failed Update is recorded in the stats.
-func TestStoreStatsUpdateFail(t *testing.T) {
-	s := newStore()
-	s.Update("/foo", "bar", TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.UpdateFail, "")
-}
-
-// Ensure that a successful CAS is recorded in the stats.
-func TestStoreStatsCompareAndSwapSuccess(t *testing.T) {
-	s := newStore()
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	s.CompareAndSwap("/foo", "bar", 0, "baz", TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.CompareAndSwapSuccess, "")
-}
-
-// Ensure that a failed CAS is recorded in the stats.
-func TestStoreStatsCompareAndSwapFail(t *testing.T) {
-	s := newStore()
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	s.CompareAndSwap("/foo", "wrong_value", 0, "baz", TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.CompareAndSwapFail, "")
-}
-
-// Ensure that a successful Delete is recorded in the stats.
-func TestStoreStatsDeleteSuccess(t *testing.T) {
-	s := newStore()
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Delete("/foo", false, false)
-	testutil.AssertEqual(t, uint64(1), s.Stats.DeleteSuccess, "")
-}
-
-// Ensure that a failed Delete is recorded in the stats.
-func TestStoreStatsDeleteFail(t *testing.T) {
-	s := newStore()
-	s.Delete("/foo", false, false)
-	testutil.AssertEqual(t, uint64(1), s.Stats.DeleteFail, "")
-}
-
-//Ensure that the number of expirations is recorded in the stats.
-func TestStoreStatsExpireCount(t *testing.T) {
-	s := newStore()
-	fc := newFakeClock()
-	s.clock = fc
-
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
-	testutil.AssertEqual(t, uint64(0), s.Stats.ExpireCount, "")
-	fc.Advance(600 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-	testutil.AssertEqual(t, uint64(1), s.Stats.ExpireCount, "")
-}
diff --git a/store/store.go b/store/store.go
deleted file mode 100644
index edf7f21..0000000
--- a/store/store.go
+++ /dev/null
@@ -1,791 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"encoding/json"
-	"fmt"
-	"path"
-	"strconv"
-	"strings"
-	"sync"
-	"time"
-
-	etcdErr "github.com/coreos/etcd/error"
-	"github.com/coreos/etcd/pkg/types"
-	"github.com/jonboulle/clockwork"
-)
-
-// The default version to set when the store is first initialized.
-const defaultVersion = 2
-
-var minExpireTime time.Time
-
-func init() {
-	minExpireTime, _ = time.Parse(time.RFC3339, "2000-01-01T00:00:00Z")
-}
-
-type Store interface {
-	Version() int
-	Index() uint64
-
-	Get(nodePath string, recursive, sorted bool) (*Event, error)
-	Set(nodePath string, dir bool, value string, expireOpts TTLOptionSet) (*Event, error)
-	Update(nodePath string, newValue string, expireOpts TTLOptionSet) (*Event, error)
-	Create(nodePath string, dir bool, value string, unique bool,
-		expireOpts TTLOptionSet) (*Event, error)
-	CompareAndSwap(nodePath string, prevValue string, prevIndex uint64,
-		value string, expireOpts TTLOptionSet) (*Event, error)
-	Delete(nodePath string, dir, recursive bool) (*Event, error)
-	CompareAndDelete(nodePath string, prevValue string, prevIndex uint64) (*Event, error)
-
-	Watch(prefix string, recursive, stream bool, sinceIndex uint64) (Watcher, error)
-
-	Save() ([]byte, error)
-	Recovery(state []byte) error
-
-	Clone() Store
-	SaveNoCopy() ([]byte, error)
-
-	JsonStats() []byte
-	DeleteExpiredKeys(cutoff time.Time)
-
-	HasTTLKeys() bool
-}
-
-type TTLOptionSet struct {
-	ExpireTime time.Time
-	Refresh    bool
-}
-
-type store struct {
-	Root           *node
-	WatcherHub     *watcherHub
-	CurrentIndex   uint64
-	Stats          *Stats
-	CurrentVersion int
-	ttlKeyHeap     *ttlKeyHeap  // need to recovery manually
-	worldLock      sync.RWMutex // stop the world lock
-	clock          clockwork.Clock
-	readonlySet    types.Set
-}
-
-// New creates a store where the given namespaces will be created as initial directories.
-func New(namespaces ...string) Store {
-	s := newStore(namespaces...)
-	s.clock = clockwork.NewRealClock()
-	return s
-}
-
-func newStore(namespaces ...string) *store {
-	s := new(store)
-	s.CurrentVersion = defaultVersion
-	s.Root = newDir(s, "/", s.CurrentIndex, nil, Permanent)
-	for _, namespace := range namespaces {
-		s.Root.Add(newDir(s, namespace, s.CurrentIndex, s.Root, Permanent))
-	}
-	s.Stats = newStats()
-	s.WatcherHub = newWatchHub(1000)
-	s.ttlKeyHeap = newTtlKeyHeap()
-	s.readonlySet = types.NewUnsafeSet(append(namespaces, "/")...)
-	return s
-}
-
-// Version retrieves current version of the store.
-func (s *store) Version() int {
-	return s.CurrentVersion
-}
-
-// Index retrieves the current index of the store.
-func (s *store) Index() uint64 {
-	s.worldLock.RLock()
-	defer s.worldLock.RUnlock()
-	return s.CurrentIndex
-}
-
-// Get returns a get event.
-// If recursive is true, it will return all the content under the node path.
-// If sorted is true, it will sort the content by keys.
-func (s *store) Get(nodePath string, recursive, sorted bool) (*Event, error) {
-	var err *etcdErr.Error
-
-	s.worldLock.RLock()
-	defer s.worldLock.RUnlock()
-
-	defer func() {
-		if err == nil {
-			s.Stats.Inc(GetSuccess)
-			if recursive {
-				reportReadSuccess(GetRecursive)
-			} else {
-				reportReadSuccess(Get)
-			}
-			return
-		}
-
-		s.Stats.Inc(GetFail)
-		if recursive {
-			reportReadFailure(GetRecursive)
-		} else {
-			reportReadFailure(Get)
-		}
-	}()
-
-	n, err := s.internalGet(nodePath)
-	if err != nil {
-		return nil, err
-	}
-
-	e := newEvent(Get, nodePath, n.ModifiedIndex, n.CreatedIndex)
-	e.EtcdIndex = s.CurrentIndex
-	e.Node.loadInternalNode(n, recursive, sorted, s.clock)
-
-	return e, nil
-}
-
-// Create creates the node at nodePath. Create will help to create intermediate directories with no ttl.
-// If the node has already existed, create will fail.
-// If any node on the path is a file, create will fail.
-func (s *store) Create(nodePath string, dir bool, value string, unique bool, expireOpts TTLOptionSet) (*Event, error) {
-	var err *etcdErr.Error
-
-	s.worldLock.Lock()
-	defer s.worldLock.Unlock()
-
-	defer func() {
-		if err == nil {
-			s.Stats.Inc(CreateSuccess)
-			reportWriteSuccess(Create)
-			return
-		}
-
-		s.Stats.Inc(CreateFail)
-		reportWriteFailure(Create)
-	}()
-
-	e, err := s.internalCreate(nodePath, dir, value, unique, false, expireOpts.ExpireTime, Create)
-	if err != nil {
-		return nil, err
-	}
-
-	e.EtcdIndex = s.CurrentIndex
-	s.WatcherHub.notify(e)
-
-	return e, nil
-}
-
-// Set creates or replace the node at nodePath.
-func (s *store) Set(nodePath string, dir bool, value string, expireOpts TTLOptionSet) (*Event, error) {
-	var err *etcdErr.Error
-
-	s.worldLock.Lock()
-	defer s.worldLock.Unlock()
-
-	defer func() {
-		if err == nil {
-			s.Stats.Inc(SetSuccess)
-			reportWriteSuccess(Set)
-			return
-		}
-
-		s.Stats.Inc(SetFail)
-		reportWriteFailure(Set)
-	}()
-
-	// Get prevNode value
-	n, getErr := s.internalGet(nodePath)
-	if getErr != nil && getErr.ErrorCode != etcdErr.EcodeKeyNotFound {
-		err = getErr
-		return nil, err
-	}
-
-	if expireOpts.Refresh {
-		if getErr != nil {
-			err = getErr
-			return nil, err
-		} else {
-			value = n.Value
-		}
-	}
-
-	// Set new value
-	e, err := s.internalCreate(nodePath, dir, value, false, true, expireOpts.ExpireTime, Set)
-	if err != nil {
-		return nil, err
-	}
-	e.EtcdIndex = s.CurrentIndex
-
-	// Put prevNode into event
-	if getErr == nil {
-		prev := newEvent(Get, nodePath, n.ModifiedIndex, n.CreatedIndex)
-		prev.Node.loadInternalNode(n, false, false, s.clock)
-		e.PrevNode = prev.Node
-	}
-
-	if !expireOpts.Refresh {
-		s.WatcherHub.notify(e)
-	} else {
-		e.SetRefresh()
-		s.WatcherHub.add(e)
-	}
-
-	return e, nil
-}
-
-// returns user-readable cause of failed comparison
-func getCompareFailCause(n *node, which int, prevValue string, prevIndex uint64) string {
-	switch which {
-	case CompareIndexNotMatch:
-		return fmt.Sprintf("[%v != %v]", prevIndex, n.ModifiedIndex)
-	case CompareValueNotMatch:
-		return fmt.Sprintf("[%v != %v]", prevValue, n.Value)
-	default:
-		return fmt.Sprintf("[%v != %v] [%v != %v]", prevValue, n.Value, prevIndex, n.ModifiedIndex)
-	}
-}
-
-func (s *store) CompareAndSwap(nodePath string, prevValue string, prevIndex uint64,
-	value string, expireOpts TTLOptionSet) (*Event, error) {
-
-	var err *etcdErr.Error
-
-	s.worldLock.Lock()
-	defer s.worldLock.Unlock()
-
-	defer func() {
-		if err == nil {
-			s.Stats.Inc(CompareAndSwapSuccess)
-			reportWriteSuccess(CompareAndSwap)
-			return
-		}
-
-		s.Stats.Inc(CompareAndSwapFail)
-		reportWriteFailure(CompareAndSwap)
-	}()
-
-	nodePath = path.Clean(path.Join("/", nodePath))
-	// we do not allow the user to change "/"
-	if s.readonlySet.Contains(nodePath) {
-		return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", s.CurrentIndex)
-	}
-
-	n, err := s.internalGet(nodePath)
-	if err != nil {
-		return nil, err
-	}
-	if n.IsDir() { // can only compare and swap file
-		err = etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, s.CurrentIndex)
-		return nil, err
-	}
-
-	// If both of the prevValue and prevIndex are given, we will test both of them.
-	// Command will be executed, only if both of the tests are successful.
-	if ok, which := n.Compare(prevValue, prevIndex); !ok {
-		cause := getCompareFailCause(n, which, prevValue, prevIndex)
-		err = etcdErr.NewError(etcdErr.EcodeTestFailed, cause, s.CurrentIndex)
-		return nil, err
-	}
-
-	if expireOpts.Refresh {
-		value = n.Value
-	}
-
-	// update etcd index
-	s.CurrentIndex++
-
-	e := newEvent(CompareAndSwap, nodePath, s.CurrentIndex, n.CreatedIndex)
-	e.EtcdIndex = s.CurrentIndex
-	e.PrevNode = n.Repr(false, false, s.clock)
-	eNode := e.Node
-
-	// if test succeed, write the value
-	n.Write(value, s.CurrentIndex)
-	n.UpdateTTL(expireOpts.ExpireTime)
-
-	// copy the value for safety
-	valueCopy := value
-	eNode.Value = &valueCopy
-	eNode.Expiration, eNode.TTL = n.expirationAndTTL(s.clock)
-
-	if !expireOpts.Refresh {
-		s.WatcherHub.notify(e)
-	} else {
-		e.SetRefresh()
-		s.WatcherHub.add(e)
-	}
-
-	return e, nil
-}
-
-// Delete deletes the node at the given path.
-// If the node is a directory, recursive must be true to delete it.
-func (s *store) Delete(nodePath string, dir, recursive bool) (*Event, error) {
-	var err *etcdErr.Error
-
-	s.worldLock.Lock()
-	defer s.worldLock.Unlock()
-
-	defer func() {
-		if err == nil {
-			s.Stats.Inc(DeleteSuccess)
-			reportWriteSuccess(Delete)
-			return
-		}
-
-		s.Stats.Inc(DeleteFail)
-		reportWriteFailure(Delete)
-	}()
-
-	nodePath = path.Clean(path.Join("/", nodePath))
-	// we do not allow the user to change "/"
-	if s.readonlySet.Contains(nodePath) {
-		return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", s.CurrentIndex)
-	}
-
-	// recursive implies dir
-	if recursive {
-		dir = true
-	}
-
-	n, err := s.internalGet(nodePath)
-	if err != nil { // if the node does not exist, return error
-		return nil, err
-	}
-
-	nextIndex := s.CurrentIndex + 1
-	e := newEvent(Delete, nodePath, nextIndex, n.CreatedIndex)
-	e.EtcdIndex = nextIndex
-	e.PrevNode = n.Repr(false, false, s.clock)
-	eNode := e.Node
-
-	if n.IsDir() {
-		eNode.Dir = true
-	}
-
-	callback := func(path string) { // notify function
-		// notify the watchers with deleted set true
-		s.WatcherHub.notifyWatchers(e, path, true)
-	}
-
-	err = n.Remove(dir, recursive, callback)
-	if err != nil {
-		return nil, err
-	}
-
-	// update etcd index
-	s.CurrentIndex++
-
-	s.WatcherHub.notify(e)
-
-	return e, nil
-}
-
-func (s *store) CompareAndDelete(nodePath string, prevValue string, prevIndex uint64) (*Event, error) {
-	var err *etcdErr.Error
-
-	s.worldLock.Lock()
-	defer s.worldLock.Unlock()
-
-	defer func() {
-		if err == nil {
-			s.Stats.Inc(CompareAndDeleteSuccess)
-			reportWriteSuccess(CompareAndDelete)
-			return
-		}
-
-		s.Stats.Inc(CompareAndDeleteFail)
-		reportWriteFailure(CompareAndDelete)
-	}()
-
-	nodePath = path.Clean(path.Join("/", nodePath))
-
-	n, err := s.internalGet(nodePath)
-	if err != nil { // if the node does not exist, return error
-		return nil, err
-	}
-	if n.IsDir() { // can only compare and delete file
-		return nil, etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, s.CurrentIndex)
-	}
-
-	// If both of the prevValue and prevIndex are given, we will test both of them.
-	// Command will be executed, only if both of the tests are successful.
-	if ok, which := n.Compare(prevValue, prevIndex); !ok {
-		cause := getCompareFailCause(n, which, prevValue, prevIndex)
-		return nil, etcdErr.NewError(etcdErr.EcodeTestFailed, cause, s.CurrentIndex)
-	}
-
-	// update etcd index
-	s.CurrentIndex++
-
-	e := newEvent(CompareAndDelete, nodePath, s.CurrentIndex, n.CreatedIndex)
-	e.EtcdIndex = s.CurrentIndex
-	e.PrevNode = n.Repr(false, false, s.clock)
-
-	callback := func(path string) { // notify function
-		// notify the watchers with deleted set true
-		s.WatcherHub.notifyWatchers(e, path, true)
-	}
-
-	err = n.Remove(false, false, callback)
-	if err != nil {
-		return nil, err
-	}
-
-	s.WatcherHub.notify(e)
-
-	return e, nil
-}
-
-func (s *store) Watch(key string, recursive, stream bool, sinceIndex uint64) (Watcher, error) {
-	s.worldLock.RLock()
-	defer s.worldLock.RUnlock()
-
-	key = path.Clean(path.Join("/", key))
-	if sinceIndex == 0 {
-		sinceIndex = s.CurrentIndex + 1
-	}
-	// WatcherHub does not know about the current index, so we need to pass it in
-	w, err := s.WatcherHub.watch(key, recursive, stream, sinceIndex, s.CurrentIndex)
-	if err != nil {
-		return nil, err
-	}
-
-	return w, nil
-}
-
-// walk walks all the nodePath and apply the walkFunc on each directory
-func (s *store) walk(nodePath string, walkFunc func(prev *node, component string) (*node, *etcdErr.Error)) (*node, *etcdErr.Error) {
-	components := strings.Split(nodePath, "/")
-
-	curr := s.Root
-	var err *etcdErr.Error
-
-	for i := 1; i < len(components); i++ {
-		if len(components[i]) == 0 { // ignore empty string
-			return curr, nil
-		}
-
-		curr, err = walkFunc(curr, components[i])
-		if err != nil {
-			return nil, err
-		}
-	}
-
-	return curr, nil
-}
-
-// Update updates the value/ttl of the node.
-// If the node is a file, the value and the ttl can be updated.
-// If the node is a directory, only the ttl can be updated.
-func (s *store) Update(nodePath string, newValue string, expireOpts TTLOptionSet) (*Event, error) {
-	var err *etcdErr.Error
-
-	s.worldLock.Lock()
-	defer s.worldLock.Unlock()
-
-	defer func() {
-		if err == nil {
-			s.Stats.Inc(UpdateSuccess)
-			reportWriteSuccess(Update)
-			return
-		}
-
-		s.Stats.Inc(UpdateFail)
-		reportWriteFailure(Update)
-	}()
-
-	nodePath = path.Clean(path.Join("/", nodePath))
-	// we do not allow the user to change "/"
-	if s.readonlySet.Contains(nodePath) {
-		return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", s.CurrentIndex)
-	}
-
-	currIndex, nextIndex := s.CurrentIndex, s.CurrentIndex+1
-
-	n, err := s.internalGet(nodePath)
-	if err != nil { // if the node does not exist, return error
-		return nil, err
-	}
-	if n.IsDir() && len(newValue) != 0 {
-		// if the node is a directory, we cannot update value to non-empty
-		return nil, etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, currIndex)
-	}
-
-	if expireOpts.Refresh {
-		newValue = n.Value
-	}
-
-	e := newEvent(Update, nodePath, nextIndex, n.CreatedIndex)
-	e.EtcdIndex = nextIndex
-	e.PrevNode = n.Repr(false, false, s.clock)
-	eNode := e.Node
-
-	n.Write(newValue, nextIndex)
-
-	if n.IsDir() {
-		eNode.Dir = true
-	} else {
-		// copy the value for safety
-		newValueCopy := newValue
-		eNode.Value = &newValueCopy
-	}
-
-	// update ttl
-	n.UpdateTTL(expireOpts.ExpireTime)
-
-	eNode.Expiration, eNode.TTL = n.expirationAndTTL(s.clock)
-
-	if !expireOpts.Refresh {
-		s.WatcherHub.notify(e)
-	} else {
-		e.SetRefresh()
-		s.WatcherHub.add(e)
-	}
-
-	s.CurrentIndex = nextIndex
-
-	return e, nil
-}
-
-func (s *store) internalCreate(nodePath string, dir bool, value string, unique, replace bool,
-	expireTime time.Time, action string) (*Event, *etcdErr.Error) {
-
-	currIndex, nextIndex := s.CurrentIndex, s.CurrentIndex+1
-
-	if unique { // append unique item under the node path
-		nodePath += "/" + fmt.Sprintf("%020s", strconv.FormatUint(nextIndex, 10))
-	}
-
-	nodePath = path.Clean(path.Join("/", nodePath))
-
-	// we do not allow the user to change "/"
-	if s.readonlySet.Contains(nodePath) {
-		return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", currIndex)
-	}
-
-	// Assume expire times that are way in the past are
-	// This can occur when the time is serialized to JS
-	if expireTime.Before(minExpireTime) {
-		expireTime = Permanent
-	}
-
-	dirName, nodeName := path.Split(nodePath)
-
-	// walk through the nodePath, create dirs and get the last directory node
-	d, err := s.walk(dirName, s.checkDir)
-
-	if err != nil {
-		s.Stats.Inc(SetFail)
-		reportWriteFailure(action)
-		err.Index = currIndex
-		return nil, err
-	}
-
-	e := newEvent(action, nodePath, nextIndex, nextIndex)
-	eNode := e.Node
-
-	n, _ := d.GetChild(nodeName)
-
-	// force will try to replace an existing file
-	if n != nil {
-		if replace {
-			if n.IsDir() {
-				return nil, etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, currIndex)
-			}
-			e.PrevNode = n.Repr(false, false, s.clock)
-
-			n.Remove(false, false, nil)
-		} else {
-			return nil, etcdErr.NewError(etcdErr.EcodeNodeExist, nodePath, currIndex)
-		}
-	}
-
-	if !dir { // create file
-		// copy the value for safety
-		valueCopy := value
-		eNode.Value = &valueCopy
-
-		n = newKV(s, nodePath, value, nextIndex, d, expireTime)
-
-	} else { // create directory
-		eNode.Dir = true
-
-		n = newDir(s, nodePath, nextIndex, d, expireTime)
-	}
-
-	// we are sure d is a directory and does not have the children with name n.Name
-	d.Add(n)
-
-	// node with TTL
-	if !n.IsPermanent() {
-		s.ttlKeyHeap.push(n)
-
-		eNode.Expiration, eNode.TTL = n.expirationAndTTL(s.clock)
-	}
-
-	s.CurrentIndex = nextIndex
-
-	return e, nil
-}
-
-// InternalGet gets the node of the given nodePath.
-func (s *store) internalGet(nodePath string) (*node, *etcdErr.Error) {
-	nodePath = path.Clean(path.Join("/", nodePath))
-
-	walkFunc := func(parent *node, name string) (*node, *etcdErr.Error) {
-
-		if !parent.IsDir() {
-			err := etcdErr.NewError(etcdErr.EcodeNotDir, parent.Path, s.CurrentIndex)
-			return nil, err
-		}
-
-		child, ok := parent.Children[name]
-		if ok {
-			return child, nil
-		}
-
-		return nil, etcdErr.NewError(etcdErr.EcodeKeyNotFound, path.Join(parent.Path, name), s.CurrentIndex)
-	}
-
-	f, err := s.walk(nodePath, walkFunc)
-
-	if err != nil {
-		return nil, err
-	}
-	return f, nil
-}
-
-// DeleteExpiredKeys will delete all expired keys
-func (s *store) DeleteExpiredKeys(cutoff time.Time) {
-	s.worldLock.Lock()
-	defer s.worldLock.Unlock()
-
-	for {
-		node := s.ttlKeyHeap.top()
-		if node == nil || node.ExpireTime.After(cutoff) {
-			break
-		}
-
-		s.CurrentIndex++
-		e := newEvent(Expire, node.Path, s.CurrentIndex, node.CreatedIndex)
-		e.EtcdIndex = s.CurrentIndex
-		e.PrevNode = node.Repr(false, false, s.clock)
-		if node.IsDir() {
-			e.Node.Dir = true
-		}
-
-		callback := func(path string) { // notify function
-			// notify the watchers with deleted set true
-			s.WatcherHub.notifyWatchers(e, path, true)
-		}
-
-		s.ttlKeyHeap.pop()
-		node.Remove(true, true, callback)
-
-		reportExpiredKey()
-		s.Stats.Inc(ExpireCount)
-
-		s.WatcherHub.notify(e)
-	}
-
-}
-
-// checkDir will check whether the component is a directory under parent node.
-// If it is a directory, this function will return the pointer to that node.
-// If it does not exist, this function will create a new directory and return the pointer to that node.
-// If it is a file, this function will return error.
-func (s *store) checkDir(parent *node, dirName string) (*node, *etcdErr.Error) {
-	node, ok := parent.Children[dirName]
-
-	if ok {
-		if node.IsDir() {
-			return node, nil
-		}
-
-		return nil, etcdErr.NewError(etcdErr.EcodeNotDir, node.Path, s.CurrentIndex)
-	}
-
-	n := newDir(s, path.Join(parent.Path, dirName), s.CurrentIndex+1, parent, Permanent)
-
-	parent.Children[dirName] = n
-
-	return n, nil
-}
-
-// Save saves the static state of the store system.
-// It will not be able to save the state of watchers.
-// It will not save the parent field of the node. Or there will
-// be cyclic dependencies issue for the json package.
-func (s *store) Save() ([]byte, error) {
-	b, err := json.Marshal(s.Clone())
-	if err != nil {
-		return nil, err
-	}
-
-	return b, nil
-}
-
-func (s *store) SaveNoCopy() ([]byte, error) {
-	b, err := json.Marshal(s)
-	if err != nil {
-		return nil, err
-	}
-
-	return b, nil
-}
-
-func (s *store) Clone() Store {
-	s.worldLock.Lock()
-
-	clonedStore := newStore()
-	clonedStore.CurrentIndex = s.CurrentIndex
-	clonedStore.Root = s.Root.Clone()
-	clonedStore.WatcherHub = s.WatcherHub.clone()
-	clonedStore.Stats = s.Stats.clone()
-	clonedStore.CurrentVersion = s.CurrentVersion
-
-	s.worldLock.Unlock()
-	return clonedStore
-}
-
-// Recovery recovers the store system from a static state
-// It needs to recover the parent field of the nodes.
-// It needs to delete the expired nodes since the saved time and also
-// needs to create monitoring go routines.
-func (s *store) Recovery(state []byte) error {
-	s.worldLock.Lock()
-	defer s.worldLock.Unlock()
-	err := json.Unmarshal(state, s)
-
-	if err != nil {
-		return err
-	}
-
-	s.ttlKeyHeap = newTtlKeyHeap()
-
-	s.Root.recoverAndclean()
-	return nil
-}
-
-func (s *store) JsonStats() []byte {
-	s.Stats.Watchers = uint64(s.WatcherHub.count)
-	return s.Stats.toJson()
-}
-
-func (s *store) HasTTLKeys() bool {
-	s.worldLock.RLock()
-	defer s.worldLock.RUnlock()
-	return s.ttlKeyHeap.Len() != 0
-}
diff --git a/store/store_bench_test.go b/store/store_bench_test.go
deleted file mode 100644
index f84309c..0000000
--- a/store/store_bench_test.go
+++ /dev/null
@@ -1,218 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"encoding/json"
-	"fmt"
-	"runtime"
-	"testing"
-)
-
-func BenchmarkStoreSet128Bytes(b *testing.B) {
-	benchStoreSet(b, 128, nil)
-}
-
-func BenchmarkStoreSet1024Bytes(b *testing.B) {
-	benchStoreSet(b, 1024, nil)
-}
-
-func BenchmarkStoreSet4096Bytes(b *testing.B) {
-	benchStoreSet(b, 4096, nil)
-}
-
-func BenchmarkStoreSetWithJson128Bytes(b *testing.B) {
-	benchStoreSet(b, 128, json.Marshal)
-}
-
-func BenchmarkStoreSetWithJson1024Bytes(b *testing.B) {
-	benchStoreSet(b, 1024, json.Marshal)
-}
-
-func BenchmarkStoreSetWithJson4096Bytes(b *testing.B) {
-	benchStoreSet(b, 4096, json.Marshal)
-}
-
-func BenchmarkStoreDelete(b *testing.B) {
-	b.StopTimer()
-
-	s := newStore()
-	kvs, _ := generateNRandomKV(b.N, 128)
-
-	memStats := new(runtime.MemStats)
-	runtime.GC()
-	runtime.ReadMemStats(memStats)
-
-	for i := 0; i < b.N; i++ {
-		_, err := s.Set(kvs[i][0], false, kvs[i][1], TTLOptionSet{ExpireTime: Permanent})
-		if err != nil {
-			panic(err)
-		}
-	}
-
-	setMemStats := new(runtime.MemStats)
-	runtime.GC()
-	runtime.ReadMemStats(setMemStats)
-
-	b.StartTimer()
-
-	for i := range kvs {
-		s.Delete(kvs[i][0], false, false)
-	}
-
-	b.StopTimer()
-
-	// clean up
-	e, err := s.Get("/", false, false)
-	if err != nil {
-		panic(err)
-	}
-
-	for _, n := range e.Node.Nodes {
-		_, err := s.Delete(n.Key, true, true)
-		if err != nil {
-			panic(err)
-		}
-	}
-	s.WatcherHub.EventHistory = nil
-
-	deleteMemStats := new(runtime.MemStats)
-	runtime.GC()
-	runtime.ReadMemStats(deleteMemStats)
-
-	fmt.Printf("\nBefore set Alloc: %v; After set Alloc: %v, After delete Alloc: %v\n",
-		memStats.Alloc/1000, setMemStats.Alloc/1000, deleteMemStats.Alloc/1000)
-}
-
-func BenchmarkWatch(b *testing.B) {
-	b.StopTimer()
-	s := newStore()
-	kvs, _ := generateNRandomKV(b.N, 128)
-	b.StartTimer()
-
-	memStats := new(runtime.MemStats)
-	runtime.GC()
-	runtime.ReadMemStats(memStats)
-
-	for i := 0; i < b.N; i++ {
-		w, _ := s.Watch(kvs[i][0], false, false, 0)
-
-		e := newEvent("set", kvs[i][0], uint64(i+1), uint64(i+1))
-		s.WatcherHub.notify(e)
-		<-w.EventChan()
-		s.CurrentIndex++
-	}
-
-	s.WatcherHub.EventHistory = nil
-	afterMemStats := new(runtime.MemStats)
-	runtime.GC()
-	runtime.ReadMemStats(afterMemStats)
-	fmt.Printf("\nBefore Alloc: %v; After Alloc: %v\n",
-		memStats.Alloc/1000, afterMemStats.Alloc/1000)
-}
-
-func BenchmarkWatchWithSet(b *testing.B) {
-	b.StopTimer()
-	s := newStore()
-	kvs, _ := generateNRandomKV(b.N, 128)
-	b.StartTimer()
-
-	for i := 0; i < b.N; i++ {
-		w, _ := s.Watch(kvs[i][0], false, false, 0)
-
-		s.Set(kvs[i][0], false, "test", TTLOptionSet{ExpireTime: Permanent})
-		<-w.EventChan()
-	}
-}
-
-func BenchmarkWatchWithSetBatch(b *testing.B) {
-	b.StopTimer()
-	s := newStore()
-	kvs, _ := generateNRandomKV(b.N, 128)
-	b.StartTimer()
-
-	watchers := make([]Watcher, b.N)
-
-	for i := 0; i < b.N; i++ {
-		watchers[i], _ = s.Watch(kvs[i][0], false, false, 0)
-	}
-
-	for i := 0; i < b.N; i++ {
-		s.Set(kvs[i][0], false, "test", TTLOptionSet{ExpireTime: Permanent})
-	}
-
-	for i := 0; i < b.N; i++ {
-		<-watchers[i].EventChan()
-	}
-
-}
-
-func BenchmarkWatchOneKey(b *testing.B) {
-	s := newStore()
-	watchers := make([]Watcher, b.N)
-
-	for i := 0; i < b.N; i++ {
-		watchers[i], _ = s.Watch("/foo", false, false, 0)
-	}
-
-	s.Set("/foo", false, "", TTLOptionSet{ExpireTime: Permanent})
-
-	for i := 0; i < b.N; i++ {
-		<-watchers[i].EventChan()
-	}
-}
-
-func benchStoreSet(b *testing.B, valueSize int, process func(interface{}) ([]byte, error)) {
-	s := newStore()
-	b.StopTimer()
-	kvs, size := generateNRandomKV(b.N, valueSize)
-	b.StartTimer()
-
-	for i := 0; i < b.N; i++ {
-		resp, err := s.Set(kvs[i][0], false, kvs[i][1], TTLOptionSet{ExpireTime: Permanent})
-		if err != nil {
-			panic(err)
-		}
-
-		if process != nil {
-			_, err = process(resp)
-			if err != nil {
-				panic(err)
-			}
-		}
-	}
-
-	b.StopTimer()
-	memStats := new(runtime.MemStats)
-	runtime.GC()
-	runtime.ReadMemStats(memStats)
-	fmt.Printf("\nAlloc: %vKB; Data: %vKB; Kvs: %v; Alloc/Data:%v\n",
-		memStats.Alloc/1000, size/1000, b.N, memStats.Alloc/size)
-}
-
-func generateNRandomKV(n int, valueSize int) ([][]string, uint64) {
-	var size uint64
-	kvs := make([][]string, n)
-	bytes := make([]byte, valueSize)
-
-	for i := 0; i < n; i++ {
-		kvs[i] = make([]string, 2)
-		kvs[i][0] = fmt.Sprintf("/%010d/%010d/%010d", n, n, n)
-		kvs[i][1] = string(bytes)
-		size = size + uint64(len(kvs[i][0])) + uint64(len(kvs[i][1]))
-	}
-
-	return kvs, size
-}
diff --git a/store/store_test.go b/store/store_test.go
deleted file mode 100644
index 44f72ef..0000000
--- a/store/store_test.go
+++ /dev/null
@@ -1,862 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store_test
-
-import (
-	"testing"
-	"time"
-
-	etcdErr "github.com/coreos/etcd/error"
-	"github.com/coreos/etcd/pkg/testutil"
-	"github.com/coreos/etcd/store"
-)
-
-type StoreCloser interface {
-	store.Store
-	Close()
-}
-
-func TestNewStoreWithNamespaces(t *testing.T) {
-	s := newTestStore(t, "/0", "/1")
-	defer s.Close()
-
-	_, err := s.Get("/0", false, false)
-	testutil.AssertNil(t, err)
-	_, err = s.Get("/1", false, false)
-	testutil.AssertNil(t, err)
-}
-
-// Ensure that the store can retrieve an existing value.
-func TestStoreGetValue(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	var eidx uint64 = 1
-	e, err := s.Get("/foo", false, false)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "get")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
-}
-
-// Ensure that the store can retrieve a directory in sorted order.
-func TestStoreGetSorted(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	s.Create("/foo/x", false, "0", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	s.Create("/foo/z", false, "0", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	s.Create("/foo/y", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	s.Create("/foo/y/a", false, "0", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	s.Create("/foo/y/b", false, "0", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	var eidx uint64 = 6
-	e, err := s.Get("/foo", true, true)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-
-	var yNodes store.NodeExterns
-	sortedStrings := []string{"/foo/x", "/foo/y", "/foo/z"}
-	for i := range e.Node.Nodes {
-		node := e.Node.Nodes[i]
-		if node.Key != sortedStrings[i] {
-			t.Errorf("expect key = %s, got key = %s", sortedStrings[i], node.Key)
-		}
-		if node.Key == "/foo/y" {
-			yNodes = node.Nodes
-		}
-	}
-
-	sortedStrings = []string{"/foo/y/a", "/foo/y/b"}
-	for i := range yNodes {
-		node := yNodes[i]
-		if node.Key != sortedStrings[i] {
-			t.Errorf("expect key = %s, got key = %s", sortedStrings[i], node.Key)
-		}
-	}
-}
-
-func TestSet(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	// Set /foo=""
-	var eidx uint64 = 1
-	e, err := s.Set("/foo", false, "", store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "set")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "")
-	testutil.AssertNil(t, e.Node.Nodes)
-	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(1))
-
-	// Set /foo="bar"
-	eidx = 2
-	e, err = s.Set("/foo", false, "bar", store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "set")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
-	testutil.AssertNil(t, e.Node.Nodes)
-	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(2))
-	// check prevNode
-	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
-	// Set /foo="baz" (for testing prevNode)
-	eidx = 3
-	e, err = s.Set("/foo", false, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "set")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	testutil.AssertNil(t, e.Node.Nodes)
-	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(3))
-	// check prevNode
-	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(2))
-
-	// Set /dir as a directory
-	eidx = 4
-	e, err = s.Set("/dir", true, "", store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "set")
-	testutil.AssertEqual(t, e.Node.Key, "/dir")
-	testutil.AssertTrue(t, e.Node.Dir)
-	testutil.AssertNil(t, e.Node.Value)
-	testutil.AssertNil(t, e.Node.Nodes)
-	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(4))
-}
-
-// Ensure that the store can create a new key if it doesn't already exist.
-func TestStoreCreateValue(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	// Create /foo=bar
-	var eidx uint64 = 1
-	e, err := s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
-	testutil.AssertNil(t, e.Node.Nodes)
-	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(1))
-
-	// Create /empty=""
-	eidx = 2
-	e, err = s.Create("/empty", false, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/empty")
-	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "")
-	testutil.AssertNil(t, e.Node.Nodes)
-	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(2))
-
-}
-
-// Ensure that the store can create a new directory if it doesn't already exist.
-func TestStoreCreateDirectory(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	var eidx uint64 = 1
-	e, err := s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertTrue(t, e.Node.Dir)
-}
-
-// Ensure that the store fails to create a key if it already exists.
-func TestStoreCreateFailsIfExists(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	// create /foo as dir
-	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-
-	// create /foo as dir again
-	e, _err := s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	err := _err.(*etcdErr.Error)
-	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeNodeExist)
-	testutil.AssertEqual(t, err.Message, "Key already exists")
-	testutil.AssertEqual(t, err.Cause, "/foo")
-	testutil.AssertEqual(t, err.Index, uint64(1))
-	testutil.AssertNil(t, e)
-}
-
-// Ensure that the store can update a key if it already exists.
-func TestStoreUpdateValue(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	// create /foo=bar
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	// update /foo="bzr"
-	var eidx uint64 = 2
-	e, err := s.Update("/foo", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(2))
-	// check prevNode
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.TTL, int64(0))
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
-
-	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-
-	// update /foo=""
-	eidx = 3
-	e, err = s.Update("/foo", "", store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "")
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(3))
-	// check prevNode
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "baz")
-	testutil.AssertEqual(t, e.PrevNode.TTL, int64(0))
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(2))
-
-	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, *e.Node.Value, "")
-}
-
-// Ensure that the store cannot update a directory.
-func TestStoreUpdateFailsIfDirectory(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e, _err := s.Update("/foo", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	err := _err.(*etcdErr.Error)
-	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeNotFile)
-	testutil.AssertEqual(t, err.Message, "Not a file")
-	testutil.AssertEqual(t, err.Cause, "/foo")
-	testutil.AssertNil(t, e)
-}
-
-// Ensure that the store can delete a value.
-func TestStoreDeleteValue(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	var eidx uint64 = 2
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e, err := s.Delete("/foo", false, false)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "delete")
-	// check prevNode
-	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-}
-
-// Ensure that the store can delete a directory if recursive is specified.
-func TestStoreDeleteDirectory(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	// create directory /foo
-	var eidx uint64 = 2
-	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	// delete /foo with dir = true and recursive = false
-	// this should succeed, since the directory is empty
-	e, err := s.Delete("/foo", true, false)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "delete")
-	// check prevNode
-	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, e.PrevNode.Dir, true)
-
-	// create directory /foo and directory /foo/bar
-	_, err = s.Create("/foo/bar", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	// delete /foo with dir = true and recursive = false
-	// this should fail, since the directory is not empty
-	_, err = s.Delete("/foo", true, false)
-	testutil.AssertNotNil(t, err)
-
-	// delete /foo with dir=false and recursive = true
-	// this should succeed, since recursive implies dir=true
-	// and recursively delete should be able to delete all
-	// items under the given directory
-	e, err = s.Delete("/foo", false, true)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.Action, "delete")
-
-}
-
-// Ensure that the store cannot delete a directory if both of recursive
-// and dir are not specified.
-func TestStoreDeleteDirectoryFailsIfNonRecursiveAndDir(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e, _err := s.Delete("/foo", false, false)
-	err := _err.(*etcdErr.Error)
-	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeNotFile)
-	testutil.AssertEqual(t, err.Message, "Not a file")
-	testutil.AssertNil(t, e)
-}
-
-func TestRootRdOnly(t *testing.T) {
-	s := newTestStore(t, "/0")
-	defer s.Close()
-
-	for _, tt := range []string{"/", "/0"} {
-		_, err := s.Set(tt, true, "", store.TTLOptionSet{ExpireTime: store.Permanent})
-		testutil.AssertNotNil(t, err)
-
-		_, err = s.Delete(tt, true, true)
-		testutil.AssertNotNil(t, err)
-
-		_, err = s.Create(tt, true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-		testutil.AssertNotNil(t, err)
-
-		_, err = s.Update(tt, "", store.TTLOptionSet{ExpireTime: store.Permanent})
-		testutil.AssertNotNil(t, err)
-
-		_, err = s.CompareAndSwap(tt, "", 0, "", store.TTLOptionSet{ExpireTime: store.Permanent})
-		testutil.AssertNotNil(t, err)
-	}
-}
-
-func TestStoreCompareAndDeletePrevValue(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	var eidx uint64 = 2
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e, err := s.CompareAndDelete("/foo", "bar", 0)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndDelete")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-
-	// check prevNode
-	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
-	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
-}
-
-func TestStoreCompareAndDeletePrevValueFailsIfNotMatch(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	var eidx uint64 = 1
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e, _err := s.CompareAndDelete("/foo", "baz", 0)
-	err := _err.(*etcdErr.Error)
-	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeTestFailed)
-	testutil.AssertEqual(t, err.Message, "Compare failed")
-	testutil.AssertNil(t, e)
-	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
-}
-
-func TestStoreCompareAndDeletePrevIndex(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	var eidx uint64 = 2
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e, err := s.CompareAndDelete("/foo", "", 1)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndDelete")
-	// check prevNode
-	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
-	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
-}
-
-func TestStoreCompareAndDeletePrevIndexFailsIfNotMatch(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	var eidx uint64 = 1
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e, _err := s.CompareAndDelete("/foo", "", 100)
-	testutil.AssertNotNil(t, _err)
-	err := _err.(*etcdErr.Error)
-	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeTestFailed)
-	testutil.AssertEqual(t, err.Message, "Compare failed")
-	testutil.AssertNil(t, e)
-	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
-}
-
-// Ensure that the store cannot delete a directory.
-func TestStoreCompareAndDeleteDirectoryFail(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	_, _err := s.CompareAndDelete("/foo", "", 0)
-	testutil.AssertNotNil(t, _err)
-	err := _err.(*etcdErr.Error)
-	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeNotFile)
-}
-
-// Ensure that the store can conditionally update a key if it has a previous value.
-func TestStoreCompareAndSwapPrevValue(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-
-	var eidx uint64 = 2
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e, err := s.CompareAndSwap("/foo", "bar", 0, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndSwap")
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	// check prevNode
-	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
-	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
-
-	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-}
-
-// Ensure that the store cannot conditionally update a key if it has the wrong previous value.
-func TestStoreCompareAndSwapPrevValueFailsIfNotMatch(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 1
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e, _err := s.CompareAndSwap("/foo", "wrong_value", 0, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	err := _err.(*etcdErr.Error)
-	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeTestFailed)
-	testutil.AssertEqual(t, err.Message, "Compare failed")
-	testutil.AssertNil(t, e)
-	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-}
-
-// Ensure that the store can conditionally update a key if it has a previous index.
-func TestStoreCompareAndSwapPrevIndex(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 2
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e, err := s.CompareAndSwap("/foo", "", 1, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndSwap")
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	// check prevNode
-	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
-	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
-
-	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-}
-
-// Ensure that the store cannot conditionally update a key if it has the wrong previous index.
-func TestStoreCompareAndSwapPrevIndexFailsIfNotMatch(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 1
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e, _err := s.CompareAndSwap("/foo", "", 100, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	err := _err.(*etcdErr.Error)
-	testutil.AssertEqual(t, err.ErrorCode, etcdErr.EcodeTestFailed)
-	testutil.AssertEqual(t, err.Message, "Compare failed")
-	testutil.AssertNil(t, e)
-	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
-}
-
-// Ensure that the store can watch for key creation.
-func TestStoreWatchCreate(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 0
-	w, _ := s.Watch("/foo", false, false, 0)
-	c := w.EventChan()
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	eidx = 1
-	e := timeoutSelect(t, c)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	select {
-	case e = <-w.EventChan():
-		testutil.AssertNil(t, e)
-	case <-time.After(100 * time.Millisecond):
-	}
-}
-
-// Ensure that the store can watch for recursive key creation.
-func TestStoreWatchRecursiveCreate(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 0
-	w, err := s.Watch("/foo", true, false, 0)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	eidx = 1
-	s.Create("/foo/bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
-}
-
-// Ensure that the store can watch for key updates.
-func TestStoreWatchUpdate(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 1
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	w, _ := s.Watch("/foo", false, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	eidx = 2
-	s.Update("/foo", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-}
-
-// Ensure that the store can watch for recursive key updates.
-func TestStoreWatchRecursiveUpdate(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 1
-	s.Create("/foo/bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	w, err := s.Watch("/foo", true, false, 0)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	eidx = 2
-	s.Update("/foo/bar", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
-}
-
-// Ensure that the store can watch for key deletions.
-func TestStoreWatchDelete(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 1
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	w, _ := s.Watch("/foo", false, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	eidx = 2
-	s.Delete("/foo", false, false)
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "delete")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-}
-
-// Ensure that the store can watch for recursive key deletions.
-func TestStoreWatchRecursiveDelete(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 1
-	s.Create("/foo/bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	w, err := s.Watch("/foo", true, false, 0)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	eidx = 2
-	s.Delete("/foo/bar", false, false)
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "delete")
-	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
-}
-
-// Ensure that the store can watch for CAS updates.
-func TestStoreWatchCompareAndSwap(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 1
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	w, _ := s.Watch("/foo", false, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	eidx = 2
-	s.CompareAndSwap("/foo", "bar", 0, "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndSwap")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-}
-
-// Ensure that the store can watch for recursive CAS updates.
-func TestStoreWatchRecursiveCompareAndSwap(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 1
-	s.Create("/foo/bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	w, _ := s.Watch("/foo", true, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	eidx = 2
-	s.CompareAndSwap("/foo/bar", "baz", 0, "bat", store.TTLOptionSet{ExpireTime: store.Permanent})
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndSwap")
-	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
-}
-
-// Ensure that the store can watch in streaming mode.
-func TestStoreWatchStream(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 1
-	w, _ := s.Watch("/foo", false, true, 0)
-	// first modification
-	s.Create("/foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
-	select {
-	case e = <-w.EventChan():
-		testutil.AssertNil(t, e)
-	case <-time.After(100 * time.Millisecond):
-	}
-	// second modification
-	eidx = 2
-	s.Update("/foo", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	e = timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	select {
-	case e = <-w.EventChan():
-		testutil.AssertNil(t, e)
-	case <-time.After(100 * time.Millisecond):
-	}
-}
-
-// Ensure that the store can watch for hidden keys as long as it's an exact path match.
-func TestStoreWatchCreateWithHiddenKey(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 1
-	w, _ := s.Watch("/_foo", false, false, 0)
-	s.Create("/_foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/_foo")
-	select {
-	case e = <-w.EventChan():
-		testutil.AssertNil(t, e)
-	case <-time.After(100 * time.Millisecond):
-	}
-}
-
-// Ensure that the store doesn't see hidden key creates without an exact path match in recursive mode.
-func TestStoreWatchRecursiveCreateWithHiddenKey(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	w, _ := s.Watch("/foo", true, false, 0)
-	s.Create("/foo/_bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	e := nbselect(w.EventChan())
-	testutil.AssertNil(t, e)
-	w, _ = s.Watch("/foo", true, false, 0)
-	s.Create("/foo/_baz", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	select {
-	case e = <-w.EventChan():
-		testutil.AssertNil(t, e)
-	case <-time.After(100 * time.Millisecond):
-	}
-	s.Create("/foo/_baz/quux", false, "quux", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	select {
-	case e = <-w.EventChan():
-		testutil.AssertNil(t, e)
-	case <-time.After(100 * time.Millisecond):
-	}
-}
-
-// Ensure that the store doesn't see hidden key updates.
-func TestStoreWatchUpdateWithHiddenKey(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	s.Create("/_foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	w, _ := s.Watch("/_foo", false, false, 0)
-	s.Update("/_foo", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/_foo")
-	e = nbselect(w.EventChan())
-	testutil.AssertNil(t, e)
-}
-
-// Ensure that the store doesn't see hidden key updates without an exact path match in recursive mode.
-func TestStoreWatchRecursiveUpdateWithHiddenKey(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	s.Create("/foo/_bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	w, _ := s.Watch("/foo", true, false, 0)
-	s.Update("/foo/_bar", "baz", store.TTLOptionSet{ExpireTime: store.Permanent})
-	e := nbselect(w.EventChan())
-	testutil.AssertNil(t, e)
-}
-
-// Ensure that the store can watch for key deletions.
-func TestStoreWatchDeleteWithHiddenKey(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 2
-	s.Create("/_foo", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	w, _ := s.Watch("/_foo", false, false, 0)
-	s.Delete("/_foo", false, false)
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "delete")
-	testutil.AssertEqual(t, e.Node.Key, "/_foo")
-	e = nbselect(w.EventChan())
-	testutil.AssertNil(t, e)
-}
-
-// Ensure that the store doesn't see hidden key deletes without an exact path match in recursive mode.
-func TestStoreWatchRecursiveDeleteWithHiddenKey(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	s.Create("/foo/_bar", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	w, _ := s.Watch("/foo", true, false, 0)
-	s.Delete("/foo/_bar", false, false)
-	e := nbselect(w.EventChan())
-	testutil.AssertNil(t, e)
-}
-
-// Ensure that the store does see hidden key creates if watching deeper than a hidden key in recursive mode.
-func TestStoreWatchRecursiveCreateDeeperThanHiddenKey(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 1
-	w, _ := s.Watch("/_foo/bar", true, false, 0)
-	s.Create("/_foo/bar/baz", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-
-	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertNotNil(t, e)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/_foo/bar/baz")
-}
-
-// Ensure that slow consumers are handled properly.
-//
-// Since Watcher.EventChan() has a buffer of size 100 we can only queue 100
-// event per watcher. If the consumer cannot consume the event on time and
-// another event arrives, the channel is closed and event is discarded.
-// This test ensures that after closing the channel, the store can continue
-// to operate correctly.
-func TestStoreWatchSlowConsumer(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	s.Watch("/foo", true, true, 0) // stream must be true
-	// Fill watch channel with 100 events
-	for i := 1; i <= 100; i++ {
-		s.Set("/foo", false, string(i), store.TTLOptionSet{ExpireTime: store.Permanent}) // ok
-	}
-	// testutil.AssertEqual(t, s.WatcherHub.count, int64(1))
-	s.Set("/foo", false, "101", store.TTLOptionSet{ExpireTime: store.Permanent}) // ok
-	// remove watcher
-	// testutil.AssertEqual(t, s.WatcherHub.count, int64(0))
-	s.Set("/foo", false, "102", store.TTLOptionSet{ExpireTime: store.Permanent}) // must not panic
-}
-
-// Performs a non-blocking select on an event channel.
-func nbselect(c <-chan *store.Event) *store.Event {
-	select {
-	case e := <-c:
-		return e
-	default:
-		return nil
-	}
-}
-
-// Performs a non-blocking select on an event channel.
-func timeoutSelect(t *testing.T, c <-chan *store.Event) *store.Event {
-	select {
-	case e := <-c:
-		return e
-	case <-time.After(time.Second):
-		t.Errorf("timed out waiting on event")
-		return nil
-	}
-}
diff --git a/store/store_ttl_test.go b/store/store_ttl_test.go
deleted file mode 100644
index 89d76e7..0000000
--- a/store/store_ttl_test.go
+++ /dev/null
@@ -1,360 +0,0 @@
-// Copyright 2017 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"testing"
-	"time"
-
-	etcdErr "github.com/coreos/etcd/error"
-	"github.com/coreos/etcd/pkg/testutil"
-	"github.com/jonboulle/clockwork"
-)
-
-// Ensure that any TTL <= minExpireTime becomes Permanent
-func TestMinExpireTime(t *testing.T) {
-	s := newStore()
-	fc := clockwork.NewFakeClock()
-	s.clock = fc
-	// FakeClock starts at 0, so minExpireTime should be far in the future.. but just in case
-	testutil.AssertTrue(t, minExpireTime.After(fc.Now()), "minExpireTime should be ahead of FakeClock!")
-	s.Create("/foo", false, "Y", false, TTLOptionSet{ExpireTime: fc.Now().Add(3 * time.Second)})
-	fc.Advance(5 * time.Second)
-	// Ensure it hasn't expired
-	s.DeleteExpiredKeys(fc.Now())
-	var eidx uint64 = 1
-	e, err := s.Get("/foo", true, false)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "get")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-}
-
-// Ensure that the store can recursively retrieve a directory listing.
-// Note that hidden files should not be returned.
-func TestStoreGetDirectory(t *testing.T) {
-	s := newStore()
-	fc := newFakeClock()
-	s.clock = fc
-	s.Create("/foo", true, "", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Create("/foo/bar", false, "X", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Create("/foo/_hidden", false, "*", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Create("/foo/baz", true, "", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Create("/foo/baz/bat", false, "Y", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Create("/foo/baz/_hidden", false, "*", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Create("/foo/baz/ttl", false, "Y", false, TTLOptionSet{ExpireTime: fc.Now().Add(time.Second * 3)})
-	var eidx uint64 = 7
-	e, err := s.Get("/foo", true, false)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "get")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, len(e.Node.Nodes), 2)
-	var bazNodes NodeExterns
-	for _, node := range e.Node.Nodes {
-		switch node.Key {
-		case "/foo/bar":
-			testutil.AssertEqual(t, *node.Value, "X")
-			testutil.AssertEqual(t, node.Dir, false)
-		case "/foo/baz":
-			testutil.AssertEqual(t, node.Dir, true)
-			testutil.AssertEqual(t, len(node.Nodes), 2)
-			bazNodes = node.Nodes
-		default:
-			t.Errorf("key = %s, not matched", node.Key)
-		}
-	}
-	for _, node := range bazNodes {
-		switch node.Key {
-		case "/foo/baz/bat":
-			testutil.AssertEqual(t, *node.Value, "Y")
-			testutil.AssertEqual(t, node.Dir, false)
-		case "/foo/baz/ttl":
-			testutil.AssertEqual(t, *node.Value, "Y")
-			testutil.AssertEqual(t, node.Dir, false)
-			testutil.AssertEqual(t, node.TTL, int64(3))
-		default:
-			t.Errorf("key = %s, not matched", node.Key)
-		}
-	}
-}
-
-// Ensure that the store can update the TTL on a value.
-func TestStoreUpdateValueTTL(t *testing.T) {
-	s := newStore()
-	fc := newFakeClock()
-	s.clock = fc
-
-	var eidx uint64 = 2
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	_, err := s.Update("/foo", "baz", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
-	testutil.AssertNil(t, err)
-	e, _ := s.Get("/foo", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	fc.Advance(600 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-	e, err = s.Get("/foo", false, false)
-	testutil.AssertNil(t, e)
-	testutil.AssertEqual(t, err.(*etcdErr.Error).ErrorCode, etcdErr.EcodeKeyNotFound)
-}
-
-// Ensure that the store can update the TTL on a directory.
-func TestStoreUpdateDirTTL(t *testing.T) {
-	s := newStore()
-	fc := newFakeClock()
-	s.clock = fc
-
-	var eidx uint64 = 3
-	s.Create("/foo", true, "", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Create("/foo/bar", false, "baz", false, TTLOptionSet{ExpireTime: Permanent})
-	e, err := s.Update("/foo", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.Node.Dir, true)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	e, _ = s.Get("/foo/bar", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-
-	fc.Advance(600 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-	e, err = s.Get("/foo/bar", false, false)
-	testutil.AssertNil(t, e)
-	testutil.AssertEqual(t, err.(*etcdErr.Error).ErrorCode, etcdErr.EcodeKeyNotFound)
-}
-
-// Ensure that the store can watch for key expiration.
-func TestStoreWatchExpire(t *testing.T) {
-	s := newStore()
-	fc := newFakeClock()
-	s.clock = fc
-
-	var eidx uint64 = 3
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(400 * time.Millisecond)})
-	s.Create("/foofoo", false, "barbarbar", false, TTLOptionSet{ExpireTime: fc.Now().Add(450 * time.Millisecond)})
-	s.Create("/foodir", true, "", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
-
-	w, _ := s.Watch("/", true, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	c := w.EventChan()
-	e := nbselect(c)
-	testutil.AssertNil(t, e)
-	fc.Advance(600 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-	eidx = 4
-	e = nbselect(c)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	w, _ = s.Watch("/", true, false, 5)
-	eidx = 6
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	e = nbselect(w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foofoo")
-	w, _ = s.Watch("/", true, false, 6)
-	e = nbselect(w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foodir")
-	testutil.AssertEqual(t, e.Node.Dir, true)
-}
-
-// Ensure that the store can watch for key expiration when refreshing.
-func TestStoreWatchExpireRefresh(t *testing.T) {
-	s := newStore()
-	fc := newFakeClock()
-	s.clock = fc
-
-	var eidx uint64 = 2
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
-	s.Create("/foofoo", false, "barbarbar", false, TTLOptionSet{ExpireTime: fc.Now().Add(1200 * time.Millisecond), Refresh: true})
-
-	// Make sure we set watch updates when Refresh is true for newly created keys
-	w, _ := s.Watch("/", true, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	c := w.EventChan()
-	e := nbselect(c)
-	testutil.AssertNil(t, e)
-	fc.Advance(600 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-	eidx = 3
-	e = nbselect(c)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-
-	s.Update("/foofoo", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
-	w, _ = s.Watch("/", true, false, 4)
-	fc.Advance(700 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-	eidx = 5 // We should skip 4 because a TTL update should occur with no watch notification if set `TTLOptionSet.Refresh` to true
-	testutil.AssertEqual(t, w.StartIndex(), eidx-1)
-	e = nbselect(w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foofoo")
-}
-
-// Ensure that the store can watch for key expiration when refreshing with an empty value.
-func TestStoreWatchExpireEmptyRefresh(t *testing.T) {
-	s := newStore()
-	fc := newFakeClock()
-	s.clock = fc
-
-	var eidx uint64
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
-	// Should be no-op
-	fc.Advance(200 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-
-	s.Update("/foo", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
-	w, _ := s.Watch("/", true, false, 2)
-	fc.Advance(700 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-	eidx = 3 // We should skip 2 because a TTL update should occur with no watch notification if set `TTLOptionSet.Refresh` to true
-	testutil.AssertEqual(t, w.StartIndex(), eidx-1)
-	e := nbselect(w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-}
-
-// Update TTL of a key (set TTLOptionSet.Refresh to false) and send notification
-func TestStoreWatchNoRefresh(t *testing.T) {
-	s := newStore()
-	fc := newFakeClock()
-	s.clock = fc
-
-	var eidx uint64
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
-	// Should be no-op
-	fc.Advance(200 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-
-	// Update key's TTL with setting `TTLOptionSet.Refresh` to false will cause an update event
-	s.Update("/foo", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: false})
-	w, _ := s.Watch("/", true, false, 2)
-	fc.Advance(700 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-	eidx = 2
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
-	e := nbselect(w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-}
-
-// Ensure that the store can update the TTL on a value with refresh.
-func TestStoreRefresh(t *testing.T) {
-	s := newStore()
-	fc := newFakeClock()
-	s.clock = fc
-
-	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
-	s.Create("/bar", true, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
-	_, err := s.Update("/foo", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
-	testutil.AssertNil(t, err)
-
-	_, err = s.Set("/foo", false, "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
-	testutil.AssertNil(t, err)
-
-	_, err = s.Update("/bar", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
-	testutil.AssertNil(t, err)
-
-	_, err = s.CompareAndSwap("/foo", "bar", 0, "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
-	testutil.AssertNil(t, err)
-}
-
-// Ensure that the store can recover from a previously saved state that includes an expiring key.
-func TestStoreRecoverWithExpiration(t *testing.T) {
-	s := newStore()
-	s.clock = newFakeClock()
-
-	fc := newFakeClock()
-
-	var eidx uint64 = 4
-	s.Create("/foo", true, "", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Create("/foo/x", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	s.Create("/foo/y", false, "baz", false, TTLOptionSet{ExpireTime: fc.Now().Add(5 * time.Millisecond)})
-	b, err := s.Save()
-	testutil.AssertNil(t, err)
-
-	time.Sleep(10 * time.Millisecond)
-
-	s2 := newStore()
-	s2.clock = fc
-
-	s2.Recovery(b)
-
-	fc.Advance(600 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-
-	e, err := s.Get("/foo/x", false, false)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
-
-	e, err = s.Get("/foo/y", false, false)
-	testutil.AssertNotNil(t, err)
-	testutil.AssertNil(t, e)
-}
-
-// Ensure that the store doesn't see expirations of hidden keys.
-func TestStoreWatchExpireWithHiddenKey(t *testing.T) {
-	s := newStore()
-	fc := newFakeClock()
-	s.clock = fc
-
-	s.Create("/_foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
-	s.Create("/foofoo", false, "barbarbar", false, TTLOptionSet{ExpireTime: fc.Now().Add(1000 * time.Millisecond)})
-
-	w, _ := s.Watch("/", true, false, 0)
-	c := w.EventChan()
-	e := nbselect(c)
-	testutil.AssertNil(t, e)
-	fc.Advance(600 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-	e = nbselect(c)
-	testutil.AssertNil(t, e)
-	fc.Advance(600 * time.Millisecond)
-	s.DeleteExpiredKeys(fc.Now())
-	e = nbselect(c)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foofoo")
-}
-
-// newFakeClock creates a new FakeClock that has been advanced to at least minExpireTime
-func newFakeClock() clockwork.FakeClock {
-	fc := clockwork.NewFakeClock()
-	for minExpireTime.After(fc.Now()) {
-		fc.Advance((0x1 << 62) * time.Nanosecond)
-	}
-	return fc
-}
-
-// Performs a non-blocking select on an event channel.
-func nbselect(c <-chan *Event) *Event {
-	select {
-	case e := <-c:
-		return e
-	default:
-		return nil
-	}
-}
diff --git a/store/store_v2_test.go b/store/store_v2_test.go
deleted file mode 100644
index 2956981..0000000
--- a/store/store_v2_test.go
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright 2017 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// +build !v2v3
-
-package store_test
-
-import (
-	"testing"
-
-	"github.com/coreos/etcd/pkg/testutil"
-	"github.com/coreos/etcd/store"
-)
-
-type v2TestStore struct {
-	store.Store
-}
-
-func (s *v2TestStore) Close() {}
-
-func newTestStore(t *testing.T, ns ...string) StoreCloser {
-	return &v2TestStore{store.New(ns...)}
-}
-
-// Ensure that the store can recover from a previously saved state.
-func TestStoreRecover(t *testing.T) {
-	s := newTestStore(t)
-	defer s.Close()
-	var eidx uint64 = 4
-	s.Create("/foo", true, "", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	s.Create("/foo/x", false, "bar", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	s.Update("/foo/x", "barbar", store.TTLOptionSet{ExpireTime: store.Permanent})
-	s.Create("/foo/y", false, "baz", false, store.TTLOptionSet{ExpireTime: store.Permanent})
-	b, err := s.Save()
-	testutil.AssertNil(t, err)
-
-	s2 := newTestStore(t)
-	s2.Recovery(b)
-
-	e, err := s.Get("/foo/x", false, false)
-	testutil.AssertEqual(t, e.Node.CreatedIndex, uint64(2))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(3))
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, *e.Node.Value, "barbar")
-
-	e, err = s.Get("/foo/y", false, false)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-}
diff --git a/store/store_v2v3_test.go b/store/store_v2v3_test.go
deleted file mode 100644
index 323c109..0000000
--- a/store/store_v2v3_test.go
+++ /dev/null
@@ -1,52 +0,0 @@
-// Copyright 2017 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// +build v2v3
-
-package store_test
-
-import (
-	"io/ioutil"
-	"testing"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/coreos/etcd/etcdserver/api/v2v3"
-	"github.com/coreos/etcd/integration"
-	"github.com/coreos/etcd/store"
-
-	"github.com/coreos/pkg/capnslog"
-	"google.golang.org/grpc/grpclog"
-)
-
-func init() {
-	capnslog.SetGlobalLogLevel(capnslog.CRITICAL)
-	clientv3.SetLogger(grpclog.NewLoggerV2(ioutil.Discard, ioutil.Discard, ioutil.Discard))
-}
-
-type v2v3TestStore struct {
-	store.Store
-	clus *integration.ClusterV3
-	t    *testing.T
-}
-
-func (s *v2v3TestStore) Close() { s.clus.Terminate(s.t) }
-
-func newTestStore(t *testing.T, ns ...string) StoreCloser {
-	clus := integration.NewClusterV3(t, &integration.ClusterConfig{Size: 1})
-	return &v2v3TestStore{
-		v2v3.NewStore(clus.Client(0), "/v2/"),
-		clus,
-		t,
-	}
-}
diff --git a/store/ttl_key_heap.go b/store/ttl_key_heap.go
deleted file mode 100644
index 21ae9b7..0000000
--- a/store/ttl_key_heap.go
+++ /dev/null
@@ -1,99 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"container/heap"
-)
-
-// An TTLKeyHeap is a min-heap of TTLKeys order by expiration time
-type ttlKeyHeap struct {
-	array  []*node
-	keyMap map[*node]int
-}
-
-func newTtlKeyHeap() *ttlKeyHeap {
-	h := &ttlKeyHeap{keyMap: make(map[*node]int)}
-	heap.Init(h)
-	return h
-}
-
-func (h ttlKeyHeap) Len() int {
-	return len(h.array)
-}
-
-func (h ttlKeyHeap) Less(i, j int) bool {
-	return h.array[i].ExpireTime.Before(h.array[j].ExpireTime)
-}
-
-func (h ttlKeyHeap) Swap(i, j int) {
-	// swap node
-	h.array[i], h.array[j] = h.array[j], h.array[i]
-
-	// update map
-	h.keyMap[h.array[i]] = i
-	h.keyMap[h.array[j]] = j
-}
-
-func (h *ttlKeyHeap) Push(x interface{}) {
-	n, _ := x.(*node)
-	h.keyMap[n] = len(h.array)
-	h.array = append(h.array, n)
-}
-
-func (h *ttlKeyHeap) Pop() interface{} {
-	old := h.array
-	n := len(old)
-	x := old[n-1]
-	// Set slice element to nil, so GC can recycle the node.
-	// This is due to golang GC doesn't support partial recycling:
-	// https://github.com/golang/go/issues/9618
-	old[n-1] = nil
-	h.array = old[0 : n-1]
-	delete(h.keyMap, x)
-	return x
-}
-
-func (h *ttlKeyHeap) top() *node {
-	if h.Len() != 0 {
-		return h.array[0]
-	}
-	return nil
-}
-
-func (h *ttlKeyHeap) pop() *node {
-	x := heap.Pop(h)
-	n, _ := x.(*node)
-	return n
-}
-
-func (h *ttlKeyHeap) push(x interface{}) {
-	heap.Push(h, x)
-}
-
-func (h *ttlKeyHeap) update(n *node) {
-	index, ok := h.keyMap[n]
-	if ok {
-		heap.Remove(h, index)
-		heap.Push(h, n)
-	}
-}
-
-func (h *ttlKeyHeap) remove(n *node) {
-	index, ok := h.keyMap[n]
-	if ok {
-		heap.Remove(h, index)
-	}
-}
diff --git a/store/watcher.go b/store/watcher.go
deleted file mode 100644
index a236ec7..0000000
--- a/store/watcher.go
+++ /dev/null
@@ -1,95 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-type Watcher interface {
-	EventChan() chan *Event
-	StartIndex() uint64 // The EtcdIndex at which the Watcher was created
-	Remove()
-}
-
-type watcher struct {
-	eventChan  chan *Event
-	stream     bool
-	recursive  bool
-	sinceIndex uint64
-	startIndex uint64
-	hub        *watcherHub
-	removed    bool
-	remove     func()
-}
-
-func (w *watcher) EventChan() chan *Event {
-	return w.eventChan
-}
-
-func (w *watcher) StartIndex() uint64 {
-	return w.startIndex
-}
-
-// notify function notifies the watcher. If the watcher interests in the given path,
-// the function will return true.
-func (w *watcher) notify(e *Event, originalPath bool, deleted bool) bool {
-	// watcher is interested the path in three cases and under one condition
-	// the condition is that the event happens after the watcher's sinceIndex
-
-	// 1. the path at which the event happens is the path the watcher is watching at.
-	// For example if the watcher is watching at "/foo" and the event happens at "/foo",
-	// the watcher must be interested in that event.
-
-	// 2. the watcher is a recursive watcher, it interests in the event happens after
-	// its watching path. For example if watcher A watches at "/foo" and it is a recursive
-	// one, it will interest in the event happens at "/foo/bar".
-
-	// 3. when we delete a directory, we need to force notify all the watchers who watches
-	// at the file we need to delete.
-	// For example a watcher is watching at "/foo/bar". And we deletes "/foo". The watcher
-	// should get notified even if "/foo" is not the path it is watching.
-	if (w.recursive || originalPath || deleted) && e.Index() >= w.sinceIndex {
-		// We cannot block here if the eventChan capacity is full, otherwise
-		// etcd will hang. eventChan capacity is full when the rate of
-		// notifications are higher than our send rate.
-		// If this happens, we close the channel.
-		select {
-		case w.eventChan <- e:
-		default:
-			// We have missed a notification. Remove the watcher.
-			// Removing the watcher also closes the eventChan.
-			w.remove()
-		}
-		return true
-	}
-	return false
-}
-
-// Remove removes the watcher from watcherHub
-// The actual remove function is guaranteed to only be executed once
-func (w *watcher) Remove() {
-	w.hub.mutex.Lock()
-	defer w.hub.mutex.Unlock()
-
-	close(w.eventChan)
-	if w.remove != nil {
-		w.remove()
-	}
-}
-
-// nopWatcher is a watcher that receives nothing, always blocking.
-type nopWatcher struct{}
-
-func NewNopWatcher() Watcher                 { return &nopWatcher{} }
-func (w *nopWatcher) EventChan() chan *Event { return nil }
-func (w *nopWatcher) StartIndex() uint64     { return 0 }
-func (w *nopWatcher) Remove()                {}
diff --git a/store/watcher_hub.go b/store/watcher_hub.go
deleted file mode 100644
index 13c23e3..0000000
--- a/store/watcher_hub.go
+++ /dev/null
@@ -1,200 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"container/list"
-	"path"
-	"strings"
-	"sync"
-	"sync/atomic"
-
-	etcdErr "github.com/coreos/etcd/error"
-)
-
-// A watcherHub contains all subscribed watchers
-// watchers is a map with watched path as key and watcher as value
-// EventHistory keeps the old events for watcherHub. It is used to help
-// watcher to get a continuous event history. Or a watcher might miss the
-// event happens between the end of the first watch command and the start
-// of the second command.
-type watcherHub struct {
-	// count must be the first element to keep 64-bit alignment for atomic
-	// access
-
-	count int64 // current number of watchers.
-
-	mutex        sync.Mutex
-	watchers     map[string]*list.List
-	EventHistory *EventHistory
-}
-
-// newWatchHub creates a watcherHub. The capacity determines how many events we will
-// keep in the eventHistory.
-// Typically, we only need to keep a small size of history[smaller than 20K].
-// Ideally, it should smaller than 20K/s[max throughput] * 2 * 50ms[RTT] = 2000
-func newWatchHub(capacity int) *watcherHub {
-	return &watcherHub{
-		watchers:     make(map[string]*list.List),
-		EventHistory: newEventHistory(capacity),
-	}
-}
-
-// Watch function returns a Watcher.
-// If recursive is true, the first change after index under key will be sent to the event channel of the watcher.
-// If recursive is false, the first change after index at key will be sent to the event channel of the watcher.
-// If index is zero, watch will start from the current index + 1.
-func (wh *watcherHub) watch(key string, recursive, stream bool, index, storeIndex uint64) (Watcher, *etcdErr.Error) {
-	reportWatchRequest()
-	event, err := wh.EventHistory.scan(key, recursive, index)
-
-	if err != nil {
-		err.Index = storeIndex
-		return nil, err
-	}
-
-	w := &watcher{
-		eventChan:  make(chan *Event, 100), // use a buffered channel
-		recursive:  recursive,
-		stream:     stream,
-		sinceIndex: index,
-		startIndex: storeIndex,
-		hub:        wh,
-	}
-
-	wh.mutex.Lock()
-	defer wh.mutex.Unlock()
-	// If the event exists in the known history, append the EtcdIndex and return immediately
-	if event != nil {
-		ne := event.Clone()
-		ne.EtcdIndex = storeIndex
-		w.eventChan <- ne
-		return w, nil
-	}
-
-	l, ok := wh.watchers[key]
-
-	var elem *list.Element
-
-	if ok { // add the new watcher to the back of the list
-		elem = l.PushBack(w)
-	} else { // create a new list and add the new watcher
-		l = list.New()
-		elem = l.PushBack(w)
-		wh.watchers[key] = l
-	}
-
-	w.remove = func() {
-		if w.removed { // avoid removing it twice
-			return
-		}
-		w.removed = true
-		l.Remove(elem)
-		atomic.AddInt64(&wh.count, -1)
-		reportWatcherRemoved()
-		if l.Len() == 0 {
-			delete(wh.watchers, key)
-		}
-	}
-
-	atomic.AddInt64(&wh.count, 1)
-	reportWatcherAdded()
-
-	return w, nil
-}
-
-func (wh *watcherHub) add(e *Event) {
-	wh.EventHistory.addEvent(e)
-}
-
-// notify function accepts an event and notify to the watchers.
-func (wh *watcherHub) notify(e *Event) {
-	e = wh.EventHistory.addEvent(e) // add event into the eventHistory
-
-	segments := strings.Split(e.Node.Key, "/")
-
-	currPath := "/"
-
-	// walk through all the segments of the path and notify the watchers
-	// if the path is "/foo/bar", it will notify watchers with path "/",
-	// "/foo" and "/foo/bar"
-
-	for _, segment := range segments {
-		currPath = path.Join(currPath, segment)
-		// notify the watchers who interests in the changes of current path
-		wh.notifyWatchers(e, currPath, false)
-	}
-}
-
-func (wh *watcherHub) notifyWatchers(e *Event, nodePath string, deleted bool) {
-	wh.mutex.Lock()
-	defer wh.mutex.Unlock()
-
-	l, ok := wh.watchers[nodePath]
-	if ok {
-		curr := l.Front()
-
-		for curr != nil {
-			next := curr.Next() // save reference to the next one in the list
-
-			w, _ := curr.Value.(*watcher)
-
-			originalPath := (e.Node.Key == nodePath)
-			if (originalPath || !isHidden(nodePath, e.Node.Key)) && w.notify(e, originalPath, deleted) {
-				if !w.stream { // do not remove the stream watcher
-					// if we successfully notify a watcher
-					// we need to remove the watcher from the list
-					// and decrease the counter
-					w.removed = true
-					l.Remove(curr)
-					atomic.AddInt64(&wh.count, -1)
-					reportWatcherRemoved()
-				}
-			}
-
-			curr = next // update current to the next element in the list
-		}
-
-		if l.Len() == 0 {
-			// if we have notified all watcher in the list
-			// we can delete the list
-			delete(wh.watchers, nodePath)
-		}
-	}
-}
-
-// clone function clones the watcherHub and return the cloned one.
-// only clone the static content. do not clone the current watchers.
-func (wh *watcherHub) clone() *watcherHub {
-	clonedHistory := wh.EventHistory.clone()
-
-	return &watcherHub{
-		EventHistory: clonedHistory,
-	}
-}
-
-// isHidden checks to see if key path is considered hidden to watch path i.e. the
-// last element is hidden or it's within a hidden directory
-func isHidden(watchPath, keyPath string) bool {
-	// When deleting a directory, watchPath might be deeper than the actual keyPath
-	// For example, when deleting /foo we also need to notify watchers on /foo/bar.
-	if len(watchPath) > len(keyPath) {
-		return false
-	}
-	// if watch path is just a "/", after path will start without "/"
-	// add a "/" to deal with the special case when watchPath is "/"
-	afterPath := path.Clean("/" + keyPath[len(watchPath):])
-	return strings.Contains(afterPath, "/_")
-}
diff --git a/store/watcher_hub_test.go b/store/watcher_hub_test.go
deleted file mode 100644
index 314ff4f..0000000
--- a/store/watcher_hub_test.go
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"testing"
-)
-
-// TestIsHidden tests isHidden functions.
-func TestIsHidden(t *testing.T) {
-	// watch at "/"
-	// key is "/_foo", hidden to "/"
-	// expected: hidden = true
-	watch := "/"
-	key := "/_foo"
-	hidden := isHidden(watch, key)
-	if !hidden {
-		t.Fatalf("%v should be hidden to %v\n", key, watch)
-	}
-
-	// watch at "/_foo"
-	// key is "/_foo", not hidden to "/_foo"
-	// expected: hidden = false
-	watch = "/_foo"
-	hidden = isHidden(watch, key)
-	if hidden {
-		t.Fatalf("%v should not be hidden to %v\n", key, watch)
-	}
-
-	// watch at "/_foo/"
-	// key is "/_foo/foo", not hidden to "/_foo"
-	key = "/_foo/foo"
-	hidden = isHidden(watch, key)
-	if hidden {
-		t.Fatalf("%v should not be hidden to %v\n", key, watch)
-	}
-
-	// watch at "/_foo/"
-	// key is "/_foo/_foo", hidden to "/_foo"
-	key = "/_foo/_foo"
-	hidden = isHidden(watch, key)
-	if !hidden {
-		t.Fatalf("%v should be hidden to %v\n", key, watch)
-	}
-
-	// watch at "/_foo/foo"
-	// key is "/_foo"
-	watch = "_foo/foo"
-	key = "/_foo/"
-	hidden = isHidden(watch, key)
-	if hidden {
-		t.Fatalf("%v should not be hidden to %v\n", key, watch)
-	}
-}
diff --git a/store/watcher_test.go b/store/watcher_test.go
deleted file mode 100644
index f7344fa..0000000
--- a/store/watcher_test.go
+++ /dev/null
@@ -1,92 +0,0 @@
-// Copyright 2015 The etcd Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package store
-
-import (
-	"testing"
-)
-
-func TestWatcher(t *testing.T) {
-	s := newStore()
-	wh := s.WatcherHub
-	w, err := wh.watch("/foo", true, false, 1, 1)
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-	c := w.EventChan()
-
-	select {
-	case <-c:
-		t.Fatal("should not receive from channel before send the event")
-	default:
-		// do nothing
-	}
-
-	e := newEvent(Create, "/foo/bar", 1, 1)
-
-	wh.notify(e)
-
-	re := <-c
-
-	if e != re {
-		t.Fatal("recv != send")
-	}
-
-	w, _ = wh.watch("/foo", false, false, 2, 1)
-	c = w.EventChan()
-
-	e = newEvent(Create, "/foo/bar", 2, 2)
-
-	wh.notify(e)
-
-	select {
-	case re = <-c:
-		t.Fatal("should not receive from channel if not recursive ", re)
-	default:
-		// do nothing
-	}
-
-	e = newEvent(Create, "/foo", 3, 3)
-
-	wh.notify(e)
-
-	re = <-c
-
-	if e != re {
-		t.Fatal("recv != send")
-	}
-
-	// ensure we are doing exact matching rather than prefix matching
-	w, _ = wh.watch("/fo", true, false, 1, 1)
-	c = w.EventChan()
-
-	select {
-	case re = <-c:
-		t.Fatal("should not receive from channel:", re)
-	default:
-		// do nothing
-	}
-
-	e = newEvent(Create, "/fo/bar", 3, 3)
-
-	wh.notify(e)
-
-	re = <-c
-
-	if e != re {
-		t.Fatal("recv != send")
-	}
-
-}
