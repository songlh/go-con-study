commit 48ec876af9c5e7c8d799227868a4c2a592823a34
Author: Brian Waldon <bcwaldon@gmail.com>
Date:   Thu Oct 30 15:27:16 2014 -0700

    godep: bump github.com/codegangsta/cli

diff --git a/Godeps/Godeps.json b/Godeps/Godeps.json
index ba5d123..14f860a 100644
--- a/Godeps/Godeps.json
+++ b/Godeps/Godeps.json
@@ -16,8 +16,8 @@
 		},
 		{
 			"ImportPath": "github.com/codegangsta/cli",
-			"Comment": "1.0.0-72-gbb91895",
-			"Rev": "bb9189510af1f49580c073c9e59e8bf288f0df27"
+			"Comment": "1.2.0-26-gf7ebb76",
+			"Rev": "f7ebb761e83e21225d1d8954fde853bf8edd46c4"
 		},
 		{
 			"ImportPath": "github.com/coreos/go-etcd/etcd",
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/.travis.yml b/Godeps/_workspace/src/github.com/codegangsta/cli/.travis.yml
index 2379c61..baf46ab 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/.travis.yml
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/.travis.yml
@@ -1,2 +1,6 @@
 language: go
 go: 1.1
+
+script:
+- go vet ./...
+- go test -v ./...
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/README.md b/Godeps/_workspace/src/github.com/codegangsta/cli/README.md
index 4621310..fe4652c 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/README.md
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/README.md
@@ -9,17 +9,17 @@ http://godoc.org/github.com/codegangsta/cli
 ## Overview
 Command line apps are usually so tiny that there is absolutely no reason why your code should *not* be self-documenting. Things like generating help text and parsing command flags/options should not hinder productivity when writing a command line app.
 
-This is where cli.go comes into play. cli.go makes command line programming fun, organized, and expressive!
+**This is where cli.go comes into play.** cli.go makes command line programming fun, organized, and expressive!
 
 ## Installation
 Make sure you have a working Go environment (go 1.1 is *required*). [See the install instructions](http://golang.org/doc/install.html).
 
-To install cli.go, simply run:
+To install `cli.go`, simply run:
 ```
 $ go get github.com/codegangsta/cli
 ```
 
-Make sure your PATH includes to the `$GOPATH/bin` directory so your commands can be easily used:
+Make sure your `PATH` includes to the `$GOPATH/bin` directory so your commands can be easily used:
 ```
 export PATH=$PATH:$GOPATH/bin
 ```
@@ -122,7 +122,7 @@ GLOBAL OPTIONS
 ```
 
 ### Arguments
-You can lookup arguments by calling the `Args` function on cli.Context.
+You can lookup arguments by calling the `Args` function on `cli.Context`.
 
 ``` go
 ...
@@ -137,7 +137,11 @@ Setting and querying flags is simple.
 ``` go
 ...
 app.Flags = []cli.Flag {
-  cli.StringFlag{"lang", "english", "language for the greeting"},
+  cli.StringFlag{
+    Name: "lang",
+    Value: "english",
+    Usage: "language for the greeting",
+  },
 }
 app.Action = func(c *cli.Context) {
   name := "someone"
@@ -155,11 +159,30 @@ app.Action = func(c *cli.Context) {
 
 #### Alternate Names
 
-You can set alternate (or short) names for flags by providing a comma-delimited list for the Name. e.g.
+You can set alternate (or short) names for flags by providing a comma-delimited list for the `Name`. e.g.
 
 ``` go
 app.Flags = []cli.Flag {
-  cli.StringFlag{"lang, l", "english", "language for the greeting"},
+  cli.StringFlag{
+    Name: "lang, l",
+    Value: "english",
+    Usage: "language for the greeting",
+  },
+}
+```
+
+#### Values from the Environment
+
+You can also have the default value set from the environment via `EnvVar`.  e.g.
+
+``` go
+app.Flags = []cli.Flag {
+  cli.StringFlag{
+    Name: "lang, l",
+    Value: "english",
+    Usage: "language for the greeting",
+    EnvVar: "APP_LANG",
+  },
 }
 ```
 
@@ -214,8 +237,8 @@ app.Commands = []cli.Command{
 
 ### Bash Completion
 
-You can enable completion commands by setting the EnableBashCompletion
-flag on the App object.  By default, this setting will only auto-complete to
+You can enable completion commands by setting the `EnableBashCompletion`
+flag on the `App` object.  By default, this setting will only auto-complete to
 show an app's subcommands, but you can write your own completion methods for
 the App or its subcommands.
 ```go
@@ -237,7 +260,7 @@ app.Commands = []cli.Command{
         return
       }
       for _, t := range tasks {
-        println(t)
+        fmt.Println(t)
       }
     },
   }
@@ -247,11 +270,18 @@ app.Commands = []cli.Command{
 
 #### To Enable
 
-Source the autocomplete/bash_autocomplete file in your .bashrc file while
-setting the PROG variable to the name of your program:
+Source the `autocomplete/bash_autocomplete` file in your `.bashrc` file while
+setting the `PROG` variable to the name of your program:
 
 `PROG=myprogram source /.../cli/autocomplete/bash_autocomplete`
 
 
+## Contribution Guidelines
+Feel free to put up a pull request to fix a bug or maybe add a feature. I will give it a code review and make sure that it does not break backwards compatibility. If I or any other collaborators agree that it is in line with the vision of the project, we will work with you to get the code into a mergeable state and merge it into the master branch.
+
+If you are have contributed something significant to the project, I will most likely add you as a collaborator. As a collaborator you are given the ability to merge others pull requests. It is very important that new code does not break existing code, so be careful about what code you do choose to merge. If you have any questions feel free to link @codegangsta to the issue in question and we can review it together.
+
+If you feel like you have contributed to the project but have not yet been added as a collaborator, I probably forgot to add you. Hit @codegangsta up over email and we will get it figured out.
+
 ## About
 cli.go is written by none other than the [Code Gangsta](http://codegangsta.io)
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/app.go b/Godeps/_workspace/src/github.com/codegangsta/cli/app.go
index 4efba5e..66e541c 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/app.go
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/app.go
@@ -22,6 +22,8 @@ type App struct {
 	Flags []Flag
 	// Boolean to enable bash completion commands
 	EnableBashCompletion bool
+	// Boolean to hide built-in help command
+	HideHelp bool
 	// An action to execute when the bash-completion flag is set
 	BashComplete func(context *Context)
 	// An action to execute before any subcommands are run, but after the context is ready
@@ -58,16 +60,15 @@ func NewApp() *App {
 		BashComplete: DefaultAppComplete,
 		Action:       helpCommand.Action,
 		Compiled:     compileTime(),
-		Author:       "Author",
-		Email:        "unknown@email",
 	}
 }
 
 // Entry point to the cli app. Parses the arguments slice and routes to the proper flag/args combination
 func (a *App) Run(arguments []string) error {
 	// append help to commands
-	if a.Command(helpCommand.Name) == nil {
+	if a.Command(helpCommand.Name) == nil && !a.HideHelp {
 		a.Commands = append(a.Commands, helpCommand)
+		a.appendFlag(HelpFlag)
 	}
 
 	//append version/help flags
@@ -75,7 +76,6 @@ func (a *App) Run(arguments []string) error {
 		a.appendFlag(BashCompletionFlag)
 	}
 	a.appendFlag(VersionFlag)
-	a.appendFlag(HelpFlag)
 
 	// parse flags
 	set := flagSet(a.Name, a.Flags)
@@ -131,12 +131,21 @@ func (a *App) Run(arguments []string) error {
 	return nil
 }
 
+// Another entry point to the cli app, takes care of passing arguments and error handling
+func (a *App) RunAndExitOnError() {
+	if err := a.Run(os.Args); err != nil {
+		os.Stderr.WriteString(fmt.Sprintln(err))
+		os.Exit(1)
+	}
+}
+
 // Invokes the subcommand given the context, parses ctx.Args() to generate command-specific flags
 func (a *App) RunAsSubcommand(ctx *Context) error {
 	// append help to commands
 	if len(a.Commands) > 0 {
-		if a.Command(helpCommand.Name) == nil {
+		if a.Command(helpCommand.Name) == nil && !a.HideHelp {
 			a.Commands = append(a.Commands, helpCommand)
+			a.appendFlag(HelpFlag)
 		}
 	}
 
@@ -144,14 +153,13 @@ func (a *App) RunAsSubcommand(ctx *Context) error {
 	if a.EnableBashCompletion {
 		a.appendFlag(BashCompletionFlag)
 	}
-	a.appendFlag(HelpFlag)
 
 	// parse flags
 	set := flagSet(a.Name, a.Flags)
 	set.SetOutput(ioutil.Discard)
 	err := set.Parse(ctx.Args().Tail())
 	nerr := normalizeFlags(a.Flags, set)
-	context := NewContext(a, set, set)
+	context := NewContext(a, set, ctx.globalSet)
 
 	if nerr != nil {
 		fmt.Println(nerr)
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/app_test.go b/Godeps/_workspace/src/github.com/codegangsta/cli/app_test.go
index b7a5431..81d1174 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/app_test.go
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/app_test.go
@@ -2,9 +2,10 @@ package cli_test
 
 import (
 	"fmt"
-	"github.com/coreos/etcd/Godeps/_workspace/src/github.com/codegangsta/cli"
 	"os"
 	"testing"
+
+	"github.com/codegangsta/cli"
 )
 
 func ExampleApp() {
@@ -42,7 +43,11 @@ func ExampleAppSubcommand() {
 					Usage:       "sends a greeting in english",
 					Description: "greets someone in english",
 					Flags: []cli.Flag{
-						cli.StringFlag{"name", "Bob", "Name of the person to greet"},
+						cli.StringFlag{
+							Name:  "name",
+							Value: "Bob",
+							Usage: "Name of the person to greet",
+						},
 					},
 					Action: func(c *cli.Context) {
 						fmt.Println("Hello,", c.String("name"))
@@ -83,12 +88,10 @@ func ExampleAppHelp() {
 	//    describeit - use it to see a description
 	//
 	// USAGE:
-	//    command describeit [command options] [arguments...]
+	//    command describeit [arguments...]
 	//
 	// DESCRIPTION:
 	//    This is how we describe describeit the function
-	//
-	// OPTIONS:
 }
 
 func ExampleAppBashComplete() {
@@ -254,11 +257,11 @@ func TestApp_ParseSliceFlags(t *testing.T) {
 	var expectedStringSlice = []string{"8.8.8.8", "8.8.4.4"}
 
 	if !IntsEquals(parsedIntSlice, expectedIntSlice) {
-		t.Errorf("%s does not match %s", parsedIntSlice, expectedIntSlice)
+		t.Errorf("%v does not match %v", parsedIntSlice, expectedIntSlice)
 	}
 
 	if !StrsEquals(parsedStringSlice, expectedStringSlice) {
-		t.Errorf("%s does not match %s", parsedStringSlice, expectedStringSlice)
+		t.Errorf("%v does not match %v", parsedStringSlice, expectedStringSlice)
 	}
 }
 
@@ -347,6 +350,26 @@ func TestAppHelpPrinter(t *testing.T) {
 	}
 }
 
+func TestAppVersionPrinter(t *testing.T) {
+	oldPrinter := cli.VersionPrinter
+	defer func() {
+		cli.VersionPrinter = oldPrinter
+	}()
+
+	var wasCalled = false
+	cli.VersionPrinter = func(c *cli.Context) {
+		wasCalled = true
+	}
+
+	app := cli.NewApp()
+	ctx := cli.NewContext(app, nil, nil)
+	cli.ShowVersion(ctx)
+
+	if wasCalled == false {
+		t.Errorf("Version printer expected to be called, but was not")
+	}
+}
+
 func TestAppCommandNotFound(t *testing.T) {
 	beforeRun, subcommandRun := false, false
 	app := cli.NewApp()
@@ -369,3 +392,32 @@ func TestAppCommandNotFound(t *testing.T) {
 	expect(t, beforeRun, true)
 	expect(t, subcommandRun, false)
 }
+
+func TestGlobalFlagsInSubcommands(t *testing.T) {
+	subcommandRun := false
+	app := cli.NewApp()
+
+	app.Flags = []cli.Flag{
+		cli.BoolFlag{Name: "debug, d", Usage: "Enable debugging"},
+	}
+
+	app.Commands = []cli.Command{
+		cli.Command{
+			Name: "foo",
+			Subcommands: []cli.Command{
+				{
+					Name: "bar",
+					Action: func(c *cli.Context) {
+						if c.GlobalBool("debug") {
+							subcommandRun = true
+						}
+					},
+				},
+			},
+		},
+	}
+
+	app.Run([]string{"command", "-d", "foo", "bar"})
+
+	expect(t, subcommandRun, true)
+}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/bash_autocomplete b/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/bash_autocomplete
index a860e03..9b55dd9 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/bash_autocomplete
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/bash_autocomplete
@@ -5,7 +5,7 @@ _cli_bash_autocomplete() {
      COMPREPLY=()
      cur="${COMP_WORDS[COMP_CWORD]}"
      prev="${COMP_WORDS[COMP_CWORD-1]}"
-     opts=$( ${COMP_WORDS[@]:0:COMP_CWORD} --generate-bash-completion )
+     opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} --generate-bash-completion )
      COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
      return 0
  }
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/zsh_autocomplete b/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/zsh_autocomplete
new file mode 100644
index 0000000..5430a18
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/zsh_autocomplete
@@ -0,0 +1,5 @@
+autoload -U compinit && compinit
+autoload -U bashcompinit && bashcompinit
+
+script_dir=$(dirname $0)
+source ${script_dir}/bash_autocomplete
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/cli_test.go b/Godeps/_workspace/src/github.com/codegangsta/cli/cli_test.go
index a2ffeae..879a793 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/cli_test.go
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/cli_test.go
@@ -1,8 +1,9 @@
 package cli_test
 
 import (
-	"github.com/coreos/etcd/Godeps/_workspace/src/github.com/codegangsta/cli"
 	"os"
+
+	"github.com/codegangsta/cli"
 )
 
 func Example() {
@@ -47,7 +48,11 @@ func ExampleSubcommand() {
 					Usage:       "sends a greeting in english",
 					Description: "greets someone in english",
 					Flags: []cli.Flag{
-						cli.StringFlag{"name", "Bob", "Name of the person to greet"},
+						cli.StringFlag{
+							Name:  "name",
+							Value: "Bob",
+							Usage: "Name of the person to greet",
+						},
 					},
 					Action: func(c *cli.Context) {
 						println("Hello, ", c.String("name"))
@@ -57,7 +62,11 @@ func ExampleSubcommand() {
 					ShortName: "sp",
 					Usage:     "sends a greeting in spanish",
 					Flags: []cli.Flag{
-						cli.StringFlag{"surname", "Jones", "Surname of the person to greet"},
+						cli.StringFlag{
+							Name:  "surname",
+							Value: "Jones",
+							Usage: "Surname of the person to greet",
+						},
 					},
 					Action: func(c *cli.Context) {
 						println("Hola, ", c.String("surname"))
@@ -67,7 +76,11 @@ func ExampleSubcommand() {
 					ShortName: "fr",
 					Usage:     "sends a greeting in french",
 					Flags: []cli.Flag{
-						cli.StringFlag{"nickname", "Stevie", "Nickname of the person to greet"},
+						cli.StringFlag{
+							Name:  "nickname",
+							Value: "Stevie",
+							Usage: "Nickname of the person to greet",
+						},
 					},
 					Action: func(c *cli.Context) {
 						println("Bonjour, ", c.String("nickname"))
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/command.go b/Godeps/_workspace/src/github.com/codegangsta/cli/command.go
index 9d8fff4..5622b38 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/command.go
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/command.go
@@ -29,6 +29,8 @@ type Command struct {
 	Flags []Flag
 	// Treat all flags as normal arguments if true
 	SkipFlagParsing bool
+	// Boolean to hide built-in help command
+	HideHelp bool
 }
 
 // Invokes the command given the context, parses ctx.Args() to generate command-specific flags
@@ -38,11 +40,13 @@ func (c Command) Run(ctx *Context) error {
 		return c.startApp(ctx)
 	}
 
-	// append help to flags
-	c.Flags = append(
-		c.Flags,
-		HelpFlag,
-	)
+	if !c.HideHelp {
+		// append help to flags
+		c.Flags = append(
+			c.Flags,
+			HelpFlag,
+		)
+	}
 
 	if ctx.App.EnableBashCompletion {
 		c.Flags = append(c.Flags, BashCompletionFlag)
@@ -114,9 +118,13 @@ func (c Command) startApp(ctx *Context) error {
 		app.Usage = c.Usage
 	}
 
+	// set CommandNotFound
+	app.CommandNotFound = ctx.App.CommandNotFound
+
 	// set the flags and commands
 	app.Commands = c.Subcommands
 	app.Flags = c.Flags
+	app.HideHelp = c.HideHelp
 
 	// bash completion
 	app.EnableBashCompletion = ctx.App.EnableBashCompletion
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/command_test.go b/Godeps/_workspace/src/github.com/codegangsta/cli/command_test.go
index 4bebd68..c0f556a 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/command_test.go
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/command_test.go
@@ -2,8 +2,9 @@ package cli_test
 
 import (
 	"flag"
-	"github.com/coreos/etcd/Godeps/_workspace/src/github.com/codegangsta/cli"
 	"testing"
+
+	"github.com/codegangsta/cli"
 )
 
 func TestCommandDoNotIgnoreFlags(t *testing.T) {
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/context.go b/Godeps/_workspace/src/github.com/codegangsta/cli/context.go
index b2c51bb..8b44148 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/context.go
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/context.go
@@ -5,6 +5,7 @@ import (
 	"flag"
 	"strconv"
 	"strings"
+	"time"
 )
 
 // Context is a type that is passed through to
@@ -29,6 +30,11 @@ func (c *Context) Int(name string) int {
 	return lookupInt(name, c.flagSet)
 }
 
+// Looks up the value of a local time.Duration flag, returns 0 if no time.Duration flag exists
+func (c *Context) Duration(name string) time.Duration {
+	return lookupDuration(name, c.flagSet)
+}
+
 // Looks up the value of a local float64 flag, returns 0 if no float64 flag exists
 func (c *Context) Float64(name string) float64 {
 	return lookupFloat64(name, c.flagSet)
@@ -69,6 +75,11 @@ func (c *Context) GlobalInt(name string) int {
 	return lookupInt(name, c.globalSet)
 }
 
+// Looks up the value of a global time.Duration flag, returns 0 if no time.Duration flag exists
+func (c *Context) GlobalDuration(name string) time.Duration {
+	return lookupDuration(name, c.globalSet)
+}
+
 // Looks up the value of a global bool flag, returns false if no bool flag exists
 func (c *Context) GlobalBool(name string) bool {
 	return lookupBool(name, c.globalSet)
@@ -105,6 +116,18 @@ func (c *Context) IsSet(name string) bool {
 	return c.setFlags[name] == true
 }
 
+// Returns a slice of flag names used in this context.
+func (c *Context) FlagNames() (names []string) {
+	for _, flag := range c.Command.Flags {
+		name := strings.Split(flag.getName(), ",")[0]
+		if name == "help" {
+			continue
+		}
+		names = append(names, name)
+	}
+	return
+}
+
 type Args []string
 
 // Returns the command line arguments associated with the context.
@@ -140,6 +163,15 @@ func (a Args) Present() bool {
 	return len(a) != 0
 }
 
+// Swaps arguments at the given indexes
+func (a Args) Swap(from, to int) error {
+	if from >= len(a) || to >= len(a) {
+		return errors.New("index out of range")
+	}
+	a[from], a[to] = a[to], a[from]
+	return nil
+}
+
 func lookupInt(name string, set *flag.FlagSet) int {
 	f := set.Lookup(name)
 	if f != nil {
@@ -153,6 +185,18 @@ func lookupInt(name string, set *flag.FlagSet) int {
 	return 0
 }
 
+func lookupDuration(name string, set *flag.FlagSet) time.Duration {
+	f := set.Lookup(name)
+	if f != nil {
+		val, err := time.ParseDuration(f.Value.String())
+		if err == nil {
+			return val
+		}
+	}
+
+	return 0
+}
+
 func lookupFloat64(name string, set *flag.FlagSet) float64 {
 	f := set.Lookup(name)
 	if f != nil {
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/context_test.go b/Godeps/_workspace/src/github.com/codegangsta/cli/context_test.go
index 7c86a48..b2d2412 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/context_test.go
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/context_test.go
@@ -2,8 +2,10 @@ package cli_test
 
 import (
 	"flag"
-	"github.com/coreos/etcd/Godeps/_workspace/src/github.com/codegangsta/cli"
 	"testing"
+	"time"
+
+	"github.com/codegangsta/cli"
 )
 
 func TestNewContext(t *testing.T) {
@@ -26,6 +28,13 @@ func TestContext_Int(t *testing.T) {
 	expect(t, c.Int("myflag"), 12)
 }
 
+func TestContext_Duration(t *testing.T) {
+	set := flag.NewFlagSet("test", 0)
+	set.Duration("myflag", time.Duration(12*time.Second), "doc")
+	c := cli.NewContext(nil, set, set)
+	expect(t, c.Duration("myflag"), time.Duration(12*time.Second))
+}
+
 func TestContext_String(t *testing.T) {
 	set := flag.NewFlagSet("test", 0)
 	set.String("myflag", "hello world", "doc")
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/flag.go b/Godeps/_workspace/src/github.com/codegangsta/cli/flag.go
index e6f8838..b30bca3 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/flag.go
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/flag.go
@@ -3,18 +3,28 @@ package cli
 import (
 	"flag"
 	"fmt"
+	"os"
 	"strconv"
 	"strings"
+	"time"
 )
 
 // This flag enables bash-completion for all commands and subcommands
-var BashCompletionFlag = BoolFlag{"generate-bash-completion", ""}
+var BashCompletionFlag = BoolFlag{
+	Name: "generate-bash-completion",
+}
 
 // This flag prints the version for the application
-var VersionFlag = BoolFlag{"version, v", "print the version"}
+var VersionFlag = BoolFlag{
+	Name:  "version, v",
+	Usage: "print the version",
+}
 
 // This flag prints the help for all commands and subcommands
-var HelpFlag = BoolFlag{"help, h", "show help"}
+var HelpFlag = BoolFlag{
+	Name:  "help, h",
+	Usage: "show help",
+}
 
 // Flag is a common interface related to parsing flags in cli.
 // For more advanced flag parsing techniques, it is recomended that
@@ -51,16 +61,24 @@ type Generic interface {
 
 // GenericFlag is the flag type for types implementing Generic
 type GenericFlag struct {
-	Name  string
-	Value Generic
-	Usage string
+	Name   string
+	Value  Generic
+	Usage  string
+	EnvVar string
 }
 
 func (f GenericFlag) String() string {
-	return fmt.Sprintf("%s%s %v\t`%v` %s", prefixFor(f.Name), f.Name, f.Value, "-"+f.Name+" option -"+f.Name+" option", f.Usage)
+	return withEnvHint(f.EnvVar, fmt.Sprintf("%s%s %v\t`%v` %s", prefixFor(f.Name), f.Name, f.Value, "-"+f.Name+" option -"+f.Name+" option", f.Usage))
 }
 
 func (f GenericFlag) Apply(set *flag.FlagSet) {
+	val := f.Value
+	if f.EnvVar != "" {
+		if envVal := os.Getenv(f.EnvVar); envVal != "" {
+			val.Set(envVal)
+		}
+	}
+
 	eachName(f.Name, func(name string) {
 		set.Var(f.Value, name, f.Usage)
 	})
@@ -86,18 +104,29 @@ func (f *StringSlice) Value() []string {
 }
 
 type StringSliceFlag struct {
-	Name  string
-	Value *StringSlice
-	Usage string
+	Name   string
+	Value  *StringSlice
+	Usage  string
+	EnvVar string
 }
 
 func (f StringSliceFlag) String() string {
 	firstName := strings.Trim(strings.Split(f.Name, ",")[0], " ")
 	pref := prefixFor(firstName)
-	return fmt.Sprintf("%s '%v'\t%v", prefixedNames(f.Name), pref+firstName+" option "+pref+firstName+" option", f.Usage)
+	return withEnvHint(f.EnvVar, fmt.Sprintf("%s '%v'\t%v", prefixedNames(f.Name), pref+firstName+" option "+pref+firstName+" option", f.Usage))
 }
 
 func (f StringSliceFlag) Apply(set *flag.FlagSet) {
+	if f.EnvVar != "" {
+		if envVal := os.Getenv(f.EnvVar); envVal != "" {
+			newVal := &StringSlice{}
+			for _, s := range strings.Split(envVal, ",") {
+				newVal.Set(s)
+			}
+			f.Value = newVal
+		}
+	}
+
 	eachName(f.Name, func(name string) {
 		set.Var(f.Value, name, f.Usage)
 	})
@@ -129,18 +158,32 @@ func (f *IntSlice) Value() []int {
 }
 
 type IntSliceFlag struct {
-	Name  string
-	Value *IntSlice
-	Usage string
+	Name   string
+	Value  *IntSlice
+	Usage  string
+	EnvVar string
 }
 
 func (f IntSliceFlag) String() string {
 	firstName := strings.Trim(strings.Split(f.Name, ",")[0], " ")
 	pref := prefixFor(firstName)
-	return fmt.Sprintf("%s '%v'\t%v", prefixedNames(f.Name), pref+firstName+" option "+pref+firstName+" option", f.Usage)
+	return withEnvHint(f.EnvVar, fmt.Sprintf("%s '%v'\t%v", prefixedNames(f.Name), pref+firstName+" option "+pref+firstName+" option", f.Usage))
 }
 
 func (f IntSliceFlag) Apply(set *flag.FlagSet) {
+	if f.EnvVar != "" {
+		if envVal := os.Getenv(f.EnvVar); envVal != "" {
+			newVal := &IntSlice{}
+			for _, s := range strings.Split(envVal, ",") {
+				err := newVal.Set(s)
+				if err != nil {
+					fmt.Fprintf(os.Stderr, err.Error())
+				}
+			}
+			f.Value = newVal
+		}
+	}
+
 	eachName(f.Name, func(name string) {
 		set.Var(f.Value, name, f.Usage)
 	})
@@ -151,17 +194,28 @@ func (f IntSliceFlag) getName() string {
 }
 
 type BoolFlag struct {
-	Name  string
-	Usage string
+	Name   string
+	Usage  string
+	EnvVar string
 }
 
 func (f BoolFlag) String() string {
-	return fmt.Sprintf("%s\t%v", prefixedNames(f.Name), f.Usage)
+	return withEnvHint(f.EnvVar, fmt.Sprintf("%s\t%v", prefixedNames(f.Name), f.Usage))
 }
 
 func (f BoolFlag) Apply(set *flag.FlagSet) {
+	val := false
+	if f.EnvVar != "" {
+		if envVal := os.Getenv(f.EnvVar); envVal != "" {
+			envValBool, err := strconv.ParseBool(envVal)
+			if err == nil {
+				val = envValBool
+			}
+		}
+	}
+
 	eachName(f.Name, func(name string) {
-		set.Bool(name, false, f.Usage)
+		set.Bool(name, val, f.Usage)
 	})
 }
 
@@ -170,17 +224,28 @@ func (f BoolFlag) getName() string {
 }
 
 type BoolTFlag struct {
-	Name  string
-	Usage string
+	Name   string
+	Usage  string
+	EnvVar string
 }
 
 func (f BoolTFlag) String() string {
-	return fmt.Sprintf("%s\t%v", prefixedNames(f.Name), f.Usage)
+	return withEnvHint(f.EnvVar, fmt.Sprintf("%s\t%v", prefixedNames(f.Name), f.Usage))
 }
 
 func (f BoolTFlag) Apply(set *flag.FlagSet) {
+	val := true
+	if f.EnvVar != "" {
+		if envVal := os.Getenv(f.EnvVar); envVal != "" {
+			envValBool, err := strconv.ParseBool(envVal)
+			if err == nil {
+				val = envValBool
+			}
+		}
+	}
+
 	eachName(f.Name, func(name string) {
-		set.Bool(name, true, f.Usage)
+		set.Bool(name, val, f.Usage)
 	})
 }
 
@@ -189,9 +254,10 @@ func (f BoolTFlag) getName() string {
 }
 
 type StringFlag struct {
-	Name  string
-	Value string
-	Usage string
+	Name   string
+	Value  string
+	Usage  string
+	EnvVar string
 }
 
 func (f StringFlag) String() string {
@@ -204,10 +270,16 @@ func (f StringFlag) String() string {
 		fmtString = "%s %v\t%v"
 	}
 
-	return fmt.Sprintf(fmtString, prefixedNames(f.Name), f.Value, f.Usage)
+	return withEnvHint(f.EnvVar, fmt.Sprintf(fmtString, prefixedNames(f.Name), f.Value, f.Usage))
 }
 
 func (f StringFlag) Apply(set *flag.FlagSet) {
+	if f.EnvVar != "" {
+		if envVal := os.Getenv(f.EnvVar); envVal != "" {
+			f.Value = envVal
+		}
+	}
+
 	eachName(f.Name, func(name string) {
 		set.String(name, f.Value, f.Usage)
 	})
@@ -218,16 +290,26 @@ func (f StringFlag) getName() string {
 }
 
 type IntFlag struct {
-	Name  string
-	Value int
-	Usage string
+	Name   string
+	Value  int
+	Usage  string
+	EnvVar string
 }
 
 func (f IntFlag) String() string {
-	return fmt.Sprintf("%s '%v'\t%v", prefixedNames(f.Name), f.Value, f.Usage)
+	return withEnvHint(f.EnvVar, fmt.Sprintf("%s '%v'\t%v", prefixedNames(f.Name), f.Value, f.Usage))
 }
 
 func (f IntFlag) Apply(set *flag.FlagSet) {
+	if f.EnvVar != "" {
+		if envVal := os.Getenv(f.EnvVar); envVal != "" {
+			envValInt, err := strconv.ParseUint(envVal, 10, 64)
+			if err == nil {
+				f.Value = int(envValInt)
+			}
+		}
+	}
+
 	eachName(f.Name, func(name string) {
 		set.Int(name, f.Value, f.Usage)
 	})
@@ -237,17 +319,57 @@ func (f IntFlag) getName() string {
 	return f.Name
 }
 
+type DurationFlag struct {
+	Name   string
+	Value  time.Duration
+	Usage  string
+	EnvVar string
+}
+
+func (f DurationFlag) String() string {
+	return withEnvHint(f.EnvVar, fmt.Sprintf("%s '%v'\t%v", prefixedNames(f.Name), f.Value, f.Usage))
+}
+
+func (f DurationFlag) Apply(set *flag.FlagSet) {
+	if f.EnvVar != "" {
+		if envVal := os.Getenv(f.EnvVar); envVal != "" {
+			envValDuration, err := time.ParseDuration(envVal)
+			if err == nil {
+				f.Value = envValDuration
+			}
+		}
+	}
+
+	eachName(f.Name, func(name string) {
+		set.Duration(name, f.Value, f.Usage)
+	})
+}
+
+func (f DurationFlag) getName() string {
+	return f.Name
+}
+
 type Float64Flag struct {
-	Name  string
-	Value float64
-	Usage string
+	Name   string
+	Value  float64
+	Usage  string
+	EnvVar string
 }
 
 func (f Float64Flag) String() string {
-	return fmt.Sprintf("%s '%v'\t%v", prefixedNames(f.Name), f.Value, f.Usage)
+	return withEnvHint(f.EnvVar, fmt.Sprintf("%s '%v'\t%v", prefixedNames(f.Name), f.Value, f.Usage))
 }
 
 func (f Float64Flag) Apply(set *flag.FlagSet) {
+	if f.EnvVar != "" {
+		if envVal := os.Getenv(f.EnvVar); envVal != "" {
+			envValFloat, err := strconv.ParseFloat(envVal, 10)
+			if err == nil {
+				f.Value = float64(envValFloat)
+			}
+		}
+	}
+
 	eachName(f.Name, func(name string) {
 		set.Float64(name, f.Value, f.Usage)
 	})
@@ -278,3 +400,11 @@ func prefixedNames(fullName string) (prefixed string) {
 	}
 	return
 }
+
+func withEnvHint(envVar, str string) string {
+	envText := ""
+	if envVar != "" {
+		envText = fmt.Sprintf(" [$%s]", envVar)
+	}
+	return str + envText
+}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/flag_test.go b/Godeps/_workspace/src/github.com/codegangsta/cli/flag_test.go
index c6409f5..bc5059c 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/flag_test.go
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/flag_test.go
@@ -1,12 +1,13 @@
 package cli_test
 
 import (
-	"github.com/coreos/etcd/Godeps/_workspace/src/github.com/codegangsta/cli"
-
 	"fmt"
+	"os"
 	"reflect"
 	"strings"
 	"testing"
+
+	"github.com/codegangsta/cli"
 )
 
 var boolFlagTests = []struct {
@@ -52,6 +53,71 @@ func TestStringFlagHelpOutput(t *testing.T) {
 	}
 }
 
+func TestStringFlagWithEnvVarHelpOutput(t *testing.T) {
+
+	os.Setenv("APP_FOO", "derp")
+	for _, test := range stringFlagTests {
+		flag := cli.StringFlag{Name: test.name, Value: test.value, EnvVar: "APP_FOO"}
+		output := flag.String()
+
+		if !strings.HasSuffix(output, " [$APP_FOO]") {
+			t.Errorf("%s does not end with [$APP_FOO]", output)
+		}
+	}
+}
+
+var stringSliceFlagTests = []struct {
+	name     string
+	value    *cli.StringSlice
+	expected string
+}{
+	{"help", func() *cli.StringSlice {
+		s := &cli.StringSlice{}
+		s.Set("")
+		return s
+	}(), "--help '--help option --help option'\t"},
+	{"h", func() *cli.StringSlice {
+		s := &cli.StringSlice{}
+		s.Set("")
+		return s
+	}(), "-h '-h option -h option'\t"},
+	{"h", func() *cli.StringSlice {
+		s := &cli.StringSlice{}
+		s.Set("")
+		return s
+	}(), "-h '-h option -h option'\t"},
+	{"test", func() *cli.StringSlice {
+		s := &cli.StringSlice{}
+		s.Set("Something")
+		return s
+	}(), "--test '--test option --test option'\t"},
+}
+
+func TestStringSliceFlagHelpOutput(t *testing.T) {
+
+	for _, test := range stringSliceFlagTests {
+		flag := cli.StringSliceFlag{Name: test.name, Value: test.value}
+		output := flag.String()
+
+		if output != test.expected {
+			t.Errorf("%q does not match %q", output, test.expected)
+		}
+	}
+}
+
+func TestStringSliceFlagWithEnvVarHelpOutput(t *testing.T) {
+
+	os.Setenv("APP_QWWX", "11,4")
+	for _, test := range stringSliceFlagTests {
+		flag := cli.StringSliceFlag{Name: test.name, Value: test.value, EnvVar: "APP_QWWX"}
+		output := flag.String()
+
+		if !strings.HasSuffix(output, " [$APP_QWWX]") {
+			t.Errorf("%q does not end with [$APP_QWWX]", output)
+		}
+	}
+}
+
 var intFlagTests = []struct {
 	name     string
 	expected string
@@ -72,6 +138,92 @@ func TestIntFlagHelpOutput(t *testing.T) {
 	}
 }
 
+func TestIntFlagWithEnvVarHelpOutput(t *testing.T) {
+
+	os.Setenv("APP_BAR", "2")
+	for _, test := range intFlagTests {
+		flag := cli.IntFlag{Name: test.name, EnvVar: "APP_BAR"}
+		output := flag.String()
+
+		if !strings.HasSuffix(output, " [$APP_BAR]") {
+			t.Errorf("%s does not end with [$APP_BAR]", output)
+		}
+	}
+}
+
+var durationFlagTests = []struct {
+	name     string
+	expected string
+}{
+	{"help", "--help '0'\t"},
+	{"h", "-h '0'\t"},
+}
+
+func TestDurationFlagHelpOutput(t *testing.T) {
+
+	for _, test := range durationFlagTests {
+		flag := cli.DurationFlag{Name: test.name}
+		output := flag.String()
+
+		if output != test.expected {
+			t.Errorf("%s does not match %s", output, test.expected)
+		}
+	}
+}
+
+func TestDurationFlagWithEnvVarHelpOutput(t *testing.T) {
+
+	os.Setenv("APP_BAR", "2h3m6s")
+	for _, test := range durationFlagTests {
+		flag := cli.DurationFlag{Name: test.name, EnvVar: "APP_BAR"}
+		output := flag.String()
+
+		if !strings.HasSuffix(output, " [$APP_BAR]") {
+			t.Errorf("%s does not end with [$APP_BAR]", output)
+		}
+	}
+}
+
+var intSliceFlagTests = []struct {
+	name     string
+	value    *cli.IntSlice
+	expected string
+}{
+	{"help", &cli.IntSlice{}, "--help '--help option --help option'\t"},
+	{"h", &cli.IntSlice{}, "-h '-h option -h option'\t"},
+	{"h", &cli.IntSlice{}, "-h '-h option -h option'\t"},
+	{"test", func() *cli.IntSlice {
+		i := &cli.IntSlice{}
+		i.Set("9")
+		return i
+	}(), "--test '--test option --test option'\t"},
+}
+
+func TestIntSliceFlagHelpOutput(t *testing.T) {
+
+	for _, test := range intSliceFlagTests {
+		flag := cli.IntSliceFlag{Name: test.name, Value: test.value}
+		output := flag.String()
+
+		if output != test.expected {
+			t.Errorf("%q does not match %q", output, test.expected)
+		}
+	}
+}
+
+func TestIntSliceFlagWithEnvVarHelpOutput(t *testing.T) {
+
+	os.Setenv("APP_SMURF", "42,3")
+	for _, test := range intSliceFlagTests {
+		flag := cli.IntSliceFlag{Name: test.name, Value: test.value, EnvVar: "APP_SMURF"}
+		output := flag.String()
+
+		if !strings.HasSuffix(output, " [$APP_SMURF]") {
+			t.Errorf("%q does not end with [$APP_SMURF]", output)
+		}
+	}
+}
+
 var float64FlagTests = []struct {
 	name     string
 	expected string
@@ -92,6 +244,54 @@ func TestFloat64FlagHelpOutput(t *testing.T) {
 	}
 }
 
+func TestFloat64FlagWithEnvVarHelpOutput(t *testing.T) {
+
+	os.Setenv("APP_BAZ", "99.4")
+	for _, test := range float64FlagTests {
+		flag := cli.Float64Flag{Name: test.name, EnvVar: "APP_BAZ"}
+		output := flag.String()
+
+		if !strings.HasSuffix(output, " [$APP_BAZ]") {
+			t.Errorf("%s does not end with [$APP_BAZ]", output)
+		}
+	}
+}
+
+var genericFlagTests = []struct {
+	name     string
+	value    cli.Generic
+	expected string
+}{
+	{"help", &Parser{}, "--help <nil>\t`-help option -help option` "},
+	{"h", &Parser{}, "-h <nil>\t`-h option -h option` "},
+	{"test", &Parser{}, "--test <nil>\t`-test option -test option` "},
+}
+
+func TestGenericFlagHelpOutput(t *testing.T) {
+
+	for _, test := range genericFlagTests {
+		flag := cli.GenericFlag{Name: test.name}
+		output := flag.String()
+
+		if output != test.expected {
+			t.Errorf("%q does not match %q", output, test.expected)
+		}
+	}
+}
+
+func TestGenericFlagWithEnvVarHelpOutput(t *testing.T) {
+
+	os.Setenv("APP_ZAP", "3")
+	for _, test := range genericFlagTests {
+		flag := cli.GenericFlag{Name: test.name, EnvVar: "APP_ZAP"}
+		output := flag.String()
+
+		if !strings.HasSuffix(output, " [$APP_ZAP]") {
+			t.Errorf("%s does not end with [$APP_ZAP]", output)
+		}
+	}
+}
+
 func TestParseMultiString(t *testing.T) {
 	(&cli.App{
 		Flags: []cli.Flag{
@@ -108,6 +308,23 @@ func TestParseMultiString(t *testing.T) {
 	}).Run([]string{"run", "-s", "10"})
 }
 
+func TestParseMultiStringFromEnv(t *testing.T) {
+	os.Setenv("APP_COUNT", "20")
+	(&cli.App{
+		Flags: []cli.Flag{
+			cli.StringFlag{Name: "count, c", EnvVar: "APP_COUNT"},
+		},
+		Action: func(ctx *cli.Context) {
+			if ctx.String("count") != "20" {
+				t.Errorf("main name not set")
+			}
+			if ctx.String("c") != "20" {
+				t.Errorf("short name not set")
+			}
+		},
+	}).Run([]string{"run"})
+}
+
 func TestParseMultiStringSlice(t *testing.T) {
 	(&cli.App{
 		Flags: []cli.Flag{
@@ -124,6 +341,24 @@ func TestParseMultiStringSlice(t *testing.T) {
 	}).Run([]string{"run", "-s", "10", "-s", "20"})
 }
 
+func TestParseMultiStringSliceFromEnv(t *testing.T) {
+	os.Setenv("APP_INTERVALS", "20,30,40")
+
+	(&cli.App{
+		Flags: []cli.Flag{
+			cli.StringSliceFlag{Name: "intervals, i", Value: &cli.StringSlice{}, EnvVar: "APP_INTERVALS"},
+		},
+		Action: func(ctx *cli.Context) {
+			if !reflect.DeepEqual(ctx.StringSlice("intervals"), []string{"20", "30", "40"}) {
+				t.Errorf("main name not set from env")
+			}
+			if !reflect.DeepEqual(ctx.StringSlice("i"), []string{"20", "30", "40"}) {
+				t.Errorf("short name not set from env")
+			}
+		},
+	}).Run([]string{"run"})
+}
+
 func TestParseMultiInt(t *testing.T) {
 	a := cli.App{
 		Flags: []cli.Flag{
@@ -141,6 +376,93 @@ func TestParseMultiInt(t *testing.T) {
 	a.Run([]string{"run", "-s", "10"})
 }
 
+func TestParseMultiIntFromEnv(t *testing.T) {
+	os.Setenv("APP_TIMEOUT_SECONDS", "10")
+	a := cli.App{
+		Flags: []cli.Flag{
+			cli.IntFlag{Name: "timeout, t", EnvVar: "APP_TIMEOUT_SECONDS"},
+		},
+		Action: func(ctx *cli.Context) {
+			if ctx.Int("timeout") != 10 {
+				t.Errorf("main name not set")
+			}
+			if ctx.Int("t") != 10 {
+				t.Errorf("short name not set")
+			}
+		},
+	}
+	a.Run([]string{"run"})
+}
+
+func TestParseMultiIntSlice(t *testing.T) {
+	(&cli.App{
+		Flags: []cli.Flag{
+			cli.IntSliceFlag{Name: "serve, s", Value: &cli.IntSlice{}},
+		},
+		Action: func(ctx *cli.Context) {
+			if !reflect.DeepEqual(ctx.IntSlice("serve"), []int{10, 20}) {
+				t.Errorf("main name not set")
+			}
+			if !reflect.DeepEqual(ctx.IntSlice("s"), []int{10, 20}) {
+				t.Errorf("short name not set")
+			}
+		},
+	}).Run([]string{"run", "-s", "10", "-s", "20"})
+}
+
+func TestParseMultiIntSliceFromEnv(t *testing.T) {
+	os.Setenv("APP_INTERVALS", "20,30,40")
+
+	(&cli.App{
+		Flags: []cli.Flag{
+			cli.IntSliceFlag{Name: "intervals, i", Value: &cli.IntSlice{}, EnvVar: "APP_INTERVALS"},
+		},
+		Action: func(ctx *cli.Context) {
+			if !reflect.DeepEqual(ctx.IntSlice("intervals"), []int{20, 30, 40}) {
+				t.Errorf("main name not set from env")
+			}
+			if !reflect.DeepEqual(ctx.IntSlice("i"), []int{20, 30, 40}) {
+				t.Errorf("short name not set from env")
+			}
+		},
+	}).Run([]string{"run"})
+}
+
+func TestParseMultiFloat64(t *testing.T) {
+	a := cli.App{
+		Flags: []cli.Flag{
+			cli.Float64Flag{Name: "serve, s"},
+		},
+		Action: func(ctx *cli.Context) {
+			if ctx.Float64("serve") != 10.2 {
+				t.Errorf("main name not set")
+			}
+			if ctx.Float64("s") != 10.2 {
+				t.Errorf("short name not set")
+			}
+		},
+	}
+	a.Run([]string{"run", "-s", "10.2"})
+}
+
+func TestParseMultiFloat64FromEnv(t *testing.T) {
+	os.Setenv("APP_TIMEOUT_SECONDS", "15.5")
+	a := cli.App{
+		Flags: []cli.Flag{
+			cli.Float64Flag{Name: "timeout, t", EnvVar: "APP_TIMEOUT_SECONDS"},
+		},
+		Action: func(ctx *cli.Context) {
+			if ctx.Float64("timeout") != 15.5 {
+				t.Errorf("main name not set")
+			}
+			if ctx.Float64("t") != 15.5 {
+				t.Errorf("short name not set")
+			}
+		},
+	}
+	a.Run([]string{"run"})
+}
+
 func TestParseMultiBool(t *testing.T) {
 	a := cli.App{
 		Flags: []cli.Flag{
@@ -158,6 +480,59 @@ func TestParseMultiBool(t *testing.T) {
 	a.Run([]string{"run", "--serve"})
 }
 
+func TestParseMultiBoolFromEnv(t *testing.T) {
+	os.Setenv("APP_DEBUG", "1")
+	a := cli.App{
+		Flags: []cli.Flag{
+			cli.BoolFlag{Name: "debug, d", EnvVar: "APP_DEBUG"},
+		},
+		Action: func(ctx *cli.Context) {
+			if ctx.Bool("debug") != true {
+				t.Errorf("main name not set from env")
+			}
+			if ctx.Bool("d") != true {
+				t.Errorf("short name not set from env")
+			}
+		},
+	}
+	a.Run([]string{"run"})
+}
+
+func TestParseMultiBoolT(t *testing.T) {
+	a := cli.App{
+		Flags: []cli.Flag{
+			cli.BoolTFlag{Name: "serve, s"},
+		},
+		Action: func(ctx *cli.Context) {
+			if ctx.BoolT("serve") != true {
+				t.Errorf("main name not set")
+			}
+			if ctx.BoolT("s") != true {
+				t.Errorf("short name not set")
+			}
+		},
+	}
+	a.Run([]string{"run", "--serve"})
+}
+
+func TestParseMultiBoolTFromEnv(t *testing.T) {
+	os.Setenv("APP_DEBUG", "0")
+	a := cli.App{
+		Flags: []cli.Flag{
+			cli.BoolTFlag{Name: "debug, d", EnvVar: "APP_DEBUG"},
+		},
+		Action: func(ctx *cli.Context) {
+			if ctx.BoolT("debug") != false {
+				t.Errorf("main name not set from env")
+			}
+			if ctx.BoolT("d") != false {
+				t.Errorf("short name not set from env")
+			}
+		},
+	}
+	a.Run([]string{"run"})
+}
+
 type Parser [2]string
 
 func (p *Parser) Set(value string) error {
@@ -192,3 +567,21 @@ func TestParseGeneric(t *testing.T) {
 	}
 	a.Run([]string{"run", "-s", "10,20"})
 }
+
+func TestParseGenericFromEnv(t *testing.T) {
+	os.Setenv("APP_SERVE", "20,30")
+	a := cli.App{
+		Flags: []cli.Flag{
+			cli.GenericFlag{Name: "serve, s", Value: &Parser{}, EnvVar: "APP_SERVE"},
+		},
+		Action: func(ctx *cli.Context) {
+			if !reflect.DeepEqual(ctx.Generic("serve"), &Parser{"20", "30"}) {
+				t.Errorf("main name not set from env")
+			}
+			if !reflect.DeepEqual(ctx.Generic("s"), &Parser{"20", "30"}) {
+				t.Errorf("short name not set from env")
+			}
+		},
+	}
+	a.Run([]string{"run"})
+}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/help.go b/Godeps/_workspace/src/github.com/codegangsta/cli/help.go
index 7c04005..5020cb6 100644
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/help.go
+++ b/Godeps/_workspace/src/github.com/codegangsta/cli/help.go
@@ -14,17 +14,21 @@ var AppHelpTemplate = `NAME:
    {{.Name}} - {{.Usage}}
 
 USAGE:
-   {{.Name}} [global options] command [command options] [arguments...]
+   {{.Name}} {{if .Flags}}[global options] {{end}}command{{if .Flags}} [command options]{{end}} [arguments...]
 
 VERSION:
-   {{.Version}}
+   {{.Version}}{{if or .Author .Email}}
+
+AUTHOR:{{if .Author}}
+  {{.Author}}{{if .Email}} - <{{.Email}}>{{end}}{{else}}
+  {{.Email}}{{end}}{{end}}
 
 COMMANDS:
    {{range .Commands}}{{.Name}}{{with .ShortName}}, {{.}}{{end}}{{ "\t" }}{{.Usage}}
-   {{end}}
+   {{end}}{{if .Flags}}
 GLOBAL OPTIONS:
    {{range .Flags}}{{.}}
-   {{end}}
+   {{end}}{{end}}
 `
 
 // The text template for the command help topic.
@@ -34,14 +38,14 @@ var CommandHelpTemplate = `NAME:
    {{.Name}} - {{.Usage}}
 
 USAGE:
-   command {{.Name}} [command options] [arguments...]
+   command {{.Name}}{{if .Flags}} [command options]{{end}} [arguments...]{{if .Description}}
 
 DESCRIPTION:
-   {{.Description}}
+   {{.Description}}{{end}}{{if .Flags}}
 
 OPTIONS:
    {{range .Flags}}{{.}}
-   {{end}}
+   {{end}}{{ end }}
 `
 
 // The text template for the subcommand help topic.
@@ -51,14 +55,14 @@ var SubcommandHelpTemplate = `NAME:
    {{.Name}} - {{.Usage}}
 
 USAGE:
-   {{.Name}} [global options] command [command options] [arguments...]
+   {{.Name}} command{{if .Flags}} [command options]{{end}} [arguments...]
 
 COMMANDS:
    {{range .Commands}}{{.Name}}{{with .ShortName}}, {{.}}{{end}}{{ "\t" }}{{.Usage}}
-   {{end}}
+   {{end}}{{if .Flags}}
 OPTIONS:
    {{range .Flags}}{{.}}
-   {{end}}
+   {{end}}{{end}}
 `
 
 var helpCommand = Command{
@@ -92,6 +96,9 @@ var helpSubcommand = Command{
 // Prints help for the App
 var HelpPrinter = printHelp
 
+// Prints version for the App
+var VersionPrinter = printVersion
+
 func ShowAppHelp(c *Context) {
 	HelpPrinter(AppHelpTemplate, c.App)
 }
@@ -129,6 +136,10 @@ func ShowSubcommandHelp(c *Context) {
 
 // Prints the version number of the App
 func ShowVersion(c *Context) {
+	VersionPrinter(c)
+}
+
+func printVersion(c *Context) {
 	fmt.Printf("%v version %v\n", c.App.Name, c.App.Version)
 }
 
