commit d5900e8b63904daaf63d315d4c43fdcaaf023720
Author: Gyu-Ho Lee <gyuhox@gmail.com>
Date:   Mon Aug 15 12:10:21 2016 -0700

    vendor: migrate to glide

diff --git a/cmd/Godeps/Godeps.json b/cmd/Godeps/Godeps.json
deleted file mode 100644
index 48537cb..0000000
--- a/cmd/Godeps/Godeps.json
+++ /dev/null
@@ -1,293 +0,0 @@
-{
-	"ImportPath": "github.com/coreos/etcd",
-	"GoVersion": "devel-a6dbfc1",
-	"GodepVersion": "v74",
-	"Packages": [
-		"./..."
-	],
-	"Deps": [
-		{
-			"ImportPath": "bitbucket.org/ww/goautoneg",
-			"Comment": "null-5",
-			"Rev": "'75cd24fc2f2c2a2088577d12123ddee5f54e0675'"
-		},
-		{
-			"ImportPath": "github.com/akrennmair/gopcap",
-			"Rev": "00e11033259acb75598ba416495bb708d864a010"
-		},
-		{
-			"ImportPath": "github.com/beorn7/perks/quantile",
-			"Rev": "b965b613227fddccbfffe13eae360ed3fa822f8d"
-		},
-		{
-			"ImportPath": "github.com/bgentry/speakeasy",
-			"Rev": "36e9cfdd690967f4f690c6edcc9ffacd006014a0"
-		},
-		{
-			"ImportPath": "github.com/boltdb/bolt",
-			"Comment": "v1.2.1",
-			"Rev": "dfb21201d9270c1082d5fb0f07f500311ff72f18"
-		},
-		{
-			"ImportPath": "github.com/cockroachdb/cmux",
-			"Rev": "112f0506e7743d64a6eb8fedbcff13d9979bbf92"
-		},
-		{
-			"ImportPath": "github.com/coreos/go-semver/semver",
-			"Rev": "568e959cd89871e61434c1143528d9162da89ef2"
-		},
-		{
-			"ImportPath": "github.com/coreos/go-systemd/daemon",
-			"Comment": "v10-13-gd6c05a1d",
-			"Rev": "d6c05a1dcbb5ac02b7653da4d99e5db340c20778"
-		},
-		{
-			"ImportPath": "github.com/coreos/go-systemd/journal",
-			"Comment": "v10-13-gd6c05a1d",
-			"Rev": "d6c05a1dcbb5ac02b7653da4d99e5db340c20778"
-		},
-		{
-			"ImportPath": "github.com/coreos/go-systemd/util",
-			"Comment": "v10-13-gd6c05a1d",
-			"Rev": "d6c05a1dcbb5ac02b7653da4d99e5db340c20778"
-		},
-		{
-			"ImportPath": "github.com/coreos/pkg/capnslog",
-			"Comment": "v2-8-gfa29b1d",
-			"Rev": "fa29b1d70f0beaddd4c7021607cc3c3be8ce94b8"
-		},
-		{
-			"ImportPath": "github.com/cpuguy83/go-md2man/md2man",
-			"Comment": "v1.0.4",
-			"Rev": "71acacd42f85e5e82f70a55327789582a5200a90"
-		},
-		{
-			"ImportPath": "github.com/dustin/go-humanize",
-			"Rev": "8929fe90cee4b2cb9deb468b51fb34eba64d1bf0"
-		},
-		{
-			"ImportPath": "github.com/ghodss/yaml",
-			"Rev": "73d445a93680fa1a78ae23a5839bad48f32ba1ee"
-		},
-		{
-			"ImportPath": "github.com/gogo/protobuf/proto",
-			"Comment": "v0.2-33-ge18d7aa",
-			"Rev": "e18d7aa8f8c624c915db340349aad4c49b10d173"
-		},
-		{
-			"ImportPath": "github.com/golang/glog",
-			"Rev": "44145f04b68cf362d9c4df2182967c2275eaefed"
-		},
-		{
-			"ImportPath": "github.com/golang/groupcache/lru",
-			"Rev": "02826c3e79038b59d737d3b1c0a1d937f71a4433"
-		},
-		{
-			"ImportPath": "github.com/golang/protobuf/jsonpb",
-			"Rev": "8616e8ee5e20a1704615e6c8d7afcdac06087a67"
-		},
-		{
-			"ImportPath": "github.com/golang/protobuf/proto",
-			"Rev": "8616e8ee5e20a1704615e6c8d7afcdac06087a67"
-		},
-		{
-			"ImportPath": "github.com/google/btree",
-			"Rev": "7d79101e329e5a3adf994758c578dab82b90c017"
-		},
-		{
-			"ImportPath": "github.com/grpc-ecosystem/grpc-gateway/runtime",
-			"Comment": "v1.0.0-8-gf52d055",
-			"Rev": "f52d055dc48aec25854ed7d31862f78913cf17d1"
-		},
-		{
-			"ImportPath": "github.com/grpc-ecosystem/grpc-gateway/runtime/internal",
-			"Comment": "v1.0.0-8-gf52d055",
-			"Rev": "f52d055dc48aec25854ed7d31862f78913cf17d1"
-		},
-		{
-			"ImportPath": "github.com/grpc-ecosystem/grpc-gateway/utilities",
-			"Comment": "v1.0.0-8-gf52d055",
-			"Rev": "f52d055dc48aec25854ed7d31862f78913cf17d1"
-		},
-		{
-			"ImportPath": "github.com/inconshreveable/mousetrap",
-			"Rev": "76626ae9c91c4f2a10f34cad8ce83ea42c93bb75"
-		},
-		{
-			"ImportPath": "github.com/jonboulle/clockwork",
-			"Rev": "72f9bd7c4e0c2a40055ab3d0f09654f730cce982"
-		},
-		{
-			"ImportPath": "github.com/kballard/go-shellquote",
-			"Rev": "d8ec1a69a250a17bb0e419c386eac1f3711dc142"
-		},
-		{
-			"ImportPath": "github.com/kr/pty",
-			"Comment": "release.r56-29-gf7ee69f",
-			"Rev": "f7ee69f31298ecbe5d2b349c711e2547a617d398"
-		},
-		{
-			"ImportPath": "github.com/mattn/go-runewidth",
-			"Comment": "v0.0.1",
-			"Rev": "d6bea18f789704b5f83375793155289da36a3c7f"
-		},
-		{
-			"ImportPath": "github.com/matttproud/golang_protobuf_extensions/pbutil",
-			"Rev": "fc2b8d3a73c4867e51861bbdd5ae3c1f0869dd6a"
-		},
-		{
-			"ImportPath": "github.com/olekukonko/tablewriter",
-			"Rev": "cca8bbc0798408af109aaaa239cbd2634846b340"
-		},
-		{
-			"ImportPath": "github.com/prometheus/client_golang/prometheus",
-			"Comment": "0.7.0-52-ge51041b",
-			"Rev": "e51041b3fa41cece0dca035740ba6411905be473"
-		},
-		{
-			"ImportPath": "github.com/prometheus/client_model/go",
-			"Comment": "model-0.0.2-12-gfa8ad6f",
-			"Rev": "fa8ad6fec33561be4280a8f0514318c79d7f6cb6"
-		},
-		{
-			"ImportPath": "github.com/prometheus/common/expfmt",
-			"Rev": "ffe929a3f4c4faeaa10f2b9535c2b1be3ad15650"
-		},
-		{
-			"ImportPath": "github.com/prometheus/common/model",
-			"Rev": "ffe929a3f4c4faeaa10f2b9535c2b1be3ad15650"
-		},
-		{
-			"ImportPath": "github.com/prometheus/procfs",
-			"Rev": "454a56f35412459b5e684fd5ec0f9211b94f002a"
-		},
-		{
-			"ImportPath": "github.com/russross/blackfriday",
-			"Comment": "v1.4-2-g300106c",
-			"Rev": "300106c228d52c8941d4b3de6054a6062a86dda3"
-		},
-		{
-			"ImportPath": "github.com/shurcooL/sanitized_anchor_name",
-			"Rev": "10ef21a441db47d8b13ebcc5fd2310f636973c77"
-		},
-		{
-			"ImportPath": "github.com/spacejam/loghisto",
-			"Rev": "323309774dec8b7430187e46cd0793974ccca04a"
-		},
-		{
-			"ImportPath": "github.com/spf13/cobra",
-			"Rev": "1c44ec8d3f1552cac48999f9306da23c4d8a288b"
-		},
-		{
-			"ImportPath": "github.com/spf13/pflag",
-			"Rev": "08b1a584251b5b62f458943640fc8ebd4d50aaa5"
-		},
-		{
-			"ImportPath": "github.com/stretchr/testify/assert",
-			"Rev": "9cc77fa25329013ce07362c7742952ff887361f2"
-		},
-		{
-			"ImportPath": "github.com/ugorji/go/codec",
-			"Rev": "f1f1a805ed361a0e078bb537e4ea78cd37dcf065"
-		},
-		{
-			"ImportPath": "github.com/urfave/cli",
-			"Comment": "v1.17.0-79-g6011f16",
-			"Rev": "6011f165dc288c72abd8acd7722f837c5c64198d"
-		},
-		{
-			"ImportPath": "github.com/xiang90/probing",
-			"Rev": "95bd620af35406ab93d7f5bf320dba4b4667982e"
-		},
-		{
-			"ImportPath": "golang.org/x/crypto/bcrypt",
-			"Rev": "1351f936d976c60a0a48d728281922cf63eafb8d"
-		},
-		{
-			"ImportPath": "golang.org/x/crypto/blowfish",
-			"Rev": "1351f936d976c60a0a48d728281922cf63eafb8d"
-		},
-		{
-			"ImportPath": "golang.org/x/net/context",
-			"Rev": "6acef71eb69611914f7a30939ea9f6e194c78172"
-		},
-		{
-			"ImportPath": "golang.org/x/net/http2",
-			"Rev": "6acef71eb69611914f7a30939ea9f6e194c78172"
-		},
-		{
-			"ImportPath": "golang.org/x/net/http2/hpack",
-			"Rev": "6acef71eb69611914f7a30939ea9f6e194c78172"
-		},
-		{
-			"ImportPath": "golang.org/x/net/internal/timeseries",
-			"Rev": "6acef71eb69611914f7a30939ea9f6e194c78172"
-		},
-		{
-			"ImportPath": "golang.org/x/net/trace",
-			"Rev": "6acef71eb69611914f7a30939ea9f6e194c78172"
-		},
-		{
-			"ImportPath": "golang.org/x/sys/unix",
-			"Rev": "9c60d1c508f5134d1ca726b4641db998f2523357"
-		},
-		{
-			"ImportPath": "golang.org/x/time/rate",
-			"Rev": "a4bde12657593d5e90d0533a3e4fd95e635124cb"
-		},
-		{
-			"ImportPath": "google.golang.org/grpc",
-			"Comment": "v1.0.0-6-g02fca89",
-			"Rev": "02fca896ff5f50c6bbbee0860345a49344b37a03"
-		},
-		{
-			"ImportPath": "google.golang.org/grpc/codes",
-			"Comment": "v1.0.0-6-g02fca89",
-			"Rev": "02fca896ff5f50c6bbbee0860345a49344b37a03"
-		},
-		{
-			"ImportPath": "google.golang.org/grpc/credentials",
-			"Comment": "v1.0.0-6-g02fca89",
-			"Rev": "02fca896ff5f50c6bbbee0860345a49344b37a03"
-		},
-		{
-			"ImportPath": "google.golang.org/grpc/grpclog",
-			"Comment": "v1.0.0-6-g02fca89",
-			"Rev": "02fca896ff5f50c6bbbee0860345a49344b37a03"
-		},
-		{
-			"ImportPath": "google.golang.org/grpc/internal",
-			"Comment": "v1.0.0-6-g02fca89",
-			"Rev": "02fca896ff5f50c6bbbee0860345a49344b37a03"
-		},
-		{
-			"ImportPath": "google.golang.org/grpc/metadata",
-			"Comment": "v1.0.0-6-g02fca89",
-			"Rev": "02fca896ff5f50c6bbbee0860345a49344b37a03"
-		},
-		{
-			"ImportPath": "google.golang.org/grpc/naming",
-			"Comment": "v1.0.0-6-g02fca89",
-			"Rev": "02fca896ff5f50c6bbbee0860345a49344b37a03"
-		},
-		{
-			"ImportPath": "google.golang.org/grpc/peer",
-			"Comment": "v1.0.0-6-g02fca89",
-			"Rev": "02fca896ff5f50c6bbbee0860345a49344b37a03"
-		},
-		{
-			"ImportPath": "google.golang.org/grpc/transport",
-			"Comment": "v1.0.0-6-g02fca89",
-			"Rev": "02fca896ff5f50c6bbbee0860345a49344b37a03"
-		},
-		{
-			"ImportPath": "gopkg.in/cheggaaa/pb.v1",
-			"Comment": "v1.0.1",
-			"Rev": "29ad9b62f9e0274422d738242b94a5b89440bfa6"
-		},
-		{
-			"ImportPath": "gopkg.in/yaml.v2",
-			"Rev": "53feefa2559fb8dfa8d81baad31be332c97d6c77"
-		}
-	]
-}
diff --git a/cmd/Godeps/Readme b/cmd/Godeps/Readme
deleted file mode 100644
index 4cdaa53..0000000
--- a/cmd/Godeps/Readme
+++ /dev/null
@@ -1,5 +0,0 @@
-This directory tree is generated automatically by godep.
-
-Please do not edit.
-
-See https://github.com/tools/godep for more information.
diff --git a/cmd/vendor/bitbucket.org/ww/goautoneg/Makefile b/cmd/vendor/bitbucket.org/ww/goautoneg/Makefile
deleted file mode 100644
index e33ee17..0000000
--- a/cmd/vendor/bitbucket.org/ww/goautoneg/Makefile
+++ /dev/null
@@ -1,13 +0,0 @@
-include $(GOROOT)/src/Make.inc
-
-TARG=bitbucket.org/ww/goautoneg
-GOFILES=autoneg.go
-
-include $(GOROOT)/src/Make.pkg
-
-format:
-	gofmt -w *.go
-
-docs:
-	gomake clean
-	godoc ${TARG} > README.txt
diff --git a/cmd/vendor/bitbucket.org/ww/goautoneg/README.txt b/cmd/vendor/bitbucket.org/ww/goautoneg/README.txt
deleted file mode 100644
index 7723656..0000000
--- a/cmd/vendor/bitbucket.org/ww/goautoneg/README.txt
+++ /dev/null
@@ -1,67 +0,0 @@
-PACKAGE
-
-package goautoneg
-import "bitbucket.org/ww/goautoneg"
-
-HTTP Content-Type Autonegotiation.
-
-The functions in this package implement the behaviour specified in
-http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
-
-Copyright (c) 2011, Open Knowledge Foundation Ltd.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-    Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in
-    the documentation and/or other materials provided with the
-    distribution.
-
-    Neither the name of the Open Knowledge Foundation Ltd. nor the
-    names of its contributors may be used to endorse or promote
-    products derived from this software without specific prior written
-    permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-FUNCTIONS
-
-func Negotiate(header string, alternatives []string) (content_type string)
-Negotiate the most appropriate content_type given the accept header
-and a list of alternatives.
-
-func ParseAccept(header string) (accept []Accept)
-Parse an Accept Header string returning a sorted list
-of clauses
-
-
-TYPES
-
-type Accept struct {
-    Type, SubType string
-    Q             float32
-    Params        map[string]string
-}
-Structure to represent a clause in an HTTP Accept Header
-
-
-SUBDIRECTORIES
-
-	.hg
diff --git a/cmd/vendor/github.com/akrennmair/gopcap/.gitignore b/cmd/vendor/github.com/akrennmair/gopcap/.gitignore
deleted file mode 100644
index 99c61aa..0000000
--- a/cmd/vendor/github.com/akrennmair/gopcap/.gitignore
+++ /dev/null
@@ -1,5 +0,0 @@
-#*
-*~
-/tools/pass/pass
-/tools/pcaptest/pcaptest
-/tools/tcpdump/tcpdump
diff --git a/cmd/vendor/github.com/akrennmair/gopcap/README.mkd b/cmd/vendor/github.com/akrennmair/gopcap/README.mkd
deleted file mode 100644
index f30ff99..0000000
--- a/cmd/vendor/github.com/akrennmair/gopcap/README.mkd
+++ /dev/null
@@ -1,11 +0,0 @@
-# PCAP
-
-This is a simple wrapper around libpcap for Go.  Originally written by Andreas
-Krennmair <ak@synflood.at> and only minorly touched up by Mark Smith <mark@qq.is>.
-
-Please see the included pcaptest.go and tcpdump.go programs for instructions on
-how to use this library.
-
-Miek Gieben <miek@miek.nl> has created a more Go-like package and replaced functionality
-with standard functions from the standard library. The package has also been renamed to
-pcap.
diff --git a/cmd/vendor/github.com/beorn7/perks/quantile/exampledata.txt b/cmd/vendor/github.com/beorn7/perks/quantile/exampledata.txt
deleted file mode 100644
index 1602287..0000000
--- a/cmd/vendor/github.com/beorn7/perks/quantile/exampledata.txt
+++ /dev/null
@@ -1,2388 +0,0 @@
-8
-5
-26
-12
-5
-235
-13
-6
-28
-30
-3
-3
-3
-3
-5
-2
-33
-7
-2
-4
-7
-12
-14
-5
-8
-3
-10
-4
-5
-3
-6
-6
-209
-20
-3
-10
-14
-3
-4
-6
-8
-5
-11
-7
-3
-2
-3
-3
-212
-5
-222
-4
-10
-10
-5
-6
-3
-8
-3
-10
-254
-220
-2
-3
-5
-24
-5
-4
-222
-7
-3
-3
-223
-8
-15
-12
-14
-14
-3
-2
-2
-3
-13
-3
-11
-4
-4
-6
-5
-7
-13
-5
-3
-5
-2
-5
-3
-5
-2
-7
-15
-17
-14
-3
-6
-6
-3
-17
-5
-4
-7
-6
-4
-4
-8
-6
-8
-3
-9
-3
-6
-3
-4
-5
-3
-3
-660
-4
-6
-10
-3
-6
-3
-2
-5
-13
-2
-4
-4
-10
-4
-8
-4
-3
-7
-9
-9
-3
-10
-37
-3
-13
-4
-12
-3
-6
-10
-8
-5
-21
-2
-3
-8
-3
-2
-3
-3
-4
-12
-2
-4
-8
-8
-4
-3
-2
-20
-1
-6
-32
-2
-11
-6
-18
-3
-8
-11
-3
-212
-3
-4
-2
-6
-7
-12
-11
-3
-2
-16
-10
-6
-4
-6
-3
-2
-7
-3
-2
-2
-2
-2
-5
-6
-4
-3
-10
-3
-4
-6
-5
-3
-4
-4
-5
-6
-4
-3
-4
-4
-5
-7
-5
-5
-3
-2
-7
-2
-4
-12
-4
-5
-6
-2
-4
-4
-8
-4
-15
-13
-7
-16
-5
-3
-23
-5
-5
-7
-3
-2
-9
-8
-7
-5
-8
-11
-4
-10
-76
-4
-47
-4
-3
-2
-7
-4
-2
-3
-37
-10
-4
-2
-20
-5
-4
-4
-10
-10
-4
-3
-7
-23
-240
-7
-13
-5
-5
-3
-3
-2
-5
-4
-2
-8
-7
-19
-2
-23
-8
-7
-2
-5
-3
-8
-3
-8
-13
-5
-5
-5
-2
-3
-23
-4
-9
-8
-4
-3
-3
-5
-220
-2
-3
-4
-6
-14
-3
-53
-6
-2
-5
-18
-6
-3
-219
-6
-5
-2
-5
-3
-6
-5
-15
-4
-3
-17
-3
-2
-4
-7
-2
-3
-3
-4
-4
-3
-2
-664
-6
-3
-23
-5
-5
-16
-5
-8
-2
-4
-2
-24
-12
-3
-2
-3
-5
-8
-3
-5
-4
-3
-14
-3
-5
-8
-2
-3
-7
-9
-4
-2
-3
-6
-8
-4
-3
-4
-6
-5
-3
-3
-6
-3
-19
-4
-4
-6
-3
-6
-3
-5
-22
-5
-4
-4
-3
-8
-11
-4
-9
-7
-6
-13
-4
-4
-4
-6
-17
-9
-3
-3
-3
-4
-3
-221
-5
-11
-3
-4
-2
-12
-6
-3
-5
-7
-5
-7
-4
-9
-7
-14
-37
-19
-217
-16
-3
-5
-2
-2
-7
-19
-7
-6
-7
-4
-24
-5
-11
-4
-7
-7
-9
-13
-3
-4
-3
-6
-28
-4
-4
-5
-5
-2
-5
-6
-4
-4
-6
-10
-5
-4
-3
-2
-3
-3
-6
-5
-5
-4
-3
-2
-3
-7
-4
-6
-18
-16
-8
-16
-4
-5
-8
-6
-9
-13
-1545
-6
-215
-6
-5
-6
-3
-45
-31
-5
-2
-2
-4
-3
-3
-2
-5
-4
-3
-5
-7
-7
-4
-5
-8
-5
-4
-749
-2
-31
-9
-11
-2
-11
-5
-4
-4
-7
-9
-11
-4
-5
-4
-7
-3
-4
-6
-2
-15
-3
-4
-3
-4
-3
-5
-2
-13
-5
-5
-3
-3
-23
-4
-4
-5
-7
-4
-13
-2
-4
-3
-4
-2
-6
-2
-7
-3
-5
-5
-3
-29
-5
-4
-4
-3
-10
-2
-3
-79
-16
-6
-6
-7
-7
-3
-5
-5
-7
-4
-3
-7
-9
-5
-6
-5
-9
-6
-3
-6
-4
-17
-2
-10
-9
-3
-6
-2
-3
-21
-22
-5
-11
-4
-2
-17
-2
-224
-2
-14
-3
-4
-4
-2
-4
-4
-4
-4
-5
-3
-4
-4
-10
-2
-6
-3
-3
-5
-7
-2
-7
-5
-6
-3
-218
-2
-2
-5
-2
-6
-3
-5
-222
-14
-6
-33
-3
-2
-5
-3
-3
-3
-9
-5
-3
-3
-2
-7
-4
-3
-4
-3
-5
-6
-5
-26
-4
-13
-9
-7
-3
-221
-3
-3
-4
-4
-4
-4
-2
-18
-5
-3
-7
-9
-6
-8
-3
-10
-3
-11
-9
-5
-4
-17
-5
-5
-6
-6
-3
-2
-4
-12
-17
-6
-7
-218
-4
-2
-4
-10
-3
-5
-15
-3
-9
-4
-3
-3
-6
-29
-3
-3
-4
-5
-5
-3
-8
-5
-6
-6
-7
-5
-3
-5
-3
-29
-2
-31
-5
-15
-24
-16
-5
-207
-4
-3
-3
-2
-15
-4
-4
-13
-5
-5
-4
-6
-10
-2
-7
-8
-4
-6
-20
-5
-3
-4
-3
-12
-12
-5
-17
-7
-3
-3
-3
-6
-10
-3
-5
-25
-80
-4
-9
-3
-2
-11
-3
-3
-2
-3
-8
-7
-5
-5
-19
-5
-3
-3
-12
-11
-2
-6
-5
-5
-5
-3
-3
-3
-4
-209
-14
-3
-2
-5
-19
-4
-4
-3
-4
-14
-5
-6
-4
-13
-9
-7
-4
-7
-10
-2
-9
-5
-7
-2
-8
-4
-6
-5
-5
-222
-8
-7
-12
-5
-216
-3
-4
-4
-6
-3
-14
-8
-7
-13
-4
-3
-3
-3
-3
-17
-5
-4
-3
-33
-6
-6
-33
-7
-5
-3
-8
-7
-5
-2
-9
-4
-2
-233
-24
-7
-4
-8
-10
-3
-4
-15
-2
-16
-3
-3
-13
-12
-7
-5
-4
-207
-4
-2
-4
-27
-15
-2
-5
-2
-25
-6
-5
-5
-6
-13
-6
-18
-6
-4
-12
-225
-10
-7
-5
-2
-2
-11
-4
-14
-21
-8
-10
-3
-5
-4
-232
-2
-5
-5
-3
-7
-17
-11
-6
-6
-23
-4
-6
-3
-5
-4
-2
-17
-3
-6
-5
-8
-3
-2
-2
-14
-9
-4
-4
-2
-5
-5
-3
-7
-6
-12
-6
-10
-3
-6
-2
-2
-19
-5
-4
-4
-9
-2
-4
-13
-3
-5
-6
-3
-6
-5
-4
-9
-6
-3
-5
-7
-3
-6
-6
-4
-3
-10
-6
-3
-221
-3
-5
-3
-6
-4
-8
-5
-3
-6
-4
-4
-2
-54
-5
-6
-11
-3
-3
-4
-4
-4
-3
-7
-3
-11
-11
-7
-10
-6
-13
-223
-213
-15
-231
-7
-3
-7
-228
-2
-3
-4
-4
-5
-6
-7
-4
-13
-3
-4
-5
-3
-6
-4
-6
-7
-2
-4
-3
-4
-3
-3
-6
-3
-7
-3
-5
-18
-5
-6
-8
-10
-3
-3
-3
-2
-4
-2
-4
-4
-5
-6
-6
-4
-10
-13
-3
-12
-5
-12
-16
-8
-4
-19
-11
-2
-4
-5
-6
-8
-5
-6
-4
-18
-10
-4
-2
-216
-6
-6
-6
-2
-4
-12
-8
-3
-11
-5
-6
-14
-5
-3
-13
-4
-5
-4
-5
-3
-28
-6
-3
-7
-219
-3
-9
-7
-3
-10
-6
-3
-4
-19
-5
-7
-11
-6
-15
-19
-4
-13
-11
-3
-7
-5
-10
-2
-8
-11
-2
-6
-4
-6
-24
-6
-3
-3
-3
-3
-6
-18
-4
-11
-4
-2
-5
-10
-8
-3
-9
-5
-3
-4
-5
-6
-2
-5
-7
-4
-4
-14
-6
-4
-4
-5
-5
-7
-2
-4
-3
-7
-3
-3
-6
-4
-5
-4
-4
-4
-3
-3
-3
-3
-8
-14
-2
-3
-5
-3
-2
-4
-5
-3
-7
-3
-3
-18
-3
-4
-4
-5
-7
-3
-3
-3
-13
-5
-4
-8
-211
-5
-5
-3
-5
-2
-5
-4
-2
-655
-6
-3
-5
-11
-2
-5
-3
-12
-9
-15
-11
-5
-12
-217
-2
-6
-17
-3
-3
-207
-5
-5
-4
-5
-9
-3
-2
-8
-5
-4
-3
-2
-5
-12
-4
-14
-5
-4
-2
-13
-5
-8
-4
-225
-4
-3
-4
-5
-4
-3
-3
-6
-23
-9
-2
-6
-7
-233
-4
-4
-6
-18
-3
-4
-6
-3
-4
-4
-2
-3
-7
-4
-13
-227
-4
-3
-5
-4
-2
-12
-9
-17
-3
-7
-14
-6
-4
-5
-21
-4
-8
-9
-2
-9
-25
-16
-3
-6
-4
-7
-8
-5
-2
-3
-5
-4
-3
-3
-5
-3
-3
-3
-2
-3
-19
-2
-4
-3
-4
-2
-3
-4
-4
-2
-4
-3
-3
-3
-2
-6
-3
-17
-5
-6
-4
-3
-13
-5
-3
-3
-3
-4
-9
-4
-2
-14
-12
-4
-5
-24
-4
-3
-37
-12
-11
-21
-3
-4
-3
-13
-4
-2
-3
-15
-4
-11
-4
-4
-3
-8
-3
-4
-4
-12
-8
-5
-3
-3
-4
-2
-220
-3
-5
-223
-3
-3
-3
-10
-3
-15
-4
-241
-9
-7
-3
-6
-6
-23
-4
-13
-7
-3
-4
-7
-4
-9
-3
-3
-4
-10
-5
-5
-1
-5
-24
-2
-4
-5
-5
-6
-14
-3
-8
-2
-3
-5
-13
-13
-3
-5
-2
-3
-15
-3
-4
-2
-10
-4
-4
-4
-5
-5
-3
-5
-3
-4
-7
-4
-27
-3
-6
-4
-15
-3
-5
-6
-6
-5
-4
-8
-3
-9
-2
-6
-3
-4
-3
-7
-4
-18
-3
-11
-3
-3
-8
-9
-7
-24
-3
-219
-7
-10
-4
-5
-9
-12
-2
-5
-4
-4
-4
-3
-3
-19
-5
-8
-16
-8
-6
-22
-3
-23
-3
-242
-9
-4
-3
-3
-5
-7
-3
-3
-5
-8
-3
-7
-5
-14
-8
-10
-3
-4
-3
-7
-4
-6
-7
-4
-10
-4
-3
-11
-3
-7
-10
-3
-13
-6
-8
-12
-10
-5
-7
-9
-3
-4
-7
-7
-10
-8
-30
-9
-19
-4
-3
-19
-15
-4
-13
-3
-215
-223
-4
-7
-4
-8
-17
-16
-3
-7
-6
-5
-5
-4
-12
-3
-7
-4
-4
-13
-4
-5
-2
-5
-6
-5
-6
-6
-7
-10
-18
-23
-9
-3
-3
-6
-5
-2
-4
-2
-7
-3
-3
-2
-5
-5
-14
-10
-224
-6
-3
-4
-3
-7
-5
-9
-3
-6
-4
-2
-5
-11
-4
-3
-3
-2
-8
-4
-7
-4
-10
-7
-3
-3
-18
-18
-17
-3
-3
-3
-4
-5
-3
-3
-4
-12
-7
-3
-11
-13
-5
-4
-7
-13
-5
-4
-11
-3
-12
-3
-6
-4
-4
-21
-4
-6
-9
-5
-3
-10
-8
-4
-6
-4
-4
-6
-5
-4
-8
-6
-4
-6
-4
-4
-5
-9
-6
-3
-4
-2
-9
-3
-18
-2
-4
-3
-13
-3
-6
-6
-8
-7
-9
-3
-2
-16
-3
-4
-6
-3
-2
-33
-22
-14
-4
-9
-12
-4
-5
-6
-3
-23
-9
-4
-3
-5
-5
-3
-4
-5
-3
-5
-3
-10
-4
-5
-5
-8
-4
-4
-6
-8
-5
-4
-3
-4
-6
-3
-3
-3
-5
-9
-12
-6
-5
-9
-3
-5
-3
-2
-2
-2
-18
-3
-2
-21
-2
-5
-4
-6
-4
-5
-10
-3
-9
-3
-2
-10
-7
-3
-6
-6
-4
-4
-8
-12
-7
-3
-7
-3
-3
-9
-3
-4
-5
-4
-4
-5
-5
-10
-15
-4
-4
-14
-6
-227
-3
-14
-5
-216
-22
-5
-4
-2
-2
-6
-3
-4
-2
-9
-9
-4
-3
-28
-13
-11
-4
-5
-3
-3
-2
-3
-3
-5
-3
-4
-3
-5
-23
-26
-3
-4
-5
-6
-4
-6
-3
-5
-5
-3
-4
-3
-2
-2
-2
-7
-14
-3
-6
-7
-17
-2
-2
-15
-14
-16
-4
-6
-7
-13
-6
-4
-5
-6
-16
-3
-3
-28
-3
-6
-15
-3
-9
-2
-4
-6
-3
-3
-22
-4
-12
-6
-7
-2
-5
-4
-10
-3
-16
-6
-9
-2
-5
-12
-7
-5
-5
-5
-5
-2
-11
-9
-17
-4
-3
-11
-7
-3
-5
-15
-4
-3
-4
-211
-8
-7
-5
-4
-7
-6
-7
-6
-3
-6
-5
-6
-5
-3
-4
-4
-26
-4
-6
-10
-4
-4
-3
-2
-3
-3
-4
-5
-9
-3
-9
-4
-4
-5
-5
-8
-2
-4
-2
-3
-8
-4
-11
-19
-5
-8
-6
-3
-5
-6
-12
-3
-2
-4
-16
-12
-3
-4
-4
-8
-6
-5
-6
-6
-219
-8
-222
-6
-16
-3
-13
-19
-5
-4
-3
-11
-6
-10
-4
-7
-7
-12
-5
-3
-3
-5
-6
-10
-3
-8
-2
-5
-4
-7
-2
-4
-4
-2
-12
-9
-6
-4
-2
-40
-2
-4
-10
-4
-223
-4
-2
-20
-6
-7
-24
-5
-4
-5
-2
-20
-16
-6
-5
-13
-2
-3
-3
-19
-3
-2
-4
-5
-6
-7
-11
-12
-5
-6
-7
-7
-3
-5
-3
-5
-3
-14
-3
-4
-4
-2
-11
-1
-7
-3
-9
-6
-11
-12
-5
-8
-6
-221
-4
-2
-12
-4
-3
-15
-4
-5
-226
-7
-218
-7
-5
-4
-5
-18
-4
-5
-9
-4
-4
-2
-9
-18
-18
-9
-5
-6
-6
-3
-3
-7
-3
-5
-4
-4
-4
-12
-3
-6
-31
-5
-4
-7
-3
-6
-5
-6
-5
-11
-2
-2
-11
-11
-6
-7
-5
-8
-7
-10
-5
-23
-7
-4
-3
-5
-34
-2
-5
-23
-7
-3
-6
-8
-4
-4
-4
-2
-5
-3
-8
-5
-4
-8
-25
-2
-3
-17
-8
-3
-4
-8
-7
-3
-15
-6
-5
-7
-21
-9
-5
-6
-6
-5
-3
-2
-3
-10
-3
-6
-3
-14
-7
-4
-4
-8
-7
-8
-2
-6
-12
-4
-213
-6
-5
-21
-8
-2
-5
-23
-3
-11
-2
-3
-6
-25
-2
-3
-6
-7
-6
-6
-4
-4
-6
-3
-17
-9
-7
-6
-4
-3
-10
-7
-2
-3
-3
-3
-11
-8
-3
-7
-6
-4
-14
-36
-3
-4
-3
-3
-22
-13
-21
-4
-2
-7
-4
-4
-17
-15
-3
-7
-11
-2
-4
-7
-6
-209
-6
-3
-2
-2
-24
-4
-9
-4
-3
-3
-3
-29
-2
-2
-4
-3
-3
-5
-4
-6
-3
-3
-2
-4
diff --git a/cmd/vendor/github.com/bgentry/speakeasy/.gitignore b/cmd/vendor/github.com/bgentry/speakeasy/.gitignore
deleted file mode 100644
index 9e13114..0000000
--- a/cmd/vendor/github.com/bgentry/speakeasy/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-example/example
-example/example.exe
diff --git a/cmd/vendor/github.com/bgentry/speakeasy/Readme.md b/cmd/vendor/github.com/bgentry/speakeasy/Readme.md
deleted file mode 100644
index fceda75..0000000
--- a/cmd/vendor/github.com/bgentry/speakeasy/Readme.md
+++ /dev/null
@@ -1,30 +0,0 @@
-# Speakeasy
-
-This package provides cross-platform Go (#golang) helpers for taking user input
-from the terminal while not echoing the input back (similar to `getpasswd`). The
-package uses syscalls to avoid any dependence on cgo, and is therefore
-compatible with cross-compiling.
-
-[![GoDoc](https://godoc.org/github.com/bgentry/speakeasy?status.png)][godoc]
-
-## Unicode
-
-Multi-byte unicode characters work successfully on Mac OS X. On Windows,
-however, this may be problematic (as is UTF in general on Windows). Other
-platforms have not been tested.
-
-## License
-
-The code herein was not written by me, but was compiled from two separate open
-source packages. Unix portions were imported from [gopass][gopass], while
-Windows portions were imported from the [CloudFoundry Go CLI][cf-cli]'s
-[Windows terminal helpers][cf-ui-windows].
-
-The [license for the windows portion](./LICENSE_WINDOWS) has been copied exactly
-from the source (though I attempted to fill in the correct owner in the
-boilerplate copyright notice).
-
-[cf-cli]: https://github.com/cloudfoundry/cli "CloudFoundry Go CLI"
-[cf-ui-windows]: https://github.com/cloudfoundry/cli/blob/master/src/cf/terminal/ui_windows.go "CloudFoundry Go CLI Windows input helpers"
-[godoc]: https://godoc.org/github.com/bgentry/speakeasy "speakeasy on Godoc.org"
-[gopass]: https://code.google.com/p/gopass "gopass"
diff --git a/cmd/vendor/github.com/boltdb/bolt/.gitignore b/cmd/vendor/github.com/boltdb/bolt/.gitignore
deleted file mode 100644
index c7bd2b7..0000000
--- a/cmd/vendor/github.com/boltdb/bolt/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-*.prof
-*.test
-*.swp
-/bin/
diff --git a/cmd/vendor/github.com/boltdb/bolt/Makefile b/cmd/vendor/github.com/boltdb/bolt/Makefile
deleted file mode 100644
index e035e63..0000000
--- a/cmd/vendor/github.com/boltdb/bolt/Makefile
+++ /dev/null
@@ -1,18 +0,0 @@
-BRANCH=`git rev-parse --abbrev-ref HEAD`
-COMMIT=`git rev-parse --short HEAD`
-GOLDFLAGS="-X main.branch $(BRANCH) -X main.commit $(COMMIT)"
-
-default: build
-
-race:
-	@go test -v -race -test.run="TestSimulate_(100op|1000op)"
-
-# go get github.com/kisielk/errcheck
-errcheck:
-	@errcheck -ignorepkg=bytes -ignore=os:Remove github.com/boltdb/bolt
-
-test: 
-	@go test -v -cover .
-	@go test -v ./cmd/bolt
-
-.PHONY: fmt test
diff --git a/cmd/vendor/github.com/boltdb/bolt/README.md b/cmd/vendor/github.com/boltdb/bolt/README.md
deleted file mode 100644
index 3bff3cc..0000000
--- a/cmd/vendor/github.com/boltdb/bolt/README.md
+++ /dev/null
@@ -1,850 +0,0 @@
-Bolt [![Coverage Status](https://coveralls.io/repos/boltdb/bolt/badge.svg?branch=master)](https://coveralls.io/r/boltdb/bolt?branch=master) [![GoDoc](https://godoc.org/github.com/boltdb/bolt?status.svg)](https://godoc.org/github.com/boltdb/bolt) ![Version](https://img.shields.io/badge/version-1.0-green.svg)
-====
-
-Bolt is a pure Go key/value store inspired by [Howard Chu's][hyc_symas]
-[LMDB project][lmdb]. The goal of the project is to provide a simple,
-fast, and reliable database for projects that don't require a full database
-server such as Postgres or MySQL.
-
-Since Bolt is meant to be used as such a low-level piece of functionality,
-simplicity is key. The API will be small and only focus on getting values
-and setting values. That's it.
-
-[hyc_symas]: https://twitter.com/hyc_symas
-[lmdb]: http://symas.com/mdb/
-
-## Project Status
-
-Bolt is stable and the API is fixed. Full unit test coverage and randomized
-black box testing are used to ensure database consistency and thread safety.
-Bolt is currently in high-load production environments serving databases as
-large as 1TB. Many companies such as Shopify and Heroku use Bolt-backed
-services every day.
-
-## Table of Contents
-
-- [Getting Started](#getting-started)
-  - [Installing](#installing)
-  - [Opening a database](#opening-a-database)
-  - [Transactions](#transactions)
-    - [Read-write transactions](#read-write-transactions)
-    - [Read-only transactions](#read-only-transactions)
-    - [Batch read-write transactions](#batch-read-write-transactions)
-    - [Managing transactions manually](#managing-transactions-manually)
-  - [Using buckets](#using-buckets)
-  - [Using key/value pairs](#using-keyvalue-pairs)
-  - [Autoincrementing integer for the bucket](#autoincrementing-integer-for-the-bucket)
-  - [Iterating over keys](#iterating-over-keys)
-    - [Prefix scans](#prefix-scans)
-    - [Range scans](#range-scans)
-    - [ForEach()](#foreach)
-  - [Nested buckets](#nested-buckets)
-  - [Database backups](#database-backups)
-  - [Statistics](#statistics)
-  - [Read-Only Mode](#read-only-mode)
-  - [Mobile Use (iOS/Android)](#mobile-use-iosandroid)
-- [Resources](#resources)
-- [Comparison with other databases](#comparison-with-other-databases)
-  - [Postgres, MySQL, & other relational databases](#postgres-mysql--other-relational-databases)
-  - [LevelDB, RocksDB](#leveldb-rocksdb)
-  - [LMDB](#lmdb)
-- [Caveats & Limitations](#caveats--limitations)
-- [Reading the Source](#reading-the-source)
-- [Other Projects Using Bolt](#other-projects-using-bolt)
-
-## Getting Started
-
-### Installing
-
-To start using Bolt, install Go and run `go get`:
-
-```sh
-$ go get github.com/boltdb/bolt/...
-```
-
-This will retrieve the library and install the `bolt` command line utility into
-your `$GOBIN` path.
-
-
-### Opening a database
-
-The top-level object in Bolt is a `DB`. It is represented as a single file on
-your disk and represents a consistent snapshot of your data.
-
-To open your database, simply use the `bolt.Open()` function:
-
-```go
-package main
-
-import (
-	"log"
-
-	"github.com/boltdb/bolt"
-)
-
-func main() {
-	// Open the my.db data file in your current directory.
-	// It will be created if it doesn't exist.
-	db, err := bolt.Open("my.db", 0600, nil)
-	if err != nil {
-		log.Fatal(err)
-	}
-	defer db.Close()
-
-	...
-}
-```
-
-Please note that Bolt obtains a file lock on the data file so multiple processes
-cannot open the same database at the same time. Opening an already open Bolt
-database will cause it to hang until the other process closes it. To prevent
-an indefinite wait you can pass a timeout option to the `Open()` function:
-
-```go
-db, err := bolt.Open("my.db", 0600, &bolt.Options{Timeout: 1 * time.Second})
-```
-
-
-### Transactions
-
-Bolt allows only one read-write transaction at a time but allows as many
-read-only transactions as you want at a time. Each transaction has a consistent
-view of the data as it existed when the transaction started.
-
-Individual transactions and all objects created from them (e.g. buckets, keys)
-are not thread safe. To work with data in multiple goroutines you must start
-a transaction for each one or use locking to ensure only one goroutine accesses
-a transaction at a time. Creating transaction from the `DB` is thread safe.
-
-Read-only transactions and read-write transactions should not depend on one
-another and generally shouldn't be opened simultaneously in the same goroutine.
-This can cause a deadlock as the read-write transaction needs to periodically
-re-map the data file but it cannot do so while a read-only transaction is open.
-
-
-#### Read-write transactions
-
-To start a read-write transaction, you can use the `DB.Update()` function:
-
-```go
-err := db.Update(func(tx *bolt.Tx) error {
-	...
-	return nil
-})
-```
-
-Inside the closure, you have a consistent view of the database. You commit the
-transaction by returning `nil` at the end. You can also rollback the transaction
-at any point by returning an error. All database operations are allowed inside
-a read-write transaction.
-
-Always check the return error as it will report any disk failures that can cause
-your transaction to not complete. If you return an error within your closure
-it will be passed through.
-
-
-#### Read-only transactions
-
-To start a read-only transaction, you can use the `DB.View()` function:
-
-```go
-err := db.View(func(tx *bolt.Tx) error {
-	...
-	return nil
-})
-```
-
-You also get a consistent view of the database within this closure, however,
-no mutating operations are allowed within a read-only transaction. You can only
-retrieve buckets, retrieve values, and copy the database within a read-only
-transaction.
-
-
-#### Batch read-write transactions
-
-Each `DB.Update()` waits for disk to commit the writes. This overhead
-can be minimized by combining multiple updates with the `DB.Batch()`
-function:
-
-```go
-err := db.Batch(func(tx *bolt.Tx) error {
-	...
-	return nil
-})
-```
-
-Concurrent Batch calls are opportunistically combined into larger
-transactions. Batch is only useful when there are multiple goroutines
-calling it.
-
-The trade-off is that `Batch` can call the given
-function multiple times, if parts of the transaction fail. The
-function must be idempotent and side effects must take effect only
-after a successful return from `DB.Batch()`.
-
-For example: don't display messages from inside the function, instead
-set variables in the enclosing scope:
-
-```go
-var id uint64
-err := db.Batch(func(tx *bolt.Tx) error {
-	// Find last key in bucket, decode as bigendian uint64, increment
-	// by one, encode back to []byte, and add new key.
-	...
-	id = newValue
-	return nil
-})
-if err != nil {
-	return ...
-}
-fmt.Println("Allocated ID %d", id)
-```
-
-
-#### Managing transactions manually
-
-The `DB.View()` and `DB.Update()` functions are wrappers around the `DB.Begin()`
-function. These helper functions will start the transaction, execute a function,
-and then safely close your transaction if an error is returned. This is the
-recommended way to use Bolt transactions.
-
-However, sometimes you may want to manually start and end your transactions.
-You can use the `Tx.Begin()` function directly but **please** be sure to close
-the transaction.
-
-```go
-// Start a writable transaction.
-tx, err := db.Begin(true)
-if err != nil {
-    return err
-}
-defer tx.Rollback()
-
-// Use the transaction...
-_, err := tx.CreateBucket([]byte("MyBucket"))
-if err != nil {
-    return err
-}
-
-// Commit the transaction and check for error.
-if err := tx.Commit(); err != nil {
-    return err
-}
-```
-
-The first argument to `DB.Begin()` is a boolean stating if the transaction
-should be writable.
-
-
-### Using buckets
-
-Buckets are collections of key/value pairs within the database. All keys in a
-bucket must be unique. You can create a bucket using the `DB.CreateBucket()`
-function:
-
-```go
-db.Update(func(tx *bolt.Tx) error {
-	b, err := tx.CreateBucket([]byte("MyBucket"))
-	if err != nil {
-		return fmt.Errorf("create bucket: %s", err)
-	}
-	return nil
-})
-```
-
-You can also create a bucket only if it doesn't exist by using the
-`Tx.CreateBucketIfNotExists()` function. It's a common pattern to call this
-function for all your top-level buckets after you open your database so you can
-guarantee that they exist for future transactions.
-
-To delete a bucket, simply call the `Tx.DeleteBucket()` function.
-
-
-### Using key/value pairs
-
-To save a key/value pair to a bucket, use the `Bucket.Put()` function:
-
-```go
-db.Update(func(tx *bolt.Tx) error {
-	b := tx.Bucket([]byte("MyBucket"))
-	err := b.Put([]byte("answer"), []byte("42"))
-	return err
-})
-```
-
-This will set the value of the `"answer"` key to `"42"` in the `MyBucket`
-bucket. To retrieve this value, we can use the `Bucket.Get()` function:
-
-```go
-db.View(func(tx *bolt.Tx) error {
-	b := tx.Bucket([]byte("MyBucket"))
-	v := b.Get([]byte("answer"))
-	fmt.Printf("The answer is: %s\n", v)
-	return nil
-})
-```
-
-The `Get()` function does not return an error because its operation is
-guaranteed to work (unless there is some kind of system failure). If the key
-exists then it will return its byte slice value. If it doesn't exist then it
-will return `nil`. It's important to note that you can have a zero-length value
-set to a key which is different than the key not existing.
-
-Use the `Bucket.Delete()` function to delete a key from the bucket.
-
-Please note that values returned from `Get()` are only valid while the
-transaction is open. If you need to use a value outside of the transaction
-then you must use `copy()` to copy it to another byte slice.
-
-
-### Autoincrementing integer for the bucket
-By using the `NextSequence()` function, you can let Bolt determine a sequence
-which can be used as the unique identifier for your key/value pairs. See the
-example below.
-
-```go
-// CreateUser saves u to the store. The new user ID is set on u once the data is persisted.
-func (s *Store) CreateUser(u *User) error {
-    return s.db.Update(func(tx *bolt.Tx) error {
-        // Retrieve the users bucket.
-        // This should be created when the DB is first opened.
-        b := tx.Bucket([]byte("users"))
-
-        // Generate ID for the user.
-        // This returns an error only if the Tx is closed or not writeable.
-        // That can't happen in an Update() call so I ignore the error check.
-        id, _ = b.NextSequence()
-        u.ID = int(id)
-
-        // Marshal user data into bytes.
-        buf, err := json.Marshal(u)
-        if err != nil {
-            return err
-        }
-
-        // Persist bytes to users bucket.
-        return b.Put(itob(u.ID), buf)
-    })
-}
-
-// itob returns an 8-byte big endian representation of v.
-func itob(v int) []byte {
-    b := make([]byte, 8)
-    binary.BigEndian.PutUint64(b, uint64(v))
-    return b
-}
-
-type User struct {
-    ID int
-    ...
-}
-```
-
-### Iterating over keys
-
-Bolt stores its keys in byte-sorted order within a bucket. This makes sequential
-iteration over these keys extremely fast. To iterate over keys we'll use a
-`Cursor`:
-
-```go
-db.View(func(tx *bolt.Tx) error {
-	// Assume bucket exists and has keys
-	b := tx.Bucket([]byte("MyBucket"))
-
-	c := b.Cursor()
-
-	for k, v := c.First(); k != nil; k, v = c.Next() {
-		fmt.Printf("key=%s, value=%s\n", k, v)
-	}
-
-	return nil
-})
-```
-
-The cursor allows you to move to a specific point in the list of keys and move
-forward or backward through the keys one at a time.
-
-The following functions are available on the cursor:
-
-```
-First()  Move to the first key.
-Last()   Move to the last key.
-Seek()   Move to a specific key.
-Next()   Move to the next key.
-Prev()   Move to the previous key.
-```
-
-Each of those functions has a return signature of `(key []byte, value []byte)`.
-When you have iterated to the end of the cursor then `Next()` will return a
-`nil` key.  You must seek to a position using `First()`, `Last()`, or `Seek()`
-before calling `Next()` or `Prev()`. If you do not seek to a position then
-these functions will return a `nil` key.
-
-During iteration, if the key is non-`nil` but the value is `nil`, that means
-the key refers to a bucket rather than a value.  Use `Bucket.Bucket()` to
-access the sub-bucket.
-
-
-#### Prefix scans
-
-To iterate over a key prefix, you can combine `Seek()` and `bytes.HasPrefix()`:
-
-```go
-db.View(func(tx *bolt.Tx) error {
-	// Assume bucket exists and has keys
-	c := tx.Bucket([]byte("MyBucket")).Cursor()
-
-	prefix := []byte("1234")
-	for k, v := c.Seek(prefix); bytes.HasPrefix(k, prefix); k, v = c.Next() {
-		fmt.Printf("key=%s, value=%s\n", k, v)
-	}
-
-	return nil
-})
-```
-
-#### Range scans
-
-Another common use case is scanning over a range such as a time range. If you
-use a sortable time encoding such as RFC3339 then you can query a specific
-date range like this:
-
-```go
-db.View(func(tx *bolt.Tx) error {
-	// Assume our events bucket exists and has RFC3339 encoded time keys.
-	c := tx.Bucket([]byte("Events")).Cursor()
-
-	// Our time range spans the 90's decade.
-	min := []byte("1990-01-01T00:00:00Z")
-	max := []byte("2000-01-01T00:00:00Z")
-
-	// Iterate over the 90's.
-	for k, v := c.Seek(min); k != nil && bytes.Compare(k, max) <= 0; k, v = c.Next() {
-		fmt.Printf("%s: %s\n", k, v)
-	}
-
-	return nil
-})
-```
-
-Note that, while RFC3339 is sortable, the Golang implementation of RFC3339Nano does not use a fixed number of digits after the decimal point and is therefore not sortable.
-
-
-#### ForEach()
-
-You can also use the function `ForEach()` if you know you'll be iterating over
-all the keys in a bucket:
-
-```go
-db.View(func(tx *bolt.Tx) error {
-	// Assume bucket exists and has keys
-	b := tx.Bucket([]byte("MyBucket"))
-
-	b.ForEach(func(k, v []byte) error {
-		fmt.Printf("key=%s, value=%s\n", k, v)
-		return nil
-	})
-	return nil
-})
-```
-
-
-### Nested buckets
-
-You can also store a bucket in a key to create nested buckets. The API is the
-same as the bucket management API on the `DB` object:
-
-```go
-func (*Bucket) CreateBucket(key []byte) (*Bucket, error)
-func (*Bucket) CreateBucketIfNotExists(key []byte) (*Bucket, error)
-func (*Bucket) DeleteBucket(key []byte) error
-```
-
-
-### Database backups
-
-Bolt is a single file so it's easy to backup. You can use the `Tx.WriteTo()`
-function to write a consistent view of the database to a writer. If you call
-this from a read-only transaction, it will perform a hot backup and not block
-your other database reads and writes.
-
-By default, it will use a regular file handle which will utilize the operating
-system's page cache. See the [`Tx`](https://godoc.org/github.com/boltdb/bolt#Tx)
-documentation for information about optimizing for larger-than-RAM datasets.
-
-One common use case is to backup over HTTP so you can use tools like `cURL` to
-do database backups:
-
-```go
-func BackupHandleFunc(w http.ResponseWriter, req *http.Request) {
-	err := db.View(func(tx *bolt.Tx) error {
-		w.Header().Set("Content-Type", "application/octet-stream")
-		w.Header().Set("Content-Disposition", `attachment; filename="my.db"`)
-		w.Header().Set("Content-Length", strconv.Itoa(int(tx.Size())))
-		_, err := tx.WriteTo(w)
-		return err
-	})
-	if err != nil {
-		http.Error(w, err.Error(), http.StatusInternalServerError)
-	}
-}
-```
-
-Then you can backup using this command:
-
-```sh
-$ curl http://localhost/backup > my.db
-```
-
-Or you can open your browser to `http://localhost/backup` and it will download
-automatically.
-
-If you want to backup to another file you can use the `Tx.CopyFile()` helper
-function.
-
-
-### Statistics
-
-The database keeps a running count of many of the internal operations it
-performs so you can better understand what's going on. By grabbing a snapshot
-of these stats at two points in time we can see what operations were performed
-in that time range.
-
-For example, we could start a goroutine to log stats every 10 seconds:
-
-```go
-go func() {
-	// Grab the initial stats.
-	prev := db.Stats()
-
-	for {
-		// Wait for 10s.
-		time.Sleep(10 * time.Second)
-
-		// Grab the current stats and diff them.
-		stats := db.Stats()
-		diff := stats.Sub(&prev)
-
-		// Encode stats to JSON and print to STDERR.
-		json.NewEncoder(os.Stderr).Encode(diff)
-
-		// Save stats for the next loop.
-		prev = stats
-	}
-}()
-```
-
-It's also useful to pipe these stats to a service such as statsd for monitoring
-or to provide an HTTP endpoint that will perform a fixed-length sample.
-
-
-### Read-Only Mode
-
-Sometimes it is useful to create a shared, read-only Bolt database. To this,
-set the `Options.ReadOnly` flag when opening your database. Read-only mode
-uses a shared lock to allow multiple processes to read from the database but
-it will block any processes from opening the database in read-write mode.
-
-```go
-db, err := bolt.Open("my.db", 0666, &bolt.Options{ReadOnly: true})
-if err != nil {
-	log.Fatal(err)
-}
-```
-
-### Mobile Use (iOS/Android)
-
-Bolt is able to run on mobile devices by leveraging the binding feature of the
-[gomobile](https://github.com/golang/mobile) tool. Create a struct that will
-contain your database logic and a reference to a `*bolt.DB` with a initializing
-contstructor that takes in a filepath where the database file will be stored.
-Neither Android nor iOS require extra permissions or cleanup from using this method.
-
-```go
-func NewBoltDB(filepath string) *BoltDB {
-	db, err := bolt.Open(filepath+"/demo.db", 0600, nil)
-	if err != nil {
-		log.Fatal(err)
-	}
-
-	return &BoltDB{db}
-}
-
-type BoltDB struct {
-	db *bolt.DB
-	...
-}
-
-func (b *BoltDB) Path() string {
-	return b.db.Path()
-}
-
-func (b *BoltDB) Close() {
-	b.db.Close()
-}
-```
-
-Database logic should be defined as methods on this wrapper struct.
-
-To initialize this struct from the native language (both platforms now sync
-their local storage to the cloud. These snippets disable that functionality for the
-database file):
-
-#### Android
-
-```java
-String path;
-if (android.os.Build.VERSION.SDK_INT >=android.os.Build.VERSION_CODES.LOLLIPOP){
-    path = getNoBackupFilesDir().getAbsolutePath();
-} else{
-    path = getFilesDir().getAbsolutePath();
-}
-Boltmobiledemo.BoltDB boltDB = Boltmobiledemo.NewBoltDB(path)
-```
-
-#### iOS
-
-```objc
-- (void)demo {
-    NSString* path = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,
-                                                          NSUserDomainMask,
-                                                          YES) objectAtIndex:0];
-	GoBoltmobiledemoBoltDB * demo = GoBoltmobiledemoNewBoltDB(path);
-	[self addSkipBackupAttributeToItemAtPath:demo.path];
-	//Some DB Logic would go here
-	[demo close];
-}
-
-- (BOOL)addSkipBackupAttributeToItemAtPath:(NSString *) filePathString
-{
-    NSURL* URL= [NSURL fileURLWithPath: filePathString];
-    assert([[NSFileManager defaultManager] fileExistsAtPath: [URL path]]);
-
-    NSError *error = nil;
-    BOOL success = [URL setResourceValue: [NSNumber numberWithBool: YES]
-                                  forKey: NSURLIsExcludedFromBackupKey error: &error];
-    if(!success){
-        NSLog(@"Error excluding %@ from backup %@", [URL lastPathComponent], error);
-    }
-    return success;
-}
-
-```
-
-## Resources
-
-For more information on getting started with Bolt, check out the following articles:
-
-* [Intro to BoltDB: Painless Performant Persistence](http://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/) by [Nate Finch](https://github.com/natefinch).
-* [Bolt -- an embedded key/value database for Go](https://www.progville.com/go/bolt-embedded-db-golang/) by Progville
-
-
-## Comparison with other databases
-
-### Postgres, MySQL, & other relational databases
-
-Relational databases structure data into rows and are only accessible through
-the use of SQL. This approach provides flexibility in how you store and query
-your data but also incurs overhead in parsing and planning SQL statements. Bolt
-accesses all data by a byte slice key. This makes Bolt fast to read and write
-data by key but provides no built-in support for joining values together.
-
-Most relational databases (with the exception of SQLite) are standalone servers
-that run separately from your application. This gives your systems
-flexibility to connect multiple application servers to a single database
-server but also adds overhead in serializing and transporting data over the
-network. Bolt runs as a library included in your application so all data access
-has to go through your application's process. This brings data closer to your
-application but limits multi-process access to the data.
-
-
-### LevelDB, RocksDB
-
-LevelDB and its derivatives (RocksDB, HyperLevelDB) are similar to Bolt in that
-they are libraries bundled into the application, however, their underlying
-structure is a log-structured merge-tree (LSM tree). An LSM tree optimizes
-random writes by using a write ahead log and multi-tiered, sorted files called
-SSTables. Bolt uses a B+tree internally and only a single file. Both approaches
-have trade-offs.
-
-If you require a high random write throughput (>10,000 w/sec) or you need to use
-spinning disks then LevelDB could be a good choice. If your application is
-read-heavy or does a lot of range scans then Bolt could be a good choice.
-
-One other important consideration is that LevelDB does not have transactions.
-It supports batch writing of key/values pairs and it supports read snapshots
-but it will not give you the ability to do a compare-and-swap operation safely.
-Bolt supports fully serializable ACID transactions.
-
-
-### LMDB
-
-Bolt was originally a port of LMDB so it is architecturally similar. Both use
-a B+tree, have ACID semantics with fully serializable transactions, and support
-lock-free MVCC using a single writer and multiple readers.
-
-The two projects have somewhat diverged. LMDB heavily focuses on raw performance
-while Bolt has focused on simplicity and ease of use. For example, LMDB allows
-several unsafe actions such as direct writes for the sake of performance. Bolt
-opts to disallow actions which can leave the database in a corrupted state. The
-only exception to this in Bolt is `DB.NoSync`.
-
-There are also a few differences in API. LMDB requires a maximum mmap size when
-opening an `mdb_env` whereas Bolt will handle incremental mmap resizing
-automatically. LMDB overloads the getter and setter functions with multiple
-flags whereas Bolt splits these specialized cases into their own functions.
-
-
-## Caveats & Limitations
-
-It's important to pick the right tool for the job and Bolt is no exception.
-Here are a few things to note when evaluating and using Bolt:
-
-* Bolt is good for read intensive workloads. Sequential write performance is
-  also fast but random writes can be slow. You can use `DB.Batch()` or add a
-  write-ahead log to help mitigate this issue.
-
-* Bolt uses a B+tree internally so there can be a lot of random page access.
-  SSDs provide a significant performance boost over spinning disks.
-
-* Try to avoid long running read transactions. Bolt uses copy-on-write so
-  old pages cannot be reclaimed while an old transaction is using them.
-
-* Byte slices returned from Bolt are only valid during a transaction. Once the
-  transaction has been committed or rolled back then the memory they point to
-  can be reused by a new page or can be unmapped from virtual memory and you'll
-  see an `unexpected fault address` panic when accessing it.
-
-* Be careful when using `Bucket.FillPercent`. Setting a high fill percent for
-  buckets that have random inserts will cause your database to have very poor
-  page utilization.
-
-* Use larger buckets in general. Smaller buckets causes poor page utilization
-  once they become larger than the page size (typically 4KB).
-
-* Bulk loading a lot of random writes into a new bucket can be slow as the
-  page will not split until the transaction is committed. Randomly inserting
-  more than 100,000 key/value pairs into a single new bucket in a single
-  transaction is not advised.
-
-* Bolt uses a memory-mapped file so the underlying operating system handles the
-  caching of the data. Typically, the OS will cache as much of the file as it
-  can in memory and will release memory as needed to other processes. This means
-  that Bolt can show very high memory usage when working with large databases.
-  However, this is expected and the OS will release memory as needed. Bolt can
-  handle databases much larger than the available physical RAM, provided its
-  memory-map fits in the process virtual address space. It may be problematic
-  on 32-bits systems.
-
-* The data structures in the Bolt database are memory mapped so the data file
-  will be endian specific. This means that you cannot copy a Bolt file from a
-  little endian machine to a big endian machine and have it work. For most
-  users this is not a concern since most modern CPUs are little endian.
-
-* Because of the way pages are laid out on disk, Bolt cannot truncate data files
-  and return free pages back to the disk. Instead, Bolt maintains a free list
-  of unused pages within its data file. These free pages can be reused by later
-  transactions. This works well for many use cases as databases generally tend
-  to grow. However, it's important to note that deleting large chunks of data
-  will not allow you to reclaim that space on disk.
-
-  For more information on page allocation, [see this comment][page-allocation].
-
-[page-allocation]: https://github.com/boltdb/bolt/issues/308#issuecomment-74811638
-
-
-## Reading the Source
-
-Bolt is a relatively small code base (<3KLOC) for an embedded, serializable,
-transactional key/value database so it can be a good starting point for people
-interested in how databases work.
-
-The best places to start are the main entry points into Bolt:
-
-- `Open()` - Initializes the reference to the database. It's responsible for
-  creating the database if it doesn't exist, obtaining an exclusive lock on the
-  file, reading the meta pages, & memory-mapping the file.
-
-- `DB.Begin()` - Starts a read-only or read-write transaction depending on the
-  value of the `writable` argument. This requires briefly obtaining the "meta"
-  lock to keep track of open transactions. Only one read-write transaction can
-  exist at a time so the "rwlock" is acquired during the life of a read-write
-  transaction.
-
-- `Bucket.Put()` - Writes a key/value pair into a bucket. After validating the
-  arguments, a cursor is used to traverse the B+tree to the page and position
-  where they key & value will be written. Once the position is found, the bucket
-  materializes the underlying page and the page's parent pages into memory as
-  "nodes". These nodes are where mutations occur during read-write transactions.
-  These changes get flushed to disk during commit.
-
-- `Bucket.Get()` - Retrieves a key/value pair from a bucket. This uses a cursor
-  to move to the page & position of a key/value pair. During a read-only
-  transaction, the key and value data is returned as a direct reference to the
-  underlying mmap file so there's no allocation overhead. For read-write
-  transactions, this data may reference the mmap file or one of the in-memory
-  node values.
-
-- `Cursor` - This object is simply for traversing the B+tree of on-disk pages
-  or in-memory nodes. It can seek to a specific key, move to the first or last
-  value, or it can move forward or backward. The cursor handles the movement up
-  and down the B+tree transparently to the end user.
-
-- `Tx.Commit()` - Converts the in-memory dirty nodes and the list of free pages
-  into pages to be written to disk. Writing to disk then occurs in two phases.
-  First, the dirty pages are written to disk and an `fsync()` occurs. Second, a
-  new meta page with an incremented transaction ID is written and another
-  `fsync()` occurs. This two phase write ensures that partially written data
-  pages are ignored in the event of a crash since the meta page pointing to them
-  is never written. Partially written meta pages are invalidated because they
-  are written with a checksum.
-
-If you have additional notes that could be helpful for others, please submit
-them via pull request.
-
-
-## Other Projects Using Bolt
-
-Below is a list of public, open source projects that use Bolt:
-
-* [Operation Go: A Routine Mission](http://gocode.io) - An online programming game for Golang using Bolt for user accounts and a leaderboard.
-* [Bazil](https://bazil.org/) - A file system that lets your data reside where it is most convenient for it to reside.
-* [DVID](https://github.com/janelia-flyem/dvid) - Added Bolt as optional storage engine and testing it against Basho-tuned leveldb.
-* [Skybox Analytics](https://github.com/skybox/skybox) - A standalone funnel analysis tool for web analytics.
-* [Scuttlebutt](https://github.com/benbjohnson/scuttlebutt) - Uses Bolt to store and process all Twitter mentions of GitHub projects.
-* [Wiki](https://github.com/peterhellberg/wiki) - A tiny wiki using Goji, BoltDB and Blackfriday.
-* [ChainStore](https://github.com/pressly/chainstore) - Simple key-value interface to a variety of storage engines organized as a chain of operations.
-* [MetricBase](https://github.com/msiebuhr/MetricBase) - Single-binary version of Graphite.
-* [Gitchain](https://github.com/gitchain/gitchain) - Decentralized, peer-to-peer Git repositories aka "Git meets Bitcoin".
-* [event-shuttle](https://github.com/sclasen/event-shuttle) - A Unix system service to collect and reliably deliver messages to Kafka.
-* [ipxed](https://github.com/kelseyhightower/ipxed) - Web interface and api for ipxed.
-* [BoltStore](https://github.com/yosssi/boltstore) - Session store using Bolt.
-* [photosite/session](https://godoc.org/bitbucket.org/kardianos/photosite/session) - Sessions for a photo viewing site.
-* [LedisDB](https://github.com/siddontang/ledisdb) - A high performance NoSQL, using Bolt as optional storage.
-* [ipLocator](https://github.com/AndreasBriese/ipLocator) - A fast ip-geo-location-server using bolt with bloom filters.
-* [cayley](https://github.com/google/cayley) - Cayley is an open-source graph database using Bolt as optional backend.
-* [bleve](http://www.blevesearch.com/) - A pure Go search engine similar to ElasticSearch that uses Bolt as the default storage backend.
-* [tentacool](https://github.com/optiflows/tentacool) - REST api server to manage system stuff (IP, DNS, Gateway...) on a linux server.
-* [SkyDB](https://github.com/skydb/sky) - Behavioral analytics database.
-* [Seaweed File System](https://github.com/chrislusf/seaweedfs) - Highly scalable distributed key~file system with O(1) disk read.
-* [InfluxDB](https://influxdata.com) - Scalable datastore for metrics, events, and real-time analytics.
-* [Freehold](http://tshannon.bitbucket.org/freehold/) - An open, secure, and lightweight platform for your files and data.
-* [Prometheus Annotation Server](https://github.com/oliver006/prom_annotation_server) - Annotation server for PromDash & Prometheus service monitoring system.
-* [Consul](https://github.com/hashicorp/consul) - Consul is service discovery and configuration made easy. Distributed, highly available, and datacenter-aware.
-* [Kala](https://github.com/ajvb/kala) - Kala is a modern job scheduler optimized to run on a single node. It is persistent, JSON over HTTP API, ISO 8601 duration notation, and dependent jobs.
-* [drive](https://github.com/odeke-em/drive) - drive is an unofficial Google Drive command line client for \*NIX operating systems.
-* [stow](https://github.com/djherbis/stow) -  a persistence manager for objects
-  backed by boltdb.
-* [buckets](https://github.com/joyrexus/buckets) - a bolt wrapper streamlining
-  simple tx and key scans.
-* [mbuckets](https://github.com/abhigupta912/mbuckets) - A Bolt wrapper that allows easy operations on multi level (nested) buckets.
-* [Request Baskets](https://github.com/darklynx/request-baskets) - A web service to collect arbitrary HTTP requests and inspect them via REST API or simple web UI, similar to [RequestBin](http://requestb.in/) service
-* [Go Report Card](https://goreportcard.com/) - Go code quality report cards as a (free and open source) service.
-* [Boltdb Boilerplate](https://github.com/bobintornado/boltdb-boilerplate) - Boilerplate wrapper around bolt aiming to make simple calls one-liners.
-* [lru](https://github.com/crowdriff/lru) - Easy to use Bolt-backed Least-Recently-Used (LRU) read-through cache with chainable remote stores.
-* [Storm](https://github.com/asdine/storm) - A simple ORM around BoltDB.
-* [GoWebApp](https://github.com/josephspurrier/gowebapp) - A basic MVC web application in Go using BoltDB.
-* [SimpleBolt](https://github.com/xyproto/simplebolt) - A simple way to use BoltDB. Deals mainly with strings.
-* [Algernon](https://github.com/xyproto/algernon) - A HTTP/2 web server with built-in support for Lua. Uses BoltDB as the default database backend.
-
-If you are using Bolt in a project please send a pull request to add it to the list.
diff --git a/cmd/vendor/github.com/boltdb/bolt/appveyor.yml b/cmd/vendor/github.com/boltdb/bolt/appveyor.yml
deleted file mode 100644
index 6e26e94..0000000
--- a/cmd/vendor/github.com/boltdb/bolt/appveyor.yml
+++ /dev/null
@@ -1,18 +0,0 @@
-version: "{build}"
-
-os: Windows Server 2012 R2
-
-clone_folder: c:\gopath\src\github.com\boltdb\bolt
-
-environment:
-  GOPATH: c:\gopath
-
-install:
-  - echo %PATH%
-  - echo %GOPATH%
-  - go version
-  - go env
-  - go get -v -t ./...
-
-build_script:
-  - go test -v ./...
diff --git a/cmd/vendor/github.com/cockroachdb/cmux/.gitignore b/cmd/vendor/github.com/cockroachdb/cmux/.gitignore
deleted file mode 100644
index daf913b..0000000
--- a/cmd/vendor/github.com/cockroachdb/cmux/.gitignore
+++ /dev/null
@@ -1,24 +0,0 @@
-# Compiled Object files, Static and Dynamic libs (Shared Objects)
-*.o
-*.a
-*.so
-
-# Folders
-_obj
-_test
-
-# Architecture specific extensions/prefixes
-*.[568vq]
-[568vq].out
-
-*.cgo1.go
-*.cgo2.c
-_cgo_defun.c
-_cgo_gotypes.go
-_cgo_export.*
-
-_testmain.go
-
-*.exe
-*.test
-*.prof
diff --git a/cmd/vendor/github.com/cockroachdb/cmux/.travis.yml b/cmd/vendor/github.com/cockroachdb/cmux/.travis.yml
deleted file mode 100644
index e73780f..0000000
--- a/cmd/vendor/github.com/cockroachdb/cmux/.travis.yml
+++ /dev/null
@@ -1,22 +0,0 @@
-language: go
-
-go:
-  - 1.3
-  - 1.4
-  - 1.5
-  - 1.6
-
-gobuild_args: -race
-
-before_install:
-  - go get -u github.com/golang/lint/golint
-  - if [[ $TRAVIS_GO_VERSION == 1.5* ]]; then go get -u github.com/kisielk/errcheck; fi
-  - go get -u golang.org/x/tools/cmd/vet
-
-before_script:
-  - '! gofmt -s -l . | read'
-  - golint ./...
-  - echo $TRAVIS_GO_VERSION
-  - if [[ $TRAVIS_GO_VERSION == 1.5* ]]; then errcheck ./...; fi
-  - go vet .
-  - go tool vet --shadow .
diff --git a/cmd/vendor/github.com/cockroachdb/cmux/README.md b/cmd/vendor/github.com/cockroachdb/cmux/README.md
deleted file mode 100644
index b3713da..0000000
--- a/cmd/vendor/github.com/cockroachdb/cmux/README.md
+++ /dev/null
@@ -1,65 +0,0 @@
-# cmux: Connection Mux [![Build Status](https://travis-ci.org/cockroachdb/cmux.svg?branch=master)](https://travis-ci.org/cockroachdb/cmux) [![GoDoc](https://godoc.org/github.com/cockroachdb/cmux?status.svg)](https://godoc.org/github.com/cockroachdb/cmux)
-
-cmux is a generic Go library to multiplex connections based on their payload.
-Using cmux, you can serve gRPC, SSH, HTTPS, HTTP, Go RPC, and pretty much any
-other protocol on the same TCP listener.
-
-## How-To
-Simply create your main listener, create a cmux for that listener,
-and then match connections:
-```go
-// Create the main listener.
-l, err := net.Listen("tcp", ":23456")
-if err != nil {
-	log.Fatal(err)
-}
-
-// Create a cmux.
-m := cmux.New(l)
-
-// Match connections in order:
-// First grpc, then HTTP, and otherwise Go RPC/TCP.
-grpcL := m.Match(cmux.HTTP2HeaderField("content-type", "application/grpc"))
-httpL := m.Match(cmux.HTTP1Fast())
-trpcL := m.Match(cmux.Any()) // Any means anything that is not yet matched.
-
-// Create your protocol servers.
-grpcS := grpc.NewServer()
-grpchello.RegisterGreeterServer(grpcs, &server{})
-
-httpS := &http.Server{
-	Handler: &helloHTTP1Handler{},
-}
-
-trpcS := rpc.NewServer()
-s.Register(&ExampleRPCRcvr{})
-
-// Use the muxed listeners for your servers.
-go grpcS.Serve(grpcL)
-go httpS.Serve(httpL)
-go trpcS.Accept(trpcL)
-
-// Start serving!
-m.Serve()
-```
-
-There are [more examples on GoDoc](https://godoc.org/github.com/cockroachdb/cmux#pkg-examples).
-
-## Performance
-Since we are only matching the very first bytes of a connection, the
-performance overhead on long-lived connections (i.e., RPCs and pipelined HTTP
-streams) is negligible.
-
-## Limitations
-* *TLS*: `net/http` uses a [type assertion](https://github.com/golang/go/issues/14221)
-to identify TLS connections; since cmux's lookahead-implementing connection
-wraps the underlying TLS connection, this type assertion fails. This means you
-can serve HTTPS using cmux but `http.Request.TLS` will not be set in your
-handlers. If you are able to wrap TLS around cmux, you can work around this
-limitation. See https://github.com/cockroachdb/cockroach/commit/83caba2 for an
-example of this approach.
-
-* *Different Protocols on The Same Connection*: `cmux` matches the connection
-when it's accepted. For example, one connection can be either gRPC or REST, but
-not both. That is, we assume that a client connection is either used for gRPC
-or REST.
diff --git a/cmd/vendor/github.com/coreos/go-semver/example.go b/cmd/vendor/github.com/coreos/go-semver/example.go
new file mode 100644
index 0000000..fd2ee5a
--- /dev/null
+++ b/cmd/vendor/github.com/coreos/go-semver/example.go
@@ -0,0 +1,20 @@
+package main
+
+import (
+	"fmt"
+	"github.com/coreos/go-semver/semver"
+	"os"
+)
+
+func main() {
+	vA, err := semver.NewVersion(os.Args[1])
+	if err != nil {
+		fmt.Println(err.Error())
+	}
+	vB, err := semver.NewVersion(os.Args[2])
+	if err != nil {
+		fmt.Println(err.Error())
+	}
+
+	fmt.Printf("%s < %s == %t\n", vA, vB, vA.LessThan(*vB))
+}
diff --git a/cmd/vendor/github.com/coreos/go-systemd/util/util.go b/cmd/vendor/github.com/coreos/go-systemd/util/util.go
index 3a2f9e1..e4ed8b2 100644
--- a/cmd/vendor/github.com/coreos/go-systemd/util/util.go
+++ b/cmd/vendor/github.com/coreos/go-systemd/util/util.go
@@ -54,11 +54,16 @@ package util
 // {
 //   return (getsid(0) == getpid());
 // }
+import "C"
 import (
 	"fmt"
 	"io/ioutil"
 	"os"
 	"strings"
+	"syscall"
+	"unsafe"
+
+	"github.com/coreos/pkg/dlopen"
 )
 
 var libsystemdNames = []string{
@@ -71,6 +76,132 @@ var libsystemdNames = []string{
 	"libsystemd.so",
 }
 
+// GetRunningSlice attempts to retrieve the name of the systemd slice in which
+// the current process is running.
+// This function is a wrapper around the libsystemd C library; if it cannot be
+// opened, an error is returned.
+func GetRunningSlice() (slice string, err error) {
+	var h *dlopen.LibHandle
+	h, err = dlopen.GetHandle(libsystemdNames)
+	if err != nil {
+		return
+	}
+	defer func() {
+		if err1 := h.Close(); err1 != nil {
+			err = err1
+		}
+	}()
+
+	sd_pid_get_slice, err := h.GetSymbolPointer("sd_pid_get_slice")
+	if err != nil {
+		return
+	}
+
+	var s string
+	sl := C.CString(s)
+	defer C.free(unsafe.Pointer(sl))
+
+	ret := C.my_sd_pid_get_slice(sd_pid_get_slice, 0, &sl)
+	if ret < 0 {
+		err = fmt.Errorf("error calling sd_pid_get_slice: %v", syscall.Errno(-ret))
+		return
+	}
+
+	return C.GoString(sl), nil
+}
+
+// RunningFromSystemService tries to detect whether the current process has
+// been invoked from a system service. The condition for this is whether the
+// process is _not_ a user process. User processes are those running in session
+// scopes or under per-user `systemd --user` instances.
+//
+// To avoid false positives on systems without `pam_systemd` (which is
+// responsible for creating user sessions), this function also uses a heuristic
+// to detect whether it's being invoked from a session leader process. This is
+// the case if the current process is executed directly from a service file
+// (e.g. with `ExecStart=/this/cmd`). Note that this heuristic will fail if the
+// command is instead launched in a subshell or similar so that it is not
+// session leader (e.g. `ExecStart=/bin/bash -c "/this/cmd"`)
+//
+// This function is a wrapper around the libsystemd C library; if this is
+// unable to successfully open a handle to the library for any reason (e.g. it
+// cannot be found), an errr will be returned
+func RunningFromSystemService() (ret bool, err error) {
+	var h *dlopen.LibHandle
+	h, err = dlopen.GetHandle(libsystemdNames)
+	if err != nil {
+		return
+	}
+	defer func() {
+		if err1 := h.Close(); err1 != nil {
+			err = err1
+		}
+	}()
+
+	sd_pid_get_owner_uid, err := h.GetSymbolPointer("sd_pid_get_owner_uid")
+	if err != nil {
+		return
+	}
+
+	var uid C.uid_t
+	errno := C.my_sd_pid_get_owner_uid(sd_pid_get_owner_uid, 0, &uid)
+	serrno := syscall.Errno(-errno)
+	// when we're running from a unit file, sd_pid_get_owner_uid returns
+	// ENOENT (systemd <220) or ENXIO (systemd >=220)
+	switch {
+	case errno >= 0:
+		ret = false
+	case serrno == syscall.ENOENT, serrno == syscall.ENXIO:
+		// Since the implementation of sessions in systemd relies on
+		// the `pam_systemd` module, using the sd_pid_get_owner_uid
+		// heuristic alone can result in false positives if that module
+		// (or PAM itself) is not present or properly configured on the
+		// system. As such, we also check if we're the session leader,
+		// which should be the case if we're invoked from a unit file,
+		// but not if e.g. we're invoked from the command line from a
+		// user's login session
+		ret = C.am_session_leader() == 1
+	default:
+		err = fmt.Errorf("error calling sd_pid_get_owner_uid: %v", syscall.Errno(-errno))
+	}
+	return
+}
+
+// CurrentUnitName attempts to retrieve the name of the systemd system unit
+// from which the calling process has been invoked. It wraps the systemd
+// `sd_pid_get_unit` call, with the same caveat: for processes not part of a
+// systemd system unit, this function will return an error.
+func CurrentUnitName() (unit string, err error) {
+	var h *dlopen.LibHandle
+	h, err = dlopen.GetHandle(libsystemdNames)
+	if err != nil {
+		return
+	}
+	defer func() {
+		if err1 := h.Close(); err1 != nil {
+			err = err1
+		}
+	}()
+
+	sd_pid_get_unit, err := h.GetSymbolPointer("sd_pid_get_unit")
+	if err != nil {
+		return
+	}
+
+	var s string
+	u := C.CString(s)
+	defer C.free(unsafe.Pointer(u))
+
+	ret := C.my_sd_pid_get_unit(sd_pid_get_unit, 0, &u)
+	if ret < 0 {
+		err = fmt.Errorf("error calling sd_pid_get_unit: %v", syscall.Errno(-ret))
+		return
+	}
+
+	unit = C.GoString(u)
+	return
+}
+
 // IsRunningSystemd checks whether the host was booted with systemd as its init
 // system. This functions similarly to systemd's `sd_booted(3)`: internally, it
 // checks whether /run/systemd/system/ exists and is a directory.
diff --git a/cmd/vendor/github.com/coreos/pkg/capnslog/README.md b/cmd/vendor/github.com/coreos/pkg/capnslog/README.md
deleted file mode 100644
index 81efb1f..0000000
--- a/cmd/vendor/github.com/coreos/pkg/capnslog/README.md
+++ /dev/null
@@ -1,39 +0,0 @@
-# capnslog, the CoreOS logging package
-
-There are far too many logging packages out there, with varying degrees of licenses, far too many features (colorization, all sorts of log frameworks) or are just a pain to use (lack of `Fatalln()`?).
-capnslog provides a simple but consistent logging interface suitable for all kinds of projects.
-
-### Design Principles
-
-##### `package main` is the place where logging gets turned on and routed
-
-A library should not touch log options, only generate log entries. Libraries are silent until main lets them speak.
-
-##### All log options are runtime-configurable. 
-
-Still the job of `main` to expose these configurations. `main` may delegate this to, say, a configuration webhook, but does so explicitly. 
-
-##### There is one log object per package. It is registered under its repository and package name.
-
-`main` activates logging for its repository and any dependency repositories it would also like to have output in its logstream. `main` also dictates at which level each subpackage logs.
-
-##### There is *one* output stream, and it is an `io.Writer` composed with a formatter.
-
-Splitting streams is probably not the job of your program, but rather, your log aggregation framework. If you must split output streams, again, `main` configures this and you can write a very simple two-output struct that satisfies io.Writer.
-
-Fancy colorful formatting and JSON output are beyond the scope of a basic logging framework -- they're application/log-collector dependant. These are, at best, provided as options, but more likely, provided by your application.
-
-##### Log objects are an interface
-
-An object knows best how to print itself. Log objects can collect more interesting metadata if they wish, however, because text isn't going away anytime soon, they must all be marshalable to text. The simplest log object is a string, which returns itself. If you wish to do more fancy tricks for printing your log objects, see also JSON output -- introspect and write a formatter which can handle your advanced log interface. Making strings is the only thing guaranteed.
-
-##### Log levels have specific meanings:
-
-  * Critical: Unrecoverable. Must fail.
-  * Error: Data has been lost, a request has failed for a bad reason, or a required resource has been lost
-  * Warning: (Hopefully) Temporary conditions that may cause errors, but may work fine. A replica disappearing (that may reconnect) is a warning.
-  * Notice: Normal, but important (uncommon) log information.
-  * Info: Normal, working log information, everything is fine, but helpful notices for auditing or common operations.
-  * Debug: Everything is still fine, but even common operations may be logged, and less helpful but more quantity of notices.
-  * Trace: Anything goes, from logging every function call as part of a common operation, to tracing execution of a query.
-
diff --git a/cmd/vendor/github.com/coreos/pkg/dlopen/dlopen.go b/cmd/vendor/github.com/coreos/pkg/dlopen/dlopen.go
new file mode 100644
index 0000000..23774f6
--- /dev/null
+++ b/cmd/vendor/github.com/coreos/pkg/dlopen/dlopen.go
@@ -0,0 +1,82 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package dlopen provides some convenience functions to dlopen a library and
+// get its symbols.
+package dlopen
+
+// #cgo LDFLAGS: -ldl
+// #include <stdlib.h>
+// #include <dlfcn.h>
+import "C"
+import (
+	"errors"
+	"fmt"
+	"unsafe"
+)
+
+var ErrSoNotFound = errors.New("unable to open a handle to the library")
+
+// LibHandle represents an open handle to a library (.so)
+type LibHandle struct {
+	Handle  unsafe.Pointer
+	Libname string
+}
+
+// GetHandle tries to get a handle to a library (.so), attempting to access it
+// by the names specified in libs and returning the first that is successfully
+// opened. Callers are responsible for closing the handler. If no library can
+// be successfully opened, an error is returned.
+func GetHandle(libs []string) (*LibHandle, error) {
+	for _, name := range libs {
+		libname := C.CString(name)
+		defer C.free(unsafe.Pointer(libname))
+		handle := C.dlopen(libname, C.RTLD_LAZY)
+		if handle != nil {
+			h := &LibHandle{
+				Handle:  handle,
+				Libname: name,
+			}
+			return h, nil
+		}
+	}
+	return nil, ErrSoNotFound
+}
+
+// GetSymbolPointer takes a symbol name and returns a pointer to the symbol.
+func (l *LibHandle) GetSymbolPointer(symbol string) (unsafe.Pointer, error) {
+	sym := C.CString(symbol)
+	defer C.free(unsafe.Pointer(sym))
+
+	C.dlerror()
+	p := C.dlsym(l.Handle, sym)
+	e := C.dlerror()
+	if e != nil {
+		return nil, fmt.Errorf("error resolving symbol %q: %v", symbol, errors.New(C.GoString(e)))
+	}
+
+	return p, nil
+}
+
+// Close closes a LibHandle.
+func (l *LibHandle) Close() error {
+	C.dlerror()
+	C.dlclose(l.Handle)
+	e := C.dlerror()
+	if e != nil {
+		return fmt.Errorf("error closing %v: %v", l.Libname, errors.New(C.GoString(e)))
+	}
+
+	return nil
+}
diff --git a/cmd/vendor/github.com/coreos/pkg/dlopen/dlopen_example.go b/cmd/vendor/github.com/coreos/pkg/dlopen/dlopen_example.go
new file mode 100644
index 0000000..48a6601
--- /dev/null
+++ b/cmd/vendor/github.com/coreos/pkg/dlopen/dlopen_example.go
@@ -0,0 +1,56 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// +build linux
+
+package dlopen
+
+// #include <string.h>
+// #include <stdlib.h>
+//
+// int
+// my_strlen(void *f, const char *s)
+// {
+//   size_t (*strlen)(const char *);
+//
+//   strlen = (size_t (*)(const char *))f;
+//   return strlen(s);
+// }
+import "C"
+
+import (
+	"fmt"
+	"unsafe"
+)
+
+func strlen(libs []string, s string) (int, error) {
+	h, err := GetHandle(libs)
+	if err != nil {
+		return -1, fmt.Errorf(`couldn't get a handle to the library: %v`, err)
+	}
+	defer h.Close()
+
+	f := "strlen"
+	cs := C.CString(s)
+	defer C.free(unsafe.Pointer(cs))
+
+	strlen, err := h.GetSymbolPointer(f)
+	if err != nil {
+		return -1, fmt.Errorf(`couldn't get symbol %q: %v`, f, err)
+	}
+
+	len := C.my_strlen(strlen, cs)
+
+	return int(len), nil
+}
diff --git a/cmd/vendor/github.com/cpuguy83/go-md2man/md2man.go b/cmd/vendor/github.com/cpuguy83/go-md2man/md2man.go
new file mode 100644
index 0000000..1dc70f4
--- /dev/null
+++ b/cmd/vendor/github.com/cpuguy83/go-md2man/md2man.go
@@ -0,0 +1,44 @@
+package main
+
+import (
+	"flag"
+	"fmt"
+	"io/ioutil"
+	"os"
+
+	"github.com/cpuguy83/go-md2man/md2man"
+)
+
+var inFilePath = flag.String("in", "", "Path to file to be processed")
+var outFilePath = flag.String("out", "", "Path to output processed file")
+
+func main() {
+	flag.Parse()
+
+	inFile, err := os.Open(*inFilePath)
+	if err != nil {
+		fmt.Println(err)
+		os.Exit(1)
+	}
+	defer inFile.Close()
+
+	doc, err := ioutil.ReadAll(inFile)
+	if err != nil {
+		fmt.Println(err)
+		os.Exit(1)
+	}
+
+	out := md2man.Render(doc)
+
+	outFile, err := os.Create(*outFilePath)
+	if err != nil {
+		fmt.Println(err)
+		os.Exit(1)
+	}
+	defer outFile.Close()
+	_, err = outFile.Write(out)
+	if err != nil {
+		fmt.Println(err)
+		os.Exit(1)
+	}
+}
diff --git a/cmd/vendor/github.com/dustin/go-humanize/.gitignore b/cmd/vendor/github.com/dustin/go-humanize/.gitignore
deleted file mode 100644
index 05b4051..0000000
--- a/cmd/vendor/github.com/dustin/go-humanize/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-#*
-*.[568]
-*.a
-*~
-[568].out
-_*
diff --git a/cmd/vendor/github.com/dustin/go-humanize/README.markdown b/cmd/vendor/github.com/dustin/go-humanize/README.markdown
deleted file mode 100644
index 5fcdfa4..0000000
--- a/cmd/vendor/github.com/dustin/go-humanize/README.markdown
+++ /dev/null
@@ -1,92 +0,0 @@
-# Humane Units
-
-Just a few functions for helping humanize times and sizes.
-
-`go get` it as `github.com/dustin/go-humanize`, import it as
-`"github.com/dustin/go-humanize"`, use it as `humanize`
-
-See [godoc](https://godoc.org/github.com/dustin/go-humanize) for
-complete documentation.
-
-## Sizes
-
-This lets you take numbers like `82854982` and convert them to useful
-strings like, `83MB` or `79MiB` (whichever you prefer).
-
-Example:
-
-```go
-fmt.Printf("That file is %s.", humanize.Bytes(82854982))
-```
-
-## Times
-
-This lets you take a `time.Time` and spit it out in relative terms.
-For example, `12 seconds ago` or `3 days from now`.
-
-Example:
-
-```go
-fmt.Printf("This was touched %s", humanize.Time(someTimeInstance))
-```
-
-Thanks to Kyle Lemons for the time implementation from an IRC
-conversation one day.  It's pretty neat.
-
-## Ordinals
-
-From a [mailing list discussion][odisc] where a user wanted to be able
-to label ordinals.
-
-    0 -> 0th
-    1 -> 1st
-    2 -> 2nd
-    3 -> 3rd
-    4 -> 4th
-    [...]
-
-Example:
-
-```go
-fmt.Printf("You're my %s best friend.", humanize.Ordinal(193))
-```
-
-## Commas
-
-Want to shove commas into numbers?  Be my guest.
-
-    0 -> 0
-    100 -> 100
-    1000 -> 1,000
-    1000000000 -> 1,000,000,000
-    -100000 -> -100,000
-
-Example:
-
-```go
-fmt.Printf("You owe $%s.\n", humanize.Comma(6582491))
-```
-
-## Ftoa
-
-Nicer float64 formatter that removes trailing zeros.
-
-```go
-fmt.Printf("%f", 2.24)                   // 2.240000
-fmt.Printf("%s", humanize.Ftoa(2.24))    // 2.24
-fmt.Printf("%f", 2.0)                    // 2.000000
-fmt.Printf("%s", humanize.Ftoa(2.0))     // 2
-```
-
-## SI notation
-
-Format numbers with [SI notation][sinotation].
-
-Example:
-
-```go
-humanize.SI(0.00000000223, "M")    // 2.23nM
-```
-
-[odisc]: https://groups.google.com/d/topic/golang-nuts/l8NhI74jl-4/discussion
-[sinotation]: http://en.wikipedia.org/wiki/Metric_prefix
diff --git a/cmd/vendor/github.com/ghodss/yaml/.gitignore b/cmd/vendor/github.com/ghodss/yaml/.gitignore
deleted file mode 100644
index e256a31..0000000
--- a/cmd/vendor/github.com/ghodss/yaml/.gitignore
+++ /dev/null
@@ -1,20 +0,0 @@
-# OSX leaves these everywhere on SMB shares
-._*
-
-# Eclipse files
-.classpath
-.project
-.settings/**
-
-# Emacs save files
-*~
-
-# Vim-related files
-[._]*.s[a-w][a-z]
-[._]s[a-w][a-z]
-*.un~
-Session.vim
-.netrwhist
-
-# Go test binaries
-*.test
diff --git a/cmd/vendor/github.com/ghodss/yaml/.travis.yml b/cmd/vendor/github.com/ghodss/yaml/.travis.yml
deleted file mode 100644
index 0e9d6ed..0000000
--- a/cmd/vendor/github.com/ghodss/yaml/.travis.yml
+++ /dev/null
@@ -1,7 +0,0 @@
-language: go
-go:
-  - 1.3
-  - 1.4
-script:
-  - go test
-  - go build
diff --git a/cmd/vendor/github.com/ghodss/yaml/README.md b/cmd/vendor/github.com/ghodss/yaml/README.md
deleted file mode 100644
index f8f7e36..0000000
--- a/cmd/vendor/github.com/ghodss/yaml/README.md
+++ /dev/null
@@ -1,116 +0,0 @@
-# YAML marshaling and unmarshaling support for Go
-
-[![Build Status](https://travis-ci.org/ghodss/yaml.svg)](https://travis-ci.org/ghodss/yaml)
-
-## Introduction
-
-A wrapper around [go-yaml](https://github.com/go-yaml/yaml) designed to enable a better way of handling YAML when marshaling to and from structs. 
-
-In short, this library first converts YAML to JSON using go-yaml and then uses `json.Marshal` and `json.Unmarshal` to convert to or from the struct. This means that it effectively reuses the JSON struct tags as well as the custom JSON methods `MarshalJSON` and `UnmarshalJSON` unlike go-yaml. For a detailed overview of the rationale behind this method, [see this blog post](http://ghodss.com/2014/the-right-way-to-handle-yaml-in-golang/).
-
-## Compatibility
-
-This package uses [go-yaml v2](https://github.com/go-yaml/yaml) and therefore supports [everything go-yaml supports](https://github.com/go-yaml/yaml#compatibility).
-
-## Caveats
-
-**Caveat #1:** When using `yaml.Marshal` and `yaml.Unmarshal`, binary data should NOT be preceded with the `!!binary` YAML tag. If you do, go-yaml will convert the binary data from base64 to native binary data, which is not compatible with JSON. You can still use binary in your YAML files though - just store them without the `!!binary` tag and decode the base64 in your code (e.g. in the custom JSON methods `MarshalJSON` and `UnmarshalJSON`). This also has the benefit that your YAML and your JSON binary data will be decoded exactly the same way. As an example:
-
-```
-BAD:
-	exampleKey: !!binary gIGC
-
-GOOD:
-	exampleKey: gIGC
-... and decode the base64 data in your code.
-```
-
-**Caveat #2:** When using `YAMLToJSON` directly, maps with keys that are maps will result in an error since this is not supported by JSON. This error will occur in `Unmarshal` as well since you can't unmarshal map keys anyways since struct fields can't be keys.
-
-## Installation and usage
-
-To install, run:
-
-```
-$ go get github.com/ghodss/yaml
-```
-
-And import using:
-
-```
-import "github.com/ghodss/yaml"
-```
-
-Usage is very similar to the JSON library:
-
-```go
-import (
-	"fmt"
-
-	"github.com/ghodss/yaml"
-)
-
-type Person struct {
-	Name string `json:"name"`  // Affects YAML field names too.
-	Age int `json:"name"`
-}
-
-func main() {
-	// Marshal a Person struct to YAML.
-	p := Person{"John", 30}
-	y, err := yaml.Marshal(p)
-	if err != nil {
-		fmt.Printf("err: %v\n", err)
-		return
-	}
-	fmt.Println(string(y))
-	/* Output:
-	name: John
-	age: 30
-	*/
-
-	// Unmarshal the YAML back into a Person struct.
-	var p2 Person
-	err := yaml.Unmarshal(y, &p2)
-	if err != nil {
-		fmt.Printf("err: %v\n", err)
-		return
-	}
-	fmt.Println(p2)
-	/* Output:
-	{John 30}
-	*/
-}
-```
-
-`yaml.YAMLToJSON` and `yaml.JSONToYAML` methods are also available:
-
-```go
-import (
-	"fmt"
-
-	"github.com/ghodss/yaml"
-)
-func main() {
-	j := []byte(`{"name": "John", "age": 30}`)
-	y, err := yaml.JSONToYAML(j)
-	if err != nil {
-		fmt.Printf("err: %v\n", err)
-		return
-	}
-	fmt.Println(string(y))
-	/* Output:
-	name: John
-	age: 30
-	*/
-	j2, err := yaml.YAMLToJSON(y)
-	if err != nil {
-		fmt.Printf("err: %v\n", err)
-		return
-	}
-	fmt.Println(string(j2))
-	/* Output:
-	{"age":30,"name":"John"}
-	*/
-}
-```
diff --git a/cmd/vendor/github.com/gogo/protobuf/proto/Makefile b/cmd/vendor/github.com/gogo/protobuf/proto/Makefile
deleted file mode 100644
index 23a6b17..0000000
--- a/cmd/vendor/github.com/gogo/protobuf/proto/Makefile
+++ /dev/null
@@ -1,43 +0,0 @@
-# Go support for Protocol Buffers - Google's data interchange format
-#
-# Copyright 2010 The Go Authors.  All rights reserved.
-# https://github.com/golang/protobuf
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are
-# met:
-#
-#     * Redistributions of source code must retain the above copyright
-# notice, this list of conditions and the following disclaimer.
-#     * Redistributions in binary form must reproduce the above
-# copyright notice, this list of conditions and the following disclaimer
-# in the documentation and/or other materials provided with the
-# distribution.
-#     * Neither the name of Google Inc. nor the names of its
-# contributors may be used to endorse or promote products derived from
-# this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-install:
-	go install
-
-test: install generate-test-pbs
-	go test
-
-
-generate-test-pbs:
-	make install
-	make -C testdata
-	protoc-min-version --version="3.0.0" --proto_path=.:../../../../ --gogo_out=. proto3_proto/proto3.proto
-	make
diff --git a/cmd/vendor/github.com/golang/glog/README b/cmd/vendor/github.com/golang/glog/README
deleted file mode 100644
index 5f9c114..0000000
--- a/cmd/vendor/github.com/golang/glog/README
+++ /dev/null
@@ -1,44 +0,0 @@
-glog
-====
-
-Leveled execution logs for Go.
-
-This is an efficient pure Go implementation of leveled logs in the
-manner of the open source C++ package
-	http://code.google.com/p/google-glog
-
-By binding methods to booleans it is possible to use the log package
-without paying the expense of evaluating the arguments to the log.
-Through the -vmodule flag, the package also provides fine-grained
-control over logging at the file level.
-
-The comment from glog.go introduces the ideas:
-
-	Package glog implements logging analogous to the Google-internal
-	C++ INFO/ERROR/V setup.  It provides functions Info, Warning,
-	Error, Fatal, plus formatting variants such as Infof. It
-	also provides V-style logging controlled by the -v and
-	-vmodule=file=2 flags.
-	
-	Basic examples:
-	
-		glog.Info("Prepare to repel boarders")
-	
-		glog.Fatalf("Initialization failed: %s", err)
-	
-	See the documentation for the V function for an explanation
-	of these examples:
-	
-		if glog.V(2) {
-			glog.Info("Starting transaction...")
-		}
-	
-		glog.V(2).Infoln("Processed", nItems, "elements")
-
-
-The repository contains an open source version of the log package
-used inside Google. The master copy of the source lives inside
-Google, not here. The code in this repo is for export only and is not itself
-under development. Feature requests will be ignored.
-
-Send bug reports to golang-nuts@googlegroups.com.
diff --git a/cmd/vendor/github.com/golang/groupcache/byteview.go b/cmd/vendor/github.com/golang/groupcache/byteview.go
new file mode 100644
index 0000000..035a9ee
--- /dev/null
+++ b/cmd/vendor/github.com/golang/groupcache/byteview.go
@@ -0,0 +1,160 @@
+/*
+Copyright 2012 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package groupcache
+
+import (
+	"bytes"
+	"errors"
+	"io"
+	"strings"
+)
+
+// A ByteView holds an immutable view of bytes.
+// Internally it wraps either a []byte or a string,
+// but that detail is invisible to callers.
+//
+// A ByteView is meant to be used as a value type, not
+// a pointer (like a time.Time).
+type ByteView struct {
+	// If b is non-nil, b is used, else s is used.
+	b []byte
+	s string
+}
+
+// Len returns the view's length.
+func (v ByteView) Len() int {
+	if v.b != nil {
+		return len(v.b)
+	}
+	return len(v.s)
+}
+
+// ByteSlice returns a copy of the data as a byte slice.
+func (v ByteView) ByteSlice() []byte {
+	if v.b != nil {
+		return cloneBytes(v.b)
+	}
+	return []byte(v.s)
+}
+
+// String returns the data as a string, making a copy if necessary.
+func (v ByteView) String() string {
+	if v.b != nil {
+		return string(v.b)
+	}
+	return v.s
+}
+
+// At returns the byte at index i.
+func (v ByteView) At(i int) byte {
+	if v.b != nil {
+		return v.b[i]
+	}
+	return v.s[i]
+}
+
+// Slice slices the view between the provided from and to indices.
+func (v ByteView) Slice(from, to int) ByteView {
+	if v.b != nil {
+		return ByteView{b: v.b[from:to]}
+	}
+	return ByteView{s: v.s[from:to]}
+}
+
+// SliceFrom slices the view from the provided index until the end.
+func (v ByteView) SliceFrom(from int) ByteView {
+	if v.b != nil {
+		return ByteView{b: v.b[from:]}
+	}
+	return ByteView{s: v.s[from:]}
+}
+
+// Copy copies b into dest and returns the number of bytes copied.
+func (v ByteView) Copy(dest []byte) int {
+	if v.b != nil {
+		return copy(dest, v.b)
+	}
+	return copy(dest, v.s)
+}
+
+// Equal returns whether the bytes in b are the same as the bytes in
+// b2.
+func (v ByteView) Equal(b2 ByteView) bool {
+	if b2.b == nil {
+		return v.EqualString(b2.s)
+	}
+	return v.EqualBytes(b2.b)
+}
+
+// EqualString returns whether the bytes in b are the same as the bytes
+// in s.
+func (v ByteView) EqualString(s string) bool {
+	if v.b == nil {
+		return v.s == s
+	}
+	l := v.Len()
+	if len(s) != l {
+		return false
+	}
+	for i, bi := range v.b {
+		if bi != s[i] {
+			return false
+		}
+	}
+	return true
+}
+
+// EqualBytes returns whether the bytes in b are the same as the bytes
+// in b2.
+func (v ByteView) EqualBytes(b2 []byte) bool {
+	if v.b != nil {
+		return bytes.Equal(v.b, b2)
+	}
+	l := v.Len()
+	if len(b2) != l {
+		return false
+	}
+	for i, bi := range b2 {
+		if bi != v.s[i] {
+			return false
+		}
+	}
+	return true
+}
+
+// Reader returns an io.ReadSeeker for the bytes in v.
+func (v ByteView) Reader() io.ReadSeeker {
+	if v.b != nil {
+		return bytes.NewReader(v.b)
+	}
+	return strings.NewReader(v.s)
+}
+
+// ReadAt implements io.ReaderAt on the bytes in v.
+func (v ByteView) ReadAt(p []byte, off int64) (n int, err error) {
+	if off < 0 {
+		return 0, errors.New("view: invalid offset")
+	}
+	if off >= int64(v.Len()) {
+		return 0, io.EOF
+	}
+	n = v.SliceFrom(int(off)).Copy(p)
+	if n < len(p) {
+		err = io.EOF
+	}
+	return
+}
diff --git a/cmd/vendor/github.com/golang/groupcache/groupcache.go b/cmd/vendor/github.com/golang/groupcache/groupcache.go
new file mode 100644
index 0000000..9499dbb
--- /dev/null
+++ b/cmd/vendor/github.com/golang/groupcache/groupcache.go
@@ -0,0 +1,489 @@
+/*
+Copyright 2012 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Package groupcache provides a data loading mechanism with caching
+// and de-duplication that works across a set of peer processes.
+//
+// Each data Get first consults its local cache, otherwise delegates
+// to the requested key's canonical owner, which then checks its cache
+// or finally gets the data.  In the common case, many concurrent
+// cache misses across a set of peers for the same key result in just
+// one cache fill.
+package groupcache
+
+import (
+	"errors"
+	"math/rand"
+	"strconv"
+	"sync"
+	"sync/atomic"
+
+	pb "github.com/golang/groupcache/groupcachepb"
+	"github.com/golang/groupcache/lru"
+	"github.com/golang/groupcache/singleflight"
+)
+
+// A Getter loads data for a key.
+type Getter interface {
+	// Get returns the value identified by key, populating dest.
+	//
+	// The returned data must be unversioned. That is, key must
+	// uniquely describe the loaded data, without an implicit
+	// current time, and without relying on cache expiration
+	// mechanisms.
+	Get(ctx Context, key string, dest Sink) error
+}
+
+// A GetterFunc implements Getter with a function.
+type GetterFunc func(ctx Context, key string, dest Sink) error
+
+func (f GetterFunc) Get(ctx Context, key string, dest Sink) error {
+	return f(ctx, key, dest)
+}
+
+var (
+	mu     sync.RWMutex
+	groups = make(map[string]*Group)
+
+	initPeerServerOnce sync.Once
+	initPeerServer     func()
+)
+
+// GetGroup returns the named group previously created with NewGroup, or
+// nil if there's no such group.
+func GetGroup(name string) *Group {
+	mu.RLock()
+	g := groups[name]
+	mu.RUnlock()
+	return g
+}
+
+// NewGroup creates a coordinated group-aware Getter from a Getter.
+//
+// The returned Getter tries (but does not guarantee) to run only one
+// Get call at once for a given key across an entire set of peer
+// processes. Concurrent callers both in the local process and in
+// other processes receive copies of the answer once the original Get
+// completes.
+//
+// The group name must be unique for each getter.
+func NewGroup(name string, cacheBytes int64, getter Getter) *Group {
+	return newGroup(name, cacheBytes, getter, nil)
+}
+
+// If peers is nil, the peerPicker is called via a sync.Once to initialize it.
+func newGroup(name string, cacheBytes int64, getter Getter, peers PeerPicker) *Group {
+	if getter == nil {
+		panic("nil Getter")
+	}
+	mu.Lock()
+	defer mu.Unlock()
+	initPeerServerOnce.Do(callInitPeerServer)
+	if _, dup := groups[name]; dup {
+		panic("duplicate registration of group " + name)
+	}
+	g := &Group{
+		name:       name,
+		getter:     getter,
+		peers:      peers,
+		cacheBytes: cacheBytes,
+		loadGroup:  &singleflight.Group{},
+	}
+	if fn := newGroupHook; fn != nil {
+		fn(g)
+	}
+	groups[name] = g
+	return g
+}
+
+// newGroupHook, if non-nil, is called right after a new group is created.
+var newGroupHook func(*Group)
+
+// RegisterNewGroupHook registers a hook that is run each time
+// a group is created.
+func RegisterNewGroupHook(fn func(*Group)) {
+	if newGroupHook != nil {
+		panic("RegisterNewGroupHook called more than once")
+	}
+	newGroupHook = fn
+}
+
+// RegisterServerStart registers a hook that is run when the first
+// group is created.
+func RegisterServerStart(fn func()) {
+	if initPeerServer != nil {
+		panic("RegisterServerStart called more than once")
+	}
+	initPeerServer = fn
+}
+
+func callInitPeerServer() {
+	if initPeerServer != nil {
+		initPeerServer()
+	}
+}
+
+// A Group is a cache namespace and associated data loaded spread over
+// a group of 1 or more machines.
+type Group struct {
+	name       string
+	getter     Getter
+	peersOnce  sync.Once
+	peers      PeerPicker
+	cacheBytes int64 // limit for sum of mainCache and hotCache size
+
+	// mainCache is a cache of the keys for which this process
+	// (amongst its peers) is authoritative. That is, this cache
+	// contains keys which consistent hash on to this process's
+	// peer number.
+	mainCache cache
+
+	// hotCache contains keys/values for which this peer is not
+	// authoritative (otherwise they would be in mainCache), but
+	// are popular enough to warrant mirroring in this process to
+	// avoid going over the network to fetch from a peer.  Having
+	// a hotCache avoids network hotspotting, where a peer's
+	// network card could become the bottleneck on a popular key.
+	// This cache is used sparingly to maximize the total number
+	// of key/value pairs that can be stored globally.
+	hotCache cache
+
+	// loadGroup ensures that each key is only fetched once
+	// (either locally or remotely), regardless of the number of
+	// concurrent callers.
+	loadGroup flightGroup
+
+	// Stats are statistics on the group.
+	Stats Stats
+}
+
+// flightGroup is defined as an interface which flightgroup.Group
+// satisfies.  We define this so that we may test with an alternate
+// implementation.
+type flightGroup interface {
+	// Done is called when Do is done.
+	Do(key string, fn func() (interface{}, error)) (interface{}, error)
+}
+
+// Stats are per-group statistics.
+type Stats struct {
+	Gets           AtomicInt // any Get request, including from peers
+	CacheHits      AtomicInt // either cache was good
+	PeerLoads      AtomicInt // either remote load or remote cache hit (not an error)
+	PeerErrors     AtomicInt
+	Loads          AtomicInt // (gets - cacheHits)
+	LoadsDeduped   AtomicInt // after singleflight
+	LocalLoads     AtomicInt // total good local loads
+	LocalLoadErrs  AtomicInt // total bad local loads
+	ServerRequests AtomicInt // gets that came over the network from peers
+}
+
+// Name returns the name of the group.
+func (g *Group) Name() string {
+	return g.name
+}
+
+func (g *Group) initPeers() {
+	if g.peers == nil {
+		g.peers = getPeers()
+	}
+}
+
+func (g *Group) Get(ctx Context, key string, dest Sink) error {
+	g.peersOnce.Do(g.initPeers)
+	g.Stats.Gets.Add(1)
+	if dest == nil {
+		return errors.New("groupcache: nil dest Sink")
+	}
+	value, cacheHit := g.lookupCache(key)
+
+	if cacheHit {
+		g.Stats.CacheHits.Add(1)
+		return setSinkView(dest, value)
+	}
+
+	// Optimization to avoid double unmarshalling or copying: keep
+	// track of whether the dest was already populated. One caller
+	// (if local) will set this; the losers will not. The common
+	// case will likely be one caller.
+	destPopulated := false
+	value, destPopulated, err := g.load(ctx, key, dest)
+	if err != nil {
+		return err
+	}
+	if destPopulated {
+		return nil
+	}
+	return setSinkView(dest, value)
+}
+
+// load loads key either by invoking the getter locally or by sending it to another machine.
+func (g *Group) load(ctx Context, key string, dest Sink) (value ByteView, destPopulated bool, err error) {
+	g.Stats.Loads.Add(1)
+	viewi, err := g.loadGroup.Do(key, func() (interface{}, error) {
+		// Check the cache again because singleflight can only dedup calls
+		// that overlap concurrently.  It's possible for 2 concurrent
+		// requests to miss the cache, resulting in 2 load() calls.  An
+		// unfortunate goroutine scheduling would result in this callback
+		// being run twice, serially.  If we don't check the cache again,
+		// cache.nbytes would be incremented below even though there will
+		// be only one entry for this key.
+		//
+		// Consider the following serialized event ordering for two
+		// goroutines in which this callback gets called twice for hte
+		// same key:
+		// 1: Get("key")
+		// 2: Get("key")
+		// 1: lookupCache("key")
+		// 2: lookupCache("key")
+		// 1: load("key")
+		// 2: load("key")
+		// 1: loadGroup.Do("key", fn)
+		// 1: fn()
+		// 2: loadGroup.Do("key", fn)
+		// 2: fn()
+		if value, cacheHit := g.lookupCache(key); cacheHit {
+			g.Stats.CacheHits.Add(1)
+			return value, nil
+		}
+		g.Stats.LoadsDeduped.Add(1)
+		var value ByteView
+		var err error
+		if peer, ok := g.peers.PickPeer(key); ok {
+			value, err = g.getFromPeer(ctx, peer, key)
+			if err == nil {
+				g.Stats.PeerLoads.Add(1)
+				return value, nil
+			}
+			g.Stats.PeerErrors.Add(1)
+			// TODO(bradfitz): log the peer's error? keep
+			// log of the past few for /groupcachez?  It's
+			// probably boring (normal task movement), so not
+			// worth logging I imagine.
+		}
+		value, err = g.getLocally(ctx, key, dest)
+		if err != nil {
+			g.Stats.LocalLoadErrs.Add(1)
+			return nil, err
+		}
+		g.Stats.LocalLoads.Add(1)
+		destPopulated = true // only one caller of load gets this return value
+		g.populateCache(key, value, &g.mainCache)
+		return value, nil
+	})
+	if err == nil {
+		value = viewi.(ByteView)
+	}
+	return
+}
+
+func (g *Group) getLocally(ctx Context, key string, dest Sink) (ByteView, error) {
+	err := g.getter.Get(ctx, key, dest)
+	if err != nil {
+		return ByteView{}, err
+	}
+	return dest.view()
+}
+
+func (g *Group) getFromPeer(ctx Context, peer ProtoGetter, key string) (ByteView, error) {
+	req := &pb.GetRequest{
+		Group: &g.name,
+		Key:   &key,
+	}
+	res := &pb.GetResponse{}
+	err := peer.Get(ctx, req, res)
+	if err != nil {
+		return ByteView{}, err
+	}
+	value := ByteView{b: res.Value}
+	// TODO(bradfitz): use res.MinuteQps or something smart to
+	// conditionally populate hotCache.  For now just do it some
+	// percentage of the time.
+	if rand.Intn(10) == 0 {
+		g.populateCache(key, value, &g.hotCache)
+	}
+	return value, nil
+}
+
+func (g *Group) lookupCache(key string) (value ByteView, ok bool) {
+	if g.cacheBytes <= 0 {
+		return
+	}
+	value, ok = g.mainCache.get(key)
+	if ok {
+		return
+	}
+	value, ok = g.hotCache.get(key)
+	return
+}
+
+func (g *Group) populateCache(key string, value ByteView, cache *cache) {
+	if g.cacheBytes <= 0 {
+		return
+	}
+	cache.add(key, value)
+
+	// Evict items from cache(s) if necessary.
+	for {
+		mainBytes := g.mainCache.bytes()
+		hotBytes := g.hotCache.bytes()
+		if mainBytes+hotBytes <= g.cacheBytes {
+			return
+		}
+
+		// TODO(bradfitz): this is good-enough-for-now logic.
+		// It should be something based on measurements and/or
+		// respecting the costs of different resources.
+		victim := &g.mainCache
+		if hotBytes > mainBytes/8 {
+			victim = &g.hotCache
+		}
+		victim.removeOldest()
+	}
+}
+
+// CacheType represents a type of cache.
+type CacheType int
+
+const (
+	// The MainCache is the cache for items that this peer is the
+	// owner for.
+	MainCache CacheType = iota + 1
+
+	// The HotCache is the cache for items that seem popular
+	// enough to replicate to this node, even though it's not the
+	// owner.
+	HotCache
+)
+
+// CacheStats returns stats about the provided cache within the group.
+func (g *Group) CacheStats(which CacheType) CacheStats {
+	switch which {
+	case MainCache:
+		return g.mainCache.stats()
+	case HotCache:
+		return g.hotCache.stats()
+	default:
+		return CacheStats{}
+	}
+}
+
+// cache is a wrapper around an *lru.Cache that adds synchronization,
+// makes values always be ByteView, and counts the size of all keys and
+// values.
+type cache struct {
+	mu         sync.RWMutex
+	nbytes     int64 // of all keys and values
+	lru        *lru.Cache
+	nhit, nget int64
+	nevict     int64 // number of evictions
+}
+
+func (c *cache) stats() CacheStats {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return CacheStats{
+		Bytes:     c.nbytes,
+		Items:     c.itemsLocked(),
+		Gets:      c.nget,
+		Hits:      c.nhit,
+		Evictions: c.nevict,
+	}
+}
+
+func (c *cache) add(key string, value ByteView) {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	if c.lru == nil {
+		c.lru = &lru.Cache{
+			OnEvicted: func(key lru.Key, value interface{}) {
+				val := value.(ByteView)
+				c.nbytes -= int64(len(key.(string))) + int64(val.Len())
+				c.nevict++
+			},
+		}
+	}
+	c.lru.Add(key, value)
+	c.nbytes += int64(len(key)) + int64(value.Len())
+}
+
+func (c *cache) get(key string) (value ByteView, ok bool) {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	c.nget++
+	if c.lru == nil {
+		return
+	}
+	vi, ok := c.lru.Get(key)
+	if !ok {
+		return
+	}
+	c.nhit++
+	return vi.(ByteView), true
+}
+
+func (c *cache) removeOldest() {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	if c.lru != nil {
+		c.lru.RemoveOldest()
+	}
+}
+
+func (c *cache) bytes() int64 {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return c.nbytes
+}
+
+func (c *cache) items() int64 {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return c.itemsLocked()
+}
+
+func (c *cache) itemsLocked() int64 {
+	if c.lru == nil {
+		return 0
+	}
+	return int64(c.lru.Len())
+}
+
+// An AtomicInt is an int64 to be accessed atomically.
+type AtomicInt int64
+
+// Add atomically adds n to i.
+func (i *AtomicInt) Add(n int64) {
+	atomic.AddInt64((*int64)(i), n)
+}
+
+// Get atomically gets the value of i.
+func (i *AtomicInt) Get() int64 {
+	return atomic.LoadInt64((*int64)(i))
+}
+
+func (i *AtomicInt) String() string {
+	return strconv.FormatInt(i.Get(), 10)
+}
+
+// CacheStats are returned by stats accessors on Group.
+type CacheStats struct {
+	Bytes     int64
+	Items     int64
+	Gets      int64
+	Hits      int64
+	Evictions int64
+}
diff --git a/cmd/vendor/github.com/golang/groupcache/http.go b/cmd/vendor/github.com/golang/groupcache/http.go
new file mode 100644
index 0000000..14eb345
--- /dev/null
+++ b/cmd/vendor/github.com/golang/groupcache/http.go
@@ -0,0 +1,227 @@
+/*
+Copyright 2013 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package groupcache
+
+import (
+	"bytes"
+	"fmt"
+	"io"
+	"net/http"
+	"net/url"
+	"strings"
+	"sync"
+
+	"github.com/golang/groupcache/consistenthash"
+	pb "github.com/golang/groupcache/groupcachepb"
+	"github.com/golang/protobuf/proto"
+)
+
+const defaultBasePath = "/_groupcache/"
+
+const defaultReplicas = 50
+
+// HTTPPool implements PeerPicker for a pool of HTTP peers.
+type HTTPPool struct {
+	// Context optionally specifies a context for the server to use when it
+	// receives a request.
+	// If nil, the server uses a nil Context.
+	Context func(*http.Request) Context
+
+	// Transport optionally specifies an http.RoundTripper for the client
+	// to use when it makes a request.
+	// If nil, the client uses http.DefaultTransport.
+	Transport func(Context) http.RoundTripper
+
+	// this peer's base URL, e.g. "https://example.net:8000"
+	self string
+
+	// opts specifies the options.
+	opts HTTPPoolOptions
+
+	mu          sync.Mutex // guards peers and httpGetters
+	peers       *consistenthash.Map
+	httpGetters map[string]*httpGetter // keyed by e.g. "http://10.0.0.2:8008"
+}
+
+// HTTPPoolOptions are the configurations of a HTTPPool.
+type HTTPPoolOptions struct {
+	// BasePath specifies the HTTP path that will serve groupcache requests.
+	// If blank, it defaults to "/_groupcache/".
+	BasePath string
+
+	// Replicas specifies the number of key replicas on the consistent hash.
+	// If blank, it defaults to 50.
+	Replicas int
+
+	// HashFn specifies the hash function of the consistent hash.
+	// If blank, it defaults to crc32.ChecksumIEEE.
+	HashFn consistenthash.Hash
+}
+
+// NewHTTPPool initializes an HTTP pool of peers, and registers itself as a PeerPicker.
+// For convenience, it also registers itself as an http.Handler with http.DefaultServeMux.
+// The self argument be a valid base URL that points to the current server,
+// for example "http://example.net:8000".
+func NewHTTPPool(self string) *HTTPPool {
+	p := NewHTTPPoolOpts(self, nil)
+	http.Handle(p.opts.BasePath, p)
+	return p
+}
+
+var httpPoolMade bool
+
+// NewHTTPPoolOpts initializes an HTTP pool of peers with the given options.
+// Unlike NewHTTPPool, this function does not register the created pool as an HTTP handler.
+// The returned *HTTPPool implements http.Handler and must be registered using http.Handle.
+func NewHTTPPoolOpts(self string, o *HTTPPoolOptions) *HTTPPool {
+	if httpPoolMade {
+		panic("groupcache: NewHTTPPool must be called only once")
+	}
+	httpPoolMade = true
+
+	p := &HTTPPool{
+		self:        self,
+		httpGetters: make(map[string]*httpGetter),
+	}
+	if o != nil {
+		p.opts = *o
+	}
+	if p.opts.BasePath == "" {
+		p.opts.BasePath = defaultBasePath
+	}
+	if p.opts.Replicas == 0 {
+		p.opts.Replicas = defaultReplicas
+	}
+	p.peers = consistenthash.New(p.opts.Replicas, p.opts.HashFn)
+
+	RegisterPeerPicker(func() PeerPicker { return p })
+	return p
+}
+
+// Set updates the pool's list of peers.
+// Each peer value should be a valid base URL,
+// for example "http://example.net:8000".
+func (p *HTTPPool) Set(peers ...string) {
+	p.mu.Lock()
+	defer p.mu.Unlock()
+	p.peers = consistenthash.New(p.opts.Replicas, p.opts.HashFn)
+	p.peers.Add(peers...)
+	p.httpGetters = make(map[string]*httpGetter, len(peers))
+	for _, peer := range peers {
+		p.httpGetters[peer] = &httpGetter{transport: p.Transport, baseURL: peer + p.opts.BasePath}
+	}
+}
+
+func (p *HTTPPool) PickPeer(key string) (ProtoGetter, bool) {
+	p.mu.Lock()
+	defer p.mu.Unlock()
+	if p.peers.IsEmpty() {
+		return nil, false
+	}
+	if peer := p.peers.Get(key); peer != p.self {
+		return p.httpGetters[peer], true
+	}
+	return nil, false
+}
+
+func (p *HTTPPool) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+	// Parse request.
+	if !strings.HasPrefix(r.URL.Path, p.opts.BasePath) {
+		panic("HTTPPool serving unexpected path: " + r.URL.Path)
+	}
+	parts := strings.SplitN(r.URL.Path[len(p.opts.BasePath):], "/", 2)
+	if len(parts) != 2 {
+		http.Error(w, "bad request", http.StatusBadRequest)
+		return
+	}
+	groupName := parts[0]
+	key := parts[1]
+
+	// Fetch the value for this group/key.
+	group := GetGroup(groupName)
+	if group == nil {
+		http.Error(w, "no such group: "+groupName, http.StatusNotFound)
+		return
+	}
+	var ctx Context
+	if p.Context != nil {
+		ctx = p.Context(r)
+	}
+
+	group.Stats.ServerRequests.Add(1)
+	var value []byte
+	err := group.Get(ctx, key, AllocatingByteSliceSink(&value))
+	if err != nil {
+		http.Error(w, err.Error(), http.StatusInternalServerError)
+		return
+	}
+
+	// Write the value to the response body as a proto message.
+	body, err := proto.Marshal(&pb.GetResponse{Value: value})
+	if err != nil {
+		http.Error(w, err.Error(), http.StatusInternalServerError)
+		return
+	}
+	w.Header().Set("Content-Type", "application/x-protobuf")
+	w.Write(body)
+}
+
+type httpGetter struct {
+	transport func(Context) http.RoundTripper
+	baseURL   string
+}
+
+var bufferPool = sync.Pool{
+	New: func() interface{} { return new(bytes.Buffer) },
+}
+
+func (h *httpGetter) Get(context Context, in *pb.GetRequest, out *pb.GetResponse) error {
+	u := fmt.Sprintf(
+		"%v%v/%v",
+		h.baseURL,
+		url.QueryEscape(in.GetGroup()),
+		url.QueryEscape(in.GetKey()),
+	)
+	req, err := http.NewRequest("GET", u, nil)
+	if err != nil {
+		return err
+	}
+	tr := http.DefaultTransport
+	if h.transport != nil {
+		tr = h.transport(context)
+	}
+	res, err := tr.RoundTrip(req)
+	if err != nil {
+		return err
+	}
+	defer res.Body.Close()
+	if res.StatusCode != http.StatusOK {
+		return fmt.Errorf("server returned: %v", res.Status)
+	}
+	b := bufferPool.Get().(*bytes.Buffer)
+	b.Reset()
+	defer bufferPool.Put(b)
+	_, err = io.Copy(b, res.Body)
+	if err != nil {
+		return fmt.Errorf("reading response body: %v", err)
+	}
+	err = proto.Unmarshal(b.Bytes(), out)
+	if err != nil {
+		return fmt.Errorf("decoding response body: %v", err)
+	}
+	return nil
+}
diff --git a/cmd/vendor/github.com/golang/groupcache/peers.go b/cmd/vendor/github.com/golang/groupcache/peers.go
new file mode 100644
index 0000000..a74a79b
--- /dev/null
+++ b/cmd/vendor/github.com/golang/groupcache/peers.go
@@ -0,0 +1,71 @@
+/*
+Copyright 2012 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// peers.go defines how processes find and communicate with their peers.
+
+package groupcache
+
+import (
+	pb "github.com/golang/groupcache/groupcachepb"
+)
+
+// Context is an opaque value passed through calls to the
+// ProtoGetter. It may be nil if your ProtoGetter implementation does
+// not require a context.
+type Context interface{}
+
+// ProtoGetter is the interface that must be implemented by a peer.
+type ProtoGetter interface {
+	Get(context Context, in *pb.GetRequest, out *pb.GetResponse) error
+}
+
+// PeerPicker is the interface that must be implemented to locate
+// the peer that owns a specific key.
+type PeerPicker interface {
+	// PickPeer returns the peer that owns the specific key
+	// and true to indicate that a remote peer was nominated.
+	// It returns nil, false if the key owner is the current peer.
+	PickPeer(key string) (peer ProtoGetter, ok bool)
+}
+
+// NoPeers is an implementation of PeerPicker that never finds a peer.
+type NoPeers struct{}
+
+func (NoPeers) PickPeer(key string) (peer ProtoGetter, ok bool) { return }
+
+var (
+	portPicker func() PeerPicker
+)
+
+// RegisterPeerPicker registers the peer initialization function.
+// It is called once, when the first group is created.
+func RegisterPeerPicker(fn func() PeerPicker) {
+	if portPicker != nil {
+		panic("RegisterPeerPicker called more than once")
+	}
+	portPicker = fn
+}
+
+func getPeers() PeerPicker {
+	if portPicker == nil {
+		return NoPeers{}
+	}
+	pk := portPicker()
+	if pk == nil {
+		pk = NoPeers{}
+	}
+	return pk
+}
diff --git a/cmd/vendor/github.com/golang/groupcache/sinks.go b/cmd/vendor/github.com/golang/groupcache/sinks.go
new file mode 100644
index 0000000..cb42b41
--- /dev/null
+++ b/cmd/vendor/github.com/golang/groupcache/sinks.go
@@ -0,0 +1,322 @@
+/*
+Copyright 2012 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package groupcache
+
+import (
+	"errors"
+
+	"github.com/golang/protobuf/proto"
+)
+
+// A Sink receives data from a Get call.
+//
+// Implementation of Getter must call exactly one of the Set methods
+// on success.
+type Sink interface {
+	// SetString sets the value to s.
+	SetString(s string) error
+
+	// SetBytes sets the value to the contents of v.
+	// The caller retains ownership of v.
+	SetBytes(v []byte) error
+
+	// SetProto sets the value to the encoded version of m.
+	// The caller retains ownership of m.
+	SetProto(m proto.Message) error
+
+	// view returns a frozen view of the bytes for caching.
+	view() (ByteView, error)
+}
+
+func cloneBytes(b []byte) []byte {
+	c := make([]byte, len(b))
+	copy(c, b)
+	return c
+}
+
+func setSinkView(s Sink, v ByteView) error {
+	// A viewSetter is a Sink that can also receive its value from
+	// a ByteView. This is a fast path to minimize copies when the
+	// item was already cached locally in memory (where it's
+	// cached as a ByteView)
+	type viewSetter interface {
+		setView(v ByteView) error
+	}
+	if vs, ok := s.(viewSetter); ok {
+		return vs.setView(v)
+	}
+	if v.b != nil {
+		return s.SetBytes(v.b)
+	}
+	return s.SetString(v.s)
+}
+
+// StringSink returns a Sink that populates the provided string pointer.
+func StringSink(sp *string) Sink {
+	return &stringSink{sp: sp}
+}
+
+type stringSink struct {
+	sp *string
+	v  ByteView
+	// TODO(bradfitz): track whether any Sets were called.
+}
+
+func (s *stringSink) view() (ByteView, error) {
+	// TODO(bradfitz): return an error if no Set was called
+	return s.v, nil
+}
+
+func (s *stringSink) SetString(v string) error {
+	s.v.b = nil
+	s.v.s = v
+	*s.sp = v
+	return nil
+}
+
+func (s *stringSink) SetBytes(v []byte) error {
+	return s.SetString(string(v))
+}
+
+func (s *stringSink) SetProto(m proto.Message) error {
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return err
+	}
+	s.v.b = b
+	*s.sp = string(b)
+	return nil
+}
+
+// ByteViewSink returns a Sink that populates a ByteView.
+func ByteViewSink(dst *ByteView) Sink {
+	if dst == nil {
+		panic("nil dst")
+	}
+	return &byteViewSink{dst: dst}
+}
+
+type byteViewSink struct {
+	dst *ByteView
+
+	// if this code ever ends up tracking that at least one set*
+	// method was called, don't make it an error to call set
+	// methods multiple times. Lorry's payload.go does that, and
+	// it makes sense. The comment at the top of this file about
+	// "exactly one of the Set methods" is overly strict. We
+	// really care about at least once (in a handler), but if
+	// multiple handlers fail (or multiple functions in a program
+	// using a Sink), it's okay to re-use the same one.
+}
+
+func (s *byteViewSink) setView(v ByteView) error {
+	*s.dst = v
+	return nil
+}
+
+func (s *byteViewSink) view() (ByteView, error) {
+	return *s.dst, nil
+}
+
+func (s *byteViewSink) SetProto(m proto.Message) error {
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return err
+	}
+	*s.dst = ByteView{b: b}
+	return nil
+}
+
+func (s *byteViewSink) SetBytes(b []byte) error {
+	*s.dst = ByteView{b: cloneBytes(b)}
+	return nil
+}
+
+func (s *byteViewSink) SetString(v string) error {
+	*s.dst = ByteView{s: v}
+	return nil
+}
+
+// ProtoSink returns a sink that unmarshals binary proto values into m.
+func ProtoSink(m proto.Message) Sink {
+	return &protoSink{
+		dst: m,
+	}
+}
+
+type protoSink struct {
+	dst proto.Message // authorative value
+	typ string
+
+	v ByteView // encoded
+}
+
+func (s *protoSink) view() (ByteView, error) {
+	return s.v, nil
+}
+
+func (s *protoSink) SetBytes(b []byte) error {
+	err := proto.Unmarshal(b, s.dst)
+	if err != nil {
+		return err
+	}
+	s.v.b = cloneBytes(b)
+	s.v.s = ""
+	return nil
+}
+
+func (s *protoSink) SetString(v string) error {
+	b := []byte(v)
+	err := proto.Unmarshal(b, s.dst)
+	if err != nil {
+		return err
+	}
+	s.v.b = b
+	s.v.s = ""
+	return nil
+}
+
+func (s *protoSink) SetProto(m proto.Message) error {
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return err
+	}
+	// TODO(bradfitz): optimize for same-task case more and write
+	// right through? would need to document ownership rules at
+	// the same time. but then we could just assign *dst = *m
+	// here. This works for now:
+	err = proto.Unmarshal(b, s.dst)
+	if err != nil {
+		return err
+	}
+	s.v.b = b
+	s.v.s = ""
+	return nil
+}
+
+// AllocatingByteSliceSink returns a Sink that allocates
+// a byte slice to hold the received value and assigns
+// it to *dst. The memory is not retained by groupcache.
+func AllocatingByteSliceSink(dst *[]byte) Sink {
+	return &allocBytesSink{dst: dst}
+}
+
+type allocBytesSink struct {
+	dst *[]byte
+	v   ByteView
+}
+
+func (s *allocBytesSink) view() (ByteView, error) {
+	return s.v, nil
+}
+
+func (s *allocBytesSink) setView(v ByteView) error {
+	if v.b != nil {
+		*s.dst = cloneBytes(v.b)
+	} else {
+		*s.dst = []byte(v.s)
+	}
+	s.v = v
+	return nil
+}
+
+func (s *allocBytesSink) SetProto(m proto.Message) error {
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return err
+	}
+	return s.setBytesOwned(b)
+}
+
+func (s *allocBytesSink) SetBytes(b []byte) error {
+	return s.setBytesOwned(cloneBytes(b))
+}
+
+func (s *allocBytesSink) setBytesOwned(b []byte) error {
+	if s.dst == nil {
+		return errors.New("nil AllocatingByteSliceSink *[]byte dst")
+	}
+	*s.dst = cloneBytes(b) // another copy, protecting the read-only s.v.b view
+	s.v.b = b
+	s.v.s = ""
+	return nil
+}
+
+func (s *allocBytesSink) SetString(v string) error {
+	if s.dst == nil {
+		return errors.New("nil AllocatingByteSliceSink *[]byte dst")
+	}
+	*s.dst = []byte(v)
+	s.v.b = nil
+	s.v.s = v
+	return nil
+}
+
+// TruncatingByteSliceSink returns a Sink that writes up to len(*dst)
+// bytes to *dst. If more bytes are available, they're silently
+// truncated. If fewer bytes are available than len(*dst), *dst
+// is shrunk to fit the number of bytes available.
+func TruncatingByteSliceSink(dst *[]byte) Sink {
+	return &truncBytesSink{dst: dst}
+}
+
+type truncBytesSink struct {
+	dst *[]byte
+	v   ByteView
+}
+
+func (s *truncBytesSink) view() (ByteView, error) {
+	return s.v, nil
+}
+
+func (s *truncBytesSink) SetProto(m proto.Message) error {
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return err
+	}
+	return s.setBytesOwned(b)
+}
+
+func (s *truncBytesSink) SetBytes(b []byte) error {
+	return s.setBytesOwned(cloneBytes(b))
+}
+
+func (s *truncBytesSink) setBytesOwned(b []byte) error {
+	if s.dst == nil {
+		return errors.New("nil TruncatingByteSliceSink *[]byte dst")
+	}
+	n := copy(*s.dst, b)
+	if n < len(*s.dst) {
+		*s.dst = (*s.dst)[:n]
+	}
+	s.v.b = b
+	s.v.s = ""
+	return nil
+}
+
+func (s *truncBytesSink) SetString(v string) error {
+	if s.dst == nil {
+		return errors.New("nil TruncatingByteSliceSink *[]byte dst")
+	}
+	n := copy(*s.dst, v)
+	if n < len(*s.dst) {
+		*s.dst = (*s.dst)[:n]
+	}
+	s.v.b = nil
+	s.v.s = v
+	return nil
+}
diff --git a/cmd/vendor/github.com/golang/protobuf/proto/Makefile b/cmd/vendor/github.com/golang/protobuf/proto/Makefile
deleted file mode 100644
index e2e0651..0000000
--- a/cmd/vendor/github.com/golang/protobuf/proto/Makefile
+++ /dev/null
@@ -1,43 +0,0 @@
-# Go support for Protocol Buffers - Google's data interchange format
-#
-# Copyright 2010 The Go Authors.  All rights reserved.
-# https://github.com/golang/protobuf
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are
-# met:
-#
-#     * Redistributions of source code must retain the above copyright
-# notice, this list of conditions and the following disclaimer.
-#     * Redistributions in binary form must reproduce the above
-# copyright notice, this list of conditions and the following disclaimer
-# in the documentation and/or other materials provided with the
-# distribution.
-#     * Neither the name of Google Inc. nor the names of its
-# contributors may be used to endorse or promote products derived from
-# this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-install:
-	go install
-
-test: install generate-test-pbs
-	go test
-
-
-generate-test-pbs:
-	make install
-	make -C testdata
-	protoc --go_out=Mtestdata/test.proto=github.com/golang/protobuf/proto/testdata,Mgoogle/protobuf/any.proto=github.com/golang/protobuf/ptypes/any:. proto3_proto/proto3.proto
-	make
diff --git a/cmd/vendor/github.com/google/btree/.travis.yml b/cmd/vendor/github.com/google/btree/.travis.yml
deleted file mode 100644
index 4f2ee4d..0000000
--- a/cmd/vendor/github.com/google/btree/.travis.yml
+++ /dev/null
@@ -1 +0,0 @@
-language: go
diff --git a/cmd/vendor/github.com/google/btree/README.md b/cmd/vendor/github.com/google/btree/README.md
deleted file mode 100644
index 6062a4d..0000000
--- a/cmd/vendor/github.com/google/btree/README.md
+++ /dev/null
@@ -1,12 +0,0 @@
-# BTree implementation for Go
-
-![Travis CI Build Status](https://api.travis-ci.org/google/btree.svg?branch=master)
-
-This package provides an in-memory B-Tree implementation for Go, useful as
-an ordered, mutable data structure.
-
-The API is based off of the wonderful
-http://godoc.org/github.com/petar/GoLLRB/llrb, and is meant to allow btree to
-act as a drop-in replacement for gollrb trees.
-
-See http://godoc.org/github.com/google/btree for documentation.
diff --git a/cmd/vendor/github.com/grpc-ecosystem/grpc-gateway/runtime/internal/stream_chunk.proto b/cmd/vendor/github.com/grpc-ecosystem/grpc-gateway/runtime/internal/stream_chunk.proto
deleted file mode 100644
index f7fba56..0000000
--- a/cmd/vendor/github.com/grpc-ecosystem/grpc-gateway/runtime/internal/stream_chunk.proto
+++ /dev/null
@@ -1,12 +0,0 @@
-syntax = "proto3";
-package grpc.gateway.runtime;
-option go_package = "internal";
-
-// StreamError is a response type which is returned when
-// streaming rpc returns an error.
-message StreamError {
-	int32 grpc_code = 1;
-	int32 http_code = 2;
-	string message = 3;
-	string http_status = 4;
-}
diff --git a/cmd/vendor/github.com/inconshreveable/mousetrap/README.md b/cmd/vendor/github.com/inconshreveable/mousetrap/README.md
deleted file mode 100644
index 7a950d1..0000000
--- a/cmd/vendor/github.com/inconshreveable/mousetrap/README.md
+++ /dev/null
@@ -1,23 +0,0 @@
-# mousetrap
-
-mousetrap is a tiny library that answers a single question.
-
-On a Windows machine, was the process invoked by someone double clicking on
-the executable file while browsing in explorer?
-
-### Motivation
-
-Windows developers unfamiliar with command line tools will often "double-click"
-the executable for a tool. Because most CLI tools print the help and then exit
-when invoked without arguments, this is often very frustrating for those users.
-
-mousetrap provides a way to detect these invocations so that you can provide
-more helpful behavior and instructions on how to run the CLI tool. To see what
-this looks like, both from an organizational and a technical perspective, see
-https://inconshreveable.com/09-09-2014/sweat-the-small-stuff/
-
-### The interface
-
-The library exposes a single interface:
-
-    func StartedByExplorer() (bool)
diff --git a/cmd/vendor/github.com/jonboulle/clockwork/.gitignore b/cmd/vendor/github.com/jonboulle/clockwork/.gitignore
deleted file mode 100644
index 010c242..0000000
--- a/cmd/vendor/github.com/jonboulle/clockwork/.gitignore
+++ /dev/null
@@ -1,25 +0,0 @@
-# Compiled Object files, Static and Dynamic libs (Shared Objects)
-*.o
-*.a
-*.so
-
-# Folders
-_obj
-_test
-
-# Architecture specific extensions/prefixes
-*.[568vq]
-[568vq].out
-
-*.cgo1.go
-*.cgo2.c
-_cgo_defun.c
-_cgo_gotypes.go
-_cgo_export.*
-
-_testmain.go
-
-*.exe
-*.test
-
-*.swp
diff --git a/cmd/vendor/github.com/jonboulle/clockwork/README.md b/cmd/vendor/github.com/jonboulle/clockwork/README.md
deleted file mode 100644
index 236c86a..0000000
--- a/cmd/vendor/github.com/jonboulle/clockwork/README.md
+++ /dev/null
@@ -1,58 +0,0 @@
-clockwork
-=========
-
-a simple fake clock for golang
-
-# Usage
-
-Replace uses of the `time` package with the `clockwork.Clock` interface instead.
-
-For example, instead of using `time.Sleep` directly:
-
-```
-func my_func() {
-	time.Sleep(3 * time.Second)
-	do_something()
-}
-```
-
-inject a clock and use its `Sleep` method instead:
-
-```
-func my_func(clock clockwork.Clock) {
-	clock.Sleep(3 * time.Second)
-	do_something()
-}
-```
-
-Now you can easily test `my_func` with a `FakeClock`:
-
-```
-func TestMyFunc(t *testing.T) {
-	c := clockwork.NewFakeClock()
-
-	// Start our sleepy function
-	my_func(c)
-
-	// Ensure we wait until my_func is sleeping
-	c.BlockUntil(1)
-
-	assert_state()
-
-	// Advance the FakeClock forward in time
-	c.Advance(3)
-
-	assert_state()
-}
-```
-
-and in production builds, simply inject the real clock instead:
-```
-my_func(clockwork.NewRealClock())
-```
-
-See [example_test.go](example_test.go) for a full example.
-
-# Credits
-
-Inspired by @wickman's [threaded fake clock](https://gist.github.com/wickman/3840816), and the [Golang playground](http://blog.golang.org/playground#Faking time)
diff --git a/cmd/vendor/github.com/kballard/go-shellquote/README b/cmd/vendor/github.com/kballard/go-shellquote/README
deleted file mode 100644
index 4d34e87..0000000
--- a/cmd/vendor/github.com/kballard/go-shellquote/README
+++ /dev/null
@@ -1,36 +0,0 @@
-PACKAGE
-
-package shellquote
-    import "github.com/kballard/go-shellquote"
-
-    Shellquote provides utilities for joining/splitting strings using sh's
-    word-splitting rules.
-
-VARIABLES
-
-var (
-    UnterminatedSingleQuoteError = errors.New("Unterminated single-quoted string")
-    UnterminatedDoubleQuoteError = errors.New("Unterminated double-quoted string")
-    UnterminatedEscapeError      = errors.New("Unterminated backslash-escape")
-)
-
-
-FUNCTIONS
-
-func Join(args ...string) string
-    Join quotes each argument and joins them with a space. If passed to
-    /bin/sh, the resulting string will be split back into the original
-    arguments.
-
-func Split(input string) (words []string, err error)
-    Split splits a string according to /bin/sh's word-splitting rules. It
-    supports backslash-escapes, single-quotes, and double-quotes. Notably it
-    does not support the $'' style of quoting. It also doesn't attempt to
-    perform any other sort of expansion, including brace expansion, shell
-    expansion, or pathname expansion.
-
-    If the given input has an unterminated quoted string or ends in a
-    backslash-escape, one of UnterminatedSingleQuoteError,
-    UnterminatedDoubleQuoteError, or UnterminatedEscapeError is returned.
-
-
diff --git a/cmd/vendor/github.com/kr/pty/.gitignore b/cmd/vendor/github.com/kr/pty/.gitignore
deleted file mode 100644
index 1f0a99f..0000000
--- a/cmd/vendor/github.com/kr/pty/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-[568].out
-_go*
-_test*
-_obj
diff --git a/cmd/vendor/github.com/kr/pty/README.md b/cmd/vendor/github.com/kr/pty/README.md
deleted file mode 100644
index 7b7900c..0000000
--- a/cmd/vendor/github.com/kr/pty/README.md
+++ /dev/null
@@ -1,36 +0,0 @@
-# pty
-
-Pty is a Go package for using unix pseudo-terminals.
-
-## Install
-
-    go get github.com/kr/pty
-
-## Example
-
-```go
-package main
-
-import (
-	"github.com/kr/pty"
-	"io"
-	"os"
-	"os/exec"
-)
-
-func main() {
-	c := exec.Command("grep", "--color=auto", "bar")
-	f, err := pty.Start(c)
-	if err != nil {
-		panic(err)
-	}
-
-	go func() {
-		f.Write([]byte("foo\n"))
-		f.Write([]byte("bar\n"))
-		f.Write([]byte("baz\n"))
-		f.Write([]byte{4}) // EOT
-	}()
-	io.Copy(os.Stdout, f)
-}
-```
diff --git a/cmd/vendor/github.com/kr/pty/mktypes.bash b/cmd/vendor/github.com/kr/pty/mktypes.bash
deleted file mode 100755
index 9952c88..0000000
--- a/cmd/vendor/github.com/kr/pty/mktypes.bash
+++ /dev/null
@@ -1,19 +0,0 @@
-#!/usr/bin/env bash
-
-GOOSARCH="${GOOS}_${GOARCH}"
-case "$GOOSARCH" in
-_* | *_ | _)
-	echo 'undefined $GOOS_$GOARCH:' "$GOOSARCH" 1>&2
-	exit 1
-	;;
-esac
-
-GODEFS="go tool cgo -godefs"
-
-$GODEFS types.go |gofmt > ztypes_$GOARCH.go
-
-case $GOOS in
-freebsd)
-	$GODEFS types_$GOOS.go |gofmt > ztypes_$GOOSARCH.go
-	;;
-esac
diff --git a/cmd/vendor/github.com/mattn/go-runewidth/.travis.yml b/cmd/vendor/github.com/mattn/go-runewidth/.travis.yml
deleted file mode 100644
index 5c9c2a3..0000000
--- a/cmd/vendor/github.com/mattn/go-runewidth/.travis.yml
+++ /dev/null
@@ -1,8 +0,0 @@
-language: go
-go:
-  - tip
-before_install:
-  - go get github.com/mattn/goveralls
-  - go get golang.org/x/tools/cmd/cover
-script:
-    - $HOME/gopath/bin/goveralls -repotoken lAKAWPzcGsD3A8yBX3BGGtRUdJ6CaGERL
diff --git a/cmd/vendor/github.com/mattn/go-runewidth/README.mkd b/cmd/vendor/github.com/mattn/go-runewidth/README.mkd
deleted file mode 100644
index ffb0edd..0000000
--- a/cmd/vendor/github.com/mattn/go-runewidth/README.mkd
+++ /dev/null
@@ -1,26 +0,0 @@
-go-runewidth
-============
-
-[![Build Status](https://travis-ci.org/mattn/go-runewidth.png?branch=master)](https://travis-ci.org/mattn/go-runewidth)
-[![Coverage Status](https://coveralls.io/repos/mattn/go-runewidth/badge.png?branch=HEAD)](https://coveralls.io/r/mattn/go-runewidth?branch=HEAD)
-[![GoDoc](https://godoc.org/github.com/mattn/go-runewidth?status.svg)](http://godoc.org/github.com/mattn/go-runewidth)
-
-Provides functions to get fixed width of the character or string.
-
-Usage
------
-
-```go
-runewidth.StringWidth("つのだ☆HIRO") == 12
-```
-
-
-Author
-------
-
-Yasuhiro Matsumoto
-
-License
--------
-
-under the MIT License: http://mattn.mit-license.org/2013
diff --git a/cmd/vendor/github.com/olekukonko/tablewriter/.travis.yml b/cmd/vendor/github.com/olekukonko/tablewriter/.travis.yml
deleted file mode 100644
index 354b7f8..0000000
--- a/cmd/vendor/github.com/olekukonko/tablewriter/.travis.yml
+++ /dev/null
@@ -1,8 +0,0 @@
-language: go
-
-go:
-  - 1.1
-  - 1.2
-  - 1.3
-  - 1.4
-  - tip
diff --git a/cmd/vendor/github.com/olekukonko/tablewriter/README.md b/cmd/vendor/github.com/olekukonko/tablewriter/README.md
deleted file mode 100644
index 4ee4435..0000000
--- a/cmd/vendor/github.com/olekukonko/tablewriter/README.md
+++ /dev/null
@@ -1,141 +0,0 @@
-ASCII Table Writer
-=========
-
-[![Build Status](https://travis-ci.org/olekukonko/tablewriter.png?branch=master)](https://travis-ci.org/olekukonko/tablewriter) [![Total views](https://sourcegraph.com/api/repos/github.com/olekukonko/tablewriter/counters/views.png)](https://sourcegraph.com/github.com/olekukonko/tablewriter)
-
-Generate ASCII table on the fly ...  Installation is simple as
-
-    go get  github.com/olekukonko/tablewriter
-
-
-#### Features
-- Automatic Padding
-- Support Multiple Lines
-- Supports Alignment
-- Support Custom Separators
-- Automatic Alignment of numbers & percentage
-- Write directly to http , file etc via `io.Writer`
-- Read directly from CSV file
-- Optional row line via `SetRowLine`
-- Normalise table header
-- Make CSV Headers optional
-- Enable or disable table border
-- Set custom footer support
-
-
-#### Example   1 - Basic
-```go
-data := [][]string{
-    []string{"A", "The Good", "500"},
-    []string{"B", "The Very very Bad Man", "288"},
-    []string{"C", "The Ugly", "120"},
-    []string{"D", "The Gopher", "800"},
-}
-
-table := tablewriter.NewWriter(os.Stdout)
-table.SetHeader([]string{"Name", "Sign", "Rating"})
-
-for _, v := range data {
-    table.Append(v)
-}
-table.Render() // Send output
-```
-
-##### Output  1
-```
-+------+-----------------------+--------+
-| NAME |         SIGN          | RATING |
-+------+-----------------------+--------+
-|  A   |       The Good        |    500 |
-|  B   | The Very very Bad Man |    288 |
-|  C   |       The Ugly        |    120 |
-|  D   |      The Gopher       |    800 |
-+------+-----------------------+--------+
-```
-
-#### Example 2 - Without Border / Footer / Bulk Append
-```go
-data := [][]string{
-    []string{"1/1/2014", "Domain name", "2233", "$10.98"},
-    []string{"1/1/2014", "January Hosting", "2233", "$54.95"},
-    []string{"1/4/2014", "February Hosting", "2233", "$51.00"},
-    []string{"1/4/2014", "February Extra Bandwidth", "2233", "$30.00"},
-}
-
-table := tablewriter.NewWriter(os.Stdout)
-table.SetHeader([]string{"Date", "Description", "CV2", "Amount"})
-table.SetFooter([]string{"", "", "Total", "$146.93"}) // Add Footer
-table.SetBorder(false)                                // Set Border to false
-table.AppendBulk(data)                                // Add Bulk Data
-table.Render()
-```
-
-##### Output 2
-```
-
-    DATE   |       DESCRIPTION        |  CV2  | AMOUNT
-+----------+--------------------------+-------+---------+
-  1/1/2014 | Domain name              |  2233 | $10.98
-  1/1/2014 | January Hosting          |  2233 | $54.95
-  1/4/2014 | February Hosting         |  2233 | $51.00
-  1/4/2014 | February Extra Bandwidth |  2233 | $30.00
-+----------+--------------------------+-------+---------+
-                                        TOTAL | $146 93
-                                      +-------+---------+
-
-```
-
-
-#### Example 3 - CSV
-```go
-table, _ := tablewriter.NewCSV(os.Stdout, "test_info.csv", true)
-table.SetAlignment(tablewriter.ALIGN_LEFT)   // Set Alignment
-table.Render()
-```
-
-##### Output 3
-```
-+----------+--------------+------+-----+---------+----------------+
-|  FIELD   |     TYPE     | NULL | KEY | DEFAULT |     EXTRA      |
-+----------+--------------+------+-----+---------+----------------+
-| user_id  | smallint(5)  | NO   | PRI | NULL    | auto_increment |
-| username | varchar(10)  | NO   |     | NULL    |                |
-| password | varchar(100) | NO   |     | NULL    |                |
-+----------+--------------+------+-----+---------+----------------+
-```
-
-#### Example 4  - Custom Separator
-```go
-table, _ := tablewriter.NewCSV(os.Stdout, "test.csv", true)
-table.SetRowLine(true)         // Enable row line
-
-// Change table lines
-table.SetCenterSeparator("*")
-table.SetColumnSeparator("‡")
-table.SetRowSeparator("-")
-
-table.SetAlignment(tablewriter.ALIGN_LEFT)
-table.Render()
-```
-
-##### Output 4
-```
-*------------*-----------*---------*
-╪ FIRST NAME ╪ LAST NAME ╪   SSN   ╪
-*------------*-----------*---------*
-╪ John       ╪ Barry     ╪ 123456  ╪
-*------------*-----------*---------*
-╪ Kathy      ╪ Smith     ╪ 687987  ╪
-*------------*-----------*---------*
-╪ Bob        ╪ McCornick ╪ 3979870 ╪
-*------------*-----------*---------*
-```
-
-#### TODO
-- ~~Import Directly from CSV~~  - `done`
-- ~~Support for `SetFooter`~~  - `done`
-- ~~Support for `SetBorder`~~  - `done`
-- ~~Support table with uneven rows~~ - `done`
-- Support custom alignment
-- General Improvement & Optimisation
-- `NewHTML` Parse table from HTML
diff --git a/cmd/vendor/github.com/olekukonko/tablewriter/test.csv b/cmd/vendor/github.com/olekukonko/tablewriter/test.csv
deleted file mode 100644
index 1609327..0000000
--- a/cmd/vendor/github.com/olekukonko/tablewriter/test.csv
+++ /dev/null
@@ -1,4 +0,0 @@
-first_name,last_name,ssn
-John,Barry,123456
-Kathy,Smith,687987
-Bob,McCornick,3979870
\ No newline at end of file
diff --git a/cmd/vendor/github.com/olekukonko/tablewriter/test_info.csv b/cmd/vendor/github.com/olekukonko/tablewriter/test_info.csv
deleted file mode 100644
index e4c40e9..0000000
--- a/cmd/vendor/github.com/olekukonko/tablewriter/test_info.csv
+++ /dev/null
@@ -1,4 +0,0 @@
-Field,Type,Null,Key,Default,Extra
-user_id,smallint(5),NO,PRI,NULL,auto_increment
-username,varchar(10),NO,,NULL, 
-password,varchar(100),NO,,NULL, 
\ No newline at end of file
diff --git a/cmd/vendor/github.com/prometheus/client_golang/prometheus/.gitignore b/cmd/vendor/github.com/prometheus/client_golang/prometheus/.gitignore
deleted file mode 100644
index 3460f03..0000000
--- a/cmd/vendor/github.com/prometheus/client_golang/prometheus/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-command-line-arguments.test
diff --git a/cmd/vendor/github.com/prometheus/client_golang/prometheus/README.md b/cmd/vendor/github.com/prometheus/client_golang/prometheus/README.md
deleted file mode 100644
index 81032be..0000000
--- a/cmd/vendor/github.com/prometheus/client_golang/prometheus/README.md
+++ /dev/null
@@ -1,53 +0,0 @@
-# Overview
-This is the [Prometheus](http://www.prometheus.io) telemetric
-instrumentation client [Go](http://golang.org) client library.  It
-enable authors to define process-space metrics for their servers and
-expose them through a web service interface for extraction,
-aggregation, and a whole slew of other post processing techniques.
-
-# Installing
-    $ go get github.com/prometheus/client_golang/prometheus
-
-# Example
-```go
-package main
-
-import (
-	"net/http"
-
-	"github.com/prometheus/client_golang/prometheus"
-)
-
-var (
-	indexed = prometheus.NewCounter(prometheus.CounterOpts{
-		Namespace: "my_company",
-		Subsystem: "indexer",
-		Name:      "documents_indexed",
-		Help:      "The number of documents indexed.",
-	})
-	size = prometheus.NewGauge(prometheus.GaugeOpts{
-		Namespace: "my_company",
-		Subsystem: "storage",
-		Name:      "documents_total_size_bytes",
-		Help:      "The total size of all documents in the storage.",
-	})
-)
-
-func main() {
-	http.Handle("/metrics", prometheus.Handler())
-
-	indexed.Inc()
-	size.Set(5)
-
-	http.ListenAndServe(":8080", nil)
-}
-
-func init() {
-	prometheus.MustRegister(indexed)
-	prometheus.MustRegister(size)
-}
-```
-
-# Documentation
-
-[![GoDoc](https://godoc.org/github.com/prometheus/client_golang?status.png)](https://godoc.org/github.com/prometheus/client_golang)
diff --git a/cmd/vendor/github.com/prometheus/procfs/.travis.yml b/cmd/vendor/github.com/prometheus/procfs/.travis.yml
deleted file mode 100644
index 25e169d..0000000
--- a/cmd/vendor/github.com/prometheus/procfs/.travis.yml
+++ /dev/null
@@ -1,7 +0,0 @@
-sudo: false
-language: go
-go:
-    - 1.3
-    - 1.4
-    - 1.5
-    - tip
diff --git a/cmd/vendor/github.com/prometheus/procfs/AUTHORS.md b/cmd/vendor/github.com/prometheus/procfs/AUTHORS.md
deleted file mode 100644
index f1c27cc..0000000
--- a/cmd/vendor/github.com/prometheus/procfs/AUTHORS.md
+++ /dev/null
@@ -1,20 +0,0 @@
-The Prometheus project was started by Matt T. Proud (emeritus) and
-Julius Volz in 2012.
-
-Maintainers of this repository:
-
-* Tobias Schmidt <ts@soundcloud.com>
-
-The following individuals have contributed code to this repository
-(listed in alphabetical order):
-
-* Armen Baghumian <abaghumian@noggin.com.au>
-* Bjoern Rabenstein <beorn@soundcloud.com>
-* David Cournapeau <cournape@gmail.com>
-* Ji-Hoon, Seol <jihoon.seol@gmail.com>
-* Jonas Große Sundrup <cherti@letopolis.de>
-* Julius Volz <julius@soundcloud.com>
-* Matthias Rampke <mr@soundcloud.com>
-* Nicky Gerritsen <nicky@streamone.nl>
-* Rémi Audebert <contact@halfr.net>
-* Tobias Schmidt <tobidt@gmail.com>
diff --git a/cmd/vendor/github.com/prometheus/procfs/CONTRIBUTING.md b/cmd/vendor/github.com/prometheus/procfs/CONTRIBUTING.md
deleted file mode 100644
index 5705f0f..0000000
--- a/cmd/vendor/github.com/prometheus/procfs/CONTRIBUTING.md
+++ /dev/null
@@ -1,18 +0,0 @@
-# Contributing
-
-Prometheus uses GitHub to manage reviews of pull requests.
-
-* If you have a trivial fix or improvement, go ahead and create a pull
-  request, addressing (with `@...`) one or more of the maintainers
-  (see [AUTHORS.md](AUTHORS.md)) in the description of the pull request.
-
-* If you plan to do something more involved, first discuss your ideas
-  on our [mailing list](https://groups.google.com/forum/?fromgroups#!forum/prometheus-developers).
-  This will avoid unnecessary work and surely give you and us a good deal
-  of inspiration.
-
-* Relevant coding style guidelines are the [Go Code Review
-  Comments](https://code.google.com/p/go-wiki/wiki/CodeReviewComments)
-  and the _Formatting and style_ section of Peter Bourgon's [Go: Best
-  Practices for Production
-  Environments](http://peter.bourgon.org/go-in-production/#formatting-and-style).
diff --git a/cmd/vendor/github.com/prometheus/procfs/Makefile b/cmd/vendor/github.com/prometheus/procfs/Makefile
deleted file mode 100644
index e8acbbc..0000000
--- a/cmd/vendor/github.com/prometheus/procfs/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-ci:
-	go fmt
-	go vet
-	go test -v ./...
-	go get github.com/golang/lint/golint
-	golint *.go
diff --git a/cmd/vendor/github.com/prometheus/procfs/README.md b/cmd/vendor/github.com/prometheus/procfs/README.md
deleted file mode 100644
index 6e7ee6b..0000000
--- a/cmd/vendor/github.com/prometheus/procfs/README.md
+++ /dev/null
@@ -1,10 +0,0 @@
-# procfs
-
-This procfs package provides functions to retrieve system, kernel and process
-metrics from the pseudo-filesystem proc.
-
-*WARNING*: This package is a work in progress. Its API may still break in
-backwards-incompatible ways without warnings. Use it at your own risk.
-
-[![GoDoc](https://godoc.org/github.com/prometheus/procfs?status.png)](https://godoc.org/github.com/prometheus/procfs)
-[![Build Status](https://travis-ci.org/prometheus/procfs.svg?branch=master)](https://travis-ci.org/prometheus/procfs)
diff --git a/cmd/vendor/github.com/russross/blackfriday/.gitignore b/cmd/vendor/github.com/russross/blackfriday/.gitignore
deleted file mode 100644
index 75623dc..0000000
--- a/cmd/vendor/github.com/russross/blackfriday/.gitignore
+++ /dev/null
@@ -1,8 +0,0 @@
-*.out
-*.swp
-*.8
-*.6
-_obj
-_test*
-markdown
-tags
diff --git a/cmd/vendor/github.com/russross/blackfriday/.travis.yml b/cmd/vendor/github.com/russross/blackfriday/.travis.yml
deleted file mode 100644
index 208fd25..0000000
--- a/cmd/vendor/github.com/russross/blackfriday/.travis.yml
+++ /dev/null
@@ -1,18 +0,0 @@
-# Travis CI (http://travis-ci.org/) is a continuous integration service for
-# open source projects. This file configures it to run unit tests for
-# blackfriday.
-
-language: go
-
-go:
-    - 1.2
-    - 1.3
-    - 1.4
-    - 1.5
-
-install:
-    - go get -d -t -v ./...
-    - go build -v ./...
-
-script:
-    - go test -v ./...
diff --git a/cmd/vendor/github.com/russross/blackfriday/README.md b/cmd/vendor/github.com/russross/blackfriday/README.md
deleted file mode 100644
index dd8eb16..0000000
--- a/cmd/vendor/github.com/russross/blackfriday/README.md
+++ /dev/null
@@ -1,267 +0,0 @@
-Blackfriday [![Build Status](https://travis-ci.org/russross/blackfriday.svg?branch=master)](https://travis-ci.org/russross/blackfriday)
-===========
-
-Blackfriday is a [Markdown][1] processor implemented in [Go][2]. It
-is paranoid about its input (so you can safely feed it user-supplied
-data), it is fast, it supports common extensions (tables, smart
-punctuation substitutions, etc.), and it is safe for all utf-8
-(unicode) input.
-
-HTML output is currently supported, along with Smartypants
-extensions. An experimental LaTeX output engine is also included.
-
-It started as a translation from C of [Sundown][3].
-
-
-Installation
-------------
-
-Blackfriday is compatible with Go 1. If you are using an older
-release of Go, consider using v1.1 of blackfriday, which was based
-on the last stable release of Go prior to Go 1. You can find it as a
-tagged commit on github.
-
-With Go 1 and git installed:
-
-    go get github.com/russross/blackfriday
-
-will download, compile, and install the package into your `$GOPATH`
-directory hierarchy. Alternatively, you can achieve the same if you
-import it into a project:
-
-    import "github.com/russross/blackfriday"
-
-and `go get` without parameters.
-
-Usage
------
-
-For basic usage, it is as simple as getting your input into a byte
-slice and calling:
-
-    output := blackfriday.MarkdownBasic(input)
-
-This renders it with no extensions enabled. To get a more useful
-feature set, use this instead:
-
-    output := blackfriday.MarkdownCommon(input)
-
-### Sanitize untrusted content
-
-Blackfriday itself does nothing to protect against malicious content. If you are
-dealing with user-supplied markdown, we recommend running blackfriday's output
-through HTML sanitizer such as
-[Bluemonday](https://github.com/microcosm-cc/bluemonday).
-
-Here's an example of simple usage of blackfriday together with bluemonday:
-
-``` go
-import (
-    "github.com/microcosm-cc/bluemonday"
-    "github.com/russross/blackfriday"
-)
-
-// ...
-unsafe := blackfriday.MarkdownCommon(input)
-html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
-```
-
-### Custom options
-
-If you want to customize the set of options, first get a renderer
-(currently either the HTML or LaTeX output engines), then use it to
-call the more general `Markdown` function. For examples, see the
-implementations of `MarkdownBasic` and `MarkdownCommon` in
-`markdown.go`.
-
-You can also check out `blackfriday-tool` for a more complete example
-of how to use it. Download and install it using:
-
-    go get github.com/russross/blackfriday-tool
-
-This is a simple command-line tool that allows you to process a
-markdown file using a standalone program.  You can also browse the
-source directly on github if you are just looking for some example
-code:
-
-* <http://github.com/russross/blackfriday-tool>
-
-Note that if you have not already done so, installing
-`blackfriday-tool` will be sufficient to download and install
-blackfriday in addition to the tool itself. The tool binary will be
-installed in `$GOPATH/bin`.  This is a statically-linked binary that
-can be copied to wherever you need it without worrying about
-dependencies and library versions.
-
-
-Features
---------
-
-All features of Sundown are supported, including:
-
-*   **Compatibility**. The Markdown v1.0.3 test suite passes with
-    the `--tidy` option.  Without `--tidy`, the differences are
-    mostly in whitespace and entity escaping, where blackfriday is
-    more consistent and cleaner.
-
-*   **Common extensions**, including table support, fenced code
-    blocks, autolinks, strikethroughs, non-strict emphasis, etc.
-
-*   **Safety**. Blackfriday is paranoid when parsing, making it safe
-    to feed untrusted user input without fear of bad things
-    happening. The test suite stress tests this and there are no
-    known inputs that make it crash.  If you find one, please let me
-    know and send me the input that does it.
-
-    NOTE: "safety" in this context means *runtime safety only*. In order to
-    protect yourself agains JavaScript injection in untrusted content, see
-    [this example](https://github.com/russross/blackfriday#sanitize-untrusted-content).
-
-*   **Fast processing**. It is fast enough to render on-demand in
-    most web applications without having to cache the output.
-
-*   **Thread safety**. You can run multiple parsers in different
-    goroutines without ill effect. There is no dependence on global
-    shared state.
-
-*   **Minimal dependencies**. Blackfriday only depends on standard
-    library packages in Go. The source code is pretty
-    self-contained, so it is easy to add to any project, including
-    Google App Engine projects.
-
-*   **Standards compliant**. Output successfully validates using the
-    W3C validation tool for HTML 4.01 and XHTML 1.0 Transitional.
-
-
-Extensions
-----------
-
-In addition to the standard markdown syntax, this package
-implements the following extensions:
-
-*   **Intra-word emphasis supression**. The `_` character is
-    commonly used inside words when discussing code, so having
-    markdown interpret it as an emphasis command is usually the
-    wrong thing. Blackfriday lets you treat all emphasis markers as
-    normal characters when they occur inside a word.
-
-*   **Tables**. Tables can be created by drawing them in the input
-    using a simple syntax:
-
-    ```
-    Name    | Age
-    --------|------
-    Bob     | 27
-    Alice   | 23
-    ```
-
-*   **Fenced code blocks**. In addition to the normal 4-space
-    indentation to mark code blocks, you can explicitly mark them
-    and supply a language (to make syntax highlighting simple). Just
-    mark it like this:
-
-        ``` go
-        func getTrue() bool {
-            return true
-        }
-        ```
-
-    You can use 3 or more backticks to mark the beginning of the
-    block, and the same number to mark the end of the block.
-
-*   **Definition lists**. A simple definition list is made of a single-line
-    term followed by a colon and the definition for that term.
-
-        Cat
-        : Fluffy animal everyone likes
-        
-        Internet
-        : Vector of transmission for pictures of cats
-
-    Terms must be separated from the previous definition by a blank line.
-
-*   **Footnotes**. A marker in the text that will become a superscript number;
-    a footnote definition that will be placed in a list of footnotes at the
-    end of the document. A footnote looks like this:
-
-        This is a footnote.[^1]
-        
-        [^1]: the footnote text.
-
-*   **Autolinking**. Blackfriday can find URLs that have not been
-    explicitly marked as links and turn them into links.
-
-*   **Strikethrough**. Use two tildes (`~~`) to mark text that
-    should be crossed out.
-
-*   **Hard line breaks**. With this extension enabled (it is off by
-    default in the `MarkdownBasic` and `MarkdownCommon` convenience
-    functions), newlines in the input translate into line breaks in
-    the output.
-
-*   **Smart quotes**. Smartypants-style punctuation substitution is
-    supported, turning normal double- and single-quote marks into
-    curly quotes, etc.
-
-*   **LaTeX-style dash parsing** is an additional option, where `--`
-    is translated into `&ndash;`, and `---` is translated into
-    `&mdash;`. This differs from most smartypants processors, which
-    turn a single hyphen into an ndash and a double hyphen into an
-    mdash.
-
-*   **Smart fractions**, where anything that looks like a fraction
-    is translated into suitable HTML (instead of just a few special
-    cases like most smartypant processors). For example, `4/5`
-    becomes `<sup>4</sup>&frasl;<sub>5</sub>`, which renders as
-    <sup>4</sup>&frasl;<sub>5</sub>.
-
-
-Other renderers
----------------
-
-Blackfriday is structured to allow alternative rendering engines. Here
-are a few of note:
-
-*   [github_flavored_markdown](https://godoc.org/github.com/shurcooL/github_flavored_markdown):
-    provides a GitHub Flavored Markdown renderer with fenced code block
-    highlighting, clickable header anchor links.
-
-    It's not customizable, and its goal is to produce HTML output
-    equivalent to the [GitHub Markdown API endpoint](https://developer.github.com/v3/markdown/#render-a-markdown-document-in-raw-mode),
-    except the rendering is performed locally.
-
-*   [markdownfmt](https://github.com/shurcooL/markdownfmt): like gofmt,
-    but for markdown.
-
-*   LaTeX output: renders output as LaTeX. This is currently part of the
-    main Blackfriday repository, but may be split into its own project
-    in the future. If you are interested in owning and maintaining the
-    LaTeX output component, please be in touch.
-
-    It renders some basic documents, but is only experimental at this
-    point. In particular, it does not do any inline escaping, so input
-    that happens to look like LaTeX code will be passed through without
-    modification.
-    
-*   [Md2Vim](https://github.com/FooSoft/md2vim): transforms markdown files into vimdoc format.
-
-
-Todo
-----
-
-*   More unit testing
-*   Improve unicode support. It does not understand all unicode
-    rules (about what constitutes a letter, a punctuation symbol,
-    etc.), so it may fail to detect word boundaries correctly in
-    some instances. It is safe on all utf-8 input.
-
-
-License
--------
-
-[Blackfriday is distributed under the Simplified BSD License](LICENSE.txt)
-
-
-   [1]: http://daringfireball.net/projects/markdown/ "Markdown"
-   [2]: http://golang.org/ "Go Language"
-   [3]: https://github.com/vmg/sundown "Sundown"
diff --git a/cmd/vendor/github.com/shurcooL/sanitized_anchor_name/.travis.yml b/cmd/vendor/github.com/shurcooL/sanitized_anchor_name/.travis.yml
deleted file mode 100644
index bcf9f82..0000000
--- a/cmd/vendor/github.com/shurcooL/sanitized_anchor_name/.travis.yml
+++ /dev/null
@@ -1,10 +0,0 @@
-language: go
-go:
-  - 1.5
-install:
-  - go get golang.org/x/tools/cmd/vet
-script:
-  - go get -t -v ./...
-  - diff -u <(echo -n) <(gofmt -d -s .)
-  - go tool vet .
-  - go test -v -race ./...
diff --git a/cmd/vendor/github.com/shurcooL/sanitized_anchor_name/README.md b/cmd/vendor/github.com/shurcooL/sanitized_anchor_name/README.md
deleted file mode 100644
index cb76fe1..0000000
--- a/cmd/vendor/github.com/shurcooL/sanitized_anchor_name/README.md
+++ /dev/null
@@ -1,31 +0,0 @@
-# sanitized_anchor_name [![Build Status](https://travis-ci.org/shurcooL/sanitized_anchor_name.svg?branch=master)](https://travis-ci.org/shurcooL/sanitized_anchor_name) [![GoDoc](https://godoc.org/github.com/shurcooL/sanitized_anchor_name?status.svg)](https://godoc.org/github.com/shurcooL/sanitized_anchor_name)
-
-Package sanitized_anchor_name provides a func to create sanitized anchor names.
-
-Its logic can be reused by multiple packages to create interoperable anchor names and links to those anchors.
-
-At this time, it does not try to ensure that generated anchor names are unique, that responsibility falls on the caller.
-
-Installation
-------------
-
-```bash
-go get -u github.com/shurcooL/sanitized_anchor_name
-```
-
-Example
--------
-
-```Go
-anchorName := sanitized_anchor_name.Create("This is a header")
-
-fmt.Println(anchorName)
-
-// Output:
-// this-is-a-header
-```
-
-License
--------
-
-- [MIT License](LICENSE)
diff --git a/cmd/vendor/github.com/shurcooL/sanitized_anchor_name/main.go b/cmd/vendor/github.com/shurcooL/sanitized_anchor_name/main.go
index 6baae23..72a8753 100644
--- a/cmd/vendor/github.com/shurcooL/sanitized_anchor_name/main.go
+++ b/cmd/vendor/github.com/shurcooL/sanitized_anchor_name/main.go
@@ -5,7 +5,7 @@
 //
 // At this time, it does not try to ensure that generated anchor names
 // are unique, that responsibility falls on the caller.
-package sanitized_anchor_name
+package sanitized_anchor_name // import "github.com/shurcooL/sanitized_anchor_name"
 
 import "unicode"
 
diff --git a/cmd/vendor/github.com/spacejam/loghisto/.travis.yml b/cmd/vendor/github.com/spacejam/loghisto/.travis.yml
deleted file mode 100644
index e8197a2..0000000
--- a/cmd/vendor/github.com/spacejam/loghisto/.travis.yml
+++ /dev/null
@@ -1,5 +0,0 @@
-language: go
-
-go:
-  - 1.4
-  - tip
diff --git a/cmd/vendor/github.com/spacejam/loghisto/readme.md b/cmd/vendor/github.com/spacejam/loghisto/readme.md
deleted file mode 100644
index 67a61b6..0000000
--- a/cmd/vendor/github.com/spacejam/loghisto/readme.md
+++ /dev/null
@@ -1,113 +0,0 @@
-loghisto
-============
-[![Build Status](https://travis-ci.org/spacejam/loghisto.svg)](https://travis-ci.org/spacejam/loghisto)
-
-A metric system for high performance counters and histograms.  Unlike popular metric systems today, this does not destroy the accuracy of histograms by sampling.  Instead, a logarithmic bucketing function compresses values, generally within 1% of their true value (although between 0 and 1 the precision loss may not be within this boundary).  This allows for extreme compression, which allows us to calculate arbitrarily high percentiles with no loss of accuracy - just a small amount of precision.  This is particularly useful for highly-clustered events that are tolerant of a small precision loss, but for which you REALLY care about what the tail looks like, such as measuring latency across a distributed system.
-
-Copied out of my work for the CockroachDB metrics system.  Based on an algorithm created by Keith Frost.
-
-
-### running a print benchmark for quick analysis
-```go
-package main
-
-import (
-  "runtime"
-  "github.com/spacejam/loghisto"
-)
-
-func benchmark() {
-  // do some stuff
-}
-
-func main() {
-  numCPU := runtime.NumCPU()
-  runtime.GOMAXPROCS(numCPU)
-
-  desiredConcurrency := uint(100)
-  loghisto.PrintBenchmark("benchmark1234", desiredConcurrency, benchmark)
-}
-```
-results in something like this printed to stdout each second:
-```
-2014-12-11 21:41:45 -0500 EST
-benchmark1234_count:     2.0171025e+07
-benchmark1234_max:       2.4642914167480484e+07
-benchmark1234_99.99:     4913.768840299134
-benchmark1234_99.9:      1001.2472422902518
-benchmark1234_99:        71.24044000732538
-benchmark1234_95:        67.03348428941965
-benchmark1234_90:        65.68633104092515
-benchmark1234_75:        63.07152259993664
-benchmark1234_50:        58.739891704145194
-benchmark1234_min:       -657.5233632152207           // Corollary: time.Since(time.Now()) is often < 0
-benchmark1234_sum:       1.648051169322668e+09
-benchmark1234_avg:       81.70388809307748
-benchmark1234_agg_avg:   89
-benchmark1234_agg_count: 6.0962226e+07
-benchmark1234_agg_sum:   5.454779078e+09
-sys.Alloc:               1.132672e+06
-sys.NumGC:               5741
-sys.PauseTotalNs:        1.569390954e+09
-sys.NumGoroutine:        113
-```
-### adding an embedded metric system to your code
-```go
-import (
-  "time"
-  "fmt"
-  "github.com/spacejam/loghisto"
-)
-func ExampleMetricSystem() {
-  // Create metric system that reports once a minute, and includes stats
-  // about goroutines, memory usage and GC.
-  includeGoProcessStats := true
-  ms := loghisto.NewMetricSystem(time.Minute, includeGoProcessStats)
-  ms.Start()
-
-  // create a channel that subscribes to metrics as they are produced once
-  // per minute.
-  // NOTE: if you allow this channel to fill up, the metric system will NOT
-  // block, and  will FORGET about your channel if you fail to unblock the
-  // channel after 3 configured intervals (in this case 3 minutes) rather
-  // than causing a memory leak.
-  myMetricStream := make(chan *loghisto.ProcessedMetricSet, 2)
-  ms.SubscribeToProcessedMetrics(myMetricStream)
-
-  // create some metrics
-  timeToken := ms.StartTimer("time for creating a counter and histo")
-  ms.Counter("some event", 1)
-  ms.Histogram("some measured thing", 123)
-  timeToken.Stop()
-
-  for m := range myMetricStream {
-    fmt.Printf("number of goroutines: %f\n", m.Metrics["sys.NumGoroutine"])
-  }
-
-  // if you want to manually unsubscribe from the metric stream
-  ms.UnsubscribeFromProcessedMetrics(myMetricStream)
-
-  // to stop and clean up your metric system
-  ms.Stop()
-}
-```
-### automatically sending your metrics to OpenTSDB, KairosDB or Graphite
-```go
-func ExampleExternalSubmitter() {
-  includeGoProcessStats := true
-  ms := NewMetricSystem(time.Minute, includeGoProcessStats)
-  ms.Start()
-  // graphite
-  s := NewSubmitter(ms, GraphiteProtocol, "tcp", "localhost:7777")
-  s.Start()
-
-  // opentsdb / kairosdb
-  s := NewSubmitter(ms, OpenTSDBProtocol, "tcp", "localhost:7777")
-  s.Start()
-
-  // to tear down:
-  s.Shutdown()
-}
-```
-
-See code for the Graphite/OpenTSDB protocols for adding your own output plugins, it's pretty simple.
diff --git a/cmd/vendor/github.com/spf13/cobra/.gitignore b/cmd/vendor/github.com/spf13/cobra/.gitignore
deleted file mode 100644
index 36d1a84..0000000
--- a/cmd/vendor/github.com/spf13/cobra/.gitignore
+++ /dev/null
@@ -1,24 +0,0 @@
-# Compiled Object files, Static and Dynamic libs (Shared Objects)
-*.o
-*.a
-*.so
-
-# Folders
-_obj
-_test
-
-# Architecture specific extensions/prefixes
-*.[568vq]
-[568vq].out
-
-*.cgo1.go
-*.cgo2.c
-_cgo_defun.c
-_cgo_gotypes.go
-_cgo_export.*
-
-_testmain.go
-
-*.exe
-
-cobra.test
diff --git a/cmd/vendor/github.com/spf13/cobra/.mailmap b/cmd/vendor/github.com/spf13/cobra/.mailmap
deleted file mode 100644
index 94ec530..0000000
--- a/cmd/vendor/github.com/spf13/cobra/.mailmap
+++ /dev/null
@@ -1,3 +0,0 @@
-Steve Francia <steve.francia@gmail.com>
-Bjørn Erik Pedersen <bjorn.erik.pedersen@gmail.com>
-Fabiano Franz <ffranz@redhat.com>                   <contact@fabianofranz.com>
diff --git a/cmd/vendor/github.com/spf13/cobra/.travis.yml b/cmd/vendor/github.com/spf13/cobra/.travis.yml
deleted file mode 100644
index 7a6cb7f..0000000
--- a/cmd/vendor/github.com/spf13/cobra/.travis.yml
+++ /dev/null
@@ -1,9 +0,0 @@
-language: go
-go:
-  - 1.3.3
-  - 1.4.2
-  - 1.5.1
-  - tip
-script:
-  - go test -v ./...
-  - go build
diff --git a/cmd/vendor/github.com/spf13/cobra/README.md b/cmd/vendor/github.com/spf13/cobra/README.md
deleted file mode 100644
index caeebb9..0000000
--- a/cmd/vendor/github.com/spf13/cobra/README.md
+++ /dev/null
@@ -1,869 +0,0 @@
-![cobra logo](https://cloud.githubusercontent.com/assets/173412/10886352/ad566232-814f-11e5-9cd0-aa101788c117.png)
-
-Cobra is both a library for creating powerful modern CLI applications as well as a program to generate applications and command files.
-
-Many of the most widely used Go projects are built using Cobra including:
-
-* [Kubernetes](http://kubernetes.io/)
-* [Hugo](http://gohugo.io)
-* [rkt](https://github.com/coreos/rkt)
-* [Docker (distribution)](https://github.com/docker/distribution)
-* [OpenShift](https://www.openshift.com/)
-* [Delve](https://github.com/derekparker/delve)
-* [GopherJS](http://www.gopherjs.org/)
-* [CockroachDB](http://www.cockroachlabs.com/)
-* [Bleve](http://www.blevesearch.com/)
-* [ProjectAtomic (enterprise)](http://www.projectatomic.io/)
-* [Parse (CLI)](https://parse.com/)
-
-
-[![Build Status](https://travis-ci.org/spf13/cobra.svg "Travis CI status")](https://travis-ci.org/spf13/cobra) 
-[![CircleCI status](https://circleci.com/gh/spf13/cobra.png?circle-token=:circle-token "CircleCI status")](https://circleci.com/gh/spf13/cobra)
-
-![cobra](https://cloud.githubusercontent.com/assets/173412/10911369/84832a8e-8212-11e5-9f82-cc96660a4794.gif)
-
-# Overview
-
-Cobra is a library providing a simple interface to create powerful modern CLI
-interfaces similar to git & go tools.
-
-Cobra is also an application that will generate your application scaffolding to rapidly
-develop a Cobra-based application.
-
-Cobra provides:
-* Easy subcommand-based CLIs: `app server`, `app fetch`, etc.
-* Fully POSIX-compliant flags (including short & long versions)
-* Nested subcommands
-* Global, local and cascading flags
-* Easy generation of applications & commands with `cobra create appname` & `cobra add cmdname`
-* Intelligent suggestions (`app srver`... did you mean `app server`?)
-* Automatic help generation for commands and flags
-* Automatic detailed help for `app help [command]`
-* Automatic help flag recognition of `-h`, `--help`, etc.
-* Automatically generated bash autocomplete for your application
-* Automatically generated man pages for your application
-* Command aliases so you can change things without breaking them
-* The flexibilty to define your own help, usage, etc.
-* Optional tight integration with [viper](http://github.com/spf13/viper) for 12-factor apps
-
-Cobra has an exceptionally clean interface and simple design without needless
-constructors or initialization methods.
-
-Applications built with Cobra commands are designed to be as user-friendly as
-possible. Flags can be placed before or after the command (as long as a
-confusing space isn’t provided). Both short and long flags can be used. A
-command need not even be fully typed.  Help is automatically generated and
-available for the application or for a specific command using either the help
-command or the `--help` flag.
-
-# Concepts
-
-Cobra is built on a structure of commands, arguments & flags.
-
-**Commands** represent actions, **Args** are things and **Flags** are modifiers for those actions.
-
-The best applications will read like sentences when used. Users will know how
-to use the application because they will natively understand how to use it.
-
-The pattern to follow is 
-`APPNAME VERB NOUN --ADJECTIVE.`
-    or
-`APPNAME COMMAND ARG --FLAG`
-
-A few good real world examples may better illustrate this point.
-
-In the following example, 'server' is a command, and 'port' is a flag:
-
-    > hugo serve --port=1313
-
-In this command we are telling Git to clone the url bare.
-
-    > git clone URL --bare
-
-## Commands
-
-Command is the central point of the application. Each interaction that
-the application supports will be contained in a Command. A command can
-have children commands and optionally run an action.
-
-In the example above, 'server' is the command.
-
-A Command has the following structure:
-
-```go
-type Command struct {
-    Use string // The one-line usage message.
-    Short string // The short description shown in the 'help' output.
-    Long string // The long message shown in the 'help <this-command>' output.
-    Run func(cmd *Command, args []string) // Run runs the command.
-}
-```
-
-## Flags
-
-A Flag is a way to modify the behavior of a command. Cobra supports
-fully POSIX-compliant flags as well as the Go [flag package](https://golang.org/pkg/flag/).
-A Cobra command can define flags that persist through to children commands
-and flags that are only available to that command.
-
-In the example above, 'port' is the flag.
-
-Flag functionality is provided by the [pflag
-library](https://github.com/ogier/pflag), a fork of the flag standard library
-which maintains the same interface while adding POSIX compliance.
-
-## Usage
-
-Cobra works by creating a set of commands and then organizing them into a tree.
-The tree defines the structure of the application.
-
-Once each command is defined with its corresponding flags, then the
-tree is assigned to the commander which is finally executed.
-
-# Installing
-Using Cobra is easy. First, use `go get` to install the latest version
-of the library. This command will install the `cobra` generator executible
-along with the library:
-
-    > go get -v github.com/spf13/cobra/cobra
-
-Next, include Cobra in your application:
-
-```go
-import "github.com/spf13/cobra"
-```
-
-# Getting Started
-
-While you are welcome to provide your own organization, typically a Cobra based
-application will follow the following organizational structure.
-
-```
-  ▾ appName/
-    ▾ cmd/
-        add.go
-        your.go
-        commands.go
-        here.go
-      main.go
-```
-
-In a Cobra app, typically the main.go file is very bare. It serves, one purpose, to initialize Cobra.
-
-```go
-package main
-
-import "{pathToYourApp}/cmd"
-
-func main() {
-	if err := cmd.RootCmd.Execute(); err != nil {
-		fmt.Println(err)
-		os.Exit(-1)
-	}
-}
-```
-
-## Using the Cobra Generator
-
-Cobra provides its own program that will create your application and add any
-commands you want. It's the easiest way to incorporate Cobra into your application.
-
-### cobra init
-
-The `cobra init [yourApp]` command will create your initial application code
-for you. It is a very powerful application that will populate your program with
-the right structure so you can immediately enjoy all the benefits of Cobra. It
-will also automatically apply the license you specify to your application.
-
-Cobra init is pretty smart. You can provide it a full path, or simply a path
-similar to what is expected in the import.
-
-```
-cobra init github.com/spf13/newAppName
-```
-
-### cobra add
-
-Once an application is initialized Cobra can create additional commands for you.
-Let's say you created an app and you wanted the following commands for it:
-
-* app serve
-* app config
-* app config create
-
-In your project directory (where your main.go file is) you would run the following:
-
-```
-cobra add serve
-cobra add config
-cobra add create -p 'configCmd'
-```
-
-Once you have run these four commands you would have an app structure that would look like:
-
-```
-  ▾ app/
-    ▾ cmd/
-        serve.go
-        config.go
-        create.go
-      main.go
-```
-
-at this point you can run `go run main.go` and it would run your app. `go run
-main.go serve`, `go run main.go config`, `go run main.go config create` along
-with `go run main.go help serve`, etc would all work.
-
-Obviously you haven't added your own code to these yet, the commands are ready
-for you to give them their tasks. Have fun.
-
-### Configuring the cobra generator
-
-The cobra generator will be easier to use if you provide a simple configuration
-file which will help you eliminate providing a bunch of repeated information in
-flags over and over.
-
-an example ~/.cobra.yaml file:
-
-```yaml
-author: Steve Francia <spf@spf13.com>
-license: MIT
-```
-
-## Manually implementing Cobra
-
-To manually implement cobra you need to create a bare main.go file and a RootCmd file.
-You will optionally provide additional commands as you see fit.
-
-### Create the root command
-
-The root command represents your binary itself.
-
-
-#### Manually create rootCmd
-
-Cobra doesn't require any special constructors. Simply create your commands.
-
-Ideally you place this in app/cmd/root.go:
-
-```go
-var RootCmd = &cobra.Command{
-	Use:   "hugo",
-	Short: "Hugo is a very fast static site generator",
-	Long: `A Fast and Flexible Static Site Generator built with
-                love by spf13 and friends in Go.
-                Complete documentation is available at http://hugo.spf13.com`,
-	Run: func(cmd *cobra.Command, args []string) {
-		// Do Stuff Here
-	},
-}
-```
-
-You will additionally define flags and handle configuration in your init() function.
-
-for example cmd/root.go:
-
-```go
-func init() {
-	cobra.OnInitialize(initConfig)
-	RootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/.cobra.yaml)")
-	RootCmd.PersistentFlags().StringVarP(&projectBase, "projectbase", "b", "", "base project directory eg. github.com/spf13/")
-	RootCmd.PersistentFlags().StringP("author", "a", "YOUR NAME", "Author name for copyright attribution")
-	RootCmd.PersistentFlags().StringVarP(&userLicense, "license", "l", "", "Name of license for the project (can provide `licensetext` in config)")
-	RootCmd.PersistentFlags().Bool("viper", true, "Use Viper for configuration")
-	viper.BindPFlag("author", RootCmd.PersistentFlags().Lookup("author"))
-	viper.BindPFlag("projectbase", RootCmd.PersistentFlags().Lookup("projectbase"))
-	viper.BindPFlag("useViper", RootCmd.PersistentFlags().Lookup("viper"))
-	viper.SetDefault("author", "NAME HERE <EMAIL ADDRESS>")
-	viper.SetDefault("license", "apache")
-}
-```
-
-### Create your main.go
-
-With the root command you need to have your main function execute it.
-Execute should be run on the root for clarity, though it can be called on any command.
-
-In a Cobra app, typically the main.go file is very bare. It serves, one purpose, to initialize Cobra.
-
-```go
-package main
-
-import "{pathToYourApp}/cmd"
-
-func main() {
-	if err := cmd.RootCmd.Execute(); err != nil {
-		fmt.Println(err)
-		os.Exit(-1)
-	}
-}
-```
-
-
-### Create additional commands
-
-Additional commands can be defined and typically are each given their own file
-inside of the cmd/ directory.
-
-If you wanted to create a version command you would create cmd/version.go and
-populate it with the following:
-
-```go
-package cmd
-
-import (
-	"github.com/spf13/cobra"
-)
-
-func init() {
-	RootCmd.AddCommand(versionCmd)
-}
-
-var versionCmd = &cobra.Command{
-	Use:   "version",
-	Short: "Print the version number of Hugo",
-	Long:  `All software has versions. This is Hugo's`,
-	Run: func(cmd *cobra.Command, args []string) {
-		fmt.Println("Hugo Static Site Generator v0.9 -- HEAD")
-	},
-}
-```
-
-### Attach command to its parent 
-
-
-If you notice in the above example we attach the command to its parent. In
-this case the parent is the rootCmd. In this example we are attaching it to the
-root, but commands can be attached at any level.
-
-```go
-RootCmd.AddCommand(versionCmd)
-```
-
-### Remove a command from its parent
-
-Removing a command is not a common action in simple programs, but it allows 3rd
-parties to customize an existing command tree.
-
-In this example, we remove the existing `VersionCmd` command of an existing
-root command, and we replace it with our own version:
-
-```go
-mainlib.RootCmd.RemoveCommand(mainlib.VersionCmd)
-mainlib.RootCmd.AddCommand(versionCmd)
-```
-
-## Working with Flags
-
-Flags provide modifiers to control how the action command operates.
-
-### Assign flags to a command
-
-Since the flags are defined and used in different locations, we need to
-define a variable outside with the correct scope to assign the flag to
-work with.
-
-```go
-var Verbose bool
-var Source string
-```
-
-There are two different approaches to assign a flag.
-
-### Persistent Flags
-
-A flag can be 'persistent' meaning that this flag will be available to the
-command it's assigned to as well as every command under that command. For
-global flags, assign a flag as a persistent flag on the root.
-
-```go
-RootCmd.PersistentFlags().BoolVarP(&Verbose, "verbose", "v", false, "verbose output")
-```
-
-### Local Flags
-
-A flag can also be assigned locally which will only apply to that specific command.
-
-```go
-RootCmd.Flags().StringVarP(&Source, "source", "s", "", "Source directory to read from")
-```
-
-
-## Example
-
-In the example below, we have defined three commands. Two are at the top level
-and one (cmdTimes) is a child of one of the top commands. In this case the root
-is not executable meaning that a subcommand is required. This is accomplished
-by not providing a 'Run' for the 'rootCmd'.
-
-We have only defined one flag for a single command.
-
-More documentation about flags is available at https://github.com/spf13/pflag
-
-```go
-package main
-
-import (
-	"fmt"
-	"strings"
-
-	"github.com/spf13/cobra"
-)
-
-func main() {
-
-	var echoTimes int
-
-	var cmdPrint = &cobra.Command{
-		Use:   "print [string to print]",
-		Short: "Print anything to the screen",
-		Long: `print is for printing anything back to the screen.
-            For many years people have printed back to the screen.
-            `,
-		Run: func(cmd *cobra.Command, args []string) {
-			fmt.Println("Print: " + strings.Join(args, " "))
-		},
-	}
-
-	var cmdEcho = &cobra.Command{
-		Use:   "echo [string to echo]",
-		Short: "Echo anything to the screen",
-		Long: `echo is for echoing anything back.
-            Echo works a lot like print, except it has a child command.
-            `,
-		Run: func(cmd *cobra.Command, args []string) {
-			fmt.Println("Print: " + strings.Join(args, " "))
-		},
-	}
-
-	var cmdTimes = &cobra.Command{
-		Use:   "times [# times] [string to echo]",
-		Short: "Echo anything to the screen more times",
-		Long: `echo things multiple times back to the user by providing
-            a count and a string.`,
-		Run: func(cmd *cobra.Command, args []string) {
-			for i := 0; i < echoTimes; i++ {
-				fmt.Println("Echo: " + strings.Join(args, " "))
-			}
-		},
-	}
-
-	cmdTimes.Flags().IntVarP(&echoTimes, "times", "t", 1, "times to echo the input")
-
-	var rootCmd = &cobra.Command{Use: "app"}
-	rootCmd.AddCommand(cmdPrint, cmdEcho)
-	cmdEcho.AddCommand(cmdTimes)
-	rootCmd.Execute()
-}
-```
-
-For a more complete example of a larger application, please checkout [Hugo](http://gohugo.io/).
-
-## The Help Command
-
-Cobra automatically adds a help command to your application when you have subcommands.
-This will be called when a user runs 'app help'. Additionally, help will also
-support all other commands as input. Say, for instance, you have a command called
-'create' without any additional configuration; Cobra will work when 'app help
-create' is called.  Every command will automatically have the '--help' flag added.
-
-### Example
-
-The following output is automatically generated by Cobra. Nothing beyond the
-command and flag definitions are needed.
-
-    > hugo help
-    
-    hugo is the main command, used to build your Hugo site.
-    
-    Hugo is a Fast and Flexible Static Site Generator
-    built with love by spf13 and friends in Go.
-    
-    Complete documentation is available at http://gohugo.io/.
-    
-    Usage:
-      hugo [flags]
-      hugo [command]
-    
-    Available Commands:
-      server          Hugo runs its own webserver to render the files
-      version         Print the version number of Hugo
-      config          Print the site configuration
-      check           Check content in the source directory
-      benchmark       Benchmark hugo by building a site a number of times.
-      convert         Convert your content to different formats
-      new             Create new content for your site
-      list            Listing out various types of content
-      undraft         Undraft changes the content's draft status from 'True' to 'False'
-      genautocomplete Generate shell autocompletion script for Hugo
-      gendoc          Generate Markdown documentation for the Hugo CLI.
-      genman          Generate man page for Hugo
-      import          Import your site from others.
-    
-    Flags:
-      -b, --baseURL="": hostname (and path) to the root, e.g. http://spf13.com/
-      -D, --buildDrafts[=false]: include content marked as draft
-      -F, --buildFuture[=false]: include content with publishdate in the future
-          --cacheDir="": filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/
-          --canonifyURLs[=false]: if true, all relative URLs will be canonicalized using baseURL
-          --config="": config file (default is path/config.yaml|json|toml)
-      -d, --destination="": filesystem path to write files to
-          --disableRSS[=false]: Do not build RSS files
-          --disableSitemap[=false]: Do not build Sitemap file
-          --editor="": edit new content with this editor, if provided
-          --ignoreCache[=false]: Ignores the cache directory for reading but still writes to it
-          --log[=false]: Enable Logging
-          --logFile="": Log File path (if set, logging enabled automatically)
-          --noTimes[=false]: Don't sync modification time of files
-          --pluralizeListTitles[=true]: Pluralize titles in lists using inflect
-          --preserveTaxonomyNames[=false]: Preserve taxonomy names as written ("Gérard Depardieu" vs "gerard-depardieu")
-      -s, --source="": filesystem path to read files relative from
-          --stepAnalysis[=false]: display memory and timing of different steps of the program
-      -t, --theme="": theme to use (located in /themes/THEMENAME/)
-          --uglyURLs[=false]: if true, use /filename.html instead of /filename/
-      -v, --verbose[=false]: verbose output
-          --verboseLog[=false]: verbose logging
-      -w, --watch[=false]: watch filesystem for changes and recreate as needed
-    
-    Use "hugo [command] --help" for more information about a command.
-
-
-Help is just a command like any other. There is no special logic or behavior
-around it. In fact, you can provide your own if you want.
-
-### Defining your own help
-
-You can provide your own Help command or you own template for the default command to use.
-
-The default help command is
-
-```go
-func (c *Command) initHelp() {
-	if c.helpCommand == nil {
-		c.helpCommand = &Command{
-			Use:   "help [command]",
-			Short: "Help about any command",
-			Long: `Help provides help for any command in the application.
-        Simply type ` + c.Name() + ` help [path to command] for full details.`,
-			Run: c.HelpFunc(),
-		}
-	}
-	c.AddCommand(c.helpCommand)
-}
-```
-
-You can provide your own command, function or template through the following methods:
-
-```go
-command.SetHelpCommand(cmd *Command)
-
-command.SetHelpFunc(f func(*Command, []string))
-
-command.SetHelpTemplate(s string)
-```
-
-The latter two will also apply to any children commands.
-
-## Usage
-
-When the user provides an invalid flag or invalid command, Cobra responds by
-showing the user the 'usage'.
-
-### Example
-You may recognize this from the help above. That's because the default help
-embeds the usage as part of its output.
-
-    Usage:
-      hugo [flags]
-      hugo [command]
-    
-    Available Commands:
-      server          Hugo runs its own webserver to render the files
-      version         Print the version number of Hugo
-      config          Print the site configuration
-      check           Check content in the source directory
-      benchmark       Benchmark hugo by building a site a number of times.
-      convert         Convert your content to different formats
-      new             Create new content for your site
-      list            Listing out various types of content
-      undraft         Undraft changes the content's draft status from 'True' to 'False'
-      genautocomplete Generate shell autocompletion script for Hugo
-      gendoc          Generate Markdown documentation for the Hugo CLI.
-      genman          Generate man page for Hugo
-      import          Import your site from others.
-    
-    Flags:
-      -b, --baseURL="": hostname (and path) to the root, e.g. http://spf13.com/
-      -D, --buildDrafts[=false]: include content marked as draft
-      -F, --buildFuture[=false]: include content with publishdate in the future
-          --cacheDir="": filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/
-          --canonifyURLs[=false]: if true, all relative URLs will be canonicalized using baseURL
-          --config="": config file (default is path/config.yaml|json|toml)
-      -d, --destination="": filesystem path to write files to
-          --disableRSS[=false]: Do not build RSS files
-          --disableSitemap[=false]: Do not build Sitemap file
-          --editor="": edit new content with this editor, if provided
-          --ignoreCache[=false]: Ignores the cache directory for reading but still writes to it
-          --log[=false]: Enable Logging
-          --logFile="": Log File path (if set, logging enabled automatically)
-          --noTimes[=false]: Don't sync modification time of files
-          --pluralizeListTitles[=true]: Pluralize titles in lists using inflect
-          --preserveTaxonomyNames[=false]: Preserve taxonomy names as written ("Gérard Depardieu" vs "gerard-depardieu")
-      -s, --source="": filesystem path to read files relative from
-          --stepAnalysis[=false]: display memory and timing of different steps of the program
-      -t, --theme="": theme to use (located in /themes/THEMENAME/)
-          --uglyURLs[=false]: if true, use /filename.html instead of /filename/
-      -v, --verbose[=false]: verbose output
-          --verboseLog[=false]: verbose logging
-      -w, --watch[=false]: watch filesystem for changes and recreate as needed
-
-### Defining your own usage
-You can provide your own usage function or template for Cobra to use.
-
-The default usage function is:
-
-```go
-return func(c *Command) error {
-	err := tmpl(c.Out(), c.UsageTemplate(), c)
-	return err
-}
-```
-
-Like help, the function and template are overridable through public methods:
-
-```go
-command.SetUsageFunc(f func(*Command) error)
-
-command.SetUsageTemplate(s string)
-```
-
-## PreRun or PostRun Hooks
-
-It is possible to run functions before or after the main `Run` function of your command. The `PersistentPreRun` and `PreRun` functions will be executed before `Run`. `PersistentPostRun` and `PostRun` will be executed after `Run`.  The `Persistent*Run` functions will be inherrited by children if they do not declare their own.  These function are run in the following order:
-
-- `PersistentPreRun`
-- `PreRun`
-- `Run`
-- `PostRun`
-- `PersistentPostRun`
-
-An example of two commands which use all of these features is below.  When the subcommand is executed, it will run the root command's `PersistentPreRun` but not the root command's `PersistentPostRun`:
-
-```go
-package main
-
-import (
-	"fmt"
-
-	"github.com/spf13/cobra"
-)
-
-func main() {
-
-	var rootCmd = &cobra.Command{
-		Use:   "root [sub]",
-		Short: "My root command",
-		PersistentPreRun: func(cmd *cobra.Command, args []string) {
-			fmt.Printf("Inside rootCmd PersistentPreRun with args: %v\n", args)
-		},
-		PreRun: func(cmd *cobra.Command, args []string) {
-			fmt.Printf("Inside rootCmd PreRun with args: %v\n", args)
-		},
-		Run: func(cmd *cobra.Command, args []string) {
-			fmt.Printf("Inside rootCmd Run with args: %v\n", args)
-		},
-		PostRun: func(cmd *cobra.Command, args []string) {
-			fmt.Printf("Inside rootCmd PostRun with args: %v\n", args)
-		},
-		PersistentPostRun: func(cmd *cobra.Command, args []string) {
-			fmt.Printf("Inside rootCmd PersistentPostRun with args: %v\n", args)
-		},
-	}
-
-	var subCmd = &cobra.Command{
-		Use:   "sub [no options!]",
-		Short: "My subcommand",
-		PreRun: func(cmd *cobra.Command, args []string) {
-			fmt.Printf("Inside subCmd PreRun with args: %v\n", args)
-		},
-		Run: func(cmd *cobra.Command, args []string) {
-			fmt.Printf("Inside subCmd Run with args: %v\n", args)
-		},
-		PostRun: func(cmd *cobra.Command, args []string) {
-			fmt.Printf("Inside subCmd PostRun with args: %v\n", args)
-		},
-		PersistentPostRun: func(cmd *cobra.Command, args []string) {
-			fmt.Printf("Inside subCmd PersistentPostRun with args: %v\n", args)
-		},
-	}
-
-	rootCmd.AddCommand(subCmd)
-
-	rootCmd.SetArgs([]string{""})
-	_ = rootCmd.Execute()
-	fmt.Print("\n")
-	rootCmd.SetArgs([]string{"sub", "arg1", "arg2"})
-	_ = rootCmd.Execute()
-}
-```
-
-
-## Alternative Error Handling
-
-Cobra also has functions where the return signature is an error. This allows for errors to bubble up to the top, providing a way to handle the errors in one location. The current list of functions that return an error is:
-
-* PersistentPreRunE
-* PreRunE
-* RunE
-* PostRunE
-* PersistentPostRunE
-
-**Example Usage using RunE:**
-
-```go
-package main
-
-import (
-	"errors"
-	"log"
-
-	"github.com/spf13/cobra"
-)
-
-func main() {
-	var rootCmd = &cobra.Command{
-		Use:   "hugo",
-		Short: "Hugo is a very fast static site generator",
-		Long: `A Fast and Flexible Static Site Generator built with
-                love by spf13 and friends in Go.
-                Complete documentation is available at http://hugo.spf13.com`,
-		RunE: func(cmd *cobra.Command, args []string) error {
-			// Do Stuff Here
-			return errors.New("some random error")
-		},
-	}
-
-	if err := rootCmd.Execute(); err != nil {
-		log.Fatal(err)
-	}
-}
-```
-
-## Suggestions when "unknown command" happens
-
-Cobra will print automatic suggestions when "unknown command" errors happen. This allows Cobra to behave similarly to the `git` command when a typo happens. For example:
-
-```
-$ hugo srever
-Error: unknown command "srever" for "hugo"
-
-Did you mean this?
-        server
-
-Run 'hugo --help' for usage.
-```
-
-Suggestions are automatic based on every subcommand registered and use an implementation of [Levenshtein distance](http://en.wikipedia.org/wiki/Levenshtein_distance). Every registered command that matches a minimum distance of 2 (ignoring case) will be displayed as a suggestion.
-
-If you need to disable suggestions or tweak the string distance in your command, use:
-
-```go
-command.DisableSuggestions = true
-```
-
-or
-
-```go
-command.SuggestionsMinimumDistance = 1
-```
-
-You can also explicitly set names for which a given command will be suggested using the `SuggestFor` attribute. This allows suggestions for strings that are not close in terms of string distance, but makes sense in your set of commands and for some which you don't want aliases. Example:
-
-```
-$ kubectl remove
-Error: unknown command "remove" for "kubectl"
-
-Did you mean this?
-        delete
-
-Run 'kubectl help' for usage.
-```
-
-## Generating Markdown-formatted documentation for your command
-
-Cobra can generate a Markdown-formatted document based on the subcommands, flags, etc. A simple example of how to do this for your command can be found in [Markdown Docs](md_docs.md).
-
-## Generating man pages for your command
-
-Cobra can generate a man page based on the subcommands, flags, etc. A simple example of how to do this for your command can be found in [Man Docs](man_docs.md).
-
-## Generating bash completions for your command
-
-Cobra can generate a bash-completion file. If you add more information to your command, these completions can be amazingly powerful and flexible.  Read more about it in [Bash Completions](bash_completions.md).
-
-## Debugging
-
-Cobra provides a ‘DebugFlags’ method on a command which, when called, will print
-out everything Cobra knows about the flags for each command.
-
-### Example
-
-```go
-command.DebugFlags()
-```
-
-## Release Notes
-* **0.9.0** June 17, 2014
-  * flags can appears anywhere in the args (provided they are unambiguous)
-  * --help prints usage screen for app or command
-  * Prefix matching for commands
-  * Cleaner looking help and usage output
-  * Extensive test suite
-* **0.8.0** Nov 5, 2013
-  * Reworked interface to remove commander completely
-  * Command now primary structure
-  * No initialization needed
-  * Usage & Help templates & functions definable at any level
-  * Updated Readme
-* **0.7.0** Sept 24, 2013
-  * Needs more eyes
-  * Test suite
-  * Support for automatic error messages
-  * Support for help command
-  * Support for printing to any io.Writer instead of os.Stderr
-  * Support for persistent flags which cascade down tree
-  * Ready for integration into Hugo
-* **0.1.0** Sept 3, 2013
-  * Implement first draft
-
-## Extensions
-
-Libraries for extending Cobra:
-
-* [cmdns](https://github.com/gosuri/cmdns): Enables name spacing a command's immediate children. It provides an alternative way to structure subcommands, similar to `heroku apps:create` and `ovrclk clusters:launch`.
-
-## ToDo
-* Launch proper documentation site
-
-## Contributing
-
-1. Fork it
-2. Create your feature branch (`git checkout -b my-new-feature`)
-3. Commit your changes (`git commit -am 'Add some feature'`)
-4. Push to the branch (`git push origin my-new-feature`)
-5. Create new Pull Request
-
-## Contributors
-
-Names in no particular order:
-
-* [spf13](https://github.com/spf13), 
-[eparis](https://github.com/eparis), 
-[bep](https://github.com/bep), and many more!
-
-## License
-
-Cobra is released under the Apache 2.0 license. See [LICENSE.txt](https://github.com/spf13/cobra/blob/master/LICENSE.txt)
-
-
-[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/spf13/cobra/trend.png)](https://bitdeli.com/free "Bitdeli Badge")
diff --git a/cmd/vendor/github.com/spf13/cobra/bash_completions.md b/cmd/vendor/github.com/spf13/cobra/bash_completions.md
deleted file mode 100644
index 204704e..0000000
--- a/cmd/vendor/github.com/spf13/cobra/bash_completions.md
+++ /dev/null
@@ -1,149 +0,0 @@
-# Generating Bash Completions For Your Own cobra.Command
-
-Generating bash completions from a cobra command is incredibly easy. An actual program which does so for the kubernetes kubectl binary is as follows:
-
-```go
-package main
-
-import (
-        "io/ioutil"
-        "os"
-
-        "github.com/GoogleCloudPlatform/kubernetes/pkg/kubectl/cmd"
-)
-
-func main() {
-        kubectl := cmd.NewFactory(nil).NewKubectlCommand(os.Stdin, ioutil.Discard, ioutil.Discard)
-        kubectl.GenBashCompletionFile("out.sh")
-}
-```
-
-That will get you completions of subcommands and flags. If you make additional annotations to your code, you can get even more intelligent and flexible behavior.
-
-## Creating your own custom functions
-
-Some more actual code that works in kubernetes:
-
-```bash
-const (
-        bash_completion_func = `__kubectl_parse_get()
-{
-    local kubectl_output out
-    if kubectl_output=$(kubectl get --no-headers "$1" 2>/dev/null); then
-        out=($(echo "${kubectl_output}" | awk '{print $1}'))
-        COMPREPLY=( $( compgen -W "${out[*]}" -- "$cur" ) )
-    fi
-}
-
-__kubectl_get_resource()
-{
-    if [[ ${#nouns[@]} -eq 0 ]]; then
-        return 1
-    fi
-    __kubectl_parse_get ${nouns[${#nouns[@]} -1]}
-    if [[ $? -eq 0 ]]; then
-        return 0
-    fi
-}
-
-__custom_func() {
-    case ${last_command} in
-        kubectl_get | kubectl_describe | kubectl_delete | kubectl_stop)
-            __kubectl_get_resource
-            return
-            ;;
-        *)
-            ;;
-    esac
-}
-`)
-```
-
-And then I set that in my command definition:
-
-```go
-cmds := &cobra.Command{
-	Use:   "kubectl",
-	Short: "kubectl controls the Kubernetes cluster manager",
-	Long: `kubectl controls the Kubernetes cluster manager.
-
-Find more information at https://github.com/GoogleCloudPlatform/kubernetes.`,
-	Run: runHelp,
-	BashCompletionFunction: bash_completion_func,
-}
-```
-
-The `BashCompletionFunction` option is really only valid/useful on the root command. Doing the above will cause `__custom_func()` to be called when the built in processor was unable to find a solution. In the case of kubernetes a valid command might look something like `kubectl get pod [mypod]`. If you type `kubectl get pod [tab][tab]` the `__customc_func()` will run because the cobra.Command only understood "kubectl" and "get." `__custom_func()` will see that the cobra.Command is "kubectl_get" and will thus call another helper `__kubectl_get_resource()`.  `__kubectl_get_resource` will look at the 'nouns' collected. In our example the only noun will be `pod`.  So it will call `__kubectl_parse_get pod`.  `__kubectl_parse_get` will actually call out to kubernetes and get any pods.  It will then set `COMPREPLY` to valid pods!
-
-## Have the completions code complete your 'nouns'
-
-In the above example "pod" was assumed to already be typed. But if you want `kubectl get [tab][tab]` to show a list of valid "nouns" you have to set them. Simplified code from `kubectl get` looks like:
-
-```go
-validArgs []string = { "pods", "nodes", "services", "replicationControllers" }
-
-cmd := &cobra.Command{
-	Use:     "get [(-o|--output=)json|yaml|template|...] (RESOURCE [NAME] | RESOURCE/NAME ...)",
-	Short:   "Display one or many resources",
-	Long:    get_long,
-	Example: get_example,
-	Run: func(cmd *cobra.Command, args []string) {
-		err := RunGet(f, out, cmd, args)
-		util.CheckErr(err)
-	},
-	ValidArgs: validArgs,
-}
-```
-
-Notice we put the "ValidArgs" on the "get" subcommand. Doing so will give results like
-
-```bash
-# kubectl get [tab][tab]
-nodes                 pods                    replicationControllers  services
-```
-
-## Mark flags as required
-
-Most of the time completions will only show subcommands. But if a flag is required to make a subcommand work, you probably want it to show up when the user types [tab][tab].  Marking a flag as 'Required' is incredibly easy.
-
-```go
-cmd.MarkFlagRequired("pod")
-cmd.MarkFlagRequired("container")
-```
-
-and you'll get something like
-
-```bash
-# kubectl exec [tab][tab][tab]
--c            --container=  -p            --pod=  
-```
-
-# Specify valid filename extensions for flags that take a filename
-
-In this example we use --filename= and expect to get a json or yaml file as the argument. To make this easier we annotate the --filename flag with valid filename extensions.
-
-```go
-	annotations := []string{"json", "yaml", "yml"}
-	annotation := make(map[string][]string)
-	annotation[cobra.BashCompFilenameExt] = annotations
-
-	flag := &pflag.Flag{
-		Name:        "filename",
-		Shorthand:   "f",
-		Usage:       usage,
-		Value:       value,
-		DefValue:    value.String(),
-		Annotations: annotation,
-	}
-	cmd.Flags().AddFlag(flag)
-```
-
-Now when you run a command with this filename flag you'll get something like
-
-```bash
-# kubectl create -f 
-test/                         example/                      rpmbuild/
-hello.yml                     test.json
-```
-
-So while there are many other files in the CWD it only shows me subdirs and those with valid extensions.
diff --git a/cmd/vendor/github.com/spf13/cobra/man_docs.md b/cmd/vendor/github.com/spf13/cobra/man_docs.md
deleted file mode 100644
index 3408c30..0000000
--- a/cmd/vendor/github.com/spf13/cobra/man_docs.md
+++ /dev/null
@@ -1,25 +0,0 @@
-# Generating Man Pages For Your Own cobra.Command
-
-Generating man pages from a cobra command is incredibly easy. An example is as follows:
-
-```go
-package main
-
-import (
-	"github.com/spf13/cobra"
-)
-
-func main() {
-	cmd := &cobra.Command{
-		Use:   "test",
-		Short: "my test program",
-	}
-	header := &cobra.GenManHeader{
-		Title: "MINE",
-		Section: "3",
-	}
-	cmd.GenManTree(header, "/tmp")
-}
-```
-
-That will get you a man page `/tmp/test.1`
diff --git a/cmd/vendor/github.com/spf13/cobra/md_docs.md b/cmd/vendor/github.com/spf13/cobra/md_docs.md
deleted file mode 100644
index 3a0d55a..0000000
--- a/cmd/vendor/github.com/spf13/cobra/md_docs.md
+++ /dev/null
@@ -1,81 +0,0 @@
-# Generating Markdown Docs For Your Own cobra.Command
-
-## Generate markdown docs for the entire command tree
-
-This program can actually generate docs for the kubectl command in the kubernetes project
-
-```go
-package main
-
-import (
-	"io/ioutil"
-	"os"
-
-	"github.com/GoogleCloudPlatform/kubernetes/pkg/kubectl/cmd"
-	"github.com/spf13/cobra"
-)
-
-func main() {
-	kubectl := cmd.NewFactory(nil).NewKubectlCommand(os.Stdin, ioutil.Discard, ioutil.Discard)
-	cobra.GenMarkdownTree(kubectl, "./")
-}
-```
-
-This will generate a whole series of files, one for each command in the tree, in the directory specified (in this case "./")
-
-## Generate markdown docs for a single command
-
-You may wish to have more control over the output, or only generate for a single command, instead of the entire command tree. If this is the case you may prefer to `GenMarkdown` instead of `GenMarkdownTree`
-
-```go
-	out := new(bytes.Buffer)
-	cobra.GenMarkdown(cmd, out)
-```
-
-This will write the markdown doc for ONLY "cmd" into the out, buffer.
-
-## Customize the output
-
-Both `GenMarkdown` and `GenMarkdownTree` have alternate versions with callbacks to get some control of the output:
-
-```go
-func GenMarkdownTreeCustom(cmd *Command, dir string, filePrepender func(string) string, linkHandler func(string) string) {
-    //...
-}
-```
-
-```go
-func GenMarkdownCustom(cmd *Command, out *bytes.Buffer, linkHandler func(string) string) {
-    //...
-}
-```
-
-The `filePrepender` will prepend the return value given the full filepath to the rendered Markdown file. A common use case is to add front matter to use the generated documentation with [Hugo](http://gohugo.io/):
-
-```go
-const fmTemplate = `---
-date: %s
-title: "%s"
-slug: %s
-url: %s
----
-`
-
-filePrepender := func(filename string) string {
-	now := time.Now().Format(time.RFC3339)
-	name := filepath.Base(filename)
-	base := strings.TrimSuffix(name, path.Ext(name))
-	url := "/commands/" + strings.ToLower(base) + "/"
-	return fmt.Sprintf(fmTemplate, now, strings.Replace(base, "_", " ", -1), base, url)
-}
-```
-
-The `linkHandler` can be used to customize the rendered internal links to the commands, given a filename:
-
-```go
-linkHandler := func(name string) string {
-	base := strings.TrimSuffix(name, path.Ext(name))
-	return "/commands/" + strings.ToLower(base) + "/"
-}
-```
- 
diff --git a/cmd/vendor/github.com/spf13/pflag/.travis.yml b/cmd/vendor/github.com/spf13/pflag/.travis.yml
deleted file mode 100644
index df435a0..0000000
--- a/cmd/vendor/github.com/spf13/pflag/.travis.yml
+++ /dev/null
@@ -1,18 +0,0 @@
-sudo: false
-
-language: go
-
-go:
-        - 1.3
-        - 1.4
-        - 1.5
-        - tip
-
-install:
-        - go get github.com/golang/lint/golint
-        - export PATH=$GOPATH/bin:$PATH
-        - go install ./...
-
-script:
-        - verify/all.sh
-        - go test ./...
diff --git a/cmd/vendor/github.com/spf13/pflag/README.md b/cmd/vendor/github.com/spf13/pflag/README.md
deleted file mode 100644
index e74dd50..0000000
--- a/cmd/vendor/github.com/spf13/pflag/README.md
+++ /dev/null
@@ -1,256 +0,0 @@
-[![Build Status](https://travis-ci.org/spf13/pflag.svg?branch=master)](https://travis-ci.org/spf13/pflag)
-
-## Description
-
-pflag is a drop-in replacement for Go's flag package, implementing
-POSIX/GNU-style --flags.
-
-pflag is compatible with the [GNU extensions to the POSIX recommendations
-for command-line options][1]. For a more precise description, see the
-"Command-line flag syntax" section below.
-
-[1]: http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
-
-pflag is available under the same style of BSD license as the Go language,
-which can be found in the LICENSE file.
-
-## Installation
-
-pflag is available using the standard `go get` command.
-
-Install by running:
-
-    go get github.com/spf13/pflag
-
-Run tests by running:
-
-    go test github.com/spf13/pflag
-
-## Usage
-
-pflag is a drop-in replacement of Go's native flag package. If you import
-pflag under the name "flag" then all code should continue to function
-with no changes.
-
-``` go
-import flag "github.com/spf13/pflag"
-```
-
-There is one exception to this: if you directly instantiate the Flag struct
-there is one more field "Shorthand" that you will need to set.
-Most code never instantiates this struct directly, and instead uses
-functions such as String(), BoolVar(), and Var(), and is therefore
-unaffected.
-
-Define flags using flag.String(), Bool(), Int(), etc.
-
-This declares an integer flag, -flagname, stored in the pointer ip, with type *int.
-
-``` go
-var ip *int = flag.Int("flagname", 1234, "help message for flagname")
-```
-
-If you like, you can bind the flag to a variable using the Var() functions.
-
-``` go
-var flagvar int
-func init() {
-    flag.IntVar(&flagvar, "flagname", 1234, "help message for flagname")
-}
-```
-
-Or you can create custom flags that satisfy the Value interface (with
-pointer receivers) and couple them to flag parsing by
-
-``` go
-flag.Var(&flagVal, "name", "help message for flagname")
-```
-
-For such flags, the default value is just the initial value of the variable.
-
-After all flags are defined, call
-
-``` go
-flag.Parse()
-```
-
-to parse the command line into the defined flags.
-
-Flags may then be used directly. If you're using the flags themselves,
-they are all pointers; if you bind to variables, they're values.
-
-``` go
-fmt.Println("ip has value ", *ip)
-fmt.Println("flagvar has value ", flagvar)
-```
-
-There are helpers function to get values later if you have the FlagSet but
-it was difficult to keep up with all of the the flag pointers in your code.
-If you have a pflag.FlagSet with a flag called 'flagname' of type int you
-can use GetInt() to get the int value. But notice that 'flagname' must exist
-and it must be an int. GetString("flagname") will fail.
-
-``` go
-i, err := flagset.GetInt("flagname")
-```
-
-After parsing, the arguments after the flag are available as the
-slice flag.Args() or individually as flag.Arg(i).
-The arguments are indexed from 0 through flag.NArg()-1.
-
-The pflag package also defines some new functions that are not in flag,
-that give one-letter shorthands for flags. You can use these by appending
-'P' to the name of any function that defines a flag.
-
-``` go
-var ip = flag.IntP("flagname", "f", 1234, "help message")
-var flagvar bool
-func init() {
-    flag.BoolVarP("boolname", "b", true, "help message")
-}
-flag.VarP(&flagVar, "varname", "v", 1234, "help message")
-```
-
-Shorthand letters can be used with single dashes on the command line.
-Boolean shorthand flags can be combined with other shorthand flags.
-
-The default set of command-line flags is controlled by
-top-level functions.  The FlagSet type allows one to define
-independent sets of flags, such as to implement subcommands
-in a command-line interface. The methods of FlagSet are
-analogous to the top-level functions for the command-line
-flag set.
-
-## Setting no option default values for flags
-
-After you create a flag it is possible to set the pflag.NoOptDefVal for
-the given flag. Doing this changes the meaning of the flag slightly. If
-a flag has a NoOptDefVal and the flag is set on the command line without
-an option the flag will be set to the NoOptDefVal. For example given:
-
-``` go
-var ip = flag.IntP("flagname", "f", 1234, "help message")
-flag.Lookup("flagname").NoOptDefVal = "4321"
-```
-
-Would result in something like
-
-| Parsed Arguments | Resulting Value |
-| -------------    | -------------   |
-| --flagname=1357  | ip=1357         |
-| --flagname       | ip=4321         |
-| [nothing]        | ip=1234         |
-
-## Command line flag syntax
-
-```
---flag    // boolean flags, or flags with no option default values
---flag x  // only on flags without a default value
---flag=x
-```
-
-Unlike the flag package, a single dash before an option means something
-different than a double dash. Single dashes signify a series of shorthand
-letters for flags. All but the last shorthand letter must be boolean flags
-or a flag with a default value
-
-```
-// boolean or flags where the 'no option default value' is set
--f
--f=true
--abc
-but
--b true is INVALID
-
-// non-boolean and flags without a 'no option default value'
--n 1234
--n=1234
--n1234
-
-// mixed
--abcs "hello"
--absd="hello"
--abcs1234
-```
-
-Flag parsing stops after the terminator "--". Unlike the flag package,
-flags can be interspersed with arguments anywhere on the command line
-before this terminator.
-
-Integer flags accept 1234, 0664, 0x1234 and may be negative.
-Boolean flags (in their long form) accept 1, 0, t, f, true, false,
-TRUE, FALSE, True, False.
-Duration flags accept any input valid for time.ParseDuration.
-
-## Mutating or "Normalizing" Flag names
-
-It is possible to set a custom flag name 'normalization function.' It allows flag names to be mutated both when created in the code and when used on the command line to some 'normalized' form. The 'normalized' form is used for comparison. Two examples of using the custom normalization func follow.
-
-**Example #1**: You want -, _, and . in flags to compare the same. aka --my-flag == --my_flag == --my.flag
-
-``` go
-func wordSepNormalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName {
-	from := []string{"-", "_"}
-	to := "."
-	for _, sep := range from {
-		name = strings.Replace(name, sep, to, -1)
-	}
-	return pflag.NormalizedName(name)
-}
-
-myFlagSet.SetNormalizeFunc(wordSepNormalizeFunc)
-```
-
-**Example #2**: You want to alias two flags. aka --old-flag-name == --new-flag-name
-
-``` go
-func aliasNormalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName {
-	switch name {
-	case "old-flag-name":
-		name = "new-flag-name"
-		break
-	}
-	return pflag.NormalizedName(name)
-}
-
-myFlagSet.SetNormalizeFunc(aliasNormalizeFunc)
-```
-
-## Deprecating a flag or its shorthand
-It is possible to deprecate a flag, or just its shorthand. Deprecating a flag/shorthand hides it from help text and prints a usage message when the deprecated flag/shorthand is used.
-
-**Example #1**: You want to deprecate a flag named "badflag" as well as inform the users what flag they should use instead.
-```go
-// deprecate a flag by specifying its name and a usage message
-flags.MarkDeprecated("badflag", "please use --good-flag instead")
-```
-This hides "badflag" from help text, and prints `Flag --badflag has been deprecated, please use --good-flag instead` when "badflag" is used.
-
-**Example #2**: You want to keep a flag name "noshorthandflag" but deprecate its shortname "n".
-```go
-// deprecate a flag shorthand by specifying its flag name and a usage message
-flags.MarkShorthandDeprecated("noshorthandflag", "please use --noshorthandflag only")
-```
-This hides the shortname "n" from help text, and prints `Flag shorthand -n has been deprecated, please use --noshorthandflag only` when the shorthand "n" is used.
-
-Note that usage message is essential here, and it should not be empty.
-
-## Hidden flags
-It is possible to mark a flag as hidden, meaning it will still function as normal, however will not show up in usage/help text.
-
-**Example**: You have a flag named "secretFlag" that you need for internal use only and don't want it showing up in help text, or for its usage text to be available.
-```go
-// hide a flag by specifying its name
-flags.MarkHidden("secretFlag")
-```
-
-## More info
-
-You can see the full reference documentation of the pflag package
-[at godoc.org][3], or through go's standard documentation system by
-running `godoc -http=:6060` and browsing to
-[http://localhost:6060/pkg/github.com/ogier/pflag][2] after
-installation.
-
-[2]: http://localhost:6060/pkg/github.com/ogier/pflag
-[3]: http://godoc.org/github.com/ogier/pflag
diff --git a/cmd/vendor/github.com/stretchr/testify/doc.go b/cmd/vendor/github.com/stretchr/testify/doc.go
new file mode 100644
index 0000000..12f5d38
--- /dev/null
+++ b/cmd/vendor/github.com/stretchr/testify/doc.go
@@ -0,0 +1,18 @@
+// A set of packages that provide many tools for testifying that your code will behave as you intend.
+//
+// testify contains the following packages:
+//
+// The assert package provides a comprehensive set of assertion functions that tie in to the Go testing system.
+//
+// The http package contains tools to make it easier to test http activity using the Go testing system.
+//
+// The mock package provides a system by which it is possible to mock your objects and verify calls are happening as expected.
+//
+// The suite package provides a basic structure for using structs as testing suites, and methods on those structs as tests.  It includes setup/teardown functionality in the way of interfaces.
+package testify
+
+import (
+    _ "github.com/stretchr/testify/assert"
+    _ "github.com/stretchr/testify/http"
+    _ "github.com/stretchr/testify/mock"
+)
diff --git a/cmd/vendor/github.com/ugorji/go/codec/README.md b/cmd/vendor/github.com/ugorji/go/codec/README.md
deleted file mode 100644
index a790a52..0000000
--- a/cmd/vendor/github.com/ugorji/go/codec/README.md
+++ /dev/null
@@ -1,148 +0,0 @@
-# Codec
-
-High Performance, Feature-Rich Idiomatic Go codec/encoding library for
-binc, msgpack, cbor, json.
-
-Supported Serialization formats are:
-
-  - msgpack: https://github.com/msgpack/msgpack
-  - binc:    http://github.com/ugorji/binc
-  - cbor:    http://cbor.io http://tools.ietf.org/html/rfc7049
-  - json:    http://json.org http://tools.ietf.org/html/rfc7159
-  - simple: 
-
-To install:
-
-    go get github.com/ugorji/go/codec
-
-This package understands the `unsafe` tag, to allow using unsafe semantics:
-
-  - When decoding into a struct, you need to read the field name as a string 
-    so you can find the struct field it is mapped to.
-    Using `unsafe` will bypass the allocation and copying overhead of `[]byte->string` conversion.
-
-To use it, you must pass the `unsafe` tag during install:
-
-```
-go install -tags=unsafe github.com/ugorji/go/codec 
-```
-
-Online documentation: http://godoc.org/github.com/ugorji/go/codec  
-Detailed Usage/How-to Primer: http://ugorji.net/blog/go-codec-primer
-
-The idiomatic Go support is as seen in other encoding packages in
-the standard library (ie json, xml, gob, etc).
-
-Rich Feature Set includes:
-
-  - Simple but extremely powerful and feature-rich API
-  - Very High Performance.
-    Our extensive benchmarks show us outperforming Gob, Json, Bson, etc by 2-4X.
-  - Multiple conversions:
-    Package coerces types where appropriate 
-    e.g. decode an int in the stream into a float, etc.
-  - Corner Cases: 
-    Overflows, nil maps/slices, nil values in streams are handled correctly
-  - Standard field renaming via tags
-  - Support for omitting empty fields during an encoding
-  - Encoding from any value and decoding into pointer to any value
-    (struct, slice, map, primitives, pointers, interface{}, etc)
-  - Extensions to support efficient encoding/decoding of any named types
-  - Support encoding.(Binary|Text)(M|Unm)arshaler interfaces
-  - Decoding without a schema (into a interface{}).
-    Includes Options to configure what specific map or slice type to use
-    when decoding an encoded list or map into a nil interface{}
-  - Encode a struct as an array, and decode struct from an array in the data stream
-  - Comprehensive support for anonymous fields
-  - Fast (no-reflection) encoding/decoding of common maps and slices
-  - Code-generation for faster performance.
-  - Support binary (e.g. messagepack, cbor) and text (e.g. json) formats
-  - Support indefinite-length formats to enable true streaming 
-    (for formats which support it e.g. json, cbor)
-  - Support canonical encoding, where a value is ALWAYS encoded as same sequence of bytes.
-    This mostly applies to maps, where iteration order is non-deterministic.
-  - NIL in data stream decoded as zero value
-  - Never silently skip data when decoding.
-    User decides whether to return an error or silently skip data when keys or indexes
-    in the data stream do not map to fields in the struct.
-  - Encode/Decode from/to chan types (for iterative streaming support)
-  - Drop-in replacement for encoding/json. `json:` key in struct tag supported.
-  - Provides a RPC Server and Client Codec for net/rpc communication protocol.
-  - Handle unique idiosynchracies of codecs e.g. 
-    - For messagepack, configure how ambiguities in handling raw bytes are resolved 
-    - For messagepack, provide rpc server/client codec to support
-      msgpack-rpc protocol defined at:
-      https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md
-
-## Extension Support
-
-Users can register a function to handle the encoding or decoding of
-their custom types.
-
-There are no restrictions on what the custom type can be. Some examples:
-
-    type BisSet   []int
-    type BitSet64 uint64
-    type UUID     string
-    type MyStructWithUnexportedFields struct { a int; b bool; c []int; }
-    type GifImage struct { ... }
-
-As an illustration, MyStructWithUnexportedFields would normally be
-encoded as an empty map because it has no exported fields, while UUID
-would be encoded as a string. However, with extension support, you can
-encode any of these however you like.
-
-## RPC
-
-RPC Client and Server Codecs are implemented, so the codecs can be used
-with the standard net/rpc package.
-
-## Usage
-
-Typical usage model:
-
-    // create and configure Handle
-    var (
-      bh codec.BincHandle
-      mh codec.MsgpackHandle
-      ch codec.CborHandle
-    )
-
-    mh.MapType = reflect.TypeOf(map[string]interface{}(nil))
-
-    // configure extensions
-    // e.g. for msgpack, define functions and enable Time support for tag 1
-    // mh.SetExt(reflect.TypeOf(time.Time{}), 1, myExt)
-
-    // create and use decoder/encoder
-    var (
-      r io.Reader
-      w io.Writer
-      b []byte
-      h = &bh // or mh to use msgpack
-    )
-
-    dec = codec.NewDecoder(r, h)
-    dec = codec.NewDecoderBytes(b, h)
-    err = dec.Decode(&v)
-
-    enc = codec.NewEncoder(w, h)
-    enc = codec.NewEncoderBytes(&b, h)
-    err = enc.Encode(v)
-
-    //RPC Server
-    go func() {
-        for {
-            conn, err := listener.Accept()
-            rpcCodec := codec.GoRpc.ServerCodec(conn, h)
-            //OR rpcCodec := codec.MsgpackSpecRpc.ServerCodec(conn, h)
-            rpc.ServeCodec(rpcCodec)
-        }
-    }()
-
-    //RPC Communication (client side)
-    conn, err = net.Dial("tcp", "localhost:5555")
-    rpcCodec := codec.GoRpc.ClientCodec(conn, h)
-    //OR rpcCodec := codec.MsgpackSpecRpc.ClientCodec(conn, h)
-    client := rpc.NewClientWithCodec(rpcCodec)
-
diff --git a/cmd/vendor/github.com/ugorji/go/codec/fast-path.go.tmpl b/cmd/vendor/github.com/ugorji/go/codec/fast-path.go.tmpl
deleted file mode 100644
index 58cc6df..0000000
--- a/cmd/vendor/github.com/ugorji/go/codec/fast-path.go.tmpl
+++ /dev/null
@@ -1,511 +0,0 @@
-// +build !notfastpath
-
-// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
-// Use of this source code is governed by a MIT license found in the LICENSE file.
-
-// ************************************************************
-// DO NOT EDIT. 
-// THIS FILE IS AUTO-GENERATED from fast-path.go.tmpl
-// ************************************************************
-
-package codec
-
-// Fast path functions try to create a fast path encode or decode implementation
-// for common maps and slices.
-//
-// We define the functions and register then in this single file
-// so as not to pollute the encode.go and decode.go, and create a dependency in there.
-// This file can be omitted without causing a build failure.
-//
-// The advantage of fast paths is:
-//    - Many calls bypass reflection altogether
-// 
-// Currently support
-//    - slice of all builtin types,
-//    - map of all builtin types to string or interface value
-//    - symetrical maps of all builtin types (e.g. str-str, uint8-uint8)
-// This should provide adequate "typical" implementations.
-// 
-// Note that fast track decode functions must handle values for which an address cannot be obtained.
-// For example: 
-//   m2 := map[string]int{}
-//   p2 := []interface{}{m2}
-//   // decoding into p2 will bomb if fast track functions do not treat like unaddressable.
-// 
-
-import (
-	"reflect"
-	"sort"
-)
-
-const fastpathCheckNilFalse = false // for reflect
-const fastpathCheckNilTrue = true // for type switch
-
-type fastpathT struct {}
-
-var fastpathTV fastpathT
-
-type fastpathE struct {
-	rtid uintptr
-	rt reflect.Type 
-	encfn func(*encFnInfo, reflect.Value)
-	decfn func(*decFnInfo, reflect.Value)
-}
-
-type fastpathA [{{ .FastpathLen }}]fastpathE
-
-func (x *fastpathA) index(rtid uintptr) int {
-	// use binary search to grab the index (adapted from sort/search.go)
-	h, i, j := 0, 0, {{ .FastpathLen }} // len(x)
-	for i < j {
-		h = i + (j-i)/2
-		if x[h].rtid < rtid {
-			i = h + 1
-		} else {
-			j = h
-		}
-	}
-	if i < {{ .FastpathLen }} && x[i].rtid == rtid {
-		return i
-	}
-	return -1
-}
-
-type fastpathAslice []fastpathE
-
-func (x fastpathAslice) Len() int { return len(x) }
-func (x fastpathAslice) Less(i, j int) bool { return x[i].rtid < x[j].rtid }
-func (x fastpathAslice) Swap(i, j int) { x[i], x[j] = x[j], x[i] }
-
-var fastpathAV fastpathA
-
-// due to possible initialization loop error, make fastpath in an init()
-func init() {
-	if !fastpathEnabled {
-		return
-	}
-	i := 0
-	fn := func(v interface{}, fe func(*encFnInfo, reflect.Value), fd func(*decFnInfo, reflect.Value)) (f fastpathE) {
-		xrt := reflect.TypeOf(v)
-		xptr := reflect.ValueOf(xrt).Pointer()
-		fastpathAV[i] = fastpathE{xptr, xrt, fe, fd}
-		i++
-		return
-	}
-	
-	{{range .Values}}{{if not .Primitive}}{{if not .MapKey }}
-	fn([]{{ .Elem }}(nil), (*encFnInfo).{{ .MethodNamePfx "fastpathEnc" false }}R, (*decFnInfo).{{ .MethodNamePfx "fastpathDec" false }}R){{end}}{{end}}{{end}}
-	
-	{{range .Values}}{{if not .Primitive}}{{if .MapKey }}
-	fn(map[{{ .MapKey }}]{{ .Elem }}(nil), (*encFnInfo).{{ .MethodNamePfx "fastpathEnc" false }}R, (*decFnInfo).{{ .MethodNamePfx "fastpathDec" false }}R){{end}}{{end}}{{end}}
-	
-	sort.Sort(fastpathAslice(fastpathAV[:]))
-}
-
-// -- encode
-
-// -- -- fast path type switch
-func fastpathEncodeTypeSwitch(iv interface{}, e *Encoder) bool {
-	if !fastpathEnabled {
-		return false
-	}
-	switch v := iv.(type) {
-{{range .Values}}{{if not .Primitive}}{{if not .MapKey }}
-	case []{{ .Elem }}:{{else}}
-	case map[{{ .MapKey }}]{{ .Elem }}:{{end}}
-		fastpathTV.{{ .MethodNamePfx "Enc" false }}V(v, fastpathCheckNilTrue, e){{if not .MapKey }}
-	case *[]{{ .Elem }}:{{else}}
-	case *map[{{ .MapKey }}]{{ .Elem }}:{{end}}
-		fastpathTV.{{ .MethodNamePfx "Enc" false }}V(*v, fastpathCheckNilTrue, e)
-{{end}}{{end}}
-	default:
-        _ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
-		return false
-	}
-	return true
-}
-
-func fastpathEncodeTypeSwitchSlice(iv interface{}, e *Encoder) bool {
-	if !fastpathEnabled {
-		return false
-	}
-	switch v := iv.(type) {
-{{range .Values}}{{if not .Primitive}}{{if not .MapKey }}
-	case []{{ .Elem }}:
-		fastpathTV.{{ .MethodNamePfx "Enc" false }}V(v, fastpathCheckNilTrue, e)
-	case *[]{{ .Elem }}:
-		fastpathTV.{{ .MethodNamePfx "Enc" false }}V(*v, fastpathCheckNilTrue, e)
-{{end}}{{end}}{{end}}
-	default:
-        _ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
-		return false
-	}
-	return true
-}
-
-func fastpathEncodeTypeSwitchMap(iv interface{}, e *Encoder) bool {
-	if !fastpathEnabled {
-		return false
-	}
-	switch v := iv.(type) {
-{{range .Values}}{{if not .Primitive}}{{if .MapKey }}
-	case map[{{ .MapKey }}]{{ .Elem }}:
-		fastpathTV.{{ .MethodNamePfx "Enc" false }}V(v, fastpathCheckNilTrue, e)
-	case *map[{{ .MapKey }}]{{ .Elem }}:
-		fastpathTV.{{ .MethodNamePfx "Enc" false }}V(*v, fastpathCheckNilTrue, e)
-{{end}}{{end}}{{end}}
-	default:
-        _ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
-		return false
-	}
-	return true
-}
-
-// -- -- fast path functions
-{{range .Values}}{{if not .Primitive}}{{if not .MapKey }} 
-
-func (f *encFnInfo) {{ .MethodNamePfx "fastpathEnc" false }}R(rv reflect.Value) {
-	fastpathTV.{{ .MethodNamePfx "Enc" false }}V(rv.Interface().([]{{ .Elem }}), fastpathCheckNilFalse, f.e)
-}
-func (_ fastpathT) {{ .MethodNamePfx "Enc" false }}V(v []{{ .Elem }}, checkNil bool, e *Encoder) {
-	ee := e.e
-	cr := e.cr
-	if checkNil && v == nil {
-		ee.EncodeNil()
-		return
-	}
-	ee.EncodeArrayStart(len(v))
-	for _, v2 := range v {
-		if cr != nil { cr.sendContainerState(containerArrayElem) }
-		{{ encmd .Elem "v2"}}
-	}
-	if cr != nil { cr.sendContainerState(containerArrayEnd) }{{/* ee.EncodeEnd() */}}
-}
-
-{{end}}{{end}}{{end}}
-
-{{range .Values}}{{if not .Primitive}}{{if .MapKey }}
-
-func (f *encFnInfo) {{ .MethodNamePfx "fastpathEnc" false }}R(rv reflect.Value) {
-	fastpathTV.{{ .MethodNamePfx "Enc" false }}V(rv.Interface().(map[{{ .MapKey }}]{{ .Elem }}), fastpathCheckNilFalse, f.e)
-}
-func (_ fastpathT) {{ .MethodNamePfx "Enc" false }}V(v map[{{ .MapKey }}]{{ .Elem }}, checkNil bool, e *Encoder) {
-	ee := e.e
-	cr := e.cr
-	if checkNil && v == nil {
-		ee.EncodeNil()
-		return
-	}
-	ee.EncodeMapStart(len(v))
-	{{if eq .MapKey "string"}}asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
-	{{end}}if e.h.Canonical {
-		{{if eq .MapKey "interface{}"}}{{/* out of band 
-		*/}}var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
-		e2 := NewEncoderBytes(&mksv, e.hh)
-		v2 := make([]bytesI, len(v))
-		var i, l int
-		var vp *bytesI {{/* put loop variables outside. seems currently needed for better perf */}}
-		for k2, _ := range v {
-			l = len(mksv)
-			e2.MustEncode(k2)
-			vp = &v2[i]
-			vp.v = mksv[l:]
-			vp.i = k2 
-			i++
-		}
-		sort.Sort(bytesISlice(v2))
-		for j := range v2 {
-			if cr != nil { cr.sendContainerState(containerMapKey) }
-			e.asis(v2[j].v)
-			if cr != nil { cr.sendContainerState(containerMapValue) }
-			e.encode(v[v2[j].i])
-		} {{else}}{{ $x := sorttype .MapKey true}}v2 := make([]{{ $x }}, len(v))
-		var i int 
-		for k, _ := range v {
-			v2[i] = {{ $x }}(k)
-			i++
-		}
-		sort.Sort({{ sorttype .MapKey false}}(v2))
-		for _, k2 := range v2 {
-			if cr != nil { cr.sendContainerState(containerMapKey) }
-			{{if eq .MapKey "string"}}if asSymbols {
-				ee.EncodeSymbol(k2)
-			} else {
-				ee.EncodeString(c_UTF8, k2)
-			}{{else}}{{ $y := printf "%s(k2)" .MapKey }}{{ encmd .MapKey $y }}{{end}}
-			if cr != nil { cr.sendContainerState(containerMapValue) }
-			{{ $y := printf "v[%s(k2)]" .MapKey }}{{ encmd .Elem $y }}
-		} {{end}}
-	} else {
-		for k2, v2 := range v {
-			if cr != nil { cr.sendContainerState(containerMapKey) }
-			{{if eq .MapKey "string"}}if asSymbols {
-				ee.EncodeSymbol(k2)
-			} else {
-				ee.EncodeString(c_UTF8, k2)
-			}{{else}}{{ encmd .MapKey "k2"}}{{end}}
-			if cr != nil { cr.sendContainerState(containerMapValue) }
-			{{ encmd .Elem "v2"}}
-		}
-	}
-	if cr != nil { cr.sendContainerState(containerMapEnd) }{{/* ee.EncodeEnd() */}}
-}
-
-{{end}}{{end}}{{end}}
-
-// -- decode
-
-// -- -- fast path type switch
-func fastpathDecodeTypeSwitch(iv interface{}, d *Decoder) bool {
-	if !fastpathEnabled {
-		return false
-	}
-	switch v := iv.(type) {
-{{range .Values}}{{if not .Primitive}}{{if not .MapKey }}
-	case []{{ .Elem }}:{{else}}
-	case map[{{ .MapKey }}]{{ .Elem }}:{{end}}
-		fastpathTV.{{ .MethodNamePfx "Dec" false }}V(v, fastpathCheckNilFalse, false, d){{if not .MapKey }}
-	case *[]{{ .Elem }}:{{else}}
-	case *map[{{ .MapKey }}]{{ .Elem }}:{{end}}
-		v2, changed2 := fastpathTV.{{ .MethodNamePfx "Dec" false }}V(*v, fastpathCheckNilFalse, true, d)
-		if changed2 {
-			*v = v2 
-		}
-{{end}}{{end}}
-	default:
-        _ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
-		return false
-	}
-	return true
-}
-
-// -- -- fast path functions
-{{range .Values}}{{if not .Primitive}}{{if not .MapKey }}
-{{/*
-Slices can change if they 
-- did not come from an array
-- are addressable (from a ptr)
-- are settable (e.g. contained in an interface{})
-*/}}
-func (f *decFnInfo) {{ .MethodNamePfx "fastpathDec" false }}R(rv reflect.Value) { 
-	array := f.seq == seqTypeArray
-	if !array && rv.CanAddr() { {{/* // CanSet => CanAddr + Exported */}}
-		vp := rv.Addr().Interface().(*[]{{ .Elem }})
-		v, changed := fastpathTV.{{ .MethodNamePfx "Dec" false }}V(*vp, fastpathCheckNilFalse, !array, f.d)
-		if changed {
-			*vp = v
-		}
-	} else {
-		v := rv.Interface().([]{{ .Elem }})
-		fastpathTV.{{ .MethodNamePfx "Dec" false }}V(v, fastpathCheckNilFalse, false, f.d)
-	}
-}
-
-func (f fastpathT) {{ .MethodNamePfx "Dec" false }}X(vp *[]{{ .Elem }}, checkNil bool, d *Decoder) {
-	v, changed := f.{{ .MethodNamePfx "Dec" false }}V(*vp, checkNil, true, d)
-	if changed {
-		*vp = v 
-	}
-}
-func (_ fastpathT) {{ .MethodNamePfx "Dec" false }}V(v []{{ .Elem }}, checkNil bool, canChange bool, d *Decoder) (_ []{{ .Elem }}, changed bool) {
-	dd := d.d
-	{{/* // if dd.isContainerType(valueTypeNil) { dd.TryDecodeAsNil() */}}
-	if checkNil && dd.TryDecodeAsNil() {
-		if v != nil {
-			changed = true 
-		}
-		return nil, changed 
-	}
-
-	slh, containerLenS := d.decSliceHelperStart()
-	if containerLenS == 0 {
-		if canChange {
-			if v == nil {
-				v = []{{ .Elem }}{}
-			} else if len(v) != 0 {
-				v = v[:0]
-			}
-			changed = true
-		}
-		slh.End()
-		return
-	}
-	
-	if containerLenS > 0 {
-		x2read := containerLenS
-		var xtrunc bool 
-		if containerLenS > cap(v) {
-			if canChange { {{/*
-				// fast-path is for "basic" immutable types, so no need to copy them over
-				// s := make([]{{ .Elem }}, decInferLen(containerLenS, d.h.MaxInitLen))
-				// copy(s, v[:cap(v)])
-				// v = s */}}
-				var xlen int 
-                xlen, xtrunc = decInferLen(containerLenS, d.h.MaxInitLen, {{ .Size }})
-				if xtrunc {
-					if xlen <= cap(v) {
-						v = v[:xlen]
-					} else {
-						v = make([]{{ .Elem }}, xlen)
-					}
-				} else {
-					v = make([]{{ .Elem }}, xlen)
-				}
-				changed = true
-			} else {
-				d.arrayCannotExpand(len(v), containerLenS)
-			}
-			x2read = len(v)
-		} else if containerLenS != len(v) {
-			if canChange {
-				v = v[:containerLenS]
-				changed = true
-			}
-		} {{/* // all checks done. cannot go past len. */}}
-		j := 0
-		for ; j < x2read; j++ {
-			slh.ElemContainerState(j)
-			{{ if eq .Elem "interface{}" }}d.decode(&v[j]){{ else }}v[j] = {{ decmd .Elem }}{{ end }}
-		}
-		if xtrunc { {{/* // means canChange=true, changed=true already. */}}
-			for ; j < containerLenS; j++ {
-				v = append(v, {{ zerocmd .Elem }})
-				slh.ElemContainerState(j)
-				{{ if eq .Elem "interface{}" }}d.decode(&v[j]){{ else }}v[j] = {{ decmd .Elem }}{{ end }}
-			}
-		} else if !canChange {
-			for ; j < containerLenS; j++ {
-				slh.ElemContainerState(j)
-				d.swallow()
-			}
-		}
-	} else {
-		breakFound := dd.CheckBreak() {{/* check break first, so we can initialize v with a capacity of 4 if necessary */}}
-		if breakFound {
-			if canChange {
-				if v == nil {
-					v = []{{ .Elem }}{}
-				} else if len(v) != 0 {
-					v = v[:0]
-				}
-				changed = true
-			}
-			slh.End()
-			return
-		}
-		if cap(v) == 0 {
-			v = make([]{{ .Elem }}, 1, 4)
-			changed = true
-		}
-		j := 0	
-		for ; !breakFound; j++ {
-			if j >= len(v) { 
-				if canChange {
-					v = append(v, {{ zerocmd .Elem }})
-					changed = true
-				} else {
-					d.arrayCannotExpand(len(v), j+1)
-				}
-			}
-			slh.ElemContainerState(j)
-			if j < len(v) { {{/* // all checks done. cannot go past len. */}}
-				{{ if eq .Elem "interface{}" }}d.decode(&v[j])
-				{{ else }}v[j] = {{ decmd .Elem }}{{ end }}
-			} else {
-				d.swallow()
-			}
-			breakFound = dd.CheckBreak()
-		}
-		if canChange && j < len(v) {
-			v = v[:j]
-			changed = true
-		}
-	}
-	slh.End() 
-	return v, changed 
-}
-
-{{end}}{{end}}{{end}}
-
-
-{{range .Values}}{{if not .Primitive}}{{if .MapKey }}
-{{/*
-Maps can change if they are
-- addressable (from a ptr)
-- settable (e.g. contained in an interface{})
-*/}}
-func (f *decFnInfo) {{ .MethodNamePfx "fastpathDec" false }}R(rv reflect.Value) { 
-	if rv.CanAddr() {
-		vp := rv.Addr().Interface().(*map[{{ .MapKey }}]{{ .Elem }})
-		v, changed := fastpathTV.{{ .MethodNamePfx "Dec" false }}V(*vp, fastpathCheckNilFalse, true, f.d)
-		if changed {
-			*vp = v
-		}
-	} else {
-		v := rv.Interface().(map[{{ .MapKey }}]{{ .Elem }})
-		fastpathTV.{{ .MethodNamePfx "Dec" false }}V(v, fastpathCheckNilFalse, false, f.d)
-	}
-}
-func (f fastpathT) {{ .MethodNamePfx "Dec" false }}X(vp *map[{{ .MapKey }}]{{ .Elem }}, checkNil bool, d *Decoder) {
-	v, changed := f.{{ .MethodNamePfx "Dec" false }}V(*vp, checkNil, true, d)
-	if changed {
-		*vp = v 
-	}
-}
-func (_ fastpathT) {{ .MethodNamePfx "Dec" false }}V(v map[{{ .MapKey }}]{{ .Elem }}, checkNil bool, canChange bool, 
-	d *Decoder) (_ map[{{ .MapKey }}]{{ .Elem }}, changed bool) {
-	dd := d.d
-	cr := d.cr
-	{{/* // if dd.isContainerType(valueTypeNil) {dd.TryDecodeAsNil() */}}
-	if checkNil && dd.TryDecodeAsNil() {
-		if v != nil {
-			changed = true
-		} 
-		return nil, changed
-	}
-
-	containerLen := dd.ReadMapStart()
-	if canChange && v == nil {
-		xlen, _ := decInferLen(containerLen, d.h.MaxInitLen, {{ .Size }})
-		v = make(map[{{ .MapKey }}]{{ .Elem }}, xlen)
-		changed = true
-	}
-	{{ if eq .Elem "interface{}" }}mapGet := !d.h.MapValueReset && !d.h.InterfaceReset{{end}}
-	var mk {{ .MapKey }}
-	var mv {{ .Elem }}
-	if containerLen > 0 {
-		for j := 0; j < containerLen; j++ {
-			if cr != nil { cr.sendContainerState(containerMapKey) }
-			{{ if eq .MapKey "interface{}" }}mk = nil 
-			d.decode(&mk)
-			if bv, bok := mk.([]byte); bok {
-				mk = d.string(bv) {{/* // maps cannot have []byte as key. switch to string. */}}
-			}{{ else }}mk = {{ decmd .MapKey }}{{ end }}
-			if cr != nil { cr.sendContainerState(containerMapValue) }
-			{{ if eq .Elem "interface{}" }}if mapGet { mv = v[mk] } else { mv = nil }
-			d.decode(&mv){{ else }}mv = {{ decmd .Elem }}{{ end }}
-			if v != nil {
-				v[mk] = mv
-			}
-		}
-	} else if containerLen < 0 {
-		for j := 0; !dd.CheckBreak(); j++ {
-			if cr != nil { cr.sendContainerState(containerMapKey) }
-			{{ if eq .MapKey "interface{}" }}mk = nil 
-			d.decode(&mk)
-			if bv, bok := mk.([]byte); bok {
-				mk = d.string(bv) {{/* // maps cannot have []byte as key. switch to string. */}}
-			}{{ else }}mk = {{ decmd .MapKey }}{{ end }}
-			if cr != nil { cr.sendContainerState(containerMapValue) }
-			{{ if eq .Elem "interface{}" }}if mapGet { mv = v[mk] } else { mv = nil }
-			d.decode(&mv){{ else }}mv = {{ decmd .Elem }}{{ end }}
-			if v != nil {
-				v[mk] = mv
-			}
-		}
-	}
-	if cr != nil { cr.sendContainerState(containerMapEnd) }
-	return v, changed
-}
-
-{{end}}{{end}}{{end}}
diff --git a/cmd/vendor/github.com/ugorji/go/codec/gen-dec-array.go.tmpl b/cmd/vendor/github.com/ugorji/go/codec/gen-dec-array.go.tmpl
deleted file mode 100644
index 2caae5b..0000000
--- a/cmd/vendor/github.com/ugorji/go/codec/gen-dec-array.go.tmpl
+++ /dev/null
@@ -1,101 +0,0 @@
-{{var "v"}} := {{if not isArray}}*{{end}}{{ .Varname }}
-{{var "h"}}, {{var "l"}} := z.DecSliceHelperStart() {{/* // helper, containerLenS */}}
-var {{var "c"}} bool {{/* // changed */}}
-if {{var "l"}} == 0 {
-	{{if isSlice }}if {{var "v"}} == nil {
-		{{var "v"}} = []{{ .Typ }}{}
-		{{var "c"}} = true
-	} else if len({{var "v"}}) != 0 {
-		{{var "v"}} = {{var "v"}}[:0]
-		{{var "c"}} = true
-	} {{end}} {{if isChan }}if {{var "v"}} == nil {
-		{{var "v"}} = make({{ .CTyp }}, 0)
-		{{var "c"}} = true
-	} {{end}}
-} else if {{var "l"}} > 0 {
-	{{if isChan }}if {{var "v"}} == nil {
-		{{var "rl"}}, _ = z.DecInferLen({{var "l"}}, z.DecBasicHandle().MaxInitLen, {{ .Size }})
-		{{var "v"}} = make({{ .CTyp }}, {{var "rl"}})
-		{{var "c"}} = true
-	}
-	for {{var "r"}} := 0; {{var "r"}} < {{var "l"}}; {{var "r"}}++ {
-		{{var "h"}}.ElemContainerState({{var "r"}})
-		var {{var "t"}} {{ .Typ }}
-		{{ $x := printf "%st%s" .TempVar .Rand }}{{ decLineVar $x }}
-		{{var "v"}} <- {{var "t"}}
-	}
-	{{ else }}	var {{var "rr"}}, {{var "rl"}} int {{/* // num2read, length of slice/array/chan */}}
-	var {{var "rt"}} bool {{/* truncated */}}
-	if {{var "l"}} > cap({{var "v"}}) {
-		{{if isArray }}z.DecArrayCannotExpand(len({{var "v"}}), {{var "l"}})
-		{{ else }}{{if not .Immutable }}
-		{{var "rg"}} := len({{var "v"}}) > 0
-		{{var "v2"}} := {{var "v"}} {{end}}
-		{{var "rl"}}, {{var "rt"}} = z.DecInferLen({{var "l"}}, z.DecBasicHandle().MaxInitLen, {{ .Size }})
-		if {{var "rt"}} {
-			if {{var "rl"}} <= cap({{var "v"}}) {
-				{{var "v"}} = {{var "v"}}[:{{var "rl"}}]
-			} else {
-				{{var "v"}} = make([]{{ .Typ }}, {{var "rl"}})
-			}
-		} else {
-			{{var "v"}} = make([]{{ .Typ }}, {{var "rl"}})
-		}
-		{{var "c"}} = true
-		{{var "rr"}} = len({{var "v"}}) {{if not .Immutable }}
-			if {{var "rg"}} { copy({{var "v"}}, {{var "v2"}}) } {{end}} {{end}}{{/* end not Immutable, isArray */}}
-	} {{if isSlice }} else if {{var "l"}} != len({{var "v"}}) {
-		{{var "v"}} = {{var "v"}}[:{{var "l"}}]
-		{{var "c"}} = true
-	} {{end}}	{{/* end isSlice:47 */}} 
-	{{var "j"}} := 0
-	for ; {{var "j"}} < {{var "rr"}} ; {{var "j"}}++ {
-		{{var "h"}}.ElemContainerState({{var "j"}})
-		{{ $x := printf "%[1]vv%[2]v[%[1]vj%[2]v]" .TempVar .Rand }}{{ decLineVar $x }}
-	}
-	{{if isArray }}for ; {{var "j"}} < {{var "l"}} ; {{var "j"}}++ {
-		{{var "h"}}.ElemContainerState({{var "j"}})
-		z.DecSwallow()
-	}
-	{{ else }}if {{var "rt"}} {
-		for ; {{var "j"}} < {{var "l"}} ; {{var "j"}}++ {
-			{{var "v"}} = append({{var "v"}}, {{ zero}})
-			{{var "h"}}.ElemContainerState({{var "j"}})
-			{{ $x := printf "%[1]vv%[2]v[%[1]vj%[2]v]" .TempVar .Rand }}{{ decLineVar $x }}
-		}
-	} {{end}} {{/* end isArray:56 */}}
-	{{end}} {{/* end isChan:16 */}}
-} else { {{/* len < 0 */}}
-	{{var "j"}} := 0
-	for ; !r.CheckBreak(); {{var "j"}}++ {
-		{{if isChan }}
-		{{var "h"}}.ElemContainerState({{var "j"}})
-		var {{var "t"}} {{ .Typ }}
-		{{ $x := printf "%st%s" .TempVar .Rand }}{{ decLineVar $x }}
-		{{var "v"}} <- {{var "t"}} 
-		{{ else }}
-		if {{var "j"}} >= len({{var "v"}}) {
-			{{if isArray }}z.DecArrayCannotExpand(len({{var "v"}}), {{var "j"}}+1)
-			{{ else }}{{var "v"}} = append({{var "v"}}, {{zero}})// var {{var "z"}} {{ .Typ }}
-			{{var "c"}} = true {{end}}
-		}
-		{{var "h"}}.ElemContainerState({{var "j"}})
-		if {{var "j"}} < len({{var "v"}}) {
-			{{ $x := printf "%[1]vv%[2]v[%[1]vj%[2]v]" .TempVar .Rand }}{{ decLineVar $x }}
-		} else {
-			z.DecSwallow()
-		}
-		{{end}}
-	}
-	{{if isSlice }}if {{var "j"}} < len({{var "v"}}) {
-		{{var "v"}} = {{var "v"}}[:{{var "j"}}]
-		{{var "c"}} = true
-	} else if {{var "j"}} == 0 && {{var "v"}} == nil {
-		{{var "v"}} = []{{ .Typ }}{}
-		{{var "c"}} = true
-	}{{end}}
-}
-{{var "h"}}.End()
-{{if not isArray }}if {{var "c"}} { 
-	*{{ .Varname }} = {{var "v"}}
-}{{end}}
diff --git a/cmd/vendor/github.com/ugorji/go/codec/gen-dec-map.go.tmpl b/cmd/vendor/github.com/ugorji/go/codec/gen-dec-map.go.tmpl
deleted file mode 100644
index 77400e0..0000000
--- a/cmd/vendor/github.com/ugorji/go/codec/gen-dec-map.go.tmpl
+++ /dev/null
@@ -1,58 +0,0 @@
-{{var "v"}} := *{{ .Varname }}
-{{var "l"}} := r.ReadMapStart()
-{{var "bh"}} := z.DecBasicHandle()
-if {{var "v"}} == nil {
-	{{var "rl"}}, _ := z.DecInferLen({{var "l"}}, {{var "bh"}}.MaxInitLen, {{ .Size }})
-	{{var "v"}} = make(map[{{ .KTyp }}]{{ .Typ }}, {{var "rl"}})
-	*{{ .Varname }} = {{var "v"}}
-}
-var {{var "mk"}} {{ .KTyp }}
-var {{var "mv"}} {{ .Typ }}
-var {{var "mg"}} {{if decElemKindPtr}}, {{var "ms"}}, {{var "mok"}}{{end}} bool
-if {{var "bh"}}.MapValueReset {
-	{{if decElemKindPtr}}{{var "mg"}} = true
-	{{else if decElemKindIntf}}if !{{var "bh"}}.InterfaceReset { {{var "mg"}} = true }
-	{{else if not decElemKindImmutable}}{{var "mg"}} = true
-	{{end}} }
-if {{var "l"}} > 0  {
-for {{var "j"}} := 0; {{var "j"}} < {{var "l"}}; {{var "j"}}++ {
-	z.DecSendContainerState(codecSelfer_containerMapKey{{ .Sfx }})
-	{{ $x := printf "%vmk%v" .TempVar .Rand }}{{ decLineVarK $x }}
-{{ if eq .KTyp "interface{}" }}{{/* // special case if a byte array. */}}if {{var "bv"}}, {{var "bok"}} := {{var "mk"}}.([]byte); {{var "bok"}} {
-		{{var "mk"}} = string({{var "bv"}})
-	}{{ end }}{{if decElemKindPtr}}
-	{{var "ms"}} = true{{end}}
-	if {{var "mg"}} {
-		{{if decElemKindPtr}}{{var "mv"}}, {{var "mok"}} = {{var "v"}}[{{var "mk"}}] 
-		if {{var "mok"}} {
-			{{var "ms"}} = false
-		} {{else}}{{var "mv"}} = {{var "v"}}[{{var "mk"}}] {{end}}
-	} {{if not decElemKindImmutable}}else { {{var "mv"}} = {{decElemZero}} }{{end}}
-	z.DecSendContainerState(codecSelfer_containerMapValue{{ .Sfx }})
-	{{ $x := printf "%vmv%v" .TempVar .Rand }}{{ decLineVar $x }}
-	if {{if decElemKindPtr}} {{var "ms"}} && {{end}} {{var "v"}} != nil {
-		{{var "v"}}[{{var "mk"}}] = {{var "mv"}}
-	}
-}
-} else if {{var "l"}} < 0  {
-for {{var "j"}} := 0; !r.CheckBreak(); {{var "j"}}++ {
-	z.DecSendContainerState(codecSelfer_containerMapKey{{ .Sfx }})
-	{{ $x := printf "%vmk%v" .TempVar .Rand }}{{ decLineVarK $x }}
-{{ if eq .KTyp "interface{}" }}{{/* // special case if a byte array. */}}if {{var "bv"}}, {{var "bok"}} := {{var "mk"}}.([]byte); {{var "bok"}} {
-		{{var "mk"}} = string({{var "bv"}})
-	}{{ end }}{{if decElemKindPtr}}
-	{{var "ms"}} = true {{ end }}
-	if {{var "mg"}} {
-		{{if decElemKindPtr}}{{var "mv"}}, {{var "mok"}} = {{var "v"}}[{{var "mk"}}] 
-		if {{var "mok"}} {
-			{{var "ms"}} = false
-		} {{else}}{{var "mv"}} = {{var "v"}}[{{var "mk"}}] {{end}}
-	} {{if not decElemKindImmutable}}else { {{var "mv"}} = {{decElemZero}} }{{end}}
-	z.DecSendContainerState(codecSelfer_containerMapValue{{ .Sfx }})
-	{{ $x := printf "%vmv%v" .TempVar .Rand }}{{ decLineVar $x }}
-	if {{if decElemKindPtr}} {{var "ms"}} && {{end}} {{var "v"}} != nil {
-		{{var "v"}}[{{var "mk"}}] = {{var "mv"}}
-	}
-}
-} // else len==0: TODO: Should we clear map entries?
-z.DecSendContainerState(codecSelfer_containerMapEnd{{ .Sfx }})
diff --git a/cmd/vendor/github.com/ugorji/go/codec/gen-helper.go.tmpl b/cmd/vendor/github.com/ugorji/go/codec/gen-helper.go.tmpl
deleted file mode 100644
index 3195857..0000000
--- a/cmd/vendor/github.com/ugorji/go/codec/gen-helper.go.tmpl
+++ /dev/null
@@ -1,364 +0,0 @@
-// //+build ignore
-
-// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
-// Use of this source code is governed by a MIT license found in the LICENSE file.
-
-// ************************************************************
-// DO NOT EDIT.
-// THIS FILE IS AUTO-GENERATED from gen-helper.go.tmpl
-// ************************************************************
-
-package codec
-
-import (
-	"encoding"
-	"reflect"
-)
-
-// This file is used to generate helper code for codecgen. 
-// The values here i.e. genHelper(En|De)coder are not to be used directly by 
-// library users. They WILL change continously and without notice.
-// 
-// To help enforce this, we create an unexported type with exported members.
-// The only way to get the type is via the one exported type that we control (somewhat).
-// 
-// When static codecs are created for types, they will use this value
-// to perform encoding or decoding of primitives or known slice or map types.
-
-// GenHelperEncoder is exported so that it can be used externally by codecgen.
-// Library users: DO NOT USE IT DIRECTLY. IT WILL CHANGE CONTINOUSLY WITHOUT NOTICE.
-func GenHelperEncoder(e *Encoder) (genHelperEncoder, encDriver) {
-	return genHelperEncoder{e:e}, e.e 
-}
-
-// GenHelperDecoder is exported so that it can be used externally by codecgen.
-// Library users: DO NOT USE IT DIRECTLY. IT WILL CHANGE CONTINOUSLY WITHOUT NOTICE.
-func GenHelperDecoder(d *Decoder) (genHelperDecoder, decDriver) {
-	return genHelperDecoder{d:d}, d.d 
-}
-
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-type genHelperEncoder struct {
-	e *Encoder
-	F fastpathT 
-}
-
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-type genHelperDecoder struct {
-	d *Decoder
-	F fastpathT 
-}
-
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncBasicHandle() *BasicHandle {
-	return f.e.h
-}
-
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncBinary() bool {
-	return f.e.be // f.e.hh.isBinaryEncoding()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncFallback(iv interface{}) {
-	// println(">>>>>>>>> EncFallback")
-	f.e.encodeI(iv, false, false)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncTextMarshal(iv encoding.TextMarshaler) {
-	bs, fnerr := iv.MarshalText()
-	f.e.marshal(bs, fnerr, false, c_UTF8)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncJSONMarshal(iv jsonMarshaler) {
-	bs, fnerr := iv.MarshalJSON()
-	f.e.marshal(bs, fnerr, true, c_UTF8)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncBinaryMarshal(iv encoding.BinaryMarshaler) {
-	bs, fnerr := iv.MarshalBinary()
-	f.e.marshal(bs, fnerr, false, c_RAW)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) TimeRtidIfBinc() uintptr {
-	if _, ok := f.e.hh.(*BincHandle); ok {
-		return timeTypId 
-	}
-	return 0
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) IsJSONHandle() bool {
-	return f.e.js
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) HasExtensions() bool {
-	return len(f.e.h.extHandle) != 0
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncExt(v interface{}) (r bool) {
-	rt := reflect.TypeOf(v)
-	if rt.Kind() == reflect.Ptr {
-		rt = rt.Elem()
-	}
-	rtid := reflect.ValueOf(rt).Pointer()
-	if xfFn := f.e.h.getExt(rtid); xfFn != nil {
-		f.e.e.EncodeExt(v, xfFn.tag, xfFn.ext, f.e)
-		return true
-	}
-	return false 
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncSendContainerState(c containerState) {
-	if f.e.cr != nil {
-		f.e.cr.sendContainerState(c)
-	}
-}
-
-// ---------------- DECODER FOLLOWS -----------------
-
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecBasicHandle() *BasicHandle {
-	return f.d.h
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecBinary() bool {
-     return f.d.be // f.d.hh.isBinaryEncoding()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecSwallow() {
-	f.d.swallow()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecScratchBuffer() []byte {
-	return f.d.b[:]
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecFallback(iv interface{}, chkPtr bool) {
-	// println(">>>>>>>>> DecFallback")
-	f.d.decodeI(iv, chkPtr, false, false, false)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecSliceHelperStart() (decSliceHelper, int) {
-	return f.d.decSliceHelperStart()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecStructFieldNotFound(index int, name string) {
-	f.d.structFieldNotFound(index, name)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecArrayCannotExpand(sliceLen, streamLen int) {
-	f.d.arrayCannotExpand(sliceLen, streamLen)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecTextUnmarshal(tm encoding.TextUnmarshaler) {
-	fnerr := tm.UnmarshalText(f.d.d.DecodeBytes(f.d.b[:], true, true))
-	if fnerr != nil {
-		panic(fnerr)
-	}
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecJSONUnmarshal(tm jsonUnmarshaler) {
-	// bs := f.dd.DecodeBytes(f.d.b[:], true, true)
-	// grab the bytes to be read, as UnmarshalJSON needs the full JSON so as to unmarshal it itself.
-	fnerr := tm.UnmarshalJSON(f.d.nextValueBytes())
-	if fnerr != nil {
-		panic(fnerr)
-	}
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecBinaryUnmarshal(bm encoding.BinaryUnmarshaler) {
-	fnerr := bm.UnmarshalBinary(f.d.d.DecodeBytes(nil, false, true))
-	if fnerr != nil {
-		panic(fnerr)
-	}
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) TimeRtidIfBinc() uintptr {
-	if _, ok := f.d.hh.(*BincHandle); ok {
-		return timeTypId 
-	}
-	return 0
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) IsJSONHandle() bool {
-	return f.d.js 
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) HasExtensions() bool {
-	return len(f.d.h.extHandle) != 0
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecExt(v interface{}) (r bool) {
-	rt := reflect.TypeOf(v).Elem()
-	rtid := reflect.ValueOf(rt).Pointer()
-	if xfFn := f.d.h.getExt(rtid); xfFn != nil {
-		f.d.d.DecodeExt(v, xfFn.tag, xfFn.ext)
-		return true
-	}
-	return false 
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecInferLen(clen, maxlen, unit int) (rvlen int, truncated bool) {
-	return decInferLen(clen, maxlen, unit)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecSendContainerState(c containerState) {
-	if f.d.cr != nil {
-		f.d.cr.sendContainerState(c)
-	}
-}
-
-{{/*
-
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncDriver() encDriver {
-	return f.e.e
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecDriver() decDriver {
-     return f.d.d
-}
-
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncNil() {
-	f.e.e.EncodeNil()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncBytes(v []byte) {
-	f.e.e.EncodeStringBytes(c_RAW, v)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncArrayStart(length int) {
-	f.e.e.EncodeArrayStart(length)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncArrayEnd() {
-	f.e.e.EncodeArrayEnd()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncArrayEntrySeparator() {
-	f.e.e.EncodeArrayEntrySeparator()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncMapStart(length int) {
-	f.e.e.EncodeMapStart(length)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncMapEnd() {
-	f.e.e.EncodeMapEnd()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncMapEntrySeparator() {
-	f.e.e.EncodeMapEntrySeparator()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) EncMapKVSeparator() {
-	f.e.e.EncodeMapKVSeparator()
-}
-
-// ---------
-
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecBytes(v *[]byte) {
-	*v = f.d.d.DecodeBytes(*v)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecTryNil() bool {
-	return f.d.d.TryDecodeAsNil()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecContainerIsNil() (b bool) {
-	return f.d.d.IsContainerType(valueTypeNil)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecContainerIsMap() (b bool) {
-	return f.d.d.IsContainerType(valueTypeMap)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecContainerIsArray() (b bool) {
-	return f.d.d.IsContainerType(valueTypeArray)
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecCheckBreak() bool {
-	return f.d.d.CheckBreak()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecMapStart() int {
-	return f.d.d.ReadMapStart()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecArrayStart() int {
-	return f.d.d.ReadArrayStart()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecMapEnd() {
-	f.d.d.ReadMapEnd()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecArrayEnd() {
-	f.d.d.ReadArrayEnd()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecArrayEntrySeparator() {
-	f.d.d.ReadArrayEntrySeparator()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecMapEntrySeparator() {
-	f.d.d.ReadMapEntrySeparator()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) DecMapKVSeparator() {
-	f.d.d.ReadMapKVSeparator()
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) ReadStringAsBytes(bs []byte) []byte {
-	return f.d.d.DecodeStringAsBytes(bs)
-}
-
-
-// -- encode calls (primitives)
-{{range .Values}}{{if .Primitive }}{{if ne .Primitive "interface{}" }}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) {{ .MethodNamePfx "Enc" true }}(v {{ .Primitive }}) {
-	ee := f.e.e
-	{{ encmd .Primitive "v" }}
-}
-{{ end }}{{ end }}{{ end }}
-
-// -- decode calls (primitives)
-{{range .Values}}{{if .Primitive }}{{if ne .Primitive "interface{}" }}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) {{ .MethodNamePfx "Dec" true }}(vp *{{ .Primitive }}) {
-	dd := f.d.d
-	*vp = {{ decmd .Primitive }}
-}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperDecoder) {{ .MethodNamePfx "Read" true }}() (v {{ .Primitive }}) {
-	dd := f.d.d
-	v = {{ decmd .Primitive }}
-	return
-}
-{{ end }}{{ end }}{{ end }}
-
-
-// -- encode calls (slices/maps)
-{{range .Values}}{{if not .Primitive }}{{if .Slice }}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) {{ .MethodNamePfx "Enc" false }}(v []{{ .Elem }}) { {{ else }}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-func (f genHelperEncoder) {{ .MethodNamePfx "Enc" false }}(v map[{{ .MapKey }}]{{ .Elem }}) { {{end}}
-	f.F.{{ .MethodNamePfx "Enc" false }}V(v, false, f.e)
-}
-{{ end }}{{ end }}
-
-// -- decode calls (slices/maps) 
-{{range .Values}}{{if not .Primitive }}
-// FOR USE BY CODECGEN ONLY. IT *WILL* CHANGE WITHOUT NOTICE. *DO NOT USE*
-{{if .Slice }}func (f genHelperDecoder) {{ .MethodNamePfx "Dec" false }}(vp *[]{{ .Elem }}) { 
-{{else}}func (f genHelperDecoder) {{ .MethodNamePfx "Dec" false }}(vp *map[{{ .MapKey }}]{{ .Elem }}) { {{end}}
-	v, changed := f.F.{{ .MethodNamePfx "Dec" false }}V(*vp, false, true, f.d)
-	if changed {
-		*vp = v 
-	}
-}
-{{ end }}{{ end }}
-*/}}
diff --git a/cmd/vendor/github.com/ugorji/go/codec/prebuild.sh b/cmd/vendor/github.com/ugorji/go/codec/prebuild.sh
deleted file mode 100755
index 98f4424..0000000
--- a/cmd/vendor/github.com/ugorji/go/codec/prebuild.sh
+++ /dev/null
@@ -1,199 +0,0 @@
-#!/bin/bash
-
-# _needgen is a helper function to tell if we need to generate files for msgp, codecgen.
-_needgen() {
-    local a="$1"
-    zneedgen=0
-    if [[ ! -e "$a" ]]
-    then
-        zneedgen=1
-        echo 1
-        return 0
-    fi 
-    for i in `ls -1 *.go.tmpl gen.go values_test.go`
-    do
-        if [[ "$a" -ot "$i" ]]
-        then
-            zneedgen=1
-            echo 1
-            return 0
-        fi 
-    done 
-    echo 0
-}
-
-# _build generates fast-path.go and gen-helper.go.
-# 
-# It is needed because there is some dependency between the generated code
-# and the other classes. Consequently, we have to totally remove the 
-# generated files and put stubs in place, before calling "go run" again
-# to recreate them.
-_build() {
-    if ! [[ "${zforce}" == "1" ||
-                "1" == $( _needgen "fast-path.generated.go" ) ||
-                "1" == $( _needgen "gen-helper.generated.go" ) ||
-                "1" == $( _needgen "gen.generated.go" ) ||
-                1 == 0 ]]
-    then
-        return 0
-    fi 
-
-   # echo "Running prebuild"
-    if [ "${zbak}" == "1" ] 
-    then
-        # echo "Backing up old generated files"
-        _zts=`date '+%m%d%Y_%H%M%S'`
-        _gg=".generated.go"
-        [ -e "gen-helper${_gg}" ] && mv gen-helper${_gg} gen-helper${_gg}__${_zts}.bak
-        [ -e "fast-path${_gg}" ] && mv fast-path${_gg} fast-path${_gg}__${_zts}.bak
-        # [ -e "safe${_gg}" ] && mv safe${_gg} safe${_gg}__${_zts}.bak
-        # [ -e "unsafe${_gg}" ] && mv unsafe${_gg} unsafe${_gg}__${_zts}.bak
-    else 
-        rm -f fast-path.generated.go gen.generated.go gen-helper.generated.go \
-           *safe.generated.go *_generated_test.go *.generated_ffjson_expose.go
-    fi
-
-    cat > gen.generated.go <<EOF
-// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
-// Use of this source code is governed by a MIT license found in the LICENSE file.
-
-package codec
-
-// DO NOT EDIT. THIS FILE IS AUTO-GENERATED FROM gen-dec-(map|array).go.tmpl
-
-const genDecMapTmpl = \`
-EOF
-
-    cat >> gen.generated.go < gen-dec-map.go.tmpl
-
-    cat >> gen.generated.go <<EOF
-\`
-
-const genDecListTmpl = \`
-EOF
-
-    cat >> gen.generated.go < gen-dec-array.go.tmpl
-
-    cat >> gen.generated.go <<EOF
-\`
-
-EOF
-
-    cat > gen-from-tmpl.codec.generated.go <<EOF
-package codec 
-import "io"
-func GenInternalGoFile(r io.Reader, w io.Writer, safe bool) error {
-return genInternalGoFile(r, w, safe)
-}
-EOF
-    
-    cat > gen-from-tmpl.generated.go <<EOF
-//+build ignore
-
-package main
-
-//import "flag"
-import "ugorji.net/codec"
-import "os"
-
-func run(fnameIn, fnameOut string, safe bool) {
-fin, err := os.Open(fnameIn)
-if err != nil { panic(err) }
-defer fin.Close()
-fout, err := os.Create(fnameOut)
-if err != nil { panic(err) }
-defer fout.Close()
-err = codec.GenInternalGoFile(fin, fout, safe)
-if err != nil { panic(err) }
-}
-
-func main() {
-// do not make safe/unsafe variants. 
-// Instead, depend on escape analysis, and place string creation and usage appropriately.
-// run("unsafe.go.tmpl", "safe.generated.go", true)
-// run("unsafe.go.tmpl", "unsafe.generated.go", false)
-run("fast-path.go.tmpl", "fast-path.generated.go", false)
-run("gen-helper.go.tmpl", "gen-helper.generated.go", false)
-}
-
-EOF
-    go run -tags=notfastpath gen-from-tmpl.generated.go && \
-        rm -f gen-from-tmpl.*generated.go 
-}
-
-_codegenerators() {
-    if [[ $zforce == "1" || 
-                "1" == $( _needgen "values_codecgen${zsfx}" ) ||
-                "1" == $( _needgen "values_msgp${zsfx}" ) ||
-                "1" == $( _needgen "values_ffjson${zsfx}" ) ||
-                1 == 0 ]] 
-    then
-        # codecgen creates some temporary files in the directory (main, pkg).
-        # Consequently, we should start msgp and ffjson first, and also put a small time latency before
-        # starting codecgen.
-        # Without this, ffjson chokes on one of the temporary files from codecgen.
-        if [[ $zexternal == "1" ]]
-        then 
-            echo "ffjson ... " && \
-                ffjson -w values_ffjson${zsfx} $zfin &
-            zzzIdFF=$!
-            echo "msgp ... " && \
-                msgp -tests=false -o=values_msgp${zsfx} -file=$zfin &
-            zzzIdMsgp=$!
-            
-            sleep 1 # give ffjson and msgp some buffer time. see note above.
-        fi
-        
-        echo "codecgen - !unsafe ... " && \
-            codecgen -rt codecgen -t 'x,codecgen,!unsafe' -o values_codecgen${zsfx} -d 19780 $zfin &
-        zzzIdC=$!
-        echo "codecgen - unsafe ... " && \
-            codecgen  -u -rt codecgen -t 'x,codecgen,unsafe' -o values_codecgen_unsafe${zsfx} -d 19781 $zfin &
-        zzzIdCU=$!
-        wait $zzzIdC $zzzIdCU $zzzIdMsgp $zzzIdFF && \
-            # remove (M|Unm)arshalJSON implementations, so they don't conflict with encoding/json bench \
-            if [[ $zexternal == "1" ]]
-            then
-                sed -i 's+ MarshalJSON(+ _MarshalJSON(+g' values_ffjson${zsfx} && \
-                    sed -i 's+ UnmarshalJSON(+ _UnmarshalJSON(+g' values_ffjson${zsfx}
-            fi && \
-            echo "generators done!" && \
-            true
-    fi 
-}
-
-# _init reads the arguments and sets up the flags
-_init() {
-OPTIND=1
-while getopts "fbx" flag
-do
-    case "x$flag" in 
-        'xf') zforce=1;;
-        'xb') zbak=1;;
-        'xx') zexternal=1;;
-        *) echo "prebuild.sh accepts [-fb] only"; return 1;;
-    esac
-done
-shift $((OPTIND-1))
-OPTIND=1
-}
-
-# main script.
-# First ensure that this is being run from the basedir (i.e. dirname of script is .)
-if [ "." = `dirname $0` ]
-then
-    zmydir=`pwd`
-    zfin="test_values.generated.go"
-    zsfx="_generated_test.go"
-    # rm -f *_generated_test.go 
-    rm -f codecgen-*.go && \
-        _init "$@" && \
-        _build && \
-        cp $zmydir/values_test.go $zmydir/$zfin && \
-        _codegenerators && \
-        echo prebuild done successfully
-    rm -f $zmydir/$zfin
-else
-    echo "Script must be run from the directory it resides in"
-fi 
-
diff --git a/cmd/vendor/github.com/ugorji/go/codec/test-cbor-goldens.json b/cmd/vendor/github.com/ugorji/go/codec/test-cbor-goldens.json
deleted file mode 100644
index 9028586..0000000
--- a/cmd/vendor/github.com/ugorji/go/codec/test-cbor-goldens.json
+++ /dev/null
@@ -1,639 +0,0 @@
-[
-  {
-    "cbor": "AA==",
-    "hex": "00",
-    "roundtrip": true,
-    "decoded": 0
-  },
-  {
-    "cbor": "AQ==",
-    "hex": "01",
-    "roundtrip": true,
-    "decoded": 1
-  },
-  {
-    "cbor": "Cg==",
-    "hex": "0a",
-    "roundtrip": true,
-    "decoded": 10
-  },
-  {
-    "cbor": "Fw==",
-    "hex": "17",
-    "roundtrip": true,
-    "decoded": 23
-  },
-  {
-    "cbor": "GBg=",
-    "hex": "1818",
-    "roundtrip": true,
-    "decoded": 24
-  },
-  {
-    "cbor": "GBk=",
-    "hex": "1819",
-    "roundtrip": true,
-    "decoded": 25
-  },
-  {
-    "cbor": "GGQ=",
-    "hex": "1864",
-    "roundtrip": true,
-    "decoded": 100
-  },
-  {
-    "cbor": "GQPo",
-    "hex": "1903e8",
-    "roundtrip": true,
-    "decoded": 1000
-  },
-  {
-    "cbor": "GgAPQkA=",
-    "hex": "1a000f4240",
-    "roundtrip": true,
-    "decoded": 1000000
-  },
-  {
-    "cbor": "GwAAAOjUpRAA",
-    "hex": "1b000000e8d4a51000",
-    "roundtrip": true,
-    "decoded": 1000000000000
-  },
-  {
-    "cbor": "G///////////",
-    "hex": "1bffffffffffffffff",
-    "roundtrip": true,
-    "decoded": 18446744073709551615
-  },
-  {
-    "cbor": "wkkBAAAAAAAAAAA=",
-    "hex": "c249010000000000000000",
-    "roundtrip": true,
-    "decoded": 18446744073709551616
-  },
-  {
-    "cbor": "O///////////",
-    "hex": "3bffffffffffffffff",
-    "roundtrip": true,
-    "decoded": -18446744073709551616,
-    "skip": true
-  },
-  {
-    "cbor": "w0kBAAAAAAAAAAA=",
-    "hex": "c349010000000000000000",
-    "roundtrip": true,
-    "decoded": -18446744073709551617
-  },
-  {
-    "cbor": "IA==",
-    "hex": "20",
-    "roundtrip": true,
-    "decoded": -1
-  },
-  {
-    "cbor": "KQ==",
-    "hex": "29",
-    "roundtrip": true,
-    "decoded": -10
-  },
-  {
-    "cbor": "OGM=",
-    "hex": "3863",
-    "roundtrip": true,
-    "decoded": -100
-  },
-  {
-    "cbor": "OQPn",
-    "hex": "3903e7",
-    "roundtrip": true,
-    "decoded": -1000
-  },
-  {
-    "cbor": "+QAA",
-    "hex": "f90000",
-    "roundtrip": true,
-    "decoded": 0.0
-  },
-  {
-    "cbor": "+YAA",
-    "hex": "f98000",
-    "roundtrip": true,
-    "decoded": -0.0
-  },
-  {
-    "cbor": "+TwA",
-    "hex": "f93c00",
-    "roundtrip": true,
-    "decoded": 1.0
-  },
-  {
-    "cbor": "+z/xmZmZmZma",
-    "hex": "fb3ff199999999999a",
-    "roundtrip": true,
-    "decoded": 1.1
-  },
-  {
-    "cbor": "+T4A",
-    "hex": "f93e00",
-    "roundtrip": true,
-    "decoded": 1.5
-  },
-  {
-    "cbor": "+Xv/",
-    "hex": "f97bff",
-    "roundtrip": true,
-    "decoded": 65504.0
-  },
-  {
-    "cbor": "+kfDUAA=",
-    "hex": "fa47c35000",
-    "roundtrip": true,
-    "decoded": 100000.0
-  },
-  {
-    "cbor": "+n9///8=",
-    "hex": "fa7f7fffff",
-    "roundtrip": true,
-    "decoded": 3.4028234663852886e+38
-  },
-  {
-    "cbor": "+3435DyIAHWc",
-    "hex": "fb7e37e43c8800759c",
-    "roundtrip": true,
-    "decoded": 1.0e+300
-  },
-  {
-    "cbor": "+QAB",
-    "hex": "f90001",
-    "roundtrip": true,
-    "decoded": 5.960464477539063e-08
-  },
-  {
-    "cbor": "+QQA",
-    "hex": "f90400",
-    "roundtrip": true,
-    "decoded": 6.103515625e-05
-  },
-  {
-    "cbor": "+cQA",
-    "hex": "f9c400",
-    "roundtrip": true,
-    "decoded": -4.0
-  },
-  {
-    "cbor": "+8AQZmZmZmZm",
-    "hex": "fbc010666666666666",
-    "roundtrip": true,
-    "decoded": -4.1
-  },
-  {
-    "cbor": "+XwA",
-    "hex": "f97c00",
-    "roundtrip": true,
-    "diagnostic": "Infinity"
-  },
-  {
-    "cbor": "+X4A",
-    "hex": "f97e00",
-    "roundtrip": true,
-    "diagnostic": "NaN"
-  },
-  {
-    "cbor": "+fwA",
-    "hex": "f9fc00",
-    "roundtrip": true,
-    "diagnostic": "-Infinity"
-  },
-  {
-    "cbor": "+n+AAAA=",
-    "hex": "fa7f800000",
-    "roundtrip": false,
-    "diagnostic": "Infinity"
-  },
-  {
-    "cbor": "+n/AAAA=",
-    "hex": "fa7fc00000",
-    "roundtrip": false,
-    "diagnostic": "NaN"
-  },
-  {
-    "cbor": "+v+AAAA=",
-    "hex": "faff800000",
-    "roundtrip": false,
-    "diagnostic": "-Infinity"
-  },
-  {
-    "cbor": "+3/wAAAAAAAA",
-    "hex": "fb7ff0000000000000",
-    "roundtrip": false,
-    "diagnostic": "Infinity"
-  },
-  {
-    "cbor": "+3/4AAAAAAAA",
-    "hex": "fb7ff8000000000000",
-    "roundtrip": false,
-    "diagnostic": "NaN"
-  },
-  {
-    "cbor": "+//wAAAAAAAA",
-    "hex": "fbfff0000000000000",
-    "roundtrip": false,
-    "diagnostic": "-Infinity"
-  },
-  {
-    "cbor": "9A==",
-    "hex": "f4",
-    "roundtrip": true,
-    "decoded": false
-  },
-  {
-    "cbor": "9Q==",
-    "hex": "f5",
-    "roundtrip": true,
-    "decoded": true
-  },
-  {
-    "cbor": "9g==",
-    "hex": "f6",
-    "roundtrip": true,
-    "decoded": null
-  },
-  {
-    "cbor": "9w==",
-    "hex": "f7",
-    "roundtrip": true,
-    "diagnostic": "undefined"
-  },
-  {
-    "cbor": "8A==",
-    "hex": "f0",
-    "roundtrip": true,
-    "diagnostic": "simple(16)"
-  },
-  {
-    "cbor": "+Bg=",
-    "hex": "f818",
-    "roundtrip": true,
-    "diagnostic": "simple(24)"
-  },
-  {
-    "cbor": "+P8=",
-    "hex": "f8ff",
-    "roundtrip": true,
-    "diagnostic": "simple(255)"
-  },
-  {
-    "cbor": "wHQyMDEzLTAzLTIxVDIwOjA0OjAwWg==",
-    "hex": "c074323031332d30332d32315432303a30343a30305a",
-    "roundtrip": true,
-    "diagnostic": "0(\"2013-03-21T20:04:00Z\")"
-  },
-  {
-    "cbor": "wRpRS2ew",
-    "hex": "c11a514b67b0",
-    "roundtrip": true,
-    "diagnostic": "1(1363896240)"
-  },
-  {
-    "cbor": "wftB1FLZ7CAAAA==",
-    "hex": "c1fb41d452d9ec200000",
-    "roundtrip": true,
-    "diagnostic": "1(1363896240.5)"
-  },
-  {
-    "cbor": "10QBAgME",
-    "hex": "d74401020304",
-    "roundtrip": true,
-    "diagnostic": "23(h'01020304')"
-  },
-  {
-    "cbor": "2BhFZElFVEY=",
-    "hex": "d818456449455446",
-    "roundtrip": true,
-    "diagnostic": "24(h'6449455446')"
-  },
-  {
-    "cbor": "2CB2aHR0cDovL3d3dy5leGFtcGxlLmNvbQ==",
-    "hex": "d82076687474703a2f2f7777772e6578616d706c652e636f6d",
-    "roundtrip": true,
-    "diagnostic": "32(\"http://www.example.com\")"
-  },
-  {
-    "cbor": "QA==",
-    "hex": "40",
-    "roundtrip": true,
-    "diagnostic": "h''"
-  },
-  {
-    "cbor": "RAECAwQ=",
-    "hex": "4401020304",
-    "roundtrip": true,
-    "diagnostic": "h'01020304'"
-  },
-  {
-    "cbor": "YA==",
-    "hex": "60",
-    "roundtrip": true,
-    "decoded": ""
-  },
-  {
-    "cbor": "YWE=",
-    "hex": "6161",
-    "roundtrip": true,
-    "decoded": "a"
-  },
-  {
-    "cbor": "ZElFVEY=",
-    "hex": "6449455446",
-    "roundtrip": true,
-    "decoded": "IETF"
-  },
-  {
-    "cbor": "YiJc",
-    "hex": "62225c",
-    "roundtrip": true,
-    "decoded": "\"\\"
-  },
-  {
-    "cbor": "YsO8",
-    "hex": "62c3bc",
-    "roundtrip": true,
-    "decoded": "ü"
-  },
-  {
-    "cbor": "Y+awtA==",
-    "hex": "63e6b0b4",
-    "roundtrip": true,
-    "decoded": "水"
-  },
-  {
-    "cbor": "ZPCQhZE=",
-    "hex": "64f0908591",
-    "roundtrip": true,
-    "decoded": "𐅑"
-  },
-  {
-    "cbor": "gA==",
-    "hex": "80",
-    "roundtrip": true,
-    "decoded": [
-
-    ]
-  },
-  {
-    "cbor": "gwECAw==",
-    "hex": "83010203",
-    "roundtrip": true,
-    "decoded": [
-      1,
-      2,
-      3
-    ]
-  },
-  {
-    "cbor": "gwGCAgOCBAU=",
-    "hex": "8301820203820405",
-    "roundtrip": true,
-    "decoded": [
-      1,
-      [
-        2,
-        3
-      ],
-      [
-        4,
-        5
-      ]
-    ]
-  },
-  {
-    "cbor": "mBkBAgMEBQYHCAkKCwwNDg8QERITFBUWFxgYGBk=",
-    "hex": "98190102030405060708090a0b0c0d0e0f101112131415161718181819",
-    "roundtrip": true,
-    "decoded": [
-      1,
-      2,
-      3,
-      4,
-      5,
-      6,
-      7,
-      8,
-      9,
-      10,
-      11,
-      12,
-      13,
-      14,
-      15,
-      16,
-      17,
-      18,
-      19,
-      20,
-      21,
-      22,
-      23,
-      24,
-      25
-    ]
-  },
-  {
-    "cbor": "oA==",
-    "hex": "a0",
-    "roundtrip": true,
-    "decoded": {
-    }
-  },
-  {
-    "cbor": "ogECAwQ=",
-    "hex": "a201020304",
-    "roundtrip": true,
-    "skip": true,
-    "diagnostic": "{1: 2, 3: 4}"
-  },
-  {
-    "cbor": "omFhAWFiggID",
-    "hex": "a26161016162820203",
-    "roundtrip": true,
-    "decoded": {
-      "a": 1,
-      "b": [
-        2,
-        3
-      ]
-    }
-  },
-  {
-    "cbor": "gmFhoWFiYWM=",
-    "hex": "826161a161626163",
-    "roundtrip": true,
-    "decoded": [
-      "a",
-      {
-        "b": "c"
-      }
-    ]
-  },
-  {
-    "cbor": "pWFhYUFhYmFCYWNhQ2FkYURhZWFF",
-    "hex": "a56161614161626142616361436164614461656145",
-    "roundtrip": true,
-    "decoded": {
-      "a": "A",
-      "b": "B",
-      "c": "C",
-      "d": "D",
-      "e": "E"
-    }
-  },
-  {
-    "cbor": "X0IBAkMDBAX/",
-    "hex": "5f42010243030405ff",
-    "roundtrip": false,
-    "skip": true,
-    "diagnostic": "(_ h'0102', h'030405')"
-  },
-  {
-    "cbor": "f2VzdHJlYWRtaW5n/w==",
-    "hex": "7f657374726561646d696e67ff",
-    "roundtrip": false,
-    "decoded": "streaming"
-  },
-  {
-    "cbor": "n/8=",
-    "hex": "9fff",
-    "roundtrip": false,
-    "decoded": [
-
-    ]
-  },
-  {
-    "cbor": "nwGCAgOfBAX//w==",
-    "hex": "9f018202039f0405ffff",
-    "roundtrip": false,
-    "decoded": [
-      1,
-      [
-        2,
-        3
-      ],
-      [
-        4,
-        5
-      ]
-    ]
-  },
-  {
-    "cbor": "nwGCAgOCBAX/",
-    "hex": "9f01820203820405ff",
-    "roundtrip": false,
-    "decoded": [
-      1,
-      [
-        2,
-        3
-      ],
-      [
-        4,
-        5
-      ]
-    ]
-  },
-  {
-    "cbor": "gwGCAgOfBAX/",
-    "hex": "83018202039f0405ff",
-    "roundtrip": false,
-    "decoded": [
-      1,
-      [
-        2,
-        3
-      ],
-      [
-        4,
-        5
-      ]
-    ]
-  },
-  {
-    "cbor": "gwGfAgP/ggQF",
-    "hex": "83019f0203ff820405",
-    "roundtrip": false,
-    "decoded": [
-      1,
-      [
-        2,
-        3
-      ],
-      [
-        4,
-        5
-      ]
-    ]
-  },
-  {
-    "cbor": "nwECAwQFBgcICQoLDA0ODxAREhMUFRYXGBgYGf8=",
-    "hex": "9f0102030405060708090a0b0c0d0e0f101112131415161718181819ff",
-    "roundtrip": false,
-    "decoded": [
-      1,
-      2,
-      3,
-      4,
-      5,
-      6,
-      7,
-      8,
-      9,
-      10,
-      11,
-      12,
-      13,
-      14,
-      15,
-      16,
-      17,
-      18,
-      19,
-      20,
-      21,
-      22,
-      23,
-      24,
-      25
-    ]
-  },
-  {
-    "cbor": "v2FhAWFinwID//8=",
-    "hex": "bf61610161629f0203ffff",
-    "roundtrip": false,
-    "decoded": {
-      "a": 1,
-      "b": [
-        2,
-        3
-      ]
-    }
-  },
-  {
-    "cbor": "gmFhv2FiYWP/",
-    "hex": "826161bf61626163ff",
-    "roundtrip": false,
-    "decoded": [
-      "a",
-      {
-        "b": "c"
-      }
-    ]
-  },
-  {
-    "cbor": "v2NGdW71Y0FtdCH/",
-    "hex": "bf6346756ef563416d7421ff",
-    "roundtrip": false,
-    "decoded": {
-      "Fun": true,
-      "Amt": -2
-    }
-  }
-]
diff --git a/cmd/vendor/github.com/ugorji/go/codec/test.py b/cmd/vendor/github.com/ugorji/go/codec/test.py
deleted file mode 100755
index dfe3b0c..0000000
--- a/cmd/vendor/github.com/ugorji/go/codec/test.py
+++ /dev/null
@@ -1,120 +0,0 @@
-#!/usr/bin/env python
-
-# This will create golden files in a directory passed to it.
-# A Test calls this internally to create the golden files
-# So it can process them (so we don't have to checkin the files).
-
-# Ensure msgpack-python and cbor are installed first, using:
-#   sudo apt-get install python-dev
-#   sudo apt-get install python-pip
-#   pip install --user msgpack-python msgpack-rpc-python cbor
-
-import cbor, msgpack, msgpackrpc, sys, os, threading
-
-def get_test_data_list():
-    # get list with all primitive types, and a combo type
-    l0 = [ 
-        -8,
-         -1616,
-         -32323232,
-         -6464646464646464,
-         192,
-         1616,
-         32323232,
-         6464646464646464,
-         192,
-         -3232.0,
-         -6464646464.0,
-         3232.0,
-         6464646464.0,
-         False,
-         True,
-         None,
-         u"someday",
-         u"",
-         u"bytestring",
-         1328176922000002000,
-         -2206187877999998000,
-         270,
-        -2013855847999995777,
-         #-6795364578871345152,
-         ]
-    l1 = [
-        { "true": True,
-          "false": False },
-        { "true": "True",
-          "false": False,
-          "uint16(1616)": 1616 },
-        { "list": [1616, 32323232, True, -3232.0, {"TRUE":True, "FALSE":False}, [True, False] ],
-          "int32":32323232, "bool": True, 
-          "LONG STRING": "123456789012345678901234567890123456789012345678901234567890",
-          "SHORT STRING": "1234567890" },	
-        { True: "true", 8: False, "false": 0 }
-        ]
-    
-    l = []
-    l.extend(l0)
-    l.append(l0)
-    l.extend(l1)
-    return l
-
-def build_test_data(destdir):
-    l = get_test_data_list()
-    for i in range(len(l)):
-        # packer = msgpack.Packer()
-        serialized = msgpack.dumps(l[i])
-        f = open(os.path.join(destdir, str(i) + '.msgpack.golden'), 'wb')
-        f.write(serialized)
-        f.close()
-        serialized = cbor.dumps(l[i])
-        f = open(os.path.join(destdir, str(i) + '.cbor.golden'), 'wb')
-        f.write(serialized)
-        f.close()
-
-def doRpcServer(port, stopTimeSec):
-    class EchoHandler(object):
-        def Echo123(self, msg1, msg2, msg3):
-            return ("1:%s 2:%s 3:%s" % (msg1, msg2, msg3))
-        def EchoStruct(self, msg):
-            return ("%s" % msg)
-    
-    addr = msgpackrpc.Address('localhost', port)
-    server = msgpackrpc.Server(EchoHandler())
-    server.listen(addr)
-    # run thread to stop it after stopTimeSec seconds if > 0
-    if stopTimeSec > 0:
-        def myStopRpcServer():
-            server.stop()
-        t = threading.Timer(stopTimeSec, myStopRpcServer)
-        t.start()
-    server.start()
-
-def doRpcClientToPythonSvc(port):
-    address = msgpackrpc.Address('localhost', port)
-    client = msgpackrpc.Client(address, unpack_encoding='utf-8')
-    print client.call("Echo123", "A1", "B2", "C3")
-    print client.call("EchoStruct", {"A" :"Aa", "B":"Bb", "C":"Cc"})
-   
-def doRpcClientToGoSvc(port):
-    # print ">>>> port: ", port, " <<<<<"
-    address = msgpackrpc.Address('localhost', port)
-    client = msgpackrpc.Client(address, unpack_encoding='utf-8')
-    print client.call("TestRpcInt.Echo123", ["A1", "B2", "C3"])
-    print client.call("TestRpcInt.EchoStruct", {"A" :"Aa", "B":"Bb", "C":"Cc"})
-
-def doMain(args):
-    if len(args) == 2 and args[0] == "testdata":
-        build_test_data(args[1])
-    elif len(args) == 3 and args[0] == "rpc-server":
-        doRpcServer(int(args[1]), int(args[2]))
-    elif len(args) == 2 and args[0] == "rpc-client-python-service":
-        doRpcClientToPythonSvc(int(args[1]))
-    elif len(args) == 2 and args[0] == "rpc-client-go-service":
-        doRpcClientToGoSvc(int(args[1]))
-    else:
-        print("Usage: test.py " + 
-              "[testdata|rpc-server|rpc-client-python-service|rpc-client-go-service] ...")
-    
-if __name__ == "__main__":
-    doMain(sys.argv[1:])
-
diff --git a/cmd/vendor/github.com/ugorji/go/codec/tests.sh b/cmd/vendor/github.com/ugorji/go/codec/tests.sh
deleted file mode 100755
index b1602ea..0000000
--- a/cmd/vendor/github.com/ugorji/go/codec/tests.sh
+++ /dev/null
@@ -1,74 +0,0 @@
-#!/bin/bash
-
-# Run all the different permutations of all the tests.
-# This helps ensure that nothing gets broken.
-
-_run() {
-    # 1. VARIATIONS: regular (t), canonical (c), IO R/W (i),
-    #                binc-nosymbols (n), struct2array (s), intern string (e),
-    # 2. MODE: reflection (r), external (x), codecgen (g), unsafe (u), notfastpath (f)
-    # 3. OPTIONS: verbose (v), reset (z), must (m),
-    # 
-    # Use combinations of mode to get exactly what you want,
-    # and then pass the variations you need.
-
-    ztags=""
-    zargs=""
-    local OPTIND 
-    OPTIND=1
-    while getopts "xurtcinsvgzmef" flag
-    do
-        case "x$flag" in 
-            'xr')  ;;
-            'xf') ztags="$ztags notfastpath" ;;
-            'xg') ztags="$ztags codecgen" ;;
-            'xx') ztags="$ztags x" ;;
-            'xu') ztags="$ztags unsafe" ;;
-            'xv') zargs="$zargs -tv" ;;
-            'xz') zargs="$zargs -tr" ;;
-            'xm') zargs="$zargs -tm" ;;
-            *) ;;
-        esac
-    done
-    # shift $((OPTIND-1))
-    printf '............. TAGS: %s .............\n' "$ztags"
-    # echo ">>>>>>> TAGS: $ztags"
-    
-    OPTIND=1
-    while getopts "xurtcinsvgzmef" flag
-    do
-        case "x$flag" in 
-            'xt') printf ">>>>>>> REGULAR    : "; go test "-tags=$ztags" $zargs ; sleep 2 ;;
-            'xc') printf ">>>>>>> CANONICAL  : "; go test "-tags=$ztags" $zargs -tc; sleep 2 ;;
-            'xi') printf ">>>>>>> I/O        : "; go test "-tags=$ztags" $zargs -ti; sleep 2 ;;
-            'xn') printf ">>>>>>> NO_SYMBOLS : "; go test "-tags=$ztags" $zargs -tn; sleep 2 ;;
-            'xs') printf ">>>>>>> TO_ARRAY   : "; go test "-tags=$ztags" $zargs -ts; sleep 2 ;;
-            'xe') printf ">>>>>>> INTERN     : "; go test "-tags=$ztags" $zargs -te; sleep 2 ;;
-            *) ;;
-        esac
-    done
-    shift $((OPTIND-1))
-
-    OPTIND=1
-}
-
-# echo ">>>>>>> RUNNING VARIATIONS OF TESTS"    
-if [[ "x$@" = "x" ]]; then
-    # All: r, x, g, gu
-    _run "-rtcinsm"  # regular
-    _run "-rtcinsmz" # regular with reset
-    _run "-rtcinsmf" # regular with no fastpath (notfastpath)
-    _run "-xtcinsm" # external
-    _run "-gxtcinsm" # codecgen: requires external
-    _run "-gxutcinsm" # codecgen + unsafe
-elif [[ "x$@" = "x-Z" ]]; then
-    # Regular
-    _run "-rtcinsm"  # regular
-    _run "-rtcinsmz" # regular with reset
-elif [[ "x$@" = "x-F" ]]; then
-    # regular with notfastpath
-    _run "-rtcinsmf"  # regular
-    _run "-rtcinsmzf" # regular with reset
-else
-    _run "$@"
-fi
diff --git a/cmd/vendor/github.com/urfave/cli/.gitignore b/cmd/vendor/github.com/urfave/cli/.gitignore
deleted file mode 100644
index faf70c4..0000000
--- a/cmd/vendor/github.com/urfave/cli/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-*.coverprofile
-node_modules/
diff --git a/cmd/vendor/github.com/urfave/cli/.travis.yml b/cmd/vendor/github.com/urfave/cli/.travis.yml
deleted file mode 100644
index 273d017..0000000
--- a/cmd/vendor/github.com/urfave/cli/.travis.yml
+++ /dev/null
@@ -1,40 +0,0 @@
-language: go
-
-sudo: false
-
-cache:
-  directories:
-  - node_modules
-
-go:
-- 1.2.2
-- 1.3.3
-- 1.4
-- 1.5.4
-- 1.6.2
-- master
-
-matrix:
-  allow_failures:
-  - go: master
-  include:
-  - go: 1.6.2
-    os: osx
-  - go: 1.1.2
-    install: go get -v .
-    before_script: echo skipping gfmxr on $TRAVIS_GO_VERSION
-    script:
-    - ./runtests vet
-    - ./runtests test
-
-before_script:
-- go get github.com/urfave/gfmxr/...
-- if [ ! -f node_modules/.bin/markdown-toc ] ; then
-    npm install markdown-toc ;
-  fi
-
-script:
-- ./runtests vet
-- ./runtests test
-- ./runtests gfmxr
-- ./runtests toc
diff --git a/cmd/vendor/github.com/urfave/cli/CHANGELOG.md b/cmd/vendor/github.com/urfave/cli/CHANGELOG.md
deleted file mode 100644
index d975be7..0000000
--- a/cmd/vendor/github.com/urfave/cli/CHANGELOG.md
+++ /dev/null
@@ -1,323 +0,0 @@
-# Change Log
-
-**ATTN**: This project uses [semantic versioning](http://semver.org/).
-
-## [Unreleased]
-### Added
-- `./runtests` test runner with coverage tracking by default
-- testing on OS X
-- testing on Windows
-- `UintFlag`, `Uint64Flag`, and `Int64Flag` types and supporting code
-
-### Changed
-- Use spaces for alignment in help/usage output instead of tabs, making the
-  output alignment consistent regardless of tab width
-
-### Fixed
-- Printing of command aliases in help text
-- Printing of visible flags for both struct and struct pointer flags
-
-## [1.17.0] - 2016-05-09
-### Added
-- Pluggable flag-level help text rendering via `cli.DefaultFlagStringFunc`
-- `context.GlobalBoolT` was added as an analogue to `context.GlobalBool`
-- Support for hiding commands by setting `Hidden: true` -- this will hide the
-  commands in help output
-
-### Changed
-- `Float64Flag`, `IntFlag`, and `DurationFlag` default values are no longer
-  quoted in help text output.
-- All flag types now include `(default: {value})` strings following usage when a
-  default value can be (reasonably) detected.
-- `IntSliceFlag` and `StringSliceFlag` usage strings are now more consistent
-  with non-slice flag types
-- Apps now exit with a code of 3 if an unknown subcommand is specified
-  (previously they printed "No help topic for...", but still exited 0. This
-  makes it easier to script around apps built using `cli` since they can trust
-  that a 0 exit code indicated a successful execution.
-- cleanups based on [Go Report Card
-  feedback](https://goreportcard.com/report/github.com/urfave/cli)
-
-## [1.16.0] - 2016-05-02
-### Added
-- `Hidden` field on all flag struct types to omit from generated help text
-
-### Changed
-- `BashCompletionFlag` (`--enable-bash-completion`) is now omitted from
-generated help text via the `Hidden` field
-
-### Fixed
-- handling of error values in `HandleAction` and `HandleExitCoder`
-
-## [1.15.0] - 2016-04-30
-### Added
-- This file!
-- Support for placeholders in flag usage strings
-- `App.Metadata` map for arbitrary data/state management
-- `Set` and `GlobalSet` methods on `*cli.Context` for altering values after
-parsing.
-- Support for nested lookup of dot-delimited keys in structures loaded from
-YAML.
-
-### Changed
-- The `App.Action` and `Command.Action` now prefer a return signature of
-`func(*cli.Context) error`, as defined by `cli.ActionFunc`.  If a non-nil
-`error` is returned, there may be two outcomes:
-    - If the error fulfills `cli.ExitCoder`, then `os.Exit` will be called
-    automatically
-    - Else the error is bubbled up and returned from `App.Run`
-- Specifying an `Action` with the legacy return signature of
-`func(*cli.Context)` will produce a deprecation message to stderr
-- Specifying an `Action` that is not a `func` type will produce a non-zero exit
-from `App.Run`
-- Specifying an `Action` func that has an invalid (input) signature will
-produce a non-zero exit from `App.Run`
-
-### Deprecated
-- <a name="deprecated-cli-app-runandexitonerror"></a>
-`cli.App.RunAndExitOnError`, which should now be done by returning an error
-that fulfills `cli.ExitCoder` to `cli.App.Run`.
-- <a name="deprecated-cli-app-action-signature"></a> the legacy signature for
-`cli.App.Action` of `func(*cli.Context)`, which should now have a return
-signature of `func(*cli.Context) error`, as defined by `cli.ActionFunc`.
-
-### Fixed
-- Added missing `*cli.Context.GlobalFloat64` method
-
-## [1.14.0] - 2016-04-03 (backfilled 2016-04-25)
-### Added
-- Codebeat badge
-- Support for categorization via `CategorizedHelp` and `Categories` on app.
-
-### Changed
-- Use `filepath.Base` instead of `path.Base` in `Name` and `HelpName`.
-
-### Fixed
-- Ensure version is not shown in help text when `HideVersion` set.
-
-## [1.13.0] - 2016-03-06 (backfilled 2016-04-25)
-### Added
-- YAML file input support.
-- `NArg` method on context.
-
-## [1.12.0] - 2016-02-17 (backfilled 2016-04-25)
-### Added
-- Custom usage error handling.
-- Custom text support in `USAGE` section of help output.
-- Improved help messages for empty strings.
-- AppVeyor CI configuration.
-
-### Changed
-- Removed `panic` from default help printer func.
-- De-duping and optimizations.
-
-### Fixed
-- Correctly handle `Before`/`After` at command level when no subcommands.
-- Case of literal `-` argument causing flag reordering.
-- Environment variable hints on Windows.
-- Docs updates.
-
-## [1.11.1] - 2015-12-21 (backfilled 2016-04-25)
-### Changed
-- Use `path.Base` in `Name` and `HelpName`
-- Export `GetName` on flag types.
-
-### Fixed
-- Flag parsing when skipping is enabled.
-- Test output cleanup.
-- Move completion check to account for empty input case.
-
-## [1.11.0] - 2015-11-15 (backfilled 2016-04-25)
-### Added
-- Destination scan support for flags.
-- Testing against `tip` in Travis CI config.
-
-### Changed
-- Go version in Travis CI config.
-
-### Fixed
-- Removed redundant tests.
-- Use correct example naming in tests.
-
-## [1.10.2] - 2015-10-29 (backfilled 2016-04-25)
-### Fixed
-- Remove unused var in bash completion.
-
-## [1.10.1] - 2015-10-21 (backfilled 2016-04-25)
-### Added
-- Coverage and reference logos in README.
-
-### Fixed
-- Use specified values in help and version parsing.
-- Only display app version and help message once.
-
-## [1.10.0] - 2015-10-06 (backfilled 2016-04-25)
-### Added
-- More tests for existing functionality.
-- `ArgsUsage` at app and command level for help text flexibility.
-
-### Fixed
-- Honor `HideHelp` and `HideVersion` in `App.Run`.
-- Remove juvenile word from README.
-
-## [1.9.0] - 2015-09-08 (backfilled 2016-04-25)
-### Added
-- `FullName` on command with accompanying help output update.
-- Set default `$PROG` in bash completion.
-
-### Changed
-- Docs formatting.
-
-### Fixed
-- Removed self-referential imports in tests.
-
-## [1.8.0] - 2015-06-30 (backfilled 2016-04-25)
-### Added
-- Support for `Copyright` at app level.
-- `Parent` func at context level to walk up context lineage.
-
-### Fixed
-- Global flag processing at top level.
-
-## [1.7.1] - 2015-06-11 (backfilled 2016-04-25)
-### Added
-- Aggregate errors from `Before`/`After` funcs.
-- Doc comments on flag structs.
-- Include non-global flags when checking version and help.
-- Travis CI config updates.
-
-### Fixed
-- Ensure slice type flags have non-nil values.
-- Collect global flags from the full command hierarchy.
-- Docs prose.
-
-## [1.7.0] - 2015-05-03 (backfilled 2016-04-25)
-### Changed
-- `HelpPrinter` signature includes output writer.
-
-### Fixed
-- Specify go 1.1+ in docs.
-- Set `Writer` when running command as app.
-
-## [1.6.0] - 2015-03-23 (backfilled 2016-04-25)
-### Added
-- Multiple author support.
-- `NumFlags` at context level.
-- `Aliases` at command level.
-
-### Deprecated
-- `ShortName` at command level.
-
-### Fixed
-- Subcommand help output.
-- Backward compatible support for deprecated `Author` and `Email` fields.
-- Docs regarding `Names`/`Aliases`.
-
-## [1.5.0] - 2015-02-20 (backfilled 2016-04-25)
-### Added
-- `After` hook func support at app and command level.
-
-### Fixed
-- Use parsed context when running command as subcommand.
-- Docs prose.
-
-## [1.4.1] - 2015-01-09 (backfilled 2016-04-25)
-### Added
-- Support for hiding `-h / --help` flags, but not `help` subcommand.
-- Stop flag parsing after `--`.
-
-### Fixed
-- Help text for generic flags to specify single value.
-- Use double quotes in output for defaults.
-- Use `ParseInt` instead of `ParseUint` for int environment var values.
-- Use `0` as base when parsing int environment var values.
-
-## [1.4.0] - 2014-12-12 (backfilled 2016-04-25)
-### Added
-- Support for environment variable lookup "cascade".
-- Support for `Stdout` on app for output redirection.
-
-### Fixed
-- Print command help instead of app help in `ShowCommandHelp`.
-
-## [1.3.1] - 2014-11-13 (backfilled 2016-04-25)
-### Added
-- Docs and example code updates.
-
-### Changed
-- Default `-v / --version` flag made optional.
-
-## [1.3.0] - 2014-08-10 (backfilled 2016-04-25)
-### Added
-- `FlagNames` at context level.
-- Exposed `VersionPrinter` var for more control over version output.
-- Zsh completion hook.
-- `AUTHOR` section in default app help template.
-- Contribution guidelines.
-- `DurationFlag` type.
-
-## [1.2.0] - 2014-08-02
-### Added
-- Support for environment variable defaults on flags plus tests.
-
-## [1.1.0] - 2014-07-15
-### Added
-- Bash completion.
-- Optional hiding of built-in help command.
-- Optional skipping of flag parsing at command level.
-- `Author`, `Email`, and `Compiled` metadata on app.
-- `Before` hook func support at app and command level.
-- `CommandNotFound` func support at app level.
-- Command reference available on context.
-- `GenericFlag` type.
-- `Float64Flag` type.
-- `BoolTFlag` type.
-- `IsSet` flag helper on context.
-- More flag lookup funcs at context level.
-- More tests &amp; docs.
-
-### Changed
-- Help template updates to account for presence/absence of flags.
-- Separated subcommand help template.
-- Exposed `HelpPrinter` var for more control over help output.
-
-## [1.0.0] - 2013-11-01
-### Added
-- `help` flag in default app flag set and each command flag set.
-- Custom handling of argument parsing errors.
-- Command lookup by name at app level.
-- `StringSliceFlag` type and supporting `StringSlice` type.
-- `IntSliceFlag` type and supporting `IntSlice` type.
-- Slice type flag lookups by name at context level.
-- Export of app and command help functions.
-- More tests &amp; docs.
-
-## 0.1.0 - 2013-07-22
-### Added
-- Initial implementation.
-
-[Unreleased]: https://github.com/urfave/cli/compare/v1.17.0...HEAD
-[1.17.0]: https://github.com/urfave/cli/compare/v1.16.0...v1.17.0
-[1.16.0]: https://github.com/urfave/cli/compare/v1.15.0...v1.16.0
-[1.15.0]: https://github.com/urfave/cli/compare/v1.14.0...v1.15.0
-[1.14.0]: https://github.com/urfave/cli/compare/v1.13.0...v1.14.0
-[1.13.0]: https://github.com/urfave/cli/compare/v1.12.0...v1.13.0
-[1.12.0]: https://github.com/urfave/cli/compare/v1.11.1...v1.12.0
-[1.11.1]: https://github.com/urfave/cli/compare/v1.11.0...v1.11.1
-[1.11.0]: https://github.com/urfave/cli/compare/v1.10.2...v1.11.0
-[1.10.2]: https://github.com/urfave/cli/compare/v1.10.1...v1.10.2
-[1.10.1]: https://github.com/urfave/cli/compare/v1.10.0...v1.10.1
-[1.10.0]: https://github.com/urfave/cli/compare/v1.9.0...v1.10.0
-[1.9.0]: https://github.com/urfave/cli/compare/v1.8.0...v1.9.0
-[1.8.0]: https://github.com/urfave/cli/compare/v1.7.1...v1.8.0
-[1.7.1]: https://github.com/urfave/cli/compare/v1.7.0...v1.7.1
-[1.7.0]: https://github.com/urfave/cli/compare/v1.6.0...v1.7.0
-[1.6.0]: https://github.com/urfave/cli/compare/v1.5.0...v1.6.0
-[1.5.0]: https://github.com/urfave/cli/compare/v1.4.1...v1.5.0
-[1.4.1]: https://github.com/urfave/cli/compare/v1.4.0...v1.4.1
-[1.4.0]: https://github.com/urfave/cli/compare/v1.3.1...v1.4.0
-[1.3.1]: https://github.com/urfave/cli/compare/v1.3.0...v1.3.1
-[1.3.0]: https://github.com/urfave/cli/compare/v1.2.0...v1.3.0
-[1.2.0]: https://github.com/urfave/cli/compare/v1.1.0...v1.2.0
-[1.1.0]: https://github.com/urfave/cli/compare/v1.0.0...v1.1.0
-[1.0.0]: https://github.com/urfave/cli/compare/v0.1.0...v1.0.0
diff --git a/cmd/vendor/github.com/urfave/cli/README.md b/cmd/vendor/github.com/urfave/cli/README.md
deleted file mode 100644
index ebb1d74..0000000
--- a/cmd/vendor/github.com/urfave/cli/README.md
+++ /dev/null
@@ -1,1309 +0,0 @@
-cli
-===
-
-[![Build Status](https://travis-ci.org/urfave/cli.svg?branch=master)](https://travis-ci.org/urfave/cli)
-[![Windows Build Status](https://ci.appveyor.com/api/projects/status/rtgk5xufi932pb2v?svg=true)](https://ci.appveyor.com/project/urfave/cli)
-[![GoDoc](https://godoc.org/github.com/urfave/cli?status.svg)](https://godoc.org/github.com/urfave/cli)
-[![codebeat](https://codebeat.co/badges/0a8f30aa-f975-404b-b878-5fab3ae1cc5f)](https://codebeat.co/projects/github-com-urfave-cli)
-[![Go Report Card](https://goreportcard.com/badge/urfave/cli)](https://goreportcard.com/report/urfave/cli)
-[![top level coverage](https://gocover.io/_badge/github.com/urfave/cli?0 "top level coverage")](http://gocover.io/github.com/urfave/cli) /
-[![altsrc coverage](https://gocover.io/_badge/github.com/urfave/cli/altsrc?0 "altsrc coverage")](http://gocover.io/github.com/urfave/cli/altsrc)
-
-**Notice:** This is the library formerly known as
-`github.com/codegangsta/cli` -- Github will automatically redirect requests
-to this repository, but we recommend updating your references for clarity.
-
-cli is a simple, fast, and fun package for building command line apps in Go. The
-goal is to enable developers to write fast and distributable command line
-applications in an expressive way.
-
-<!-- toc -->
-
-- [Overview](#overview)
-- [Installation](#installation)
-  * [Supported platforms](#supported-platforms)
-  * [Using the `v2` branch](#using-the-v2-branch)
-  * [Pinning to the `v1` branch](#pinning-to-the-v1-branch)
-- [Getting Started](#getting-started)
-- [Examples](#examples)
-  * [Arguments](#arguments)
-  * [Flags](#flags)
-    + [Placeholder Values](#placeholder-values)
-    + [Alternate Names](#alternate-names)
-    + [Values from the Environment](#values-from-the-environment)
-    + [Values from alternate input sources (YAML and others)](#values-from-alternate-input-sources-yaml-and-others)
-  * [Subcommands](#subcommands)
-  * [Subcommands categories](#subcommands-categories)
-  * [Exit code](#exit-code)
-  * [Bash Completion](#bash-completion)
-    + [Enabling](#enabling)
-    + [Distribution](#distribution)
-    + [Customization](#customization)
-  * [Generated Help Text](#generated-help-text)
-    + [Customization](#customization-1)
-  * [Version Flag](#version-flag)
-    + [Customization](#customization-2)
-    + [Full API Example](#full-api-example)
-- [Contribution Guidelines](#contribution-guidelines)
-
-<!-- tocstop -->
-
-## Overview
-
-Command line apps are usually so tiny that there is absolutely no reason why
-your code should *not* be self-documenting. Things like generating help text and
-parsing command flags/options should not hinder productivity when writing a
-command line app.
-
-**This is where cli comes into play.** cli makes command line programming fun,
-organized, and expressive!
-
-## Installation
-
-Make sure you have a working Go environment.  Go version 1.1+ is required for
-core cli, whereas use of the [`./altsrc`](./altsrc) input extensions requires Go
-version 1.2+. [See the install
-instructions](http://golang.org/doc/install.html).
-
-To install cli, simply run:
-```
-$ go get github.com/urfave/cli
-```
-
-Make sure your `PATH` includes to the `$GOPATH/bin` directory so your commands
-can be easily used:
-```
-export PATH=$PATH:$GOPATH/bin
-```
-
-### Supported platforms
-
-cli is tested against multiple versions of Go on Linux, and against the latest
-released version of Go on OS X and Windows.  For full details, see
-[`./.travis.yml`](./.travis.yml) and [`./appveyor.yml`](./appveyor.yml).
-
-### Using the `v2` branch
-
-**Warning**: The `v2` branch is currently unreleased and considered unstable.
-
-There is currently a long-lived branch named `v2` that is intended to land as
-the new `master` branch once development there has settled down.  The current
-`master` branch (mirrored as `v1`) is being manually merged into `v2` on
-an irregular human-based schedule, but generally if one wants to "upgrade" to
-`v2` *now* and accept the volatility (read: "awesomeness") that comes along with
-that, please use whatever version pinning of your preference, such as via
-`gopkg.in`:
-
-```
-$ go get gopkg.in/urfave/cli.v2
-```
-
-``` go
-...
-import (
-  "gopkg.in/urfave/cli.v2" // imports as package "cli"
-)
-...
-```
-
-### Pinning to the `v1` branch
-
-Similarly to the section above describing use of the `v2` branch, if one wants
-to avoid any unexpected compatibility pains once `v2` becomes `master`, then
-pinning to the `v1` branch is an acceptable option, e.g.:
-
-```
-$ go get gopkg.in/urfave/cli.v1
-```
-
-``` go
-...
-import (
-  "gopkg.in/urfave/cli.v1" // imports as package "cli"
-)
-...
-```
-
-## Getting Started
-
-One of the philosophies behind cli is that an API should be playful and full of
-discovery. So a cli app can be as little as one line of code in `main()`.
-
-<!-- {
-  "args": ["&#45;&#45;help"],
-  "output": "A new cli application"
-} -->
-``` go
-package main
-
-import (
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  cli.NewApp().Run(os.Args)
-}
-```
-
-This app will run and show help text, but is not very useful. Let's give an
-action to execute and some help documentation:
-
-<!-- {
-  "output": "boom! I say!"
-} -->
-``` go
-package main
-
-import (
-  "fmt"
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-  app.Name = "boom"
-  app.Usage = "make an explosive entrance"
-  app.Action = func(c *cli.Context) error {
-    fmt.Println("boom! I say!")
-    return nil
-  }
-
-  app.Run(os.Args)
-}
-```
-
-Running this already gives you a ton of functionality, plus support for things
-like subcommands and flags, which are covered below.
-
-## Examples
-
-Being a programmer can be a lonely job. Thankfully by the power of automation
-that is not the case! Let's create a greeter app to fend off our demons of
-loneliness!
-
-Start by creating a directory named `greet`, and within it, add a file,
-`greet.go` with the following code in it:
-
-<!-- {
-  "output": "Hello friend!"
-} -->
-``` go
-package main
-
-import (
-  "fmt"
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-  app.Name = "greet"
-  app.Usage = "fight the loneliness!"
-  app.Action = func(c *cli.Context) error {
-    fmt.Println("Hello friend!")
-    return nil
-  }
-
-  app.Run(os.Args)
-}
-```
-
-Install our command to the `$GOPATH/bin` directory:
-
-```
-$ go install
-```
-
-Finally run our new command:
-
-```
-$ greet
-Hello friend!
-```
-
-cli also generates neat help text:
-
-```
-$ greet help
-NAME:
-    greet - fight the loneliness!
-
-USAGE:
-    greet [global options] command [command options] [arguments...]
-
-VERSION:
-    0.0.0
-
-COMMANDS:
-    help, h  Shows a list of commands or help for one command
-
-GLOBAL OPTIONS
-    --version Shows version information
-```
-
-### Arguments
-
-You can lookup arguments by calling the `Args` function on `cli.Context`, e.g.:
-
-<!-- {
-  "output": "Hello \""
-} -->
-``` go
-package main
-
-import (
-  "fmt"
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-
-  app.Action = func(c *cli.Context) error {
-    fmt.Printf("Hello %q", c.Args().Get(0))
-    return nil
-  }
-
-  app.Run(os.Args)
-}
-```
-
-### Flags
-
-Setting and querying flags is simple.
-
-<!-- {
-  "output": "Hello Nefertiti"
-} -->
-``` go
-package main
-
-import (
-  "fmt"
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-
-  app.Flags = []cli.Flag {
-    cli.StringFlag{
-      Name: "lang",
-      Value: "english",
-      Usage: "language for the greeting",
-    },
-  }
-
-  app.Action = func(c *cli.Context) error {
-    name := "Nefertiti"
-    if c.NArg() > 0 {
-      name = c.Args().Get(0)
-    }
-    if c.String("lang") == "spanish" {
-      fmt.Println("Hola", name)
-    } else {
-      fmt.Println("Hello", name)
-    }
-    return nil
-  }
-
-  app.Run(os.Args)
-}
-```
-
-You can also set a destination variable for a flag, to which the content will be
-scanned.
-
-<!-- {
-  "output": "Hello someone"
-} -->
-``` go
-package main
-
-import (
-  "os"
-  "fmt"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  var language string
-
-  app := cli.NewApp()
-
-  app.Flags = []cli.Flag {
-    cli.StringFlag{
-      Name:        "lang",
-      Value:       "english",
-      Usage:       "language for the greeting",
-      Destination: &language,
-    },
-  }
-
-  app.Action = func(c *cli.Context) error {
-    name := "someone"
-    if c.NArg() > 0 {
-      name = c.Args()[0]
-    }
-    if language == "spanish" {
-      fmt.Println("Hola", name)
-    } else {
-      fmt.Println("Hello", name)
-    }
-    return nil
-  }
-
-  app.Run(os.Args)
-}
-```
-
-See full list of flags at http://godoc.org/github.com/urfave/cli
-
-#### Placeholder Values
-
-Sometimes it's useful to specify a flag's value within the usage string itself.
-Such placeholders are indicated with back quotes.
-
-For example this:
-
-<!-- {
-  "args": ["&#45;&#45;help"],
-  "output": "&#45;&#45;config FILE, &#45;c FILE"
-} -->
-```go
-package main
-
-import (
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-
-  app.Flags = []cli.Flag{
-    cli.StringFlag{
-      Name:  "config, c",
-      Usage: "Load configuration from `FILE`",
-    },
-  }
-
-  app.Run(os.Args)
-}
-```
-
-Will result in help output like:
-
-```
---config FILE, -c FILE   Load configuration from FILE
-```
-
-Note that only the first placeholder is used. Subsequent back-quoted words will
-be left as-is.
-
-#### Alternate Names
-
-You can set alternate (or short) names for flags by providing a comma-delimited
-list for the `Name`. e.g.
-
-<!-- {
-  "args": ["&#45;&#45;help"],
-  "output": "&#45;&#45;lang value, &#45;l value.*language for the greeting.*default: \"english\""
-} -->
-``` go
-package main
-
-import (
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-
-  app.Flags = []cli.Flag {
-    cli.StringFlag{
-      Name: "lang, l",
-      Value: "english",
-      Usage: "language for the greeting",
-    },
-  }
-
-  app.Run(os.Args)
-}
-```
-
-That flag can then be set with `--lang spanish` or `-l spanish`. Note that
-giving two different forms of the same flag in the same command invocation is an
-error.
-
-#### Values from the Environment
-
-You can also have the default value set from the environment via `EnvVar`.  e.g.
-
-<!-- {
-  "args": ["&#45;&#45;help"],
-  "output": "language for the greeting.*APP_LANG"
-} -->
-``` go
-package main
-
-import (
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-
-  app.Flags = []cli.Flag {
-    cli.StringFlag{
-      Name: "lang, l",
-      Value: "english",
-      Usage: "language for the greeting",
-      EnvVar: "APP_LANG",
-    },
-  }
-
-  app.Run(os.Args)
-}
-```
-
-The `EnvVar` may also be given as a comma-delimited "cascade", where the first
-environment variable that resolves is used as the default.
-
-<!-- {
-  "args": ["&#45;&#45;help"],
-  "output": "language for the greeting.*LEGACY_COMPAT_LANG.*APP_LANG.*LANG"
-} -->
-``` go
-package main
-
-import (
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-
-  app.Flags = []cli.Flag {
-    cli.StringFlag{
-      Name: "lang, l",
-      Value: "english",
-      Usage: "language for the greeting",
-      EnvVar: "LEGACY_COMPAT_LANG,APP_LANG,LANG",
-    },
-  }
-
-  app.Run(os.Args)
-}
-```
-
-#### Values from alternate input sources (YAML and others)
-
-There is a separate package altsrc that adds support for getting flag values
-from other input sources like YAML.
-
-In order to get values for a flag from an alternate input source the following
-code would be added to wrap an existing cli.Flag like below:
-
-``` go
-  altsrc.NewIntFlag(cli.IntFlag{Name: "test"})
-```
-
-Initialization must also occur for these flags. Below is an example initializing
-getting data from a yaml file below.
-
-``` go
-  command.Before = altsrc.InitInputSourceWithContext(command.Flags, NewYamlSourceFromFlagFunc("load"))
-```
-
-The code above will use the "load" string as a flag name to get the file name of
-a yaml file from the cli.Context.  It will then use that file name to initialize
-the yaml input source for any flags that are defined on that command.  As a note
-the "load" flag used would also have to be defined on the command flags in order
-for this code snipped to work.
-
-Currently only YAML files are supported but developers can add support for other
-input sources by implementing the altsrc.InputSourceContext for their given
-sources.
-
-Here is a more complete sample of a command using YAML support:
-
-<!-- {
-  "args": ["test-cmd", "&#45;&#45;help"],
-  "output": "&#45&#45;test value.*default: 0"
-} -->
-``` go
-package notmain
-
-import (
-  "fmt"
-  "os"
-
-  "github.com/urfave/cli"
-  "github.com/urfave/cli/altsrc"
-)
-
-func main() {
-  app := cli.NewApp()
-
-  flags := []cli.Flag{
-    altsrc.NewIntFlag(cli.IntFlag{Name: "test"}),
-    cli.StringFlag{Name: "load"},
-  }
-
-  app.Action = func(c *cli.Context) error {
-    fmt.Println("yaml ist rad")
-    return nil
-  }
-
-  app.Before = altsrc.InitInputSourceWithContext(flags, altsrc.NewYamlSourceFromFlagFunc("load"))
-  app.Flags = flags
-
-  app.Run(os.Args)
-}
-```
-
-### Subcommands
-
-Subcommands can be defined for a more git-like command line app.
-
-<!-- {
-  "args": ["template", "add"],
-  "output": "new task template: .+"
-} -->
-```go
-package main
-
-import (
-  "fmt"
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-
-  app.Commands = []cli.Command{
-    {
-      Name:    "add",
-      Aliases: []string{"a"},
-      Usage:   "add a task to the list",
-      Action:  func(c *cli.Context) error {
-        fmt.Println("added task: ", c.Args().First())
-        return nil
-      },
-    },
-    {
-      Name:    "complete",
-      Aliases: []string{"c"},
-      Usage:   "complete a task on the list",
-      Action:  func(c *cli.Context) error {
-        fmt.Println("completed task: ", c.Args().First())
-        return nil
-      },
-    },
-    {
-      Name:        "template",
-      Aliases:     []string{"t"},
-      Usage:       "options for task templates",
-      Subcommands: []cli.Command{
-        {
-          Name:  "add",
-          Usage: "add a new template",
-          Action: func(c *cli.Context) error {
-            fmt.Println("new task template: ", c.Args().First())
-            return nil
-          },
-        },
-        {
-          Name:  "remove",
-          Usage: "remove an existing template",
-          Action: func(c *cli.Context) error {
-            fmt.Println("removed task template: ", c.Args().First())
-            return nil
-          },
-        },
-      },
-    },
-  }
-
-  app.Run(os.Args)
-}
-```
-
-### Subcommands categories
-
-For additional organization in apps that have many subcommands, you can
-associate a category for each command to group them together in the help
-output.
-
-E.g.
-
-```go
-package main
-
-import (
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-
-  app.Commands = []cli.Command{
-    {
-      Name: "noop",
-    },
-    {
-      Name:     "add",
-      Category: "template",
-    },
-    {
-      Name:     "remove",
-      Category: "template",
-    },
-  }
-
-  app.Run(os.Args)
-}
-```
-
-Will include:
-
-```
-COMMANDS:
-    noop
-
-  Template actions:
-    add
-    remove
-```
-
-### Exit code
-
-Calling `App.Run` will not automatically call `os.Exit`, which means that by
-default the exit code will "fall through" to being `0`.  An explicit exit code
-may be set by returning a non-nil error that fulfills `cli.ExitCoder`, *or* a
-`cli.MultiError` that includes an error that fulfills `cli.ExitCoder`, e.g.:
-
-``` go
-package main
-
-import (
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-  app.Flags = []cli.Flag{
-    cli.BoolTFlag{
-      Name:  "ginger-crouton",
-      Usage: "is it in the soup?",
-    },
-  }
-  app.Action = func(ctx *cli.Context) error {
-    if !ctx.Bool("ginger-crouton") {
-      return cli.NewExitError("it is not in the soup", 86)
-    }
-    return nil
-  }
-
-  app.Run(os.Args)
-}
-```
-
-### Bash Completion
-
-You can enable completion commands by setting the `EnableBashCompletion`
-flag on the `App` object.  By default, this setting will only auto-complete to
-show an app's subcommands, but you can write your own completion methods for
-the App or its subcommands.
-
-<!-- {
-  "args": ["complete", "&#45;&#45;generate&#45;bash&#45;completion"],
-  "output": "laundry"
-} -->
-``` go
-package main
-
-import (
-  "fmt"
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  tasks := []string{"cook", "clean", "laundry", "eat", "sleep", "code"}
-
-  app := cli.NewApp()
-  app.EnableBashCompletion = true
-  app.Commands = []cli.Command{
-    {
-      Name:  "complete",
-      Aliases: []string{"c"},
-      Usage: "complete a task on the list",
-      Action: func(c *cli.Context) error {
-         fmt.Println("completed task: ", c.Args().First())
-         return nil
-      },
-      BashComplete: func(c *cli.Context) {
-        // This will complete if no args are passed
-        if c.NArg() > 0 {
-          return
-        }
-        for _, t := range tasks {
-          fmt.Println(t)
-        }
-      },
-    },
-  }
-
-  app.Run(os.Args)
-}
-```
-
-#### Enabling
-
-Source the `autocomplete/bash_autocomplete` file in your `.bashrc` file while
-setting the `PROG` variable to the name of your program:
-
-`PROG=myprogram source /.../cli/autocomplete/bash_autocomplete`
-
-#### Distribution
-
-Copy `autocomplete/bash_autocomplete` into `/etc/bash_completion.d/` and rename
-it to the name of the program you wish to add autocomplete support for (or
-automatically install it there if you are distributing a package). Don't forget
-to source the file to make it active in the current shell.
-
-```
-sudo cp src/bash_autocomplete /etc/bash_completion.d/<myprogram>
-source /etc/bash_completion.d/<myprogram>
-```
-
-Alternatively, you can just document that users should source the generic
-`autocomplete/bash_autocomplete` in their bash configuration with `$PROG` set
-to the name of their program (as above).
-
-#### Customization
-
-The default bash completion flag (`--generate-bash-completion`) is defined as
-`cli.BashCompletionFlag`, and may be redefined if desired, e.g.:
-
-<!-- {
-  "args": ["&#45;&#45;compgen"],
-  "output": "wat\nhelp\nh"
-} -->
-``` go
-package main
-
-import (
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  cli.BashCompletionFlag = cli.BoolFlag{
-    Name:   "compgen",
-    Hidden: true,
-  }
-
-  app := cli.NewApp()
-  app.EnableBashCompletion = true
-  app.Commands = []cli.Command{
-    {
-      Name: "wat",
-    },
-  }
-  app.Run(os.Args)
-}
-```
-
-### Generated Help Text
-
-The default help flag (`-h/--help`) is defined as `cli.HelpFlag` and is checked 
-by the cli internals in order to print generated help text for the app, command,
-or subcommand, and break execution.
-
-#### Customization
-
-All of the help text generation may be customized, and at multiple levels.  The
-templates are exposed as variables `AppHelpTemplate`, `CommandHelpTemplate`, and
-`SubcommandHelpTemplate` which may be reassigned or augmented, and full override
-is possible by assigning a compatible func to the `cli.HelpPrinter` variable,
-e.g.:
-
-<!-- {
-  "output": "Ha HA.  I pwnd the help!!1"
-} -->
-``` go
-package main
-
-import (
-  "fmt"
-  "io"
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  // EXAMPLE: Append to an existing template
-  cli.AppHelpTemplate = fmt.Sprintf(`%s
-
-WEBSITE: http://awesometown.example.com
-
-SUPPORT: support@awesometown.example.com
-
-`, cli.AppHelpTemplate)
-
-  // EXAMPLE: Override a template
-  cli.AppHelpTemplate = `NAME:
-   {{.Name}} - {{.Usage}}
-USAGE:
-   {{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command
-[command options]{{end}} {{if
-.ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}
-   {{if len .Authors}}
-AUTHOR(S):
-   {{range .Authors}}{{ . }}{{end}}
-   {{end}}{{if .Commands}}
-COMMANDS:
-{{range .Commands}}{{if not .HideHelp}}   {{join .Names ", "}}{{ "\t"
-}}{{.Usage}}{{ "\n" }}{{end}}{{end}}{{end}}{{if .VisibleFlags}}
-GLOBAL OPTIONS:
-   {{range .VisibleFlags}}{{.}}
-   {{end}}{{end}}{{if .Copyright }}
-COPYRIGHT:
-   {{.Copyright}}
-   {{end}}{{if .Version}}
-VERSION:
-   {{.Version}}
-   {{end}}
-`
-
-  // EXAMPLE: Replace the `HelpPrinter` func
-  cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {
-    fmt.Println("Ha HA.  I pwnd the help!!1")
-  }
-
-  cli.NewApp().Run(os.Args)
-}
-```
-
-The default flag may be customized to something other than `-h/--help` by
-setting `cli.HelpFlag`, e.g.:
-
-<!-- {
-  "args": ["&#45;&#45halp"],
-  "output": "haaaaalp.*HALP"
-} -->
-``` go
-package main
-
-import (
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  cli.HelpFlag = cli.BoolFlag{
-    Name: "halp, haaaaalp",
-    Usage: "HALP",
-    EnvVar: "SHOW_HALP,HALPPLZ",
-  }
-
-  cli.NewApp().Run(os.Args)
-}
-```
-
-### Version Flag
-
-The default version flag (`-v/--version`) is defined as `cli.VersionFlag`, which
-is checked by the cli internals in order to print the `App.Version` via
-`cli.VersionPrinter` and break execution.
-
-#### Customization
-
-The default flag may be cusomized to something other than `-v/--version` by
-setting `cli.VersionFlag`, e.g.:
-
-<!-- {
-  "args": ["&#45;&#45print-version"],
-  "output": "partay version v19\\.99\\.0"
-} -->
-``` go
-package main
-
-import (
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-func main() {
-  cli.VersionFlag = cli.BoolFlag{
-    Name: "print-version, V",
-    Usage: "print only the version",
-  }
-
-  app := cli.NewApp()
-  app.Name = "partay"
-  app.Version = "v19.99.0"
-  app.Run(os.Args)
-}
-```
-
-Alternatively, the version printer at `cli.VersionPrinter` may be overridden, e.g.:
-
-<!-- {
-  "args": ["&#45;&#45version"],
-  "output": "version=v19\\.99\\.0 revision=fafafaf"
-} -->
-``` go
-package main
-
-import (
-  "fmt"
-  "os"
-
-  "github.com/urfave/cli"
-)
-
-var (
-  Revision = "fafafaf"
-)
-
-func main() {
-  cli.VersionPrinter = func(c *cli.Context) {
-    fmt.Printf("version=%s revision=%s\n", c.App.Version, Revision)
-  }
-
-  app := cli.NewApp()
-  app.Name = "partay"
-  app.Version = "v19.99.0"
-  app.Run(os.Args)
-}
-```
-
-#### Full API Example
-
-**Notice**: This is a contrived (functioning) example meant strictly for API
-demonstration purposes.  Use of one's imagination is encouraged.
-
-<!-- {
-  "output": "made it!\nPhew!"
-} -->
-``` go
-package main
-
-import (
-  "errors"
-  "flag"
-  "fmt"
-  "io"
-  "io/ioutil"
-  "os"
-  "time"
-
-  "github.com/urfave/cli"
-)
-
-func init() {
-  cli.AppHelpTemplate += "\nCUSTOMIZED: you bet ur muffins\n"
-  cli.CommandHelpTemplate += "\nYMMV\n"
-  cli.SubcommandHelpTemplate += "\nor something\n"
-
-  cli.HelpFlag = cli.BoolFlag{Name: "halp"}
-  cli.BashCompletionFlag = cli.BoolFlag{Name: "compgen", Hidden: true}
-  cli.VersionFlag = cli.BoolFlag{Name: "print-version, V"}
-
-  cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {
-    fmt.Fprintf(w, "best of luck to you\n")
-  }
-  cli.VersionPrinter = func(c *cli.Context) {
-    fmt.Fprintf(c.App.Writer, "version=%s\n", c.App.Version)
-  }
-  cli.OsExiter = func(c int) {
-    fmt.Fprintf(cli.ErrWriter, "refusing to exit %d\n", c)
-  }
-  cli.ErrWriter = ioutil.Discard
-  cli.FlagStringer = func(fl cli.Flag) string {
-    return fmt.Sprintf("\t\t%s", fl.GetName())
-  }
-}
-
-type hexWriter struct{}
-
-func (w *hexWriter) Write(p []byte) (int, error) {
-  for _, b := range p {
-    fmt.Printf("%x", b)
-  }
-  fmt.Printf("\n")
-
-  return len(p), nil
-}
-
-type genericType struct{
-  s string
-}
-
-func (g *genericType) Set(value string) error {
-  g.s = value
-  return nil
-}
-
-func (g *genericType) String() string {
-  return g.s
-}
-
-func main() {
-  app := cli.NewApp()
-  app.Name = "kənˈtrīv"
-  app.Version = "v19.99.0"
-  app.Compiled = time.Now()
-  app.Authors = []cli.Author{
-    cli.Author{
-      Name:  "Example Human",
-      Email: "human@example.com",
-    },
-  }
-  app.Copyright = "(c) 1999 Serious Enterprise"
-  app.HelpName = "contrive"
-  app.Usage = "demonstrate available API"
-  app.UsageText = "contrive - demonstrating the available API"
-  app.ArgsUsage = "[args and such]"
-  app.Commands = []cli.Command{
-    cli.Command{
-      Name:        "doo",
-      Aliases:     []string{"do"},
-      Category:    "motion",
-      Usage:       "do the doo",
-      UsageText:   "doo - does the dooing",
-      Description: "no really, there is a lot of dooing to be done",
-      ArgsUsage:   "[arrgh]",
-      Flags: []cli.Flag{
-        cli.BoolFlag{Name: "forever, forevvarr"},
-      },
-      Subcommands: cli.Commands{
-        cli.Command{
-          Name:   "wop",
-          Action: wopAction,
-        },
-      },
-      SkipFlagParsing: false,
-      HideHelp:        false,
-      Hidden:          false,
-      HelpName:        "doo!",
-      BashComplete: func(c *cli.Context) {
-        fmt.Fprintf(c.App.Writer, "--better\n")
-      },
-      Before: func(c *cli.Context) error {
-        fmt.Fprintf(c.App.Writer, "brace for impact\n")
-        return nil
-      },
-      After: func(c *cli.Context) error {
-        fmt.Fprintf(c.App.Writer, "did we lose anyone?\n")
-        return nil
-      },
-      Action: func(c *cli.Context) error {
-        c.Command.FullName()
-        c.Command.HasName("wop")
-        c.Command.Names()
-        c.Command.VisibleFlags()
-        fmt.Fprintf(c.App.Writer, "dodododododoodododddooooododododooo\n")
-        if c.Bool("forever") {
-          c.Command.Run(c)
-        }
-        return nil
-      },
-      OnUsageError: func(c *cli.Context, err error, isSubcommand bool) error {
-        fmt.Fprintf(c.App.Writer, "for shame\n")
-        return err
-      },
-    },
-  }
-  app.Flags = []cli.Flag{
-    cli.BoolFlag{Name: "fancy"},
-    cli.BoolTFlag{Name: "fancier"},
-    cli.DurationFlag{Name: "howlong, H", Value: time.Second * 3},
-    cli.Float64Flag{Name: "howmuch"},
-    cli.GenericFlag{Name: "wat", Value: &genericType{}},
-    cli.Int64Flag{Name: "longdistance"},
-    cli.Int64SliceFlag{Name: "intervals"},
-    cli.IntFlag{Name: "distance"},
-    cli.IntSliceFlag{Name: "times"},
-    cli.StringFlag{Name: "dance-move, d"},
-    cli.StringSliceFlag{Name: "names, N"},
-    cli.UintFlag{Name: "age"},
-    cli.Uint64Flag{Name: "bigage"},
-  }
-  app.EnableBashCompletion = true
-  app.HideHelp = false
-  app.HideVersion = false
-  app.BashComplete = func(c *cli.Context) {
-    fmt.Fprintf(c.App.Writer, "lipstick\nkiss\nme\nlipstick\nringo\n")
-  }
-  app.Before = func(c *cli.Context) error {
-    fmt.Fprintf(c.App.Writer, "HEEEERE GOES\n")
-    return nil
-  }
-  app.After = func(c *cli.Context) error {
-    fmt.Fprintf(c.App.Writer, "Phew!\n")
-    return nil
-  }
-  app.CommandNotFound = func(c *cli.Context, command string) {
-    fmt.Fprintf(c.App.Writer, "Thar be no %q here.\n", command)
-  }
-  app.OnUsageError = func(c *cli.Context, err error, isSubcommand bool) error {
-    if isSubcommand {
-      return err
-    }
-
-    fmt.Fprintf(c.App.Writer, "WRONG: %#v\n", err)
-    return nil
-  }
-  app.Action = func(c *cli.Context) error {
-    cli.DefaultAppComplete(c)
-    cli.HandleExitCoder(errors.New("not an exit coder, though"))
-    cli.ShowAppHelp(c)
-    cli.ShowCommandCompletions(c, "nope")
-    cli.ShowCommandHelp(c, "also-nope")
-    cli.ShowCompletions(c)
-    cli.ShowSubcommandHelp(c)
-    cli.ShowVersion(c)
-
-    categories := c.App.Categories()
-    categories.AddCommand("sounds", cli.Command{
-      Name: "bloop",
-    })
-
-    for _, category := range c.App.Categories() {
-      fmt.Fprintf(c.App.Writer, "%s\n", category.Name)
-      fmt.Fprintf(c.App.Writer, "%#v\n", category.Commands)
-      fmt.Fprintf(c.App.Writer, "%#v\n", category.VisibleCommands())
-    }
-
-    fmt.Printf("%#v\n", c.App.Command("doo"))
-    if c.Bool("infinite") {
-      c.App.Run([]string{"app", "doo", "wop"})
-    }
-
-    if c.Bool("forevar") {
-      c.App.RunAsSubcommand(c)
-    }
-    c.App.Setup()
-    fmt.Printf("%#v\n", c.App.VisibleCategories())
-    fmt.Printf("%#v\n", c.App.VisibleCommands())
-    fmt.Printf("%#v\n", c.App.VisibleFlags())
-
-    fmt.Printf("%#v\n", c.Args().First())
-    if len(c.Args()) > 0 {
-      fmt.Printf("%#v\n", c.Args()[1])
-    }
-    fmt.Printf("%#v\n", c.Args().Present())
-    fmt.Printf("%#v\n", c.Args().Tail())
-
-    set := flag.NewFlagSet("contrive", 0)
-    nc := cli.NewContext(c.App, set, c)
-
-    fmt.Printf("%#v\n", nc.Args())
-    fmt.Printf("%#v\n", nc.Bool("nope"))
-    fmt.Printf("%#v\n", nc.BoolT("nerp"))
-    fmt.Printf("%#v\n", nc.Duration("howlong"))
-    fmt.Printf("%#v\n", nc.Float64("hay"))
-    fmt.Printf("%#v\n", nc.Generic("bloop"))
-    fmt.Printf("%#v\n", nc.Int64("bonk"))
-    fmt.Printf("%#v\n", nc.Int64Slice("burnks"))
-    fmt.Printf("%#v\n", nc.Int("bips"))
-    fmt.Printf("%#v\n", nc.IntSlice("blups"))
-    fmt.Printf("%#v\n", nc.String("snurt"))
-    fmt.Printf("%#v\n", nc.StringSlice("snurkles"))
-    fmt.Printf("%#v\n", nc.Uint("flub"))
-    fmt.Printf("%#v\n", nc.Uint64("florb"))
-    fmt.Printf("%#v\n", nc.GlobalBool("global-nope"))
-    fmt.Printf("%#v\n", nc.GlobalBoolT("global-nerp"))
-    fmt.Printf("%#v\n", nc.GlobalDuration("global-howlong"))
-    fmt.Printf("%#v\n", nc.GlobalFloat64("global-hay"))
-    fmt.Printf("%#v\n", nc.GlobalGeneric("global-bloop"))
-    fmt.Printf("%#v\n", nc.GlobalInt("global-bips"))
-    fmt.Printf("%#v\n", nc.GlobalIntSlice("global-blups"))
-    fmt.Printf("%#v\n", nc.GlobalString("global-snurt"))
-    fmt.Printf("%#v\n", nc.GlobalStringSlice("global-snurkles"))
-
-    fmt.Printf("%#v\n", nc.FlagNames())
-    fmt.Printf("%#v\n", nc.GlobalFlagNames())
-    fmt.Printf("%#v\n", nc.GlobalIsSet("wat"))
-    fmt.Printf("%#v\n", nc.GlobalSet("wat", "nope"))
-    fmt.Printf("%#v\n", nc.NArg())
-    fmt.Printf("%#v\n", nc.NumFlags())
-    fmt.Printf("%#v\n", nc.Parent())
-
-    nc.Set("wat", "also-nope")
-
-    ec := cli.NewExitError("ohwell", 86)
-    fmt.Fprintf(c.App.Writer, "%d", ec.ExitCode())
-    fmt.Printf("made it!\n")
-    return ec
-  }
-
-  if os.Getenv("HEXY") != "" {
-    app.Writer = &hexWriter{}
-    app.ErrWriter = &hexWriter{}
-  }
-
-  app.Metadata = map[string]interface{}{
-    "layers":     "many",
-    "explicable": false,
-    "whatever-values": 19.99,
-  }
-
-  app.Run(os.Args)
-}
-
-func wopAction(c *cli.Context) error {
-  fmt.Fprintf(c.App.Writer, ":wave: over here, eh\n")
-  return nil
-}
-```
-
-## Contribution Guidelines
-
-Feel free to put up a pull request to fix a bug or maybe add a feature. I will
-give it a code review and make sure that it does not break backwards
-compatibility. If I or any other collaborators agree that it is in line with
-the vision of the project, we will work with you to get the code into
-a mergeable state and merge it into the master branch.
-
-If you have contributed something significant to the project, we will most
-likely add you as a collaborator. As a collaborator you are given the ability
-to merge others pull requests. It is very important that new code does not
-break existing code, so be careful about what code you do choose to merge.
-
-If you feel like you have contributed to the project but have not yet been
-added as a collaborator, we probably forgot to add you, please open an issue.
diff --git a/cmd/vendor/github.com/urfave/cli/appveyor.yml b/cmd/vendor/github.com/urfave/cli/appveyor.yml
deleted file mode 100644
index 173086e..0000000
--- a/cmd/vendor/github.com/urfave/cli/appveyor.yml
+++ /dev/null
@@ -1,25 +0,0 @@
-version: "{build}"
-
-os: Windows Server 2012 R2
-
-clone_folder: c:\gopath\src\github.com\urfave\cli
-
-environment:
-  GOPATH: C:\gopath
-  GOVERSION: 1.6
-  PYTHON: C:\Python27-x64
-  PYTHON_VERSION: 2.7.x
-  PYTHON_ARCH: 64
-  GFMXR_DEBUG: 1
-
-install:
-- set PATH=%GOPATH%\bin;C:\go\bin;%PATH%
-- go version
-- go env
-- go get github.com/urfave/gfmxr/...
-- go get -v -t ./...
-
-build_script:
-- python runtests vet
-- python runtests test
-- python runtests gfmxr
diff --git a/cmd/vendor/github.com/urfave/cli/runtests b/cmd/vendor/github.com/urfave/cli/runtests
deleted file mode 100755
index 0a7b483..0000000
--- a/cmd/vendor/github.com/urfave/cli/runtests
+++ /dev/null
@@ -1,105 +0,0 @@
-#!/usr/bin/env python
-from __future__ import print_function
-
-import argparse
-import os
-import sys
-import tempfile
-
-from subprocess import check_call, check_output
-
-
-PACKAGE_NAME = os.environ.get(
-    'CLI_PACKAGE_NAME', 'github.com/urfave/cli'
-)
-
-
-def main(sysargs=sys.argv[:]):
-    targets = {
-        'vet': _vet,
-        'test': _test,
-        'gfmxr': _gfmxr,
-        'toc': _toc,
-    }
-
-    parser = argparse.ArgumentParser()
-    parser.add_argument(
-        'target', nargs='?', choices=tuple(targets.keys()), default='test'
-    )
-    args = parser.parse_args(sysargs[1:])
-
-    targets[args.target]()
-    return 0
-
-
-def _test():
-    if check_output('go version'.split()).split()[2] < 'go1.2':
-        _run('go test -v .'.split())
-        return
-
-    coverprofiles = []
-    for subpackage in ['', 'altsrc']:
-        coverprofile = 'cli.coverprofile'
-        if subpackage != '':
-            coverprofile = '{}.coverprofile'.format(subpackage)
-
-        coverprofiles.append(coverprofile)
-
-        _run('go test -v'.split() + [
-            '-coverprofile={}'.format(coverprofile),
-            ('{}/{}'.format(PACKAGE_NAME, subpackage)).rstrip('/')
-        ])
-
-    combined_name = _combine_coverprofiles(coverprofiles)
-    _run('go tool cover -func={}'.format(combined_name).split())
-    os.remove(combined_name)
-
-
-def _gfmxr():
-    _run(['gfmxr', '-c', str(_gfmxr_count()), '-s', 'README.md'])
-
-
-def _vet():
-    _run('go vet ./...'.split())
-
-
-def _toc():
-    _run(['node_modules/.bin/markdown-toc', '-i', 'README.md'])
-    _run(['git', 'diff', '--quiet'])
-
-
-def _run(command):
-    print('runtests: {}'.format(' '.join(command)), file=sys.stderr)
-    check_call(command)
-
-
-def _gfmxr_count():
-    with open('README.md') as infile:
-        lines = infile.read().splitlines()
-        return len(filter(_is_go_runnable, lines))
-
-
-def _is_go_runnable(line):
-    return line.startswith('package main')
-
-
-def _combine_coverprofiles(coverprofiles):
-    combined = tempfile.NamedTemporaryFile(
-        suffix='.coverprofile', delete=False
-    )
-    combined.write('mode: set\n')
-
-    for coverprofile in coverprofiles:
-        with open(coverprofile, 'r') as infile:
-            for line in infile.readlines():
-                if not line.startswith('mode: '):
-                    combined.write(line)
-
-    combined.flush()
-    name = combined.name
-    combined.close()
-    return name
-
-
-if __name__ == '__main__':
-    sys.exit(main())
diff --git a/cmd/vendor/github.com/xiang90/probing/.gitignore b/cmd/vendor/github.com/xiang90/probing/.gitignore
deleted file mode 100644
index daf913b..0000000
--- a/cmd/vendor/github.com/xiang90/probing/.gitignore
+++ /dev/null
@@ -1,24 +0,0 @@
-# Compiled Object files, Static and Dynamic libs (Shared Objects)
-*.o
-*.a
-*.so
-
-# Folders
-_obj
-_test
-
-# Architecture specific extensions/prefixes
-*.[568vq]
-[568vq].out
-
-*.cgo1.go
-*.cgo2.c
-_cgo_defun.c
-_cgo_gotypes.go
-_cgo_export.*
-
-_testmain.go
-
-*.exe
-*.test
-*.prof
diff --git a/cmd/vendor/github.com/xiang90/probing/README.md b/cmd/vendor/github.com/xiang90/probing/README.md
deleted file mode 100644
index 2ff6820..0000000
--- a/cmd/vendor/github.com/xiang90/probing/README.md
+++ /dev/null
@@ -1,39 +0,0 @@
-## Getting Started
-
-### Install the handler
-
-We first need to serve the probing HTTP handler.
-
-```go
-    http.HandleFunc("/health", probing.NewHandler())
-    err := http.ListenAndServe(":12345", nil)
-	if err != nil {
-		log.Fatal("ListenAndServe: ", err)
-	}
-```
-
-### Start to probe
-
-Now we can start to probe the endpoint.
-
-``` go
-    id := "example"
-    probingInterval = 5 * time.Second
-    url := "http://example.com:12345/health"
-    p.AddHTTP(id, probingInterval, url)
-
-	time.Sleep(13 * time.Second)
-	status, err := p.Status(id)
- 	fmt.Printf("Total Probing: %d, Total Loss: %d, Estimated RTT: %v, Estimated Clock Difference: %v\n",
-		status.Total(), status.Loss(), status.SRTT(), status.ClockDiff())
-	// Total Probing: 2, Total Loss: 0, Estimated RTT: 320.771µs, Estimated Clock Difference: -35.869µs
-```
-
-### TODOs:
-
-- TCP probing
-- UDP probing
-- Gossip based probing
-- More accurate RTT estimation
-- More accurate Clock difference estimation
-- Use a clock interface rather than the real clock
diff --git a/cmd/vendor/golang.org/x/crypto/bcrypt/bcrypt.go b/cmd/vendor/golang.org/x/crypto/bcrypt/bcrypt.go
index b8e18d7..f8b807f 100644
--- a/cmd/vendor/golang.org/x/crypto/bcrypt/bcrypt.go
+++ b/cmd/vendor/golang.org/x/crypto/bcrypt/bcrypt.go
@@ -4,7 +4,7 @@
 
 // Package bcrypt implements Provos and Mazières's bcrypt adaptive hashing
 // algorithm. See http://www.usenix.org/event/usenix99/provos/provos.pdf
-package bcrypt
+package bcrypt // import "golang.org/x/crypto/bcrypt"
 
 // The code is a port of Provos and Mazières's C implementation.
 import (
diff --git a/cmd/vendor/golang.org/x/crypto/blowfish/cipher.go b/cmd/vendor/golang.org/x/crypto/blowfish/cipher.go
index 5019658..542984a 100644
--- a/cmd/vendor/golang.org/x/crypto/blowfish/cipher.go
+++ b/cmd/vendor/golang.org/x/crypto/blowfish/cipher.go
@@ -3,7 +3,7 @@
 // license that can be found in the LICENSE file.
 
 // Package blowfish implements Bruce Schneier's Blowfish encryption algorithm.
-package blowfish
+package blowfish // import "golang.org/x/crypto/blowfish"
 
 // The code is a port of Bruce Schneier's C implementation.
 // See http://www.schneier.com/blowfish.html.
diff --git a/cmd/vendor/golang.org/x/net/context/context.go b/cmd/vendor/golang.org/x/net/context/context.go
index 11bd8d3..77b64d0 100644
--- a/cmd/vendor/golang.org/x/net/context/context.go
+++ b/cmd/vendor/golang.org/x/net/context/context.go
@@ -34,7 +34,7 @@
 //
 // See http://blog.golang.org/context for example code for a server that uses
 // Contexts.
-package context
+package context // import "golang.org/x/net/context"
 
 import (
 	"errors"
diff --git a/cmd/vendor/golang.org/x/net/http2/.gitignore b/cmd/vendor/golang.org/x/net/http2/.gitignore
deleted file mode 100644
index 190f122..0000000
--- a/cmd/vendor/golang.org/x/net/http2/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-*~
-h2i/h2i
diff --git a/cmd/vendor/golang.org/x/net/http2/Dockerfile b/cmd/vendor/golang.org/x/net/http2/Dockerfile
deleted file mode 100644
index 53fc525..0000000
--- a/cmd/vendor/golang.org/x/net/http2/Dockerfile
+++ /dev/null
@@ -1,51 +0,0 @@
-#
-# This Dockerfile builds a recent curl with HTTP/2 client support, using
-# a recent nghttp2 build.
-#
-# See the Makefile for how to tag it. If Docker and that image is found, the
-# Go tests use this curl binary for integration tests.
-#
-
-FROM ubuntu:trusty
-
-RUN apt-get update && \
-    apt-get upgrade -y && \
-    apt-get install -y git-core build-essential wget
-
-RUN apt-get install -y --no-install-recommends \
-       autotools-dev libtool pkg-config zlib1g-dev \
-       libcunit1-dev libssl-dev libxml2-dev libevent-dev \
-       automake autoconf
-
-# The list of packages nghttp2 recommends for h2load:
-RUN apt-get install -y --no-install-recommends make binutils \
-        autoconf automake autotools-dev \
-        libtool pkg-config zlib1g-dev libcunit1-dev libssl-dev libxml2-dev \
-        libev-dev libevent-dev libjansson-dev libjemalloc-dev \
-        cython python3.4-dev python-setuptools
-
-# Note: setting NGHTTP2_VER before the git clone, so an old git clone isn't cached:
-ENV NGHTTP2_VER 895da9a
-RUN cd /root && git clone https://github.com/tatsuhiro-t/nghttp2.git
-
-WORKDIR /root/nghttp2
-RUN git reset --hard $NGHTTP2_VER
-RUN autoreconf -i
-RUN automake
-RUN autoconf
-RUN ./configure
-RUN make
-RUN make install
-
-WORKDIR /root
-RUN wget http://curl.haxx.se/download/curl-7.45.0.tar.gz
-RUN tar -zxvf curl-7.45.0.tar.gz
-WORKDIR /root/curl-7.45.0
-RUN ./configure --with-ssl --with-nghttp2=/usr/local
-RUN make
-RUN make install
-RUN ldconfig
-
-CMD ["-h"]
-ENTRYPOINT ["/usr/local/bin/curl"]
-
diff --git a/cmd/vendor/golang.org/x/net/http2/Makefile b/cmd/vendor/golang.org/x/net/http2/Makefile
deleted file mode 100644
index 55fd826..0000000
--- a/cmd/vendor/golang.org/x/net/http2/Makefile
+++ /dev/null
@@ -1,3 +0,0 @@
-curlimage:
-	docker build -t gohttp2/curl .
-
diff --git a/cmd/vendor/golang.org/x/net/http2/README b/cmd/vendor/golang.org/x/net/http2/README
deleted file mode 100644
index 360d5aa..0000000
--- a/cmd/vendor/golang.org/x/net/http2/README
+++ /dev/null
@@ -1,20 +0,0 @@
-This is a work-in-progress HTTP/2 implementation for Go.
-
-It will eventually live in the Go standard library and won't require
-any changes to your code to use.  It will just be automatic.
-
-Status:
-
-* The server support is pretty good. A few things are missing
-  but are being worked on.
-* The client work has just started but shares a lot of code
-  is coming along much quicker.
-
-Docs are at https://godoc.org/golang.org/x/net/http2
-
-Demo test server at https://http2.golang.org/
-
-Help & bug reports welcome!
-
-Contributing: https://golang.org/doc/contribute.html
-Bugs:         https://golang.org/issue/new?title=x/net/http2:+
diff --git a/cmd/vendor/golang.org/x/net/internal/timeseries/timeseries.go b/cmd/vendor/golang.org/x/net/internal/timeseries/timeseries.go
index 3f90b73..1119f34 100644
--- a/cmd/vendor/golang.org/x/net/internal/timeseries/timeseries.go
+++ b/cmd/vendor/golang.org/x/net/internal/timeseries/timeseries.go
@@ -3,7 +3,7 @@
 // license that can be found in the LICENSE file.
 
 // Package timeseries implements a time series structure for stats collection.
-package timeseries
+package timeseries // import "golang.org/x/net/internal/timeseries"
 
 import (
 	"fmt"
diff --git a/cmd/vendor/golang.org/x/net/trace/trace.go b/cmd/vendor/golang.org/x/net/trace/trace.go
index 197402e..0767c8c 100644
--- a/cmd/vendor/golang.org/x/net/trace/trace.go
+++ b/cmd/vendor/golang.org/x/net/trace/trace.go
@@ -60,7 +60,7 @@ The /debug/events HTTP endpoint organizes the event logs by family and
 by time since the last error.  The expanded view displays recent log
 entries and the log's call stack.
 */
-package trace
+package trace // import "golang.org/x/net/trace"
 
 import (
 	"bytes"
diff --git a/cmd/vendor/golang.org/x/sys/unix/mkall.sh b/cmd/vendor/golang.org/x/sys/unix/mkall.sh
deleted file mode 100755
index d41d610..0000000
--- a/cmd/vendor/golang.org/x/sys/unix/mkall.sh
+++ /dev/null
@@ -1,274 +0,0 @@
-#!/usr/bin/env bash
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# The unix package provides access to the raw system call
-# interface of the underlying operating system.  Porting Go to
-# a new architecture/operating system combination requires
-# some manual effort, though there are tools that automate
-# much of the process.  The auto-generated files have names
-# beginning with z.
-#
-# This script runs or (given -n) prints suggested commands to generate z files
-# for the current system.  Running those commands is not automatic.
-# This script is documentation more than anything else.
-#
-# * asm_${GOOS}_${GOARCH}.s
-#
-# This hand-written assembly file implements system call dispatch.
-# There are three entry points:
-#
-# 	func Syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr);
-# 	func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr);
-# 	func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr);
-#
-# The first and second are the standard ones; they differ only in
-# how many arguments can be passed to the kernel.
-# The third is for low-level use by the ForkExec wrapper;
-# unlike the first two, it does not call into the scheduler to
-# let it know that a system call is running.
-#
-# * syscall_${GOOS}.go
-#
-# This hand-written Go file implements system calls that need
-# special handling and lists "//sys" comments giving prototypes
-# for ones that can be auto-generated.  Mksyscall reads those
-# comments to generate the stubs.
-#
-# * syscall_${GOOS}_${GOARCH}.go
-#
-# Same as syscall_${GOOS}.go except that it contains code specific
-# to ${GOOS} on one particular architecture.
-#
-# * types_${GOOS}.c
-#
-# This hand-written C file includes standard C headers and then
-# creates typedef or enum names beginning with a dollar sign
-# (use of $ in variable names is a gcc extension).  The hardest
-# part about preparing this file is figuring out which headers to
-# include and which symbols need to be #defined to get the
-# actual data structures that pass through to the kernel system calls.
-# Some C libraries present alternate versions for binary compatibility
-# and translate them on the way in and out of system calls, but
-# there is almost always a #define that can get the real ones.
-# See types_darwin.c and types_linux.c for examples.
-#
-# * zerror_${GOOS}_${GOARCH}.go
-#
-# This machine-generated file defines the system's error numbers,
-# error strings, and signal numbers.  The generator is "mkerrors.sh".
-# Usually no arguments are needed, but mkerrors.sh will pass its
-# arguments on to godefs.
-#
-# * zsyscall_${GOOS}_${GOARCH}.go
-#
-# Generated by mksyscall.pl; see syscall_${GOOS}.go above.
-#
-# * zsysnum_${GOOS}_${GOARCH}.go
-#
-# Generated by mksysnum_${GOOS}.
-#
-# * ztypes_${GOOS}_${GOARCH}.go
-#
-# Generated by godefs; see types_${GOOS}.c above.
-
-GOOSARCH="${GOOS}_${GOARCH}"
-
-# defaults
-mksyscall="./mksyscall.pl"
-mkerrors="./mkerrors.sh"
-zerrors="zerrors_$GOOSARCH.go"
-mksysctl=""
-zsysctl="zsysctl_$GOOSARCH.go"
-mksysnum=
-mktypes=
-run="sh"
-
-case "$1" in
--syscalls)
-	for i in zsyscall*go
-	do
-		sed 1q $i | sed 's;^// ;;' | sh > _$i && gofmt < _$i > $i
-		rm _$i
-	done
-	exit 0
-	;;
--n)
-	run="cat"
-	shift
-esac
-
-case "$#" in
-0)
-	;;
-*)
-	echo 'usage: mkall.sh [-n]' 1>&2
-	exit 2
-esac
-
-GOOSARCH_in=syscall_$GOOSARCH.go
-case "$GOOSARCH" in
-_* | *_ | _)
-	echo 'undefined $GOOS_$GOARCH:' "$GOOSARCH" 1>&2
-	exit 1
-	;;
-darwin_386)
-	mkerrors="$mkerrors -m32"
-	mksyscall="./mksyscall.pl -l32"
-	mksysnum="./mksysnum_darwin.pl /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/syscall.h"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-darwin_amd64)
-	mkerrors="$mkerrors -m64"
-	mksysnum="./mksysnum_darwin.pl /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/syscall.h"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-darwin_arm)
-	mkerrors="$mkerrors"
-	mksysnum="./mksysnum_darwin.pl /usr/include/sys/syscall.h"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-darwin_arm64)
-	mkerrors="$mkerrors -m64"
-	mksysnum="./mksysnum_darwin.pl /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sys/syscall.h"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-dragonfly_386)
-	mkerrors="$mkerrors -m32"
-	mksyscall="./mksyscall.pl -l32 -dragonfly"
-	mksysnum="curl -s 'http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/kern/syscalls.master' | ./mksysnum_dragonfly.pl"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-dragonfly_amd64)
-	mkerrors="$mkerrors -m64"
-	mksyscall="./mksyscall.pl -dragonfly"
-	mksysnum="curl -s 'http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/kern/syscalls.master' | ./mksysnum_dragonfly.pl"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-freebsd_386)
-	mkerrors="$mkerrors -m32"
-	mksyscall="./mksyscall.pl -l32"
-	mksysnum="curl -s 'http://svn.freebsd.org/base/stable/10/sys/kern/syscalls.master' | ./mksysnum_freebsd.pl"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-freebsd_amd64)
-	mkerrors="$mkerrors -m64"
-	mksysnum="curl -s 'http://svn.freebsd.org/base/stable/10/sys/kern/syscalls.master' | ./mksysnum_freebsd.pl"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-freebsd_arm)
-	mkerrors="$mkerrors"
-	mksyscall="./mksyscall.pl -l32 -arm"
-	mksysnum="curl -s 'http://svn.freebsd.org/base/stable/10/sys/kern/syscalls.master' | ./mksysnum_freebsd.pl"
-	# Let the type of C char be singed for making the bare syscall
-	# API consistent across over platforms.
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs -- -fsigned-char"
-	;;
-linux_386)
-	mkerrors="$mkerrors -m32"
-	mksyscall="./mksyscall.pl -l32"
-	mksysnum="./mksysnum_linux.pl /usr/include/asm/unistd_32.h"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-linux_amd64)
-	unistd_h=$(ls -1 /usr/include/asm/unistd_64.h /usr/include/x86_64-linux-gnu/asm/unistd_64.h 2>/dev/null | head -1)
-	if [ "$unistd_h" = "" ]; then
-		echo >&2 cannot find unistd_64.h
-		exit 1
-	fi
-	mkerrors="$mkerrors -m64"
-	mksysnum="./mksysnum_linux.pl $unistd_h"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-linux_arm)
-	mkerrors="$mkerrors"
-	mksyscall="./mksyscall.pl -l32 -arm"
-	mksysnum="curl -s 'http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/arch/arm/include/uapi/asm/unistd.h' | ./mksysnum_linux.pl -"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-linux_arm64)
-	unistd_h=$(ls -1 /usr/include/asm/unistd.h /usr/include/asm-generic/unistd.h 2>/dev/null | head -1)
-	if [ "$unistd_h" = "" ]; then
-		echo >&2 cannot find unistd_64.h
-		exit 1
-	fi
-	mksysnum="./mksysnum_linux.pl $unistd_h"
-	# Let the type of C char be singed for making the bare syscall
-	# API consistent across over platforms.
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs -- -fsigned-char"
-	;;
-linux_ppc64)
-	GOOSARCH_in=syscall_linux_ppc64x.go
-	unistd_h=/usr/include/asm/unistd.h
-	mkerrors="$mkerrors -m64"
-	mksysnum="./mksysnum_linux.pl $unistd_h"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-linux_ppc64le)
-	GOOSARCH_in=syscall_linux_ppc64x.go
-	unistd_h=/usr/include/powerpc64le-linux-gnu/asm/unistd.h
-	mkerrors="$mkerrors -m64"
-	mksysnum="./mksysnum_linux.pl $unistd_h"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-netbsd_386)
-	mkerrors="$mkerrors -m32"
-	mksyscall="./mksyscall.pl -l32 -netbsd"
-	mksysnum="curl -s 'http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/sys/kern/syscalls.master' | ./mksysnum_netbsd.pl"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-netbsd_amd64)
-	mkerrors="$mkerrors -m64"
-	mksyscall="./mksyscall.pl -netbsd"
-	mksysnum="curl -s 'http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/sys/kern/syscalls.master' | ./mksysnum_netbsd.pl"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-openbsd_386)
-	mkerrors="$mkerrors -m32"
-	mksyscall="./mksyscall.pl -l32 -openbsd"
-	mksysctl="./mksysctl_openbsd.pl"
-	zsysctl="zsysctl_openbsd.go"
-	mksysnum="curl -s 'http://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master' | ./mksysnum_openbsd.pl"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-openbsd_amd64)
-	mkerrors="$mkerrors -m64"
-	mksyscall="./mksyscall.pl -openbsd"
-	mksysctl="./mksysctl_openbsd.pl"
-	zsysctl="zsysctl_openbsd.go"
-	mksysnum="curl -s 'http://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master' | ./mksysnum_openbsd.pl"
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-solaris_amd64)
-	mksyscall="./mksyscall_solaris.pl"
-	mkerrors="$mkerrors -m64"
-	mksysnum=
-	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
-	;;
-*)
-	echo 'unrecognized $GOOS_$GOARCH: ' "$GOOSARCH" 1>&2
-	exit 1
-	;;
-esac
-
-(
-	if [ -n "$mkerrors" ]; then echo "$mkerrors |gofmt >$zerrors"; fi
-	case "$GOOS" in
-	*)
-		syscall_goos="syscall_$GOOS.go"
-		case "$GOOS" in
-		darwin | dragonfly | freebsd | netbsd | openbsd)
-			syscall_goos="syscall_bsd.go $syscall_goos"
-			;;
-		esac
-		if [ -n "$mksyscall" ]; then echo "$mksyscall $syscall_goos $GOOSARCH_in |gofmt >zsyscall_$GOOSARCH.go"; fi
-		;;
-	esac
-	if [ -n "$mksysctl" ]; then echo "$mksysctl |gofmt >$zsysctl"; fi
-	if [ -n "$mksysnum" ]; then echo "$mksysnum |gofmt >zsysnum_$GOOSARCH.go"; fi
-	if [ -n "$mktypes" ]; then
-		echo "echo // +build $GOARCH,$GOOS > ztypes_$GOOSARCH.go";
-		echo "$mktypes types_$GOOS.go | gofmt >>ztypes_$GOOSARCH.go";
-	fi
-) | $run
diff --git a/cmd/vendor/golang.org/x/sys/unix/mkerrors.sh b/cmd/vendor/golang.org/x/sys/unix/mkerrors.sh
deleted file mode 100755
index 77c4804..0000000
--- a/cmd/vendor/golang.org/x/sys/unix/mkerrors.sh
+++ /dev/null
@@ -1,457 +0,0 @@
-#!/usr/bin/env bash
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# Generate Go code listing errors and other #defined constant
-# values (ENAMETOOLONG etc.), by asking the preprocessor
-# about the definitions.
-
-unset LANG
-export LC_ALL=C
-export LC_CTYPE=C
-
-if test -z "$GOARCH" -o -z "$GOOS"; then
-  echo 1>&2 "GOARCH or GOOS not defined in environment"
-  exit 1
-fi
-
-CC=${CC:-gcc}
-
-uname=$(uname)
-
-includes_Darwin='
-#define _DARWIN_C_SOURCE
-#define KERNEL
-#define _DARWIN_USE_64_BIT_INODE
-#include <sys/types.h>
-#include <sys/event.h>
-#include <sys/ptrace.h>
-#include <sys/socket.h>
-#include <sys/sockio.h>
-#include <sys/sysctl.h>
-#include <sys/mman.h>
-#include <sys/wait.h>
-#include <net/bpf.h>
-#include <net/if.h>
-#include <net/if_types.h>
-#include <net/route.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <termios.h>
-'
-
-includes_DragonFly='
-#include <sys/types.h>
-#include <sys/event.h>
-#include <sys/socket.h>
-#include <sys/sockio.h>
-#include <sys/sysctl.h>
-#include <sys/mman.h>
-#include <sys/wait.h>
-#include <sys/ioctl.h>
-#include <net/bpf.h>
-#include <net/if.h>
-#include <net/if_types.h>
-#include <net/route.h>
-#include <netinet/in.h>
-#include <termios.h>
-#include <netinet/ip.h>
-#include <net/ip_mroute/ip_mroute.h>
-'
-
-includes_FreeBSD='
-#include <sys/param.h>
-#include <sys/types.h>
-#include <sys/event.h>
-#include <sys/socket.h>
-#include <sys/sockio.h>
-#include <sys/sysctl.h>
-#include <sys/mman.h>
-#include <sys/wait.h>
-#include <sys/ioctl.h>
-#include <net/bpf.h>
-#include <net/if.h>
-#include <net/if_types.h>
-#include <net/route.h>
-#include <netinet/in.h>
-#include <termios.h>
-#include <netinet/ip.h>
-#include <netinet/ip_mroute.h>
-#include <sys/extattr.h>
-
-#if __FreeBSD__ >= 10
-#define IFT_CARP	0xf8	// IFT_CARP is deprecated in FreeBSD 10
-#undef SIOCAIFADDR
-#define SIOCAIFADDR	_IOW(105, 26, struct oifaliasreq)	// ifaliasreq contains if_data
-#undef SIOCSIFPHYADDR
-#define SIOCSIFPHYADDR	_IOW(105, 70, struct oifaliasreq)	// ifaliasreq contains if_data
-#endif
-'
-
-includes_Linux='
-#define _LARGEFILE_SOURCE
-#define _LARGEFILE64_SOURCE
-#ifndef __LP64__
-#define _FILE_OFFSET_BITS 64
-#endif
-#define _GNU_SOURCE
-
-#include <bits/sockaddr.h>
-#include <sys/epoll.h>
-#include <sys/inotify.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/mount.h>
-#include <sys/prctl.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/time.h>
-#include <sys/socket.h>
-#include <linux/if.h>
-#include <linux/if_arp.h>
-#include <linux/if_ether.h>
-#include <linux/if_tun.h>
-#include <linux/if_packet.h>
-#include <linux/if_addr.h>
-#include <linux/filter.h>
-#include <linux/netlink.h>
-#include <linux/reboot.h>
-#include <linux/rtnetlink.h>
-#include <linux/ptrace.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/icmpv6.h>
-#include <net/route.h>
-#include <termios.h>
-
-#ifndef MSG_FASTOPEN
-#define MSG_FASTOPEN    0x20000000
-#endif
-
-#ifndef PTRACE_GETREGS
-#define PTRACE_GETREGS	0xc
-#endif
-
-#ifndef PTRACE_SETREGS
-#define PTRACE_SETREGS	0xd
-#endif
-'
-
-includes_NetBSD='
-#include <sys/types.h>
-#include <sys/param.h>
-#include <sys/event.h>
-#include <sys/mman.h>
-#include <sys/socket.h>
-#include <sys/sockio.h>
-#include <sys/sysctl.h>
-#include <sys/termios.h>
-#include <sys/ttycom.h>
-#include <sys/wait.h>
-#include <net/bpf.h>
-#include <net/if.h>
-#include <net/if_types.h>
-#include <net/route.h>
-#include <netinet/in.h>
-#include <netinet/in_systm.h>
-#include <netinet/ip.h>
-#include <netinet/ip_mroute.h>
-#include <netinet/if_ether.h>
-
-// Needed since <sys/param.h> refers to it...
-#define schedppq 1
-'
-
-includes_OpenBSD='
-#include <sys/types.h>
-#include <sys/param.h>
-#include <sys/event.h>
-#include <sys/mman.h>
-#include <sys/socket.h>
-#include <sys/sockio.h>
-#include <sys/sysctl.h>
-#include <sys/termios.h>
-#include <sys/ttycom.h>
-#include <sys/wait.h>
-#include <net/bpf.h>
-#include <net/if.h>
-#include <net/if_types.h>
-#include <net/if_var.h>
-#include <net/route.h>
-#include <netinet/in.h>
-#include <netinet/in_systm.h>
-#include <netinet/ip.h>
-#include <netinet/ip_mroute.h>
-#include <netinet/if_ether.h>
-#include <net/if_bridge.h>
-
-// We keep some constants not supported in OpenBSD 5.5 and beyond for
-// the promise of compatibility.
-#define EMUL_ENABLED		0x1
-#define EMUL_NATIVE		0x2
-#define IPV6_FAITH		0x1d
-#define IPV6_OPTIONS		0x1
-#define IPV6_RTHDR_STRICT	0x1
-#define IPV6_SOCKOPT_RESERVED1	0x3
-#define SIOCGIFGENERIC		0xc020693a
-#define SIOCSIFGENERIC		0x80206939
-#define WALTSIG			0x4
-'
-
-includes_SunOS='
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/sockio.h>
-#include <sys/mman.h>
-#include <sys/wait.h>
-#include <sys/ioctl.h>
-#include <net/bpf.h>
-#include <net/if.h>
-#include <net/if_arp.h>
-#include <net/if_types.h>
-#include <net/route.h>
-#include <netinet/in.h>
-#include <termios.h>
-#include <netinet/ip.h>
-#include <netinet/ip_mroute.h>
-'
-
-
-includes='
-#include <sys/types.h>
-#include <sys/file.h>
-#include <fcntl.h>
-#include <dirent.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <netinet/ip6.h>
-#include <netinet/tcp.h>
-#include <errno.h>
-#include <sys/signal.h>
-#include <signal.h>
-#include <sys/resource.h>
-#include <time.h>
-'
-ccflags="$@"
-
-# Write go tool cgo -godefs input.
-(
-	echo package unix
-	echo
-	echo '/*'
-	indirect="includes_$(uname)"
-	echo "${!indirect} $includes"
-	echo '*/'
-	echo 'import "C"'
-	echo 'import "syscall"'
-	echo
-	echo 'const ('
-
-	# The gcc command line prints all the #defines
-	# it encounters while processing the input
-	echo "${!indirect} $includes" | $CC -x c - -E -dM $ccflags |
-	awk '
-		$1 != "#define" || $2 ~ /\(/ || $3 == "" {next}
-
-		$2 ~ /^E([ABCD]X|[BIS]P|[SD]I|S|FL)$/ {next}  # 386 registers
-		$2 ~ /^(SIGEV_|SIGSTKSZ|SIGRT(MIN|MAX))/ {next}
-		$2 ~ /^(SCM_SRCRT)$/ {next}
-		$2 ~ /^(MAP_FAILED)$/ {next}
-		$2 ~ /^ELF_.*$/ {next}# <asm/elf.h> contains ELF_ARCH, etc.
-
-		$2 ~ /^EXTATTR_NAMESPACE_NAMES/ ||
-		$2 ~ /^EXTATTR_NAMESPACE_[A-Z]+_STRING/ {next}
-
-		$2 !~ /^ETH_/ &&
-		$2 !~ /^EPROC_/ &&
-		$2 !~ /^EQUIV_/ &&
-		$2 !~ /^EXPR_/ &&
-		$2 ~ /^E[A-Z0-9_]+$/ ||
-		$2 ~ /^B[0-9_]+$/ ||
-		$2 ~ /^V[A-Z0-9]+$/ ||
-		$2 ~ /^CS[A-Z0-9]/ ||
-		$2 ~ /^I(SIG|CANON|CRNL|EXTEN|MAXBEL|STRIP|UTF8)$/ ||
-		$2 ~ /^IGN/ ||
-		$2 ~ /^IX(ON|ANY|OFF)$/ ||
-		$2 ~ /^IN(LCR|PCK)$/ ||
-		$2 ~ /(^FLU?SH)|(FLU?SH$)/ ||
-		$2 ~ /^C(LOCAL|READ)$/ ||
-		$2 == "BRKINT" ||
-		$2 == "HUPCL" ||
-		$2 == "PENDIN" ||
-		$2 == "TOSTOP" ||
-		$2 ~ /^PAR/ ||
-		$2 ~ /^SIG[^_]/ ||
-		$2 ~ /^O[CNPFP][A-Z]+[^_][A-Z]+$/ ||
-		$2 ~ /^IN_/ ||
-		$2 ~ /^LOCK_(SH|EX|NB|UN)$/ ||
-		$2 ~ /^(AF|SOCK|SO|SOL|IPPROTO|IP|IPV6|ICMP6|TCP|EVFILT|NOTE|EV|SHUT|PROT|MAP|PACKET|MSG|SCM|MCL|DT|MADV|PR)_/ ||
-		$2 == "ICMPV6_FILTER" ||
-		$2 == "SOMAXCONN" ||
-		$2 == "NAME_MAX" ||
-		$2 == "IFNAMSIZ" ||
-		$2 ~ /^CTL_(MAXNAME|NET|QUERY)$/ ||
-		$2 ~ /^SYSCTL_VERS/ ||
-		$2 ~ /^(MS|MNT)_/ ||
-		$2 ~ /^TUN(SET|GET|ATTACH|DETACH)/ ||
-		$2 ~ /^(O|F|FD|NAME|S|PTRACE|PT)_/ ||
-		$2 ~ /^LINUX_REBOOT_CMD_/ ||
-		$2 ~ /^LINUX_REBOOT_MAGIC[12]$/ ||
-		$2 !~ "NLA_TYPE_MASK" &&
-		$2 ~ /^(NETLINK|NLM|NLMSG|NLA|IFA|IFAN|RT|RTCF|RTN|RTPROT|RTNH|ARPHRD|ETH_P)_/ ||
-		$2 ~ /^SIOC/ ||
-		$2 ~ /^TIOC/ ||
-		$2 !~ "RTF_BITS" &&
-		$2 ~ /^(IFF|IFT|NET_RT|RTM|RTF|RTV|RTA|RTAX)_/ ||
-		$2 ~ /^BIOC/ ||
-		$2 ~ /^RUSAGE_(SELF|CHILDREN|THREAD)/ ||
-		$2 ~ /^RLIMIT_(AS|CORE|CPU|DATA|FSIZE|NOFILE|STACK)|RLIM_INFINITY/ ||
-		$2 ~ /^PRIO_(PROCESS|PGRP|USER)/ ||
-		$2 ~ /^CLONE_[A-Z_]+/ ||
-		$2 !~ /^(BPF_TIMEVAL)$/ &&
-		$2 ~ /^(BPF|DLT)_/ ||
-		$2 ~ /^CLOCK_/ ||
-		$2 !~ "WMESGLEN" &&
-		$2 ~ /^W[A-Z0-9]+$/ {printf("\t%s = C.%s\n", $2, $2)}
-		$2 ~ /^__WCOREFLAG$/ {next}
-		$2 ~ /^__W[A-Z0-9]+$/ {printf("\t%s = C.%s\n", substr($2,3), $2)}
-
-		{next}
-	' | sort
-
-	echo ')'
-) >_const.go
-
-# Pull out the error names for later.
-errors=$(
-	echo '#include <errno.h>' | $CC -x c - -E -dM $ccflags |
-	awk '$1=="#define" && $2 ~ /^E[A-Z0-9_]+$/ { print $2 }' |
-	sort
-)
-
-# Pull out the signal names for later.
-signals=$(
-	echo '#include <signal.h>' | $CC -x c - -E -dM $ccflags |
-	awk '$1=="#define" && $2 ~ /^SIG[A-Z0-9]+$/ { print $2 }' |
-	egrep -v '(SIGSTKSIZE|SIGSTKSZ|SIGRT)' |
-	sort
-)
-
-# Again, writing regexps to a file.
-echo '#include <errno.h>' | $CC -x c - -E -dM $ccflags |
-	awk '$1=="#define" && $2 ~ /^E[A-Z0-9_]+$/ { print "^\t" $2 "[ \t]*=" }' |
-	sort >_error.grep
-echo '#include <signal.h>' | $CC -x c - -E -dM $ccflags |
-	awk '$1=="#define" && $2 ~ /^SIG[A-Z0-9]+$/ { print "^\t" $2 "[ \t]*=" }' |
-	egrep -v '(SIGSTKSIZE|SIGSTKSZ|SIGRT)' |
-	sort >_signal.grep
-
-echo '// mkerrors.sh' "$@"
-echo '// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT'
-echo
-echo "// +build ${GOARCH},${GOOS}"
-echo
-go tool cgo -godefs -- "$@" _const.go >_error.out
-cat _error.out | grep -vf _error.grep | grep -vf _signal.grep
-echo
-echo '// Errors'
-echo 'const ('
-cat _error.out | grep -f _error.grep | sed 's/=\(.*\)/= syscall.Errno(\1)/'
-echo ')'
-
-echo
-echo '// Signals'
-echo 'const ('
-cat _error.out | grep -f _signal.grep | sed 's/=\(.*\)/= syscall.Signal(\1)/'
-echo ')'
-
-# Run C program to print error and syscall strings.
-(
-	echo -E "
-#include <stdio.h>
-#include <stdlib.h>
-#include <errno.h>
-#include <ctype.h>
-#include <string.h>
-#include <signal.h>
-
-#define nelem(x) (sizeof(x)/sizeof((x)[0]))
-
-enum { A = 'A', Z = 'Z', a = 'a', z = 'z' }; // avoid need for single quotes below
-
-int errors[] = {
-"
-	for i in $errors
-	do
-		echo -E '	'$i,
-	done
-
-	echo -E "
-};
-
-int signals[] = {
-"
-	for i in $signals
-	do
-		echo -E '	'$i,
-	done
-
-	# Use -E because on some systems bash builtin interprets \n itself.
-	echo -E '
-};
-
-static int
-intcmp(const void *a, const void *b)
-{
-	return *(int*)a - *(int*)b;
-}
-
-int
-main(void)
-{
-	int i, j, e;
-	char buf[1024], *p;
-
-	printf("\n\n// Error table\n");
-	printf("var errors = [...]string {\n");
-	qsort(errors, nelem(errors), sizeof errors[0], intcmp);
-	for(i=0; i<nelem(errors); i++) {
-		e = errors[i];
-		if(i > 0 && errors[i-1] == e)
-			continue;
-		strcpy(buf, strerror(e));
-		// lowercase first letter: Bad -> bad, but STREAM -> STREAM.
-		if(A <= buf[0] && buf[0] <= Z && a <= buf[1] && buf[1] <= z)
-			buf[0] += a - A;
-		printf("\t%d: \"%s\",\n", e, buf);
-	}
-	printf("}\n\n");
-	
-	printf("\n\n// Signal table\n");
-	printf("var signals = [...]string {\n");
-	qsort(signals, nelem(signals), sizeof signals[0], intcmp);
-	for(i=0; i<nelem(signals); i++) {
-		e = signals[i];
-		if(i > 0 && signals[i-1] == e)
-			continue;
-		strcpy(buf, strsignal(e));
-		// lowercase first letter: Bad -> bad, but STREAM -> STREAM.
-		if(A <= buf[0] && buf[0] <= Z && a <= buf[1] && buf[1] <= z)
-			buf[0] += a - A;
-		// cut trailing : number.
-		p = strrchr(buf, ":"[0]);
-		if(p)
-			*p = '\0';
-		printf("\t%d: \"%s\",\n", e, buf);
-	}
-	printf("}\n\n");
-
-	return 0;
-}
-
-'
-) >_errors.c
-
-$CC $ccflags -o _errors _errors.c && $GORUN ./_errors && rm -f _errors.c _errors _const.go _error.grep _signal.grep _error.out
diff --git a/cmd/vendor/golang.org/x/sys/unix/mksyscall.pl b/cmd/vendor/golang.org/x/sys/unix/mksyscall.pl
deleted file mode 100755
index b1e7766..0000000
--- a/cmd/vendor/golang.org/x/sys/unix/mksyscall.pl
+++ /dev/null
@@ -1,323 +0,0 @@
-#!/usr/bin/env perl
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# This program reads a file containing function prototypes
-# (like syscall_darwin.go) and generates system call bodies.
-# The prototypes are marked by lines beginning with "//sys"
-# and read like func declarations if //sys is replaced by func, but:
-#	* The parameter lists must give a name for each argument.
-#	  This includes return parameters.
-#	* The parameter lists must give a type for each argument:
-#	  the (x, y, z int) shorthand is not allowed.
-#	* If the return parameter is an error number, it must be named errno.
-
-# A line beginning with //sysnb is like //sys, except that the
-# goroutine will not be suspended during the execution of the system
-# call.  This must only be used for system calls which can never
-# block, as otherwise the system call could cause all goroutines to
-# hang.
-
-use strict;
-
-my $cmdline = "mksyscall.pl " . join(' ', @ARGV);
-my $errors = 0;
-my $_32bit = "";
-my $plan9 = 0;
-my $openbsd = 0;
-my $netbsd = 0;
-my $dragonfly = 0;
-my $arm = 0; # 64-bit value should use (even, odd)-pair
-
-if($ARGV[0] eq "-b32") {
-	$_32bit = "big-endian";
-	shift;
-} elsif($ARGV[0] eq "-l32") {
-	$_32bit = "little-endian";
-	shift;
-}
-if($ARGV[0] eq "-plan9") {
-	$plan9 = 1;
-	shift;
-}
-if($ARGV[0] eq "-openbsd") {
-	$openbsd = 1;
-	shift;
-}
-if($ARGV[0] eq "-netbsd") {
-	$netbsd = 1;
-	shift;
-}
-if($ARGV[0] eq "-dragonfly") {
-	$dragonfly = 1;
-	shift;
-}
-if($ARGV[0] eq "-arm") {
-	$arm = 1;
-	shift;
-}
-
-if($ARGV[0] =~ /^-/) {
-	print STDERR "usage: mksyscall.pl [-b32 | -l32] [file ...]\n";
-	exit 1;
-}
-
-if($ENV{'GOARCH'} eq "" || $ENV{'GOOS'} eq "") {
-	print STDERR "GOARCH or GOOS not defined in environment\n";
-	exit 1;
-}
-
-sub parseparamlist($) {
-	my ($list) = @_;
-	$list =~ s/^\s*//;
-	$list =~ s/\s*$//;
-	if($list eq "") {
-		return ();
-	}
-	return split(/\s*,\s*/, $list);
-}
-
-sub parseparam($) {
-	my ($p) = @_;
-	if($p !~ /^(\S*) (\S*)$/) {
-		print STDERR "$ARGV:$.: malformed parameter: $p\n";
-		$errors = 1;
-		return ("xx", "int");
-	}
-	return ($1, $2);
-}
-
-my $text = "";
-while(<>) {
-	chomp;
-	s/\s+/ /g;
-	s/^\s+//;
-	s/\s+$//;
-	my $nonblock = /^\/\/sysnb /;
-	next if !/^\/\/sys / && !$nonblock;
-
-	# Line must be of the form
-	#	func Open(path string, mode int, perm int) (fd int, errno error)
-	# Split into name, in params, out params.
-	if(!/^\/\/sys(nb)? (\w+)\(([^()]*)\)\s*(?:\(([^()]+)\))?\s*(?:=\s*((?i)SYS_[A-Z0-9_]+))?$/) {
-		print STDERR "$ARGV:$.: malformed //sys declaration\n";
-		$errors = 1;
-		next;
-	}
-	my ($func, $in, $out, $sysname) = ($2, $3, $4, $5);
-
-	# Split argument lists on comma.
-	my @in = parseparamlist($in);
-	my @out = parseparamlist($out);
-
-	# Try in vain to keep people from editing this file.
-	# The theory is that they jump into the middle of the file
-	# without reading the header.
-	$text .= "// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n\n";
-
-	# Go function header.
-	my $out_decl = @out ? sprintf(" (%s)", join(', ', @out)) : "";
-	$text .= sprintf "func %s(%s)%s {\n", $func, join(', ', @in), $out_decl;
-
-	# Check if err return available
-	my $errvar = "";
-	foreach my $p (@out) {
-		my ($name, $type) = parseparam($p);
-		if($type eq "error") {
-			$errvar = $name;
-			last;
-		}
-	}
-
-	# Prepare arguments to Syscall.
-	my @args = ();
-	my @uses = ();
-	my $n = 0;
-	foreach my $p (@in) {
-		my ($name, $type) = parseparam($p);
-		if($type =~ /^\*/) {
-			push @args, "uintptr(unsafe.Pointer($name))";
-		} elsif($type eq "string" && $errvar ne "") {
-			$text .= "\tvar _p$n *byte\n";
-			$text .= "\t_p$n, $errvar = BytePtrFromString($name)\n";
-			$text .= "\tif $errvar != nil {\n\t\treturn\n\t}\n";
-			push @args, "uintptr(unsafe.Pointer(_p$n))";
-			push @uses, "use(unsafe.Pointer(_p$n))";
-			$n++;
-		} elsif($type eq "string") {
-			print STDERR "$ARGV:$.: $func uses string arguments, but has no error return\n";
-			$text .= "\tvar _p$n *byte\n";
-			$text .= "\t_p$n, _ = BytePtrFromString($name)\n";
-			push @args, "uintptr(unsafe.Pointer(_p$n))";
-			push @uses, "use(unsafe.Pointer(_p$n))";
-			$n++;
-		} elsif($type =~ /^\[\](.*)/) {
-			# Convert slice into pointer, length.
-			# Have to be careful not to take address of &a[0] if len == 0:
-			# pass dummy pointer in that case.
-			# Used to pass nil, but some OSes or simulators reject write(fd, nil, 0).
-			$text .= "\tvar _p$n unsafe.Pointer\n";
-			$text .= "\tif len($name) > 0 {\n\t\t_p$n = unsafe.Pointer(\&${name}[0])\n\t}";
-			$text .= " else {\n\t\t_p$n = unsafe.Pointer(&_zero)\n\t}";
-			$text .= "\n";
-			push @args, "uintptr(_p$n)", "uintptr(len($name))";
-			$n++;
-		} elsif($type eq "int64" && ($openbsd || $netbsd)) {
-			push @args, "0";
-			if($_32bit eq "big-endian") {
-				push @args, "uintptr($name>>32)", "uintptr($name)";
-			} elsif($_32bit eq "little-endian") {
-				push @args, "uintptr($name)", "uintptr($name>>32)";
-			} else {
-				push @args, "uintptr($name)";
-			}
-		} elsif($type eq "int64" && $dragonfly) {
-			if ($func !~ /^extp(read|write)/i) {
-				push @args, "0";
-			}
-			if($_32bit eq "big-endian") {
-				push @args, "uintptr($name>>32)", "uintptr($name)";
-			} elsif($_32bit eq "little-endian") {
-				push @args, "uintptr($name)", "uintptr($name>>32)";
-			} else {
-				push @args, "uintptr($name)";
-			}
-		} elsif($type eq "int64" && $_32bit ne "") {
-			if(@args % 2 && $arm) {
-				# arm abi specifies 64-bit argument uses 
-				# (even, odd) pair
-				push @args, "0"
-			}
-			if($_32bit eq "big-endian") {
-				push @args, "uintptr($name>>32)", "uintptr($name)";
-			} else {
-				push @args, "uintptr($name)", "uintptr($name>>32)";
-			}
-		} else {
-			push @args, "uintptr($name)";
-		}
-	}
-
-	# Determine which form to use; pad args with zeros.
-	my $asm = "Syscall";
-	if ($nonblock) {
-		$asm = "RawSyscall";
-	}
-	if(@args <= 3) {
-		while(@args < 3) {
-			push @args, "0";
-		}
-	} elsif(@args <= 6) {
-		$asm .= "6";
-		while(@args < 6) {
-			push @args, "0";
-		}
-	} elsif(@args <= 9) {
-		$asm .= "9";
-		while(@args < 9) {
-			push @args, "0";
-		}
-	} else {
-		print STDERR "$ARGV:$.: too many arguments to system call\n";
-	}
-
-	# System call number.
-	if($sysname eq "") {
-		$sysname = "SYS_$func";
-		$sysname =~ s/([a-z])([A-Z])/${1}_$2/g;	# turn FooBar into Foo_Bar
-		$sysname =~ y/a-z/A-Z/;
-	}
-
-	# Actual call.
-	my $args = join(', ', @args);
-	my $call = "$asm($sysname, $args)";
-
-	# Assign return values.
-	my $body = "";
-	my @ret = ("_", "_", "_");
-	my $do_errno = 0;
-	for(my $i=0; $i<@out; $i++) {
-		my $p = $out[$i];
-		my ($name, $type) = parseparam($p);
-		my $reg = "";
-		if($name eq "err" && !$plan9) {
-			$reg = "e1";
-			$ret[2] = $reg;
-			$do_errno = 1;
-		} elsif($name eq "err" && $plan9) {
-			$ret[0] = "r0";
-			$ret[2] = "e1";
-			next;
-		} else {
-			$reg = sprintf("r%d", $i);
-			$ret[$i] = $reg;
-		}
-		if($type eq "bool") {
-			$reg = "$reg != 0";
-		}
-		if($type eq "int64" && $_32bit ne "") {
-			# 64-bit number in r1:r0 or r0:r1.
-			if($i+2 > @out) {
-				print STDERR "$ARGV:$.: not enough registers for int64 return\n";
-			}
-			if($_32bit eq "big-endian") {
-				$reg = sprintf("int64(r%d)<<32 | int64(r%d)", $i, $i+1);
-			} else {
-				$reg = sprintf("int64(r%d)<<32 | int64(r%d)", $i+1, $i);
-			}
-			$ret[$i] = sprintf("r%d", $i);
-			$ret[$i+1] = sprintf("r%d", $i+1);
-		}
-		if($reg ne "e1" || $plan9) {
-			$body .= "\t$name = $type($reg)\n";
-		}
-	}
-	if ($ret[0] eq "_" && $ret[1] eq "_" && $ret[2] eq "_") {
-		$text .= "\t$call\n";
-	} else {
-		$text .= "\t$ret[0], $ret[1], $ret[2] := $call\n";
-	}
-	foreach my $use (@uses) {
-		$text .= "\t$use\n";
-	}
-	$text .= $body;
-	
-	if ($plan9 && $ret[2] eq "e1") {
-		$text .= "\tif int32(r0) == -1 {\n";
-		$text .= "\t\terr = e1\n";
-		$text .= "\t}\n";
-	} elsif ($do_errno) {
-		$text .= "\tif e1 != 0 {\n";
-		$text .= "\t\terr = errnoErr(e1)\n";
-		$text .= "\t}\n";
-	}
-	$text .= "\treturn\n";
-	$text .= "}\n\n";
-}
-
-chomp $text;
-chomp $text;
-
-if($errors) {
-	exit 1;
-}
-
-print <<EOF;
-// $cmdline
-// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
-
-// +build $ENV{'GOARCH'},$ENV{'GOOS'}
-
-package unix
-
-import (
-	"syscall"
-	"unsafe"
-)
-
-var _ syscall.Errno
-
-$text
-EOF
-exit 0;
diff --git a/cmd/vendor/golang.org/x/sys/unix/mksyscall_solaris.pl b/cmd/vendor/golang.org/x/sys/unix/mksyscall_solaris.pl
deleted file mode 100755
index f17b612..0000000
--- a/cmd/vendor/golang.org/x/sys/unix/mksyscall_solaris.pl
+++ /dev/null
@@ -1,294 +0,0 @@
-#!/usr/bin/env perl
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# This program reads a file containing function prototypes
-# (like syscall_solaris.go) and generates system call bodies.
-# The prototypes are marked by lines beginning with "//sys"
-# and read like func declarations if //sys is replaced by func, but:
-#	* The parameter lists must give a name for each argument.
-#	  This includes return parameters.
-#	* The parameter lists must give a type for each argument:
-#	  the (x, y, z int) shorthand is not allowed.
-#	* If the return parameter is an error number, it must be named err.
-#	* If go func name needs to be different than its libc name, 
-#	* or the function is not in libc, name could be specified
-#	* at the end, after "=" sign, like
-#	  //sys getsockopt(s int, level int, name int, val uintptr, vallen *_Socklen) (err error) = libsocket.getsockopt
-
-use strict;
-
-my $cmdline = "mksyscall_solaris.pl " . join(' ', @ARGV);
-my $errors = 0;
-my $_32bit = "";
-
-binmode STDOUT;
-
-if($ARGV[0] eq "-b32") {
-	$_32bit = "big-endian";
-	shift;
-} elsif($ARGV[0] eq "-l32") {
-	$_32bit = "little-endian";
-	shift;
-}
-
-if($ARGV[0] =~ /^-/) {
-	print STDERR "usage: mksyscall_solaris.pl [-b32 | -l32] [file ...]\n";
-	exit 1;
-}
-
-if($ENV{'GOARCH'} eq "" || $ENV{'GOOS'} eq "") {
-	print STDERR "GOARCH or GOOS not defined in environment\n";
-	exit 1;
-}
-
-sub parseparamlist($) {
-	my ($list) = @_;
-	$list =~ s/^\s*//;
-	$list =~ s/\s*$//;
-	if($list eq "") {
-		return ();
-	}
-	return split(/\s*,\s*/, $list);
-}
-
-sub parseparam($) {
-	my ($p) = @_;
-	if($p !~ /^(\S*) (\S*)$/) {
-		print STDERR "$ARGV:$.: malformed parameter: $p\n";
-		$errors = 1;
-		return ("xx", "int");
-	}
-	return ($1, $2);
-}
-
-my $package = "";
-my $text = "";
-my $dynimports = "";
-my $linknames = "";
-my @vars = ();
-while(<>) {
-	chomp;
-	s/\s+/ /g;
-	s/^\s+//;
-	s/\s+$//;
-	$package = $1 if !$package && /^package (\S+)$/;
-	my $nonblock = /^\/\/sysnb /;
-	next if !/^\/\/sys / && !$nonblock;
-
-	# Line must be of the form
-	#	func Open(path string, mode int, perm int) (fd int, err error)
-	# Split into name, in params, out params.
-	if(!/^\/\/sys(nb)? (\w+)\(([^()]*)\)\s*(?:\(([^()]+)\))?\s*(?:=\s*(?:(\w*)\.)?(\w*))?$/) {
-		print STDERR "$ARGV:$.: malformed //sys declaration\n";
-		$errors = 1;
-		next;
-	}
-	my ($nb, $func, $in, $out, $modname, $sysname) = ($1, $2, $3, $4, $5, $6);
-
-	# Split argument lists on comma.
-	my @in = parseparamlist($in);
-	my @out = parseparamlist($out);
-
-	# So file name.
-	if($modname eq "") {
-		$modname = "libc";
-	}
-
-	# System call name.
-	if($sysname eq "") {
-		$sysname = "$func";
-	}
-
-	# System call pointer variable name.
-	my $sysvarname = "proc$sysname";
-
-	my $strconvfunc = "BytePtrFromString";
-	my $strconvtype = "*byte";
-
-	$sysname =~ y/A-Z/a-z/; # All libc functions are lowercase.
-
-	# Runtime import of function to allow cross-platform builds.
-	$dynimports .= "//go:cgo_import_dynamic ${modname}_${sysname} ${sysname} \"$modname.so\"\n";
-	# Link symbol to proc address variable.
-	$linknames .= "//go:linkname ${sysvarname} ${modname}_${sysname}\n";
-	# Library proc address variable.
-	push @vars, $sysvarname;
-
-	# Go function header.
-	$out = join(', ', @out);
-	if($out ne "") {
-		$out = " ($out)";
-	}
-	if($text ne "") {
-		$text .= "\n"
-	}
-	$text .= sprintf "func %s(%s)%s {\n", $func, join(', ', @in), $out;
-
-	# Check if err return available
-	my $errvar = "";
-	foreach my $p (@out) {
-		my ($name, $type) = parseparam($p);
-		if($type eq "error") {
-			$errvar = $name;
-			last;
-		}
-	}
-
-	# Prepare arguments to Syscall.
-	my @args = ();
-	my @uses = ();
-	my $n = 0;
-	foreach my $p (@in) {
-		my ($name, $type) = parseparam($p);
-		if($type =~ /^\*/) {
-			push @args, "uintptr(unsafe.Pointer($name))";
-		} elsif($type eq "string" && $errvar ne "") {
-			$text .= "\tvar _p$n $strconvtype\n";
-			$text .= "\t_p$n, $errvar = $strconvfunc($name)\n";
-			$text .= "\tif $errvar != nil {\n\t\treturn\n\t}\n";
-			push @args, "uintptr(unsafe.Pointer(_p$n))";
-			push @uses, "use(unsafe.Pointer(_p$n))";
-			$n++;
-		} elsif($type eq "string") {
-			print STDERR "$ARGV:$.: $func uses string arguments, but has no error return\n";
-			$text .= "\tvar _p$n $strconvtype\n";
-			$text .= "\t_p$n, _ = $strconvfunc($name)\n";
-			push @args, "uintptr(unsafe.Pointer(_p$n))";
-			push @uses, "use(unsafe.Pointer(_p$n))";
-			$n++;
-		} elsif($type =~ /^\[\](.*)/) {
-			# Convert slice into pointer, length.
-			# Have to be careful not to take address of &a[0] if len == 0:
-			# pass nil in that case.
-			$text .= "\tvar _p$n *$1\n";
-			$text .= "\tif len($name) > 0 {\n\t\t_p$n = \&$name\[0]\n\t}\n";
-			push @args, "uintptr(unsafe.Pointer(_p$n))", "uintptr(len($name))";
-			$n++;
-		} elsif($type eq "int64" && $_32bit ne "") {
-			if($_32bit eq "big-endian") {
-				push @args, "uintptr($name >> 32)", "uintptr($name)";
-			} else {
-				push @args, "uintptr($name)", "uintptr($name >> 32)";
-			}
-		} elsif($type eq "bool") {
- 			$text .= "\tvar _p$n uint32\n";
-			$text .= "\tif $name {\n\t\t_p$n = 1\n\t} else {\n\t\t_p$n = 0\n\t}\n";
-			push @args, "uintptr(_p$n)";
-			$n++;
-		} else {
-			push @args, "uintptr($name)";
-		}
-	}
-	my $nargs = @args;
-
-	# Determine which form to use; pad args with zeros.
-	my $asm = "sysvicall6";
-	if ($nonblock) {
-		$asm = "rawSysvicall6";
-	}
-	if(@args <= 6) {
-		while(@args < 6) {
-			push @args, "0";
-		}
-	} else {
-		print STDERR "$ARGV:$.: too many arguments to system call\n";
-	}
-
-	# Actual call.
-	my $args = join(', ', @args);
-	my $call = "$asm(uintptr(unsafe.Pointer(&$sysvarname)), $nargs, $args)";
-
-	# Assign return values.
-	my $body = "";
-	my $failexpr = "";
-	my @ret = ("_", "_", "_");
-	my @pout= ();
-	my $do_errno = 0;
-	for(my $i=0; $i<@out; $i++) {
-		my $p = $out[$i];
-		my ($name, $type) = parseparam($p);
-		my $reg = "";
-		if($name eq "err") {
-			$reg = "e1";
-			$ret[2] = $reg;
-			$do_errno = 1;
-		} else {
-			$reg = sprintf("r%d", $i);
-			$ret[$i] = $reg;
-		}
-		if($type eq "bool") {
-			$reg = "$reg != 0";
-		}
-		if($type eq "int64" && $_32bit ne "") {
-			# 64-bit number in r1:r0 or r0:r1.
-			if($i+2 > @out) {
-				print STDERR "$ARGV:$.: not enough registers for int64 return\n";
-			}
-			if($_32bit eq "big-endian") {
-				$reg = sprintf("int64(r%d)<<32 | int64(r%d)", $i, $i+1);
-			} else {
-				$reg = sprintf("int64(r%d)<<32 | int64(r%d)", $i+1, $i);
-			}
-			$ret[$i] = sprintf("r%d", $i);
-			$ret[$i+1] = sprintf("r%d", $i+1);
-		}
-		if($reg ne "e1") {
-			$body .= "\t$name = $type($reg)\n";
-		}
-	}
-	if ($ret[0] eq "_" && $ret[1] eq "_" && $ret[2] eq "_") {
-		$text .= "\t$call\n";
-	} else {
-		$text .= "\t$ret[0], $ret[1], $ret[2] := $call\n";
-	}
-	foreach my $use (@uses) {
-		$text .= "\t$use\n";
-	}
-	$text .= $body;
-
-	if ($do_errno) {
-		$text .= "\tif e1 != 0 {\n";
-		$text .= "\t\terr = e1\n";
-		$text .= "\t}\n";
-	}
-	$text .= "\treturn\n";
-	$text .= "}\n";
-}
-
-if($errors) {
-	exit 1;
-}
-
-print <<EOF;
-// $cmdline
-// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
-
-// +build $ENV{'GOARCH'},$ENV{'GOOS'}
-
-package $package
-
-import (
-	"syscall"
-	"unsafe"
-)
-EOF
-
-print "import \"golang.org/x/sys/unix\"\n" if $package ne "unix";
-
-my $vardecls = "\t" . join(",\n\t", @vars);
-$vardecls .= " syscallFunc";
-
-chomp($_=<<EOF);
-
-$dynimports
-$linknames
-var (
-$vardecls
-)
-
-$text
-EOF
-print $_;
-exit 0;
diff --git a/cmd/vendor/golang.org/x/sys/unix/mksysctl_openbsd.pl b/cmd/vendor/golang.org/x/sys/unix/mksysctl_openbsd.pl
deleted file mode 100755
index be67afa..0000000
--- a/cmd/vendor/golang.org/x/sys/unix/mksysctl_openbsd.pl
+++ /dev/null
@@ -1,264 +0,0 @@
-#!/usr/bin/env perl
-
-# Copyright 2011 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-#
-# Parse the header files for OpenBSD and generate a Go usable sysctl MIB.
-#
-# Build a MIB with each entry being an array containing the level, type and
-# a hash that will contain additional entries if the current entry is a node.
-# We then walk this MIB and create a flattened sysctl name to OID hash.
-#
-
-use strict;
-
-if($ENV{'GOARCH'} eq "" || $ENV{'GOOS'} eq "") {
-	print STDERR "GOARCH or GOOS not defined in environment\n";
-	exit 1;
-}
-
-my $debug = 0;
-my %ctls = ();
-
-my @headers = qw (
-	sys/sysctl.h
-	sys/socket.h
-	sys/tty.h
-	sys/malloc.h
-	sys/mount.h
-	sys/namei.h
-	sys/sem.h
-	sys/shm.h
-	sys/vmmeter.h
-	uvm/uvm_param.h
-	uvm/uvm_swap_encrypt.h
-	ddb/db_var.h
-	net/if.h
-	net/if_pfsync.h
-	net/pipex.h
-	netinet/in.h
-	netinet/icmp_var.h
-	netinet/igmp_var.h
-	netinet/ip_ah.h
-	netinet/ip_carp.h
-	netinet/ip_divert.h
-	netinet/ip_esp.h
-	netinet/ip_ether.h
-	netinet/ip_gre.h
-	netinet/ip_ipcomp.h
-	netinet/ip_ipip.h
-	netinet/pim_var.h
-	netinet/tcp_var.h
-	netinet/udp_var.h
-	netinet6/in6.h
-	netinet6/ip6_divert.h
-	netinet6/pim6_var.h
-	netinet/icmp6.h
-	netmpls/mpls.h
-);
-
-my @ctls = qw (
-	kern
-	vm
-	fs
-	net
-	#debug				# Special handling required
-	hw
-	#machdep			# Arch specific
-	user
-	ddb
-	#vfs				# Special handling required
-	fs.posix
-	kern.forkstat
-	kern.intrcnt
-	kern.malloc
-	kern.nchstats
-	kern.seminfo
-	kern.shminfo
-	kern.timecounter
-	kern.tty
-	kern.watchdog
-	net.bpf
-	net.ifq
-	net.inet
-	net.inet.ah
-	net.inet.carp
-	net.inet.divert
-	net.inet.esp
-	net.inet.etherip
-	net.inet.gre
-	net.inet.icmp
-	net.inet.igmp
-	net.inet.ip
-	net.inet.ip.ifq
-	net.inet.ipcomp
-	net.inet.ipip
-	net.inet.mobileip
-	net.inet.pfsync
-	net.inet.pim
-	net.inet.tcp
-	net.inet.udp
-	net.inet6
-	net.inet6.divert
-	net.inet6.ip6
-	net.inet6.icmp6
-	net.inet6.pim6
-	net.inet6.tcp6
-	net.inet6.udp6
-	net.mpls
-	net.mpls.ifq
-	net.key
-	net.pflow
-	net.pfsync
-	net.pipex
-	net.rt
-	vm.swapencrypt
-	#vfsgenctl			# Special handling required
-);
-
-# Node name "fixups"
-my %ctl_map = (
-	"ipproto" => "net.inet",
-	"net.inet.ipproto" => "net.inet",
-	"net.inet6.ipv6proto" => "net.inet6",
-	"net.inet6.ipv6" => "net.inet6.ip6",
-	"net.inet.icmpv6" => "net.inet6.icmp6",
-	"net.inet6.divert6" => "net.inet6.divert",
-	"net.inet6.tcp6" => "net.inet.tcp",
-	"net.inet6.udp6" => "net.inet.udp",
-	"mpls" => "net.mpls",
-	"swpenc" => "vm.swapencrypt"
-);
-
-# Node mappings
-my %node_map = (
-	"net.inet.ip.ifq" => "net.ifq",
-	"net.inet.pfsync" => "net.pfsync",
-	"net.mpls.ifq" => "net.ifq"
-);
-
-my $ctlname;
-my %mib = ();
-my %sysctl = ();
-my $node;
-
-sub debug() {
-	print STDERR "$_[0]\n" if $debug;
-}
-
-# Walk the MIB and build a sysctl name to OID mapping.
-sub build_sysctl() {
-	my ($node, $name, $oid) = @_;
-	my %node = %{$node};
-	my @oid = @{$oid};
-
-	foreach my $key (sort keys %node) {
-		my @node = @{$node{$key}};
-		my $nodename = $name.($name ne '' ? '.' : '').$key;
-		my @nodeoid = (@oid, $node[0]);
-		if ($node[1] eq 'CTLTYPE_NODE') {
-			if (exists $node_map{$nodename}) {
-				$node = \%mib;
-				$ctlname = $node_map{$nodename};
-				foreach my $part (split /\./, $ctlname) {
-					$node = \%{@{$$node{$part}}[2]};
-				}
-			} else {
-				$node = $node[2];
-			}
-			&build_sysctl($node, $nodename, \@nodeoid);
-		} elsif ($node[1] ne '') {
-			$sysctl{$nodename} = \@nodeoid;
-		}
-	}
-}
-
-foreach my $ctl (@ctls) {
-	$ctls{$ctl} = $ctl;
-}
-
-# Build MIB
-foreach my $header (@headers) {
-	&debug("Processing $header...");
-	open HEADER, "/usr/include/$header" ||
-	    print STDERR "Failed to open $header\n";
-	while (<HEADER>) {
-		if ($_ =~ /^#define\s+(CTL_NAMES)\s+{/ ||
-		    $_ =~ /^#define\s+(CTL_(.*)_NAMES)\s+{/ ||
-		    $_ =~ /^#define\s+((.*)CTL_NAMES)\s+{/) {
-			if ($1 eq 'CTL_NAMES') {
-				# Top level.
-				$node = \%mib;
-			} else {
-				# Node.
-				my $nodename = lc($2);
-				if ($header =~ /^netinet\//) {
-					$ctlname = "net.inet.$nodename";
-				} elsif ($header =~ /^netinet6\//) {
-					$ctlname = "net.inet6.$nodename";
-				} elsif ($header =~ /^net\//) {
-					$ctlname = "net.$nodename";
-				} else {
-					$ctlname = "$nodename";
-					$ctlname =~ s/^(fs|net|kern)_/$1\./;
-				}
-				if (exists $ctl_map{$ctlname}) {
-					$ctlname = $ctl_map{$ctlname};
-				}
-				if (not exists $ctls{$ctlname}) {
-					&debug("Ignoring $ctlname...");
-					next;
-				}
-
-				# Walk down from the top of the MIB.
-				$node = \%mib;
-				foreach my $part (split /\./, $ctlname) {
-					if (not exists $$node{$part}) {
-						&debug("Missing node $part");
-						$$node{$part} = [ 0, '', {} ];
-					}
-					$node = \%{@{$$node{$part}}[2]};
-				}
-			}
-
-			# Populate current node with entries.
-			my $i = -1;
-			while (defined($_) && $_ !~ /^}/) {
-				$_ = <HEADER>;
-				$i++ if $_ =~ /{.*}/;
-				next if $_ !~ /{\s+"(\w+)",\s+(CTLTYPE_[A-Z]+)\s+}/;
-				$$node{$1} = [ $i, $2, {} ];
-			}
-		}
-	}
-	close HEADER;
-}
-
-&build_sysctl(\%mib, "", []);
-
-print <<EOF;
-// mksysctl_openbsd.pl
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT
-
-// +build $ENV{'GOARCH'},$ENV{'GOOS'}
-
-package unix;
-
-type mibentry struct {
-	ctlname string
-	ctloid []_C_int
-}
-
-var sysctlMib = []mibentry {
-EOF
-
-foreach my $name (sort keys %sysctl) {
-	my @oid = @{$sysctl{$name}};
-	print "\t{ \"$name\", []_C_int{ ", join(', ', @oid), " } }, \n";
-}
-
-print <<EOF;
-}
-EOF
diff --git a/cmd/vendor/golang.org/x/sys/unix/mksysnum_darwin.pl b/cmd/vendor/golang.org/x/sys/unix/mksysnum_darwin.pl
deleted file mode 100755
index d3e5147..0000000
--- a/cmd/vendor/golang.org/x/sys/unix/mksysnum_darwin.pl
+++ /dev/null
@@ -1,39 +0,0 @@
-#!/usr/bin/env perl
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-#
-# Generate system call table for Darwin from sys/syscall.h
-
-use strict;
-
-if($ENV{'GOARCH'} eq "" || $ENV{'GOOS'} eq "") {
-	print STDERR "GOARCH or GOOS not defined in environment\n";
-	exit 1;
-}
-
-my $command = "mksysnum_darwin.pl " . join(' ', @ARGV);
-
-print <<EOF;
-// $command
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT
-
-// +build $ENV{'GOARCH'},$ENV{'GOOS'}
-
-package unix
-
-const (
-EOF
-
-while(<>){
-	if(/^#define\s+SYS_(\w+)\s+([0-9]+)/){
-		my $name = $1;
-		my $num = $2;
-		$name =~ y/a-z/A-Z/;
-		print "	SYS_$name = $num;"
-	}
-}
-
-print <<EOF;
-)
-EOF
diff --git a/cmd/vendor/golang.org/x/sys/unix/mksysnum_dragonfly.pl b/cmd/vendor/golang.org/x/sys/unix/mksysnum_dragonfly.pl
deleted file mode 100755
index 266a248..0000000
--- a/cmd/vendor/golang.org/x/sys/unix/mksysnum_dragonfly.pl
+++ /dev/null
@@ -1,50 +0,0 @@
-#!/usr/bin/env perl
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-#
-# Generate system call table for DragonFly from master list
-# (for example, /usr/src/sys/kern/syscalls.master).
-
-use strict;
-
-if($ENV{'GOARCH'} eq "" || $ENV{'GOOS'} eq "") {
-	print STDERR "GOARCH or GOOS not defined in environment\n";
-	exit 1;
-}
-
-my $command = "mksysnum_dragonfly.pl " . join(' ', @ARGV);
-
-print <<EOF;
-// $command
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT
-
-// +build $ENV{'GOARCH'},$ENV{'GOOS'}
-
-package unix
-
-const (
-EOF
-
-while(<>){
-	if(/^([0-9]+)\s+STD\s+({ \S+\s+(\w+).*)$/){
-		my $num = $1;
-		my $proto = $2;
-		my $name = "SYS_$3";
-		$name =~ y/a-z/A-Z/;
-
-		# There are multiple entries for enosys and nosys, so comment them out.
-		if($name =~ /^SYS_E?NOSYS$/){
-			$name = "// $name";
-		}
-		if($name eq 'SYS_SYS_EXIT'){
-			$name = 'SYS_EXIT';
-		}
-
-		print "	$name = $num;  // $proto\n";
-	}
-}
-
-print <<EOF;
-)
-EOF
diff --git a/cmd/vendor/golang.org/x/sys/unix/mksysnum_freebsd.pl b/cmd/vendor/golang.org/x/sys/unix/mksysnum_freebsd.pl
deleted file mode 100755
index b767e12..0000000
--- a/cmd/vendor/golang.org/x/sys/unix/mksysnum_freebsd.pl
+++ /dev/null
@@ -1,63 +0,0 @@
-#!/usr/bin/env perl
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-#
-# Generate system call table for FreeBSD from master list
-# (for example, /usr/src/sys/kern/syscalls.master).
-
-use strict;
-
-if($ENV{'GOARCH'} eq "" || $ENV{'GOOS'} eq "") {
-	print STDERR "GOARCH or GOOS not defined in environment\n";
-	exit 1;
-}
-
-my $command = "mksysnum_freebsd.pl " . join(' ', @ARGV);
-
-print <<EOF;
-// $command
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT
-
-// +build $ENV{'GOARCH'},$ENV{'GOOS'}
-
-package unix
-
-const (
-EOF
-
-while(<>){
-	if(/^([0-9]+)\s+\S+\s+STD\s+({ \S+\s+(\w+).*)$/){
-		my $num = $1;
-		my $proto = $2;
-		my $name = "SYS_$3";
-		$name =~ y/a-z/A-Z/;
-
-		# There are multiple entries for enosys and nosys, so comment them out.
-		if($name =~ /^SYS_E?NOSYS$/){
-			$name = "// $name";
-		}
-		if($name eq 'SYS_SYS_EXIT'){
-			$name = 'SYS_EXIT';
-		}
-		if($name =~ /^SYS_CAP_+/ || $name =~ /^SYS___CAP_+/){
-			next
-		}
-
-		print "	$name = $num;  // $proto\n";
-
-		# We keep Capsicum syscall numbers for FreeBSD
-		# 9-STABLE here because we are not sure whether they
-		# are mature and stable.
-		if($num == 513){
-			print " SYS_CAP_NEW = 514 // { int cap_new(int fd, uint64_t rights); }\n";
-			print " SYS_CAP_GETRIGHTS = 515 // { int cap_getrights(int fd, \\\n";
-			print " SYS_CAP_ENTER = 516 // { int cap_enter(void); }\n";
-			print " SYS_CAP_GETMODE = 517 // { int cap_getmode(u_int *modep); }\n";
-		}
-	}
-}
-
-print <<EOF;
-)
-EOF
diff --git a/cmd/vendor/golang.org/x/sys/unix/mksysnum_linux.pl b/cmd/vendor/golang.org/x/sys/unix/mksysnum_linux.pl
deleted file mode 100755
index 4d4017d..0000000
--- a/cmd/vendor/golang.org/x/sys/unix/mksysnum_linux.pl
+++ /dev/null
@@ -1,58 +0,0 @@
-#!/usr/bin/env perl
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-use strict;
-
-if($ENV{'GOARCH'} eq "" || $ENV{'GOOS'} eq "") {
-	print STDERR "GOARCH or GOOS not defined in environment\n";
-	exit 1;
-}
-
-my $command = "mksysnum_linux.pl ". join(' ', @ARGV);
-
-print <<EOF;
-// $command
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT
-
-// +build $ENV{'GOARCH'},$ENV{'GOOS'}
-
-package unix
-
-const(
-EOF
-
-sub fmt {
-	my ($name, $num) = @_;
-	if($num > 999){
-		# ignore deprecated syscalls that are no longer implemented
-		# https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/asm-generic/unistd.h?id=refs/heads/master#n716
-		return;
-	}
-	$name =~ y/a-z/A-Z/;
-	print "	SYS_$name = $num;\n";
-}
-
-my $prev;
-open(GCC, "gcc -E -dD $ARGV[0] |") || die "can't run gcc";
-while(<GCC>){
-	if(/^#define __NR_syscalls\s+/) {
-		# ignore redefinitions of __NR_syscalls
-	}
-	elsif(/^#define __NR_(\w+)\s+([0-9]+)/){
-		$prev = $2;
-		fmt($1, $2);
-	}
-	elsif(/^#define __NR3264_(\w+)\s+([0-9]+)/){
-		$prev = $2;
-		fmt($1, $2);
-	}
-	elsif(/^#define __NR_(\w+)\s+\(\w+\+\s*([0-9]+)\)/){
-		fmt($1, $prev+$2)
-	}
-}
-
-print <<EOF;
-)
-EOF
diff --git a/cmd/vendor/golang.org/x/sys/unix/mksysnum_netbsd.pl b/cmd/vendor/golang.org/x/sys/unix/mksysnum_netbsd.pl
deleted file mode 100755
index e74616a..0000000
--- a/cmd/vendor/golang.org/x/sys/unix/mksysnum_netbsd.pl
+++ /dev/null
@@ -1,58 +0,0 @@
-#!/usr/bin/env perl
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-#
-# Generate system call table for OpenBSD from master list
-# (for example, /usr/src/sys/kern/syscalls.master).
-
-use strict;
-
-if($ENV{'GOARCH'} eq "" || $ENV{'GOOS'} eq "") {
-	print STDERR "GOARCH or GOOS not defined in environment\n";
-	exit 1;
-}
-
-my $command = "mksysnum_netbsd.pl " . join(' ', @ARGV);
-
-print <<EOF;
-// $command
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT
-
-// +build $ENV{'GOARCH'},$ENV{'GOOS'}
-
-package unix
-
-const (
-EOF
-
-my $line = '';
-while(<>){
-	if($line =~ /^(.*)\\$/) {
-		# Handle continuation
-		$line = $1;
-		$_ =~ s/^\s+//;
-		$line .= $_;
-	} else {
-		# New line
-		$line = $_;
-	}
-	next if $line =~ /\\$/;
-	if($line =~ /^([0-9]+)\s+((STD)|(NOERR))\s+(RUMP\s+)?({\s+\S+\s*\*?\s*\|(\S+)\|(\S*)\|(\w+).*\s+})(\s+(\S+))?$/) {
-		my $num = $1;
-		my $proto = $6;
-		my $compat = $8;
-		my $name = "$7_$9";
-
-		$name = "$7_$11" if $11 ne '';
-		$name =~ y/a-z/A-Z/;
-
-		if($compat eq '' || $compat eq '30' || $compat eq '50') {
-			print "	$name = $num;  // $proto\n";
-		}
-	}
-}
-
-print <<EOF;
-)
-EOF
diff --git a/cmd/vendor/golang.org/x/sys/unix/mksysnum_openbsd.pl b/cmd/vendor/golang.org/x/sys/unix/mksysnum_openbsd.pl
deleted file mode 100755
index ae5aad5..0000000
--- a/cmd/vendor/golang.org/x/sys/unix/mksysnum_openbsd.pl
+++ /dev/null
@@ -1,50 +0,0 @@
-#!/usr/bin/env perl
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-#
-# Generate system call table for OpenBSD from master list
-# (for example, /usr/src/sys/kern/syscalls.master).
-
-use strict;
-
-if($ENV{'GOARCH'} eq "" || $ENV{'GOOS'} eq "") {
-	print STDERR "GOARCH or GOOS not defined in environment\n";
-	exit 1;
-}
-
-my $command = "mksysnum_openbsd.pl " . join(' ', @ARGV);
-
-print <<EOF;
-// $command
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT
-
-// +build $ENV{'GOARCH'},$ENV{'GOOS'}
-
-package unix
-
-const (
-EOF
-
-while(<>){
-	if(/^([0-9]+)\s+STD\s+(NOLOCK\s+)?({ \S+\s+\*?(\w+).*)$/){
-		my $num = $1;
-		my $proto = $3;
-		my $name = $4;
-		$name =~ y/a-z/A-Z/;
-
-		# There are multiple entries for enosys and nosys, so comment them out.
-		if($name =~ /^SYS_E?NOSYS$/){
-			$name = "// $name";
-		}
-		if($name eq 'SYS_SYS_EXIT'){
-			$name = 'SYS_EXIT';
-		}
-
-		print "	$name = $num;  // $proto\n";
-	}
-}
-
-print <<EOF;
-)
-EOF
diff --git a/cmd/vendor/golang.org/x/sys/unix/syscall.go b/cmd/vendor/golang.org/x/sys/unix/syscall.go
index a48d47c..6442a99 100644
--- a/cmd/vendor/golang.org/x/sys/unix/syscall.go
+++ b/cmd/vendor/golang.org/x/sys/unix/syscall.go
@@ -19,7 +19,7 @@
 // These calls return err == nil to indicate success; otherwise
 // err represents an operating system error describing the failure and
 // holds a value of type syscall.Errno.
-package unix
+package unix // import "golang.org/x/sys/unix"
 
 import "unsafe"
 
diff --git a/cmd/vendor/google.golang.org/grpc/.travis.yml b/cmd/vendor/google.golang.org/grpc/.travis.yml
deleted file mode 100644
index 9bc2c12..0000000
--- a/cmd/vendor/google.golang.org/grpc/.travis.yml
+++ /dev/null
@@ -1,17 +0,0 @@
-language: go
-
-go:
-  - 1.5.3
-  - 1.6
-
-before_install:
-  - go get github.com/axw/gocov/gocov
-  - go get github.com/mattn/goveralls
-  - go get golang.org/x/tools/cmd/cover
-
-install:
-  - mkdir -p "$GOPATH/src/google.golang.org"
-  - mv "$TRAVIS_BUILD_DIR" "$GOPATH/src/google.golang.org/grpc"
-
-script:
-  - make test testrace
diff --git a/cmd/vendor/google.golang.org/grpc/CONTRIBUTING.md b/cmd/vendor/google.golang.org/grpc/CONTRIBUTING.md
deleted file mode 100644
index 36cd6f7..0000000
--- a/cmd/vendor/google.golang.org/grpc/CONTRIBUTING.md
+++ /dev/null
@@ -1,46 +0,0 @@
-# How to contribute
-
-We definitely welcome patches and contribution to grpc! Here are some guidelines
-and information about how to do so.
-
-## Sending patches
-
-### Getting started
-
-1. Check out the code:
-
-        $ go get google.golang.org/grpc
-        $ cd $GOPATH/src/google.golang.org/grpc
-
-1. Create a fork of the grpc-go repository.
-1. Add your fork as a remote:
-
-        $ git remote add fork git@github.com:$YOURGITHUBUSERNAME/grpc-go.git
-
-1. Make changes, commit them.
-1. Run the test suite:
-
-        $ make test
-
-1. Push your changes to your fork:
-
-        $ git push fork ...
-
-1. Open a pull request.
-
-## Legal requirements
-
-In order to protect both you and ourselves, you will need to sign the
-[Contributor License Agreement](https://cla.developers.google.com/clas).
-
-## Filing Issues
-When filing an issue, make sure to answer these five questions:
-
-1. What version of Go are you using (`go version`)?
-2. What operating system and processor architecture are you using?
-3. What did you do?
-4. What did you expect to see?
-5. What did you see instead?
-
-### Contributing code
-Unless otherwise noted, the Go source files are distributed under the BSD-style license found in the LICENSE file.
diff --git a/cmd/vendor/google.golang.org/grpc/Makefile b/cmd/vendor/google.golang.org/grpc/Makefile
deleted file mode 100644
index 03bb01f..0000000
--- a/cmd/vendor/google.golang.org/grpc/Makefile
+++ /dev/null
@@ -1,52 +0,0 @@
-all: test testrace
-
-deps:
-	go get -d -v google.golang.org/grpc/...
-
-updatedeps:
-	go get -d -v -u -f google.golang.org/grpc/...
-
-testdeps:
-	go get -d -v -t google.golang.org/grpc/...
-
-updatetestdeps:
-	go get -d -v -t -u -f google.golang.org/grpc/...
-
-build: deps
-	go build google.golang.org/grpc/...
-
-proto:
-	@ if ! which protoc > /dev/null; then \
-		echo "error: protoc not installed" >&2; \
-		exit 1; \
-	fi
-	go get -u -v github.com/golang/protobuf/protoc-gen-go
-	# use $$dir as the root for all proto files in the same directory
-	for dir in $$(git ls-files '*.proto' | xargs -n1 dirname | uniq); do \
-		protoc -I $$dir --go_out=plugins=grpc:$$dir $$dir/*.proto; \
-	done
-
-test: testdeps
-	go test -v -cpu 1,4 google.golang.org/grpc/...
-
-testrace: testdeps
-	go test -v -race -cpu 1,4 google.golang.org/grpc/...
-
-clean:
-	go clean -i google.golang.org/grpc/...
-
-coverage: testdeps
-	./coverage.sh --coveralls
-
-.PHONY: \
-	all \
-	deps \
-	updatedeps \
-	testdeps \
-	updatetestdeps \
-	build \
-	proto \
-	test \
-	testrace \
-	clean \
-	coverage
diff --git a/cmd/vendor/google.golang.org/grpc/README.md b/cmd/vendor/google.golang.org/grpc/README.md
deleted file mode 100644
index 90e9453..0000000
--- a/cmd/vendor/google.golang.org/grpc/README.md
+++ /dev/null
@@ -1,32 +0,0 @@
-#gRPC-Go
-
-[![Build Status](https://travis-ci.org/grpc/grpc-go.svg)](https://travis-ci.org/grpc/grpc-go) [![GoDoc](https://godoc.org/google.golang.org/grpc?status.svg)](https://godoc.org/google.golang.org/grpc)
-
-The Go implementation of [gRPC](http://www.grpc.io/): A high performance, open source, general RPC framework that puts mobile and HTTP/2 first. For more information see the [gRPC Quick Start](http://www.grpc.io/docs/) guide.
-
-Installation
-------------
-
-To install this package, you need to install Go and setup your Go workspace on your computer. The simplest way to install the library is to run:
-
-```
-$ go get google.golang.org/grpc
-```
-
-Prerequisites
--------------
-
-This requires Go 1.5 or later .
-
-Constraints
------------
-The grpc package should only depend on standard Go packages and a small number of exceptions. If your contribution introduces new dependencies which are NOT in the [list](http://godoc.org/google.golang.org/grpc?imports), you need a discussion with gRPC-Go authors and consultants.
-
-Documentation
--------------
-See [API documentation](https://godoc.org/google.golang.org/grpc) for package and API descriptions and find examples in the [examples directory](examples/).
-
-Status
-------
-Beta release
-
diff --git a/cmd/vendor/google.golang.org/grpc/codegen.sh b/cmd/vendor/google.golang.org/grpc/codegen.sh
deleted file mode 100755
index b009488..0000000
--- a/cmd/vendor/google.golang.org/grpc/codegen.sh
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/bin/bash
-
-# This script serves as an example to demonstrate how to generate the gRPC-Go
-# interface and the related messages from .proto file.
-#
-# It assumes the installation of i) Google proto buffer compiler at
-# https://github.com/google/protobuf (after v2.6.1) and ii) the Go codegen
-# plugin at https://github.com/golang/protobuf (after 2015-02-20). If you have
-# not, please install them first.
-#
-# We recommend running this script at $GOPATH/src.
-#
-# If this is not what you need, feel free to make your own scripts. Again, this
-# script is for demonstration purpose.
-#
-proto=$1
-protoc --go_out=plugins=grpc:. $proto
diff --git a/cmd/vendor/google.golang.org/grpc/codes/codes.go b/cmd/vendor/google.golang.org/grpc/codes/codes.go
index 37c5b86..e14b464 100644
--- a/cmd/vendor/google.golang.org/grpc/codes/codes.go
+++ b/cmd/vendor/google.golang.org/grpc/codes/codes.go
@@ -33,7 +33,7 @@
 
 // Package codes defines the canonical error codes used by gRPC. It is
 // consistent across various languages.
-package codes
+package codes // import "google.golang.org/grpc/codes"
 
 // A Code is an unsigned 32-bit error code as defined in the gRPC spec.
 type Code uint32
diff --git a/cmd/vendor/google.golang.org/grpc/coverage.sh b/cmd/vendor/google.golang.org/grpc/coverage.sh
deleted file mode 100755
index 1202353..0000000
--- a/cmd/vendor/google.golang.org/grpc/coverage.sh
+++ /dev/null
@@ -1,47 +0,0 @@
-#!/bin/bash
-
-set -e
-
-workdir=.cover
-profile="$workdir/cover.out"
-mode=set
-end2endtest="google.golang.org/grpc/test"
-
-generate_cover_data() {
-    rm -rf "$workdir"
-    mkdir "$workdir"
-
-    for pkg in "$@"; do
-        if [ $pkg == "google.golang.org/grpc" -o $pkg == "google.golang.org/grpc/transport" -o $pkg == "google.golang.org/grpc/metadata" -o $pkg == "google.golang.org/grpc/credentials" ]
-            then
-                f="$workdir/$(echo $pkg | tr / -)"
-                go test -covermode="$mode" -coverprofile="$f.cover" "$pkg"
-                go test -covermode="$mode" -coverpkg "$pkg" -coverprofile="$f.e2e.cover" "$end2endtest"
-        fi
-    done
-
-    echo "mode: $mode" >"$profile"
-    grep -h -v "^mode:" "$workdir"/*.cover >>"$profile"
-}
-
-show_cover_report() {
-    go tool cover -${1}="$profile"
-}
-
-push_to_coveralls() {
-    goveralls -coverprofile="$profile"
-}
-
-generate_cover_data $(go list ./...)
-show_cover_report func
-case "$1" in
-"")
-    ;;
---html)
-    show_cover_report html ;;
---coveralls)
-    push_to_coveralls ;;
-*)
-    echo >&2 "error: invalid option: $1" ;;
-esac
-rm -rf "$workdir"
diff --git a/cmd/vendor/google.golang.org/grpc/credentials/credentials.go b/cmd/vendor/google.golang.org/grpc/credentials/credentials.go
index b021e1e..8d4c57c 100644
--- a/cmd/vendor/google.golang.org/grpc/credentials/credentials.go
+++ b/cmd/vendor/google.golang.org/grpc/credentials/credentials.go
@@ -35,7 +35,7 @@
 // which encapsulate all the state needed by a client to authenticate with a
 // server and make various assertions, e.g., about the client's identity, role,
 // or whether it is authorized to make a particular call.
-package credentials
+package credentials // import "google.golang.org/grpc/credentials"
 
 import (
 	"crypto/tls"
diff --git a/cmd/vendor/google.golang.org/grpc/doc.go b/cmd/vendor/google.golang.org/grpc/doc.go
index b4c0e74..a35f218 100644
--- a/cmd/vendor/google.golang.org/grpc/doc.go
+++ b/cmd/vendor/google.golang.org/grpc/doc.go
@@ -3,4 +3,4 @@ Package grpc implements an RPC system called gRPC.
 
 See www.grpc.io for more information about gRPC.
 */
-package grpc
+package grpc // import "google.golang.org/grpc"
diff --git a/cmd/vendor/google.golang.org/grpc/grpclog/logger.go b/cmd/vendor/google.golang.org/grpc/grpclog/logger.go
index 2cc09be..3b29330 100644
--- a/cmd/vendor/google.golang.org/grpc/grpclog/logger.go
+++ b/cmd/vendor/google.golang.org/grpc/grpclog/logger.go
@@ -34,7 +34,7 @@
 /*
 Package grpclog defines logging for grpc.
 */
-package grpclog
+package grpclog // import "google.golang.org/grpc/grpclog"
 
 import (
 	"log"
diff --git a/cmd/vendor/google.golang.org/grpc/metadata/metadata.go b/cmd/vendor/google.golang.org/grpc/metadata/metadata.go
index 58469dd..52070db 100644
--- a/cmd/vendor/google.golang.org/grpc/metadata/metadata.go
+++ b/cmd/vendor/google.golang.org/grpc/metadata/metadata.go
@@ -32,7 +32,7 @@
  */
 
 // Package metadata define the structure of the metadata supported by gRPC library.
-package metadata
+package metadata // import "google.golang.org/grpc/metadata"
 
 import (
 	"encoding/base64"
diff --git a/cmd/vendor/google.golang.org/grpc/transport/transport.go b/cmd/vendor/google.golang.org/grpc/transport/transport.go
index 599f25d..d4c220a 100644
--- a/cmd/vendor/google.golang.org/grpc/transport/transport.go
+++ b/cmd/vendor/google.golang.org/grpc/transport/transport.go
@@ -35,7 +35,7 @@
 Package transport defines and implements message oriented communication channel
 to complete various transactions (e.g., an RPC).
 */
-package transport
+package transport // import "google.golang.org/grpc/transport"
 
 import (
 	"bytes"
diff --git a/cmd/vendor/gopkg.in/cheggaaa/pb.v1/.travis.yml b/cmd/vendor/gopkg.in/cheggaaa/pb.v1/.travis.yml
deleted file mode 100644
index 8ee0750..0000000
--- a/cmd/vendor/gopkg.in/cheggaaa/pb.v1/.travis.yml
+++ /dev/null
@@ -1,7 +0,0 @@
-language: go
-go:
-- 1.4.2
-sudo: false
-os:
-- linux
-- osx
diff --git a/cmd/vendor/gopkg.in/cheggaaa/pb.v1/README.md b/cmd/vendor/gopkg.in/cheggaaa/pb.v1/README.md
deleted file mode 100644
index 9647e3e..0000000
--- a/cmd/vendor/gopkg.in/cheggaaa/pb.v1/README.md
+++ /dev/null
@@ -1,176 +0,0 @@
-# Terminal progress bar for Go  
-
-Simple progress bar for console programs. 
-    
-
-## Installation
-
-```
-go get gopkg.in/cheggaaa/pb.v1
-```   
-
-## Usage   
-
-```Go
-package main
-
-import (
-	"gopkg.in/cheggaaa/pb.v1"
-	"time"
-)
-
-func main() {
-	count := 100000
-	bar := pb.StartNew(count)
-	for i := 0; i < count; i++ {
-		bar.Increment()
-		time.Sleep(time.Millisecond)
-	}
-	bar.FinishPrint("The End!")
-}
-
-```
-
-Result will be like this:
-
-```
-> go run test.go
-37158 / 100000 [================>_______________________________] 37.16% 1m11s
-```
-
-## Customization
-
-```Go  
-// create bar
-bar := pb.New(count)
-
-// refresh info every second (default 200ms)
-bar.SetRefreshRate(time.Second)
-
-// show percents (by default already true)
-bar.ShowPercent = true
-
-// show bar (by default already true)
-bar.ShowBar = true
-
-// no counters
-bar.ShowCounters = false
-
-// show "time left"
-bar.ShowTimeLeft = true
-
-// show average speed
-bar.ShowSpeed = true
-
-// sets the width of the progress bar
-bar.SetWidth(80)
-
-// sets the width of the progress bar, but if terminal size smaller will be ignored
-bar.SetMaxWidth(80)
-
-// convert output to readable format (like KB, MB)
-bar.SetUnits(pb.U_BYTES)
-
-// and start
-bar.Start()
-``` 
-
-## Progress bar for IO Operations
-
-```go
-// create and start bar
-bar := pb.New(myDataLen).SetUnits(pb.U_BYTES)
-bar.Start()
-
-// my io.Reader
-r := myReader
-
-// my io.Writer
-w := myWriter
-
-// create proxy reader
-reader := bar.NewProxyReader(r)
-
-// and copy from pb reader
-io.Copy(w, reader)
-
-```
-
-```go
-// create and start bar
-bar := pb.New(myDataLen).SetUnits(pb.U_BYTES)
-bar.Start()
-
-// my io.Reader
-r := myReader
-
-// my io.Writer
-w := myWriter
-
-// create multi writer
-writer := io.MultiWriter(w, bar)
-
-// and copy
-io.Copy(writer, r)
-```
-
-## Custom Progress Bar Look-and-feel
-
-```go
-bar.Format("<.- >")
-```
-
-## Multiple Progress Bars (experimental and unstable)
-
-#####Multiple bars do not works at Windows!!!
-
-Do not print to terminal while pool is active.
-
-```go
-package main
-
-import (
-    "math/rand"
-    "sync"
-    "time"
-
-    "gopkg.in/cheggaaa/pb.v1"
-)
-
-func main() {
-    // create bars
-    first := pb.New(200).Prefix("First ")
-    second := pb.New(200).Prefix("Second ")
-    third := pb.New(200).Prefix("Third ")
-    // start pool
-    pool, err := pb.StartPool(first, second, third)
-    if err != nil {
-        panic(err)
-    }
-    // update bars
-    wg := new(sync.WaitGroup)
-    for _, bar := range []*pb.ProgressBar{first, second, third} {
-        wg.Add(1)
-        go func(cb *pb.ProgressBar) {
-            for n := 0; n < 200; n++ {
-                cb.Increment()
-                time.Sleep(time.Millisecond * time.Duration(rand.Intn(100)))
-            }
-            cb.Finish()
-            wg.Done()
-        }(bar)
-    }
-    wg.Wait()
-    // close pool
-    pool.Stop()
-}
-```
-
-The result will be as follows:
-
-```
-$ go run example/multiple.go 
-First 141 / 1000 [===============>---------------------------------------] 14.10 % 44s
-Second 139 / 1000 [==============>---------------------------------------] 13.90 % 44s
-Third 152 / 1000 [================>--------------------------------------] 15.20 % 40s
-```
diff --git a/cmd/vendor/gopkg.in/yaml.v2/README.md b/cmd/vendor/gopkg.in/yaml.v2/README.md
deleted file mode 100644
index 7b8bd86..0000000
--- a/cmd/vendor/gopkg.in/yaml.v2/README.md
+++ /dev/null
@@ -1,131 +0,0 @@
-# YAML support for the Go language
-
-Introduction
-------------
-
-The yaml package enables Go programs to comfortably encode and decode YAML
-values. It was developed within [Canonical](https://www.canonical.com) as
-part of the [juju](https://juju.ubuntu.com) project, and is based on a
-pure Go port of the well-known [libyaml](http://pyyaml.org/wiki/LibYAML)
-C library to parse and generate YAML data quickly and reliably.
-
-Compatibility
--------------
-
-The yaml package supports most of YAML 1.1 and 1.2, including support for
-anchors, tags, map merging, etc. Multi-document unmarshalling is not yet
-implemented, and base-60 floats from YAML 1.1 are purposefully not
-supported since they're a poor design and are gone in YAML 1.2.
-
-Installation and usage
-----------------------
-
-The import path for the package is *gopkg.in/yaml.v2*.
-
-To install it, run:
-
-    go get gopkg.in/yaml.v2
-
-API documentation
------------------
-
-If opened in a browser, the import path itself leads to the API documentation:
-
-  * [https://gopkg.in/yaml.v2](https://gopkg.in/yaml.v2)
-
-API stability
--------------
-
-The package API for yaml v2 will remain stable as described in [gopkg.in](https://gopkg.in).
-
-
-License
--------
-
-The yaml package is licensed under the LGPL with an exception that allows it to be linked statically. Please see the LICENSE file for details.
-
-
-Example
--------
-
-```Go
-package main
-
-import (
-        "fmt"
-        "log"
-
-        "gopkg.in/yaml.v2"
-)
-
-var data = `
-a: Easy!
-b:
-  c: 2
-  d: [3, 4]
-`
-
-type T struct {
-        A string
-        B struct {
-                RenamedC int   `yaml:"c"`
-                D        []int `yaml:",flow"`
-        }
-}
-
-func main() {
-        t := T{}
-    
-        err := yaml.Unmarshal([]byte(data), &t)
-        if err != nil {
-                log.Fatalf("error: %v", err)
-        }
-        fmt.Printf("--- t:\n%v\n\n", t)
-    
-        d, err := yaml.Marshal(&t)
-        if err != nil {
-                log.Fatalf("error: %v", err)
-        }
-        fmt.Printf("--- t dump:\n%s\n\n", string(d))
-    
-        m := make(map[interface{}]interface{})
-    
-        err = yaml.Unmarshal([]byte(data), &m)
-        if err != nil {
-                log.Fatalf("error: %v", err)
-        }
-        fmt.Printf("--- m:\n%v\n\n", m)
-    
-        d, err = yaml.Marshal(&m)
-        if err != nil {
-                log.Fatalf("error: %v", err)
-        }
-        fmt.Printf("--- m dump:\n%s\n\n", string(d))
-}
-```
-
-This example will generate the following output:
-
-```
---- t:
-{Easy! {2 [3 4]}}
-
---- t dump:
-a: Easy!
-b:
-  c: 2
-  d: [3, 4]
-
-
---- m:
-map[a:Easy! b:map[c:2 d:[3 4]]]
-
---- m dump:
-a: Easy!
-b:
-  c: 2
-  d:
-  - 3
-  - 4
-```
-
