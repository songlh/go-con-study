commit 0453d09af64b04e2d2b645b48a308e50cf68dc98
Author: Blake Mizerany <blake.mizerany@gmail.com>
Date:   Fri Aug 22 13:24:33 2014 -0700

    raft: moved into new raft

diff --git a/raft/diff_test.go b/raft/diff_test.go
deleted file mode 100644
index 96c5d68..0000000
--- a/raft/diff_test.go
+++ /dev/null
@@ -1,51 +0,0 @@
-package raft
-
-import (
-	"fmt"
-	"io"
-	"io/ioutil"
-	"os"
-	"os/exec"
-	"strings"
-)
-
-func diffu(a, b string) string {
-	if a == b {
-		return ""
-	}
-	aname, bname := mustTemp("base", a), mustTemp("other", b)
-	defer os.Remove(aname)
-	defer os.Remove(bname)
-	cmd := exec.Command("diff", "-u", aname, bname)
-	buf, err := cmd.CombinedOutput()
-	if err != nil {
-		if _, ok := err.(*exec.ExitError); ok {
-			// do nothing
-			return string(buf)
-		}
-		panic(err)
-	}
-	return string(buf)
-}
-
-func mustTemp(pre, body string) string {
-	f, err := ioutil.TempFile("", pre)
-	if err != nil {
-		panic(err)
-	}
-	_, err = io.Copy(f, strings.NewReader(body))
-	if err != nil {
-		panic(err)
-	}
-	f.Close()
-	return f.Name()
-}
-
-func ltoa(l *raftLog) string {
-	s := fmt.Sprintf("committed: %d\n", l.committed)
-	s += fmt.Sprintf("applied:  %d\n", l.applied)
-	for i, e := range l.ents {
-		s += fmt.Sprintf("#%d: %+v\n", i, e)
-	}
-	return s
-}
diff --git a/raft/entry.pb.go b/raft/entry.pb.go
deleted file mode 100644
index 0d6ff69..0000000
--- a/raft/entry.pb.go
+++ /dev/null
@@ -1,243 +0,0 @@
-// Code generated by protoc-gen-gogo.
-// source: entry.proto
-// DO NOT EDIT!
-
-/*
-	Package raft is a generated protocol buffer package.
-
-	It is generated from these files:
-		entry.proto
-
-	It has these top-level messages:
-		Entry
-*/
-package raft
-
-import proto "code.google.com/p/gogoprotobuf/proto"
-import json "encoding/json"
-import math "math"
-
-// discarding unused import gogoproto "code.google.com/p/gogoprotobuf/gogoproto/gogo.pb"
-
-import io "io"
-import code_google_com_p_gogoprotobuf_proto "code.google.com/p/gogoprotobuf/proto"
-
-// Reference proto, json, and math imports to suppress error if they are not otherwise used.
-var _ = proto.Marshal
-var _ = &json.SyntaxError{}
-var _ = math.Inf
-
-type Entry struct {
-	Type             int64  `protobuf:"varint,1,req,name=type" json:"type"`
-	Term             int64  `protobuf:"varint,2,req,name=term" json:"term"`
-	Index            int64  `protobuf:"varint,3,req,name=index" json:"index"`
-	Data             []byte `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
-	XXX_unrecognized []byte `json:"-"`
-}
-
-func (m *Entry) Reset()         { *m = Entry{} }
-func (m *Entry) String() string { return proto.CompactTextString(m) }
-func (*Entry) ProtoMessage()    {}
-
-func init() {
-}
-func (m *Entry) Unmarshal(data []byte) error {
-	l := len(data)
-	index := 0
-	for index < l {
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if index >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := data[index]
-			index++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
-			}
-			for shift := uint(0); ; shift += 7 {
-				if index >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := data[index]
-				index++
-				m.Type |= (int64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 2:
-			if wireType != 0 {
-				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
-			}
-			for shift := uint(0); ; shift += 7 {
-				if index >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := data[index]
-				index++
-				m.Term |= (int64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 3:
-			if wireType != 0 {
-				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
-			}
-			for shift := uint(0); ; shift += 7 {
-				if index >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := data[index]
-				index++
-				m.Index |= (int64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 4:
-			if wireType != 2 {
-				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
-			}
-			var byteLen int
-			for shift := uint(0); ; shift += 7 {
-				if index >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := data[index]
-				index++
-				byteLen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			postIndex := index + byteLen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Data = append(m.Data, data[index:postIndex]...)
-			index = postIndex
-		default:
-			var sizeOfWire int
-			for {
-				sizeOfWire++
-				wire >>= 7
-				if wire == 0 {
-					break
-				}
-			}
-			index -= sizeOfWire
-			skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
-			if err != nil {
-				return err
-			}
-			if (index + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
-			index += skippy
-		}
-	}
-	return nil
-}
-func (m *Entry) Size() (n int) {
-	var l int
-	_ = l
-	n += 1 + sovEntry(uint64(m.Type))
-	n += 1 + sovEntry(uint64(m.Term))
-	n += 1 + sovEntry(uint64(m.Index))
-	if m.Data != nil {
-		l = len(m.Data)
-		n += 1 + l + sovEntry(uint64(l))
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
-}
-
-func sovEntry(x uint64) (n int) {
-	for {
-		n++
-		x >>= 7
-		if x == 0 {
-			break
-		}
-	}
-	return n
-}
-func sozEntry(x uint64) (n int) {
-	return sovEntry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
-}
-func (m *Entry) Marshal() (data []byte, err error) {
-	size := m.Size()
-	data = make([]byte, size)
-	n, err := m.MarshalTo(data)
-	if err != nil {
-		return nil, err
-	}
-	return data[:n], nil
-}
-
-func (m *Entry) MarshalTo(data []byte) (n int, err error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	data[i] = 0x8
-	i++
-	i = encodeVarintEntry(data, i, uint64(m.Type))
-	data[i] = 0x10
-	i++
-	i = encodeVarintEntry(data, i, uint64(m.Term))
-	data[i] = 0x18
-	i++
-	i = encodeVarintEntry(data, i, uint64(m.Index))
-	if m.Data != nil {
-		data[i] = 0x22
-		i++
-		i = encodeVarintEntry(data, i, uint64(len(m.Data)))
-		i += copy(data[i:], m.Data)
-	}
-	if m.XXX_unrecognized != nil {
-		i += copy(data[i:], m.XXX_unrecognized)
-	}
-	return i, nil
-}
-func encodeFixed64Entry(data []byte, offset int, v uint64) int {
-	data[offset] = uint8(v)
-	data[offset+1] = uint8(v >> 8)
-	data[offset+2] = uint8(v >> 16)
-	data[offset+3] = uint8(v >> 24)
-	data[offset+4] = uint8(v >> 32)
-	data[offset+5] = uint8(v >> 40)
-	data[offset+6] = uint8(v >> 48)
-	data[offset+7] = uint8(v >> 56)
-	return offset + 8
-}
-func encodeFixed32Entry(data []byte, offset int, v uint32) int {
-	data[offset] = uint8(v)
-	data[offset+1] = uint8(v >> 8)
-	data[offset+2] = uint8(v >> 16)
-	data[offset+3] = uint8(v >> 24)
-	return offset + 4
-}
-func encodeVarintEntry(data []byte, offset int, v uint64) int {
-	for v >= 1<<7 {
-		data[offset] = uint8(v&0x7f | 0x80)
-		v >>= 7
-		offset++
-	}
-	data[offset] = uint8(v)
-	return offset + 1
-}
diff --git a/raft/info.pb.go b/raft/info.pb.go
deleted file mode 100644
index a8d9b84..0000000
--- a/raft/info.pb.go
+++ /dev/null
@@ -1,170 +0,0 @@
-// Code generated by protoc-gen-gogo.
-// source: info.proto
-// DO NOT EDIT!
-
-/*
-Package raft is a generated protocol buffer package.
-
-It is generated from these files:
-	info.proto
-
-It has these top-level messages:
-	Info
-*/
-package raft
-
-import proto "code.google.com/p/gogoprotobuf/proto"
-import json "encoding/json"
-import math "math"
-
-// discarding unused import gogoproto "code.google.com/p/gogoprotobuf/gogoproto/gogo.pb"
-
-import io "io"
-import code_google_com_p_gogoprotobuf_proto "code.google.com/p/gogoprotobuf/proto"
-
-// Reference proto, json, and math imports to suppress error if they are not otherwise used.
-var _ = proto.Marshal
-var _ = &json.SyntaxError{}
-var _ = math.Inf
-
-type Info struct {
-	Id               int64  `protobuf:"varint,1,req,name=id" json:"id"`
-	XXX_unrecognized []byte `json:"-"`
-}
-
-func (m *Info) Reset()         { *m = Info{} }
-func (m *Info) String() string { return proto.CompactTextString(m) }
-func (*Info) ProtoMessage()    {}
-
-func init() {
-}
-func (m *Info) Unmarshal(data []byte) error {
-	l := len(data)
-	index := 0
-	for index < l {
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if index >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := data[index]
-			index++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
-			}
-			for shift := uint(0); ; shift += 7 {
-				if index >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := data[index]
-				index++
-				m.Id |= (int64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		default:
-			var sizeOfWire int
-			for {
-				sizeOfWire++
-				wire >>= 7
-				if wire == 0 {
-					break
-				}
-			}
-			index -= sizeOfWire
-			skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
-			if err != nil {
-				return err
-			}
-			if (index + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
-			index += skippy
-		}
-	}
-	return nil
-}
-func (m *Info) Size() (n int) {
-	var l int
-	_ = l
-	n += 1 + sovInfo(uint64(m.Id))
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
-}
-
-func sovInfo(x uint64) (n int) {
-	for {
-		n++
-		x >>= 7
-		if x == 0 {
-			break
-		}
-	}
-	return n
-}
-func sozInfo(x uint64) (n int) {
-	return sovInfo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
-}
-func (m *Info) Marshal() (data []byte, err error) {
-	size := m.Size()
-	data = make([]byte, size)
-	n, err := m.MarshalTo(data)
-	if err != nil {
-		return nil, err
-	}
-	return data[:n], nil
-}
-
-func (m *Info) MarshalTo(data []byte) (n int, err error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	data[i] = 0x8
-	i++
-	i = encodeVarintInfo(data, i, uint64(m.Id))
-	if m.XXX_unrecognized != nil {
-		i += copy(data[i:], m.XXX_unrecognized)
-	}
-	return i, nil
-}
-func encodeFixed64Info(data []byte, offset int, v uint64) int {
-	data[offset] = uint8(v)
-	data[offset+1] = uint8(v >> 8)
-	data[offset+2] = uint8(v >> 16)
-	data[offset+3] = uint8(v >> 24)
-	data[offset+4] = uint8(v >> 32)
-	data[offset+5] = uint8(v >> 40)
-	data[offset+6] = uint8(v >> 48)
-	data[offset+7] = uint8(v >> 56)
-	return offset + 8
-}
-func encodeFixed32Info(data []byte, offset int, v uint32) int {
-	data[offset] = uint8(v)
-	data[offset+1] = uint8(v >> 8)
-	data[offset+2] = uint8(v >> 16)
-	data[offset+3] = uint8(v >> 24)
-	return offset + 4
-}
-func encodeVarintInfo(data []byte, offset int, v uint64) int {
-	for v >= 1<<7 {
-		data[offset] = uint8(v&0x7f | 0x80)
-		v >>= 7
-		offset++
-	}
-	data[offset] = uint8(v)
-	return offset + 1
-}
diff --git a/raft/log.go b/raft/log.go
deleted file mode 100644
index 54ed1f9..0000000
--- a/raft/log.go
+++ /dev/null
@@ -1,220 +0,0 @@
-package raft
-
-import "fmt"
-
-const (
-	Normal int64 = iota
-
-	ClusterInit
-	AddNode
-	RemoveNode
-)
-
-const (
-	defaultCompactThreshold = 10000
-)
-
-func (e *Entry) isConfig() bool {
-	return e.Type == AddNode || e.Type == RemoveNode
-}
-
-type raftLog struct {
-	ents             []Entry
-	unstable         int64
-	committed        int64
-	applied          int64
-	offset           int64
-	snapshot         Snapshot
-	unstableSnapshot Snapshot
-
-	// want a compact after the number of entries exceeds the threshold
-	// TODO(xiangli) size might be a better criteria
-	compactThreshold int64
-}
-
-func newLog() *raftLog {
-	return &raftLog{
-		ents:             make([]Entry, 1),
-		unstable:         1,
-		committed:        0,
-		applied:          0,
-		compactThreshold: defaultCompactThreshold,
-	}
-}
-
-func (l *raftLog) isEmpty() bool {
-	return l.offset == 0 && len(l.ents) == 1
-}
-
-func (l *raftLog) String() string {
-	return fmt.Sprintf("offset=%d committed=%d applied=%d len(ents)=%d", l.offset, l.committed, l.applied, len(l.ents))
-}
-
-func (l *raftLog) maybeAppend(index, logTerm, committed int64, ents ...Entry) bool {
-	if l.matchTerm(index, logTerm) {
-		from := index + 1
-		ci := l.findConflict(from, ents)
-		switch {
-		case ci == -1:
-		case ci <= l.committed:
-			panic("conflict with committed entry")
-		default:
-			l.append(ci-1, ents[ci-from:]...)
-		}
-		if l.committed < committed {
-			l.committed = min(committed, l.lastIndex())
-		}
-		return true
-	}
-	return false
-}
-
-func (l *raftLog) append(after int64, ents ...Entry) int64 {
-	l.ents = append(l.slice(l.offset, after+1), ents...)
-	l.unstable = min(l.unstable, after+1)
-	return l.lastIndex()
-}
-
-func (l *raftLog) findConflict(from int64, ents []Entry) int64 {
-	for i, ne := range ents {
-		if oe := l.at(from + int64(i)); oe == nil || oe.Term != ne.Term {
-			return from + int64(i)
-		}
-	}
-	return -1
-}
-
-func (l *raftLog) unstableEnts() []Entry {
-	return l.entries(l.unstable)
-}
-
-func (l *raftLog) resetUnstable() {
-	l.unstable = l.lastIndex() + 1
-}
-
-// nextEnts returns all the available entries for execution.
-// all the returned entries will be marked as applied.
-func (l *raftLog) nextEnts() (ents []Entry) {
-	if l.committed > l.applied {
-		return l.slice(l.applied+1, l.committed+1)
-	}
-	return nil
-}
-
-func (l *raftLog) resetNextEnts() {
-	if l.committed > l.applied {
-		l.applied = l.committed
-	}
-}
-
-func (l *raftLog) lastIndex() int64 {
-	return int64(len(l.ents)) - 1 + l.offset
-}
-
-func (l *raftLog) term(i int64) int64 {
-	if e := l.at(i); e != nil {
-		return e.Term
-	}
-	return -1
-}
-
-func (l *raftLog) entries(i int64) []Entry {
-	// never send out the first entry
-	// first entry is only used for matching
-	// prevLogTerm
-	if i == l.offset {
-		panic("cannot return the first entry in log")
-	}
-	return l.slice(i, l.lastIndex()+1)
-}
-
-func (l *raftLog) isUpToDate(i, term int64) bool {
-	e := l.at(l.lastIndex())
-	return term > e.Term || (term == e.Term && i >= l.lastIndex())
-}
-
-func (l *raftLog) matchTerm(i, term int64) bool {
-	if e := l.at(i); e != nil {
-		return e.Term == term
-	}
-	return false
-}
-
-func (l *raftLog) maybeCommit(maxIndex, term int64) bool {
-	if maxIndex > l.committed && l.term(maxIndex) == term {
-		l.committed = maxIndex
-		return true
-	}
-	return false
-}
-
-// compact compacts all log entries until i.
-// It removes the log entries before i, exclusive.
-// i must be not smaller than the index of the first entry
-// and not greater than the index of the last entry.
-// the number of entries after compaction will be returned.
-func (l *raftLog) compact(i int64) int64 {
-	if l.isOutOfBounds(i) {
-		panic(fmt.Sprintf("compact %d out of bounds [%d:%d]", i, l.offset, l.lastIndex()))
-	}
-	l.ents = l.slice(i, l.lastIndex()+1)
-	l.unstable = max(i+1, l.unstable)
-	l.offset = i
-	return int64(len(l.ents))
-}
-
-func (l *raftLog) snap(d []byte, clusterId, index, term int64, nodes []int64) {
-	l.snapshot = Snapshot{clusterId, d, nodes, index, term}
-}
-
-func (l *raftLog) shouldCompact() bool {
-	return (l.applied - l.offset) > l.compactThreshold
-}
-
-func (l *raftLog) restore(s Snapshot) {
-	l.ents = []Entry{{Term: s.Term}}
-	l.unstable = s.Index + 1
-	l.committed = s.Index
-	l.applied = s.Index
-	l.offset = s.Index
-	l.snapshot = s
-}
-
-func (l *raftLog) at(i int64) *Entry {
-	if l.isOutOfBounds(i) {
-		return nil
-	}
-	return &l.ents[i-l.offset]
-}
-
-// slice get a slice of log entries from lo through hi-1, inclusive.
-func (l *raftLog) slice(lo int64, hi int64) []Entry {
-	if lo >= hi {
-		return nil
-	}
-	if l.isOutOfBounds(lo) || l.isOutOfBounds(hi-1) {
-		return nil
-	}
-	return l.ents[lo-l.offset : hi-l.offset]
-}
-
-func (l *raftLog) isOutOfBounds(i int64) bool {
-	if i < l.offset || i > l.lastIndex() {
-		return true
-	}
-	return false
-}
-
-func min(a, b int64) int64 {
-	if a > b {
-		return b
-	}
-	return a
-}
-
-func max(a, b int64) int64 {
-	if a > b {
-		return a
-	}
-	return b
-}
diff --git a/raft/log_test.go b/raft/log_test.go
deleted file mode 100644
index 5af620b..0000000
--- a/raft/log_test.go
+++ /dev/null
@@ -1,303 +0,0 @@
-package raft
-
-import (
-	"reflect"
-	"testing"
-)
-
-// TestAppend ensures:
-// 1. If an existing entry conflicts with a new one (same index
-// but different terms), delete the existing entry and all that
-// follow it
-// 2.Append any new entries not already in the log
-func TestAppend(t *testing.T) {
-	previousEnts := []Entry{{Term: 1}, {Term: 2}}
-	previousUnstable := int64(3)
-	tests := []struct {
-		after     int64
-		ents      []Entry
-		windex    int64
-		wents     []Entry
-		wunstable int64
-	}{
-		{
-			2,
-			[]Entry{},
-			2,
-			[]Entry{{Term: 1}, {Term: 2}},
-			3,
-		},
-		{
-			2,
-			[]Entry{{Term: 2}},
-			3,
-			[]Entry{{Term: 1}, {Term: 2}, {Term: 2}},
-			3,
-		},
-		// conflicts with index 1
-		{
-			0,
-			[]Entry{{Term: 2}},
-			1,
-			[]Entry{{Term: 2}},
-			1,
-		},
-		// conflicts with index 2
-		{
-			1,
-			[]Entry{{Term: 3}, {Term: 3}},
-			3,
-			[]Entry{{Term: 1}, {Term: 3}, {Term: 3}},
-			2,
-		},
-	}
-
-	for i, tt := range tests {
-		raftLog := newLog()
-		raftLog.ents = append(raftLog.ents, previousEnts...)
-		raftLog.unstable = previousUnstable
-		index := raftLog.append(tt.after, tt.ents...)
-		if index != tt.windex {
-			t.Errorf("#%d: lastIndex = %d, want %d", i, index, tt.windex)
-		}
-		if g := raftLog.entries(1); !reflect.DeepEqual(g, tt.wents) {
-			t.Errorf("#%d: logEnts = %+v, want %+v", i, g, tt.wents)
-		}
-		if g := raftLog.unstable; g != tt.wunstable {
-			t.Errorf("#%d: unstable = %d, want %d", i, g, tt.wunstable)
-		}
-	}
-}
-
-// TestCompactionSideEffects ensures that all the log related funcationality works correctly after
-// a compaction.
-func TestCompactionSideEffects(t *testing.T) {
-	var i int64
-	lastIndex := int64(1000)
-	raftLog := newLog()
-
-	for i = 0; i < lastIndex; i++ {
-		raftLog.append(int64(i), Entry{Term: int64(i + 1), Index: int64(i + 1)})
-	}
-
-	raftLog.compact(500)
-
-	if raftLog.lastIndex() != lastIndex {
-		t.Errorf("lastIndex = %d, want %d", raftLog.lastIndex(), lastIndex)
-	}
-
-	for i := raftLog.offset; i <= raftLog.lastIndex(); i++ {
-		if raftLog.term(i) != i {
-			t.Errorf("term(%d) = %d, want %d", i, raftLog.term(i), i)
-		}
-	}
-
-	for i := raftLog.offset; i <= raftLog.lastIndex(); i++ {
-		if !raftLog.matchTerm(i, i) {
-			t.Errorf("matchTerm(%d) = false, want true", i)
-		}
-	}
-
-	unstableEnts := raftLog.unstableEnts()
-	if g := len(unstableEnts); g != 500 {
-		t.Errorf("len(unstableEntries) = %d, want = %d", g, 500)
-	}
-	if unstableEnts[0].Index != 501 {
-		t.Errorf("Index = %d, want = %d", unstableEnts[0].Index, 501)
-	}
-
-	prev := raftLog.lastIndex()
-	raftLog.append(raftLog.lastIndex(), Entry{Term: raftLog.lastIndex() + 1})
-	if raftLog.lastIndex() != prev+1 {
-		t.Errorf("lastIndex = %d, want = %d", raftLog.lastIndex(), prev+1)
-	}
-
-	ents := raftLog.entries(raftLog.lastIndex())
-	if len(ents) != 1 {
-		t.Errorf("len(entries) = %d, want = %d", len(ents), 1)
-	}
-}
-
-func TestUnstableEnts(t *testing.T) {
-	previousEnts := []Entry{{Term: 1, Index: 1}, {Term: 2, Index: 2}}
-	tests := []struct {
-		unstable  int64
-		wents     []Entry
-		wunstable int64
-	}{
-		{3, nil, 3},
-		{1, previousEnts, 3},
-	}
-
-	for i, tt := range tests {
-		raftLog := newLog()
-		raftLog.ents = append(raftLog.ents, previousEnts...)
-		raftLog.unstable = tt.unstable
-		ents := raftLog.unstableEnts()
-		raftLog.resetUnstable()
-		if !reflect.DeepEqual(ents, tt.wents) {
-			t.Errorf("#%d: unstableEnts = %+v, want %+v", i, ents, tt.wents)
-		}
-		if g := raftLog.unstable; g != tt.wunstable {
-			t.Errorf("#%d: unstable = %d, want %d", i, g, tt.wunstable)
-		}
-	}
-}
-
-//TestCompaction ensures that the number of log entreis is correct after compactions.
-func TestCompaction(t *testing.T) {
-	tests := []struct {
-		app     int
-		compact []int64
-		wleft   []int
-		wallow  bool
-	}{
-		// out of upper bound
-		{1000, []int64{1001}, []int{-1}, false},
-		{1000, []int64{300, 500, 800, 900}, []int{701, 501, 201, 101}, true},
-		// out of lower bound
-		{1000, []int64{300, 299}, []int{701, -1}, false},
-	}
-
-	for i, tt := range tests {
-		func() {
-			defer func() {
-				if r := recover(); r != nil {
-					if tt.wallow == true {
-						t.Errorf("%d: allow = %v, want %v", i, false, true)
-					}
-				}
-			}()
-
-			raftLog := newLog()
-			for i := 0; i < tt.app; i++ {
-				raftLog.append(int64(i), Entry{})
-			}
-
-			for j := 0; j < len(tt.compact); j++ {
-				raftLog.compact(tt.compact[j])
-				if len(raftLog.ents) != tt.wleft[j] {
-					t.Errorf("#%d.%d len = %d, want %d", i, j, len(raftLog.ents), tt.wleft[j])
-				}
-			}
-		}()
-	}
-}
-
-func TestLogRestore(t *testing.T) {
-	var i int64
-	raftLog := newLog()
-	for i = 0; i < 100; i++ {
-		raftLog.append(i, Entry{Term: i + 1})
-	}
-
-	index := int64(1000)
-	term := int64(1000)
-	raftLog.restore(Snapshot{Index: index, Term: term})
-
-	// only has the guard entry
-	if len(raftLog.ents) != 1 {
-		t.Errorf("len = %d, want 0", len(raftLog.ents))
-	}
-	if raftLog.offset != index {
-		t.Errorf("offset = %d, want %d", raftLog.offset, index)
-	}
-	if raftLog.applied != index {
-		t.Errorf("applied = %d, want %d", raftLog.applied, index)
-	}
-	if raftLog.committed != index {
-		t.Errorf("comitted = %d, want %d", raftLog.committed, index)
-	}
-	if raftLog.unstable != index+1 {
-		t.Errorf("unstable = %d, want %d", raftLog.unstable, index+1)
-	}
-	if raftLog.term(index) != term {
-		t.Errorf("term = %d, want %d", raftLog.term(index), term)
-	}
-}
-
-func TestIsOutOfBounds(t *testing.T) {
-	offset := int64(100)
-	num := int64(100)
-	l := &raftLog{offset: offset, ents: make([]Entry, num)}
-
-	tests := []struct {
-		index int64
-		w     bool
-	}{
-		{offset - 1, true},
-		{offset, false},
-		{offset + num/2, false},
-		{offset + num - 1, false},
-		{offset + num, true},
-	}
-
-	for i, tt := range tests {
-		g := l.isOutOfBounds(tt.index)
-		if g != tt.w {
-			t.Errorf("#%d: isOutOfBounds = %v, want %v", i, g, tt.w)
-		}
-	}
-}
-
-func TestAt(t *testing.T) {
-	var i int64
-	offset := int64(100)
-	num := int64(100)
-
-	l := &raftLog{offset: offset}
-	for i = 0; i < num; i++ {
-		l.ents = append(l.ents, Entry{Term: i})
-	}
-
-	tests := []struct {
-		index int64
-		w     *Entry
-	}{
-		{offset - 1, nil},
-		{offset, &Entry{Term: 0}},
-		{offset + num/2, &Entry{Term: num / 2}},
-		{offset + num - 1, &Entry{Term: num - 1}},
-		{offset + num, nil},
-	}
-
-	for i, tt := range tests {
-		g := l.at(tt.index)
-		if !reflect.DeepEqual(g, tt.w) {
-			t.Errorf("#%d: at = %v, want %v", i, g, tt.w)
-		}
-	}
-}
-
-func TestSlice(t *testing.T) {
-	var i int64
-	offset := int64(100)
-	num := int64(100)
-
-	l := &raftLog{offset: offset}
-	for i = 0; i < num; i++ {
-		l.ents = append(l.ents, Entry{Term: i})
-	}
-
-	tests := []struct {
-		from int64
-		to   int64
-		w    []Entry
-	}{
-		{offset - 1, offset + 1, nil},
-		{offset, offset + 1, []Entry{{Term: 0}}},
-		{offset + num/2, offset + num/2 + 1, []Entry{{Term: num / 2}}},
-		{offset + num - 1, offset + num, []Entry{{Term: num - 1}}},
-		{offset + num, offset + num + 1, nil},
-
-		{offset + num/2, offset + num/2, nil},
-		{offset + num/2, offset + num/2 - 1, nil},
-	}
-
-	for i, tt := range tests {
-		g := l.slice(tt.from, tt.to)
-		if !reflect.DeepEqual(g, tt.w) {
-			t.Errorf("#%d: from %d to %d = %v, want %v", i, tt.from, tt.to, g, tt.w)
-		}
-	}
-}
diff --git a/raft/raft.go b/raft/raft.go
deleted file mode 100644
index f550d05..0000000
--- a/raft/raft.go
+++ /dev/null
@@ -1,593 +0,0 @@
-package raft
-
-import (
-	"errors"
-	"fmt"
-	"sort"
-	"sync/atomic"
-)
-
-const none = -1
-
-type messageType int64
-
-const (
-	msgHup messageType = iota
-	msgBeat
-	msgProp
-	msgApp
-	msgAppResp
-	msgVote
-	msgVoteResp
-	msgSnap
-	msgDenied
-)
-
-var mtmap = [...]string{
-	msgHup:      "msgHup",
-	msgBeat:     "msgBeat",
-	msgProp:     "msgProp",
-	msgApp:      "msgApp",
-	msgAppResp:  "msgAppResp",
-	msgVote:     "msgVote",
-	msgVoteResp: "msgVoteResp",
-	msgSnap:     "msgSnap",
-	msgDenied:   "msgDenied",
-}
-
-func (mt messageType) String() string {
-	return mtmap[int64(mt)]
-}
-
-var errNoLeader = errors.New("no leader")
-
-const (
-	stateFollower stateType = iota
-	stateCandidate
-	stateLeader
-)
-
-type stateType int64
-
-var stmap = [...]string{
-	stateFollower:  "stateFollower",
-	stateCandidate: "stateCandidate",
-	stateLeader:    "stateLeader",
-}
-
-var stepmap = [...]stepFunc{
-	stateFollower:  stepFollower,
-	stateCandidate: stepCandidate,
-	stateLeader:    stepLeader,
-}
-
-func (st stateType) String() string {
-	return stmap[int64(st)]
-}
-
-var EmptyState = State{}
-
-type Message struct {
-	Type      messageType
-	ClusterId int64
-	To        int64
-	From      int64
-	Term      int64
-	LogTerm   int64
-	Index     int64
-	Entries   []Entry
-	Commit    int64
-	Snapshot  Snapshot
-}
-
-func (m Message) IsMsgApp() bool {
-	return m.Type == msgApp
-}
-
-func (m Message) String() string {
-	return fmt.Sprintf("type=%v from=%x to=%x term=%d logTerm=%d i=%d ci=%d len(ents)=%d",
-		m.Type, m.From, m.To, m.Term, m.LogTerm, m.Index, m.Commit, len(m.Entries))
-}
-
-type index struct {
-	match, next int64
-}
-
-func (in *index) update(n int64) {
-	in.match = n
-	in.next = n + 1
-}
-
-func (in *index) decr() {
-	if in.next--; in.next < 1 {
-		in.next = 1
-	}
-}
-
-func (in *index) String() string {
-	return fmt.Sprintf("n=%d m=%d", in.next, in.match)
-}
-
-// An AtomicInt is an int64 to be accessed atomically.
-type atomicInt int64
-
-func (i *atomicInt) Set(n int64) {
-	atomic.StoreInt64((*int64)(i), n)
-}
-
-func (i *atomicInt) Get() int64 {
-	return atomic.LoadInt64((*int64)(i))
-}
-
-// int64Slice implements sort interface
-type int64Slice []int64
-
-func (p int64Slice) Len() int           { return len(p) }
-func (p int64Slice) Less(i, j int) bool { return p[i] < p[j] }
-func (p int64Slice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
-
-type stateMachine struct {
-	clusterId int64
-	id        int64
-
-	// the term we are participating in at any time
-	term  atomicInt
-	index atomicInt
-
-	// who we voted for in term
-	vote int64
-
-	// the log
-	raftLog *raftLog
-
-	ins map[int64]*index
-
-	state stateType
-
-	votes map[int64]bool
-
-	msgs []Message
-
-	// the leader id
-	lead atomicInt
-
-	// pending reconfiguration
-	pendingConf bool
-
-	unstableState State
-
-	// promotable indicates whether state machine could be promoted.
-	// New machine has to wait until it has been added to the cluster, or it
-	// may become the leader of the cluster without it.
-	promotable bool
-}
-
-func newStateMachine(id int64, peers []int64) *stateMachine {
-	if id == none {
-		panic("cannot use none id")
-	}
-	sm := &stateMachine{id: id, clusterId: none, lead: none, raftLog: newLog(), ins: make(map[int64]*index)}
-	for _, p := range peers {
-		sm.ins[p] = &index{}
-	}
-	sm.reset(0)
-	return sm
-}
-
-func (sm *stateMachine) String() string {
-	s := fmt.Sprintf(`state=%v term=%d`, sm.state, sm.term)
-	switch sm.state {
-	case stateFollower:
-		s += fmt.Sprintf(" vote=%v lead=%v", sm.vote, sm.lead)
-	case stateCandidate:
-		s += fmt.Sprintf(` votes="%v"`, sm.votes)
-	case stateLeader:
-		s += fmt.Sprintf(` ins="%v"`, sm.ins)
-	}
-	return s
-}
-
-func (sm *stateMachine) poll(id int64, v bool) (granted int) {
-	if _, ok := sm.votes[id]; !ok {
-		sm.votes[id] = v
-	}
-	for _, vv := range sm.votes {
-		if vv {
-			granted++
-		}
-	}
-	return granted
-}
-
-// send persists state to stable storage and then sends to its mailbox.
-func (sm *stateMachine) send(m Message) {
-	m.ClusterId = sm.clusterId
-	m.From = sm.id
-	m.Term = sm.term.Get()
-	sm.msgs = append(sm.msgs, m)
-}
-
-// sendAppend sends RRPC, with entries to the given peer.
-func (sm *stateMachine) sendAppend(to int64) {
-	in := sm.ins[to]
-	m := Message{}
-	m.To = to
-	m.Index = in.next - 1
-	if sm.needSnapshot(m.Index) {
-		m.Type = msgSnap
-		m.Snapshot = sm.raftLog.snapshot
-	} else {
-		m.Type = msgApp
-		m.LogTerm = sm.raftLog.term(in.next - 1)
-		m.Entries = sm.raftLog.entries(in.next)
-		m.Commit = sm.raftLog.committed
-	}
-	sm.send(m)
-}
-
-// sendHeartbeat sends RRPC, without entries to the given peer.
-func (sm *stateMachine) sendHeartbeat(to int64) {
-	in := sm.ins[to]
-	index := max(in.next-1, sm.raftLog.lastIndex())
-	m := Message{
-		To:      to,
-		Type:    msgApp,
-		Index:   index,
-		LogTerm: sm.raftLog.term(index),
-		Commit:  sm.raftLog.committed,
-	}
-	sm.send(m)
-}
-
-// bcastAppend sends RRPC, with entries to all peers that are not up-to-date according to sm.mis.
-func (sm *stateMachine) bcastAppend() {
-	for i := range sm.ins {
-		if i == sm.id {
-			continue
-		}
-		sm.sendAppend(i)
-	}
-}
-
-// bcastHeartbeat sends RRPC, without entries to all the peers.
-func (sm *stateMachine) bcastHeartbeat() {
-	for i := range sm.ins {
-		if i == sm.id {
-			continue
-		}
-		sm.sendHeartbeat(i)
-	}
-}
-
-func (sm *stateMachine) maybeCommit() bool {
-	// TODO(bmizerany): optimize.. Currently naive
-	mis := make(int64Slice, 0, len(sm.ins))
-	for i := range sm.ins {
-		mis = append(mis, sm.ins[i].match)
-	}
-	sort.Sort(sort.Reverse(mis))
-	mci := mis[sm.q()-1]
-
-	return sm.raftLog.maybeCommit(mci, sm.term.Get())
-}
-
-// nextEnts returns the appliable entries and updates the applied index
-func (sm *stateMachine) nextEnts() (ents []Entry) {
-	ents = sm.raftLog.nextEnts()
-	sm.raftLog.resetNextEnts()
-	return ents
-}
-
-func (sm *stateMachine) reset(term int64) {
-	sm.setTerm(term)
-	sm.lead.Set(none)
-	sm.setVote(none)
-	sm.votes = make(map[int64]bool)
-	for i := range sm.ins {
-		sm.ins[i] = &index{next: sm.raftLog.lastIndex() + 1}
-		if i == sm.id {
-			sm.ins[i].match = sm.raftLog.lastIndex()
-		}
-	}
-}
-
-func (sm *stateMachine) q() int {
-	return len(sm.ins)/2 + 1
-}
-
-func (sm *stateMachine) appendEntry(e Entry) {
-	e.Term = sm.term.Get()
-	e.Index = sm.raftLog.lastIndex() + 1
-	sm.index.Set(sm.raftLog.append(sm.raftLog.lastIndex(), e))
-	sm.ins[sm.id].update(sm.raftLog.lastIndex())
-	sm.maybeCommit()
-}
-
-func (sm *stateMachine) becomeFollower(term int64, lead int64) {
-	sm.reset(term)
-	sm.lead.Set(lead)
-	sm.state = stateFollower
-	sm.pendingConf = false
-}
-
-func (sm *stateMachine) becomeCandidate() {
-	// TODO(xiangli) remove the panic when the raft implementation is stable
-	if sm.state == stateLeader {
-		panic("invalid transition [leader -> candidate]")
-	}
-	sm.reset(sm.term.Get() + 1)
-	sm.setVote(sm.id)
-	sm.state = stateCandidate
-}
-
-func (sm *stateMachine) becomeLeader() {
-	// TODO(xiangli) remove the panic when the raft implementation is stable
-	if sm.state == stateFollower {
-		panic("invalid transition [follower -> leader]")
-	}
-	sm.reset(sm.term.Get())
-	sm.lead.Set(sm.id)
-	sm.state = stateLeader
-
-	for _, e := range sm.raftLog.entries(sm.raftLog.committed + 1) {
-		if e.isConfig() {
-			sm.pendingConf = true
-		}
-	}
-
-	sm.appendEntry(Entry{Type: Normal, Data: nil})
-}
-
-func (sm *stateMachine) Msgs() []Message {
-	msgs := sm.msgs
-	sm.msgs = make([]Message, 0)
-
-	return msgs
-}
-
-func (sm *stateMachine) Step(m Message) (ok bool) {
-	if m.Type == msgHup {
-		sm.becomeCandidate()
-		if sm.q() == sm.poll(sm.id, true) {
-			sm.becomeLeader()
-			return true
-		}
-		for i := range sm.ins {
-			if i == sm.id {
-				continue
-			}
-			lasti := sm.raftLog.lastIndex()
-			sm.send(Message{To: i, Type: msgVote, Index: lasti, LogTerm: sm.raftLog.term(lasti)})
-		}
-		return true
-	}
-
-	switch {
-	case m.Term == 0:
-		// local message
-	case m.Term > sm.term.Get():
-		lead := m.From
-		if m.Type == msgVote {
-			lead = none
-		}
-		sm.becomeFollower(m.Term, lead)
-	case m.Term < sm.term.Get():
-		// ignore
-		return true
-	}
-
-	return stepmap[sm.state](sm, m)
-}
-
-func (sm *stateMachine) handleAppendEntries(m Message) {
-	if sm.raftLog.maybeAppend(m.Index, m.LogTerm, m.Commit, m.Entries...) {
-		sm.index.Set(sm.raftLog.lastIndex())
-		sm.send(Message{To: m.From, Type: msgAppResp, Index: sm.raftLog.lastIndex()})
-	} else {
-		sm.send(Message{To: m.From, Type: msgAppResp, Index: -1})
-	}
-}
-
-func (sm *stateMachine) handleSnapshot(m Message) {
-	if sm.restore(m.Snapshot) {
-		sm.raftLog.unstableSnapshot = m.Snapshot
-		sm.send(Message{To: m.From, Type: msgAppResp, Index: sm.raftLog.lastIndex()})
-	} else {
-		sm.send(Message{To: m.From, Type: msgAppResp, Index: sm.raftLog.committed})
-	}
-}
-
-func (sm *stateMachine) addNode(id int64) {
-	sm.addIns(id, 0, sm.raftLog.lastIndex()+1)
-	sm.pendingConf = false
-	if id == sm.id {
-		sm.promotable = true
-	}
-}
-
-func (sm *stateMachine) removeNode(id int64) {
-	sm.deleteIns(id)
-	sm.pendingConf = false
-}
-
-type stepFunc func(sm *stateMachine, m Message) bool
-
-func stepLeader(sm *stateMachine, m Message) bool {
-	switch m.Type {
-	case msgBeat:
-		sm.bcastHeartbeat()
-	case msgProp:
-		if len(m.Entries) != 1 {
-			panic("unexpected length(entries) of a msgProp")
-		}
-		e := m.Entries[0]
-		if e.isConfig() {
-			if sm.pendingConf {
-				return false
-			}
-			sm.pendingConf = true
-		}
-		sm.appendEntry(e)
-		sm.bcastAppend()
-	case msgAppResp:
-		if m.Index < 0 {
-			sm.ins[m.From].decr()
-			sm.sendAppend(m.From)
-		} else {
-			sm.ins[m.From].update(m.Index)
-			if sm.maybeCommit() {
-				sm.bcastAppend()
-			}
-		}
-	case msgVote:
-		sm.send(Message{To: m.From, Type: msgVoteResp, Index: -1})
-	}
-	return true
-}
-
-func stepCandidate(sm *stateMachine, m Message) bool {
-	switch m.Type {
-	case msgProp:
-		return false
-	case msgApp:
-		sm.becomeFollower(sm.term.Get(), m.From)
-		sm.handleAppendEntries(m)
-	case msgSnap:
-		sm.becomeFollower(m.Term, m.From)
-		sm.handleSnapshot(m)
-	case msgVote:
-		sm.send(Message{To: m.From, Type: msgVoteResp, Index: -1})
-	case msgVoteResp:
-		gr := sm.poll(m.From, m.Index >= 0)
-		switch sm.q() {
-		case gr:
-			sm.becomeLeader()
-			sm.bcastAppend()
-		case len(sm.votes) - gr:
-			sm.becomeFollower(sm.term.Get(), none)
-		}
-	}
-	return true
-}
-
-func stepFollower(sm *stateMachine, m Message) bool {
-	switch m.Type {
-	case msgProp:
-		if sm.lead.Get() == none {
-			return false
-		}
-		m.To = sm.lead.Get()
-		sm.send(m)
-	case msgApp:
-		sm.lead.Set(m.From)
-		sm.handleAppendEntries(m)
-	case msgSnap:
-		sm.handleSnapshot(m)
-	case msgVote:
-		if (sm.vote == none || sm.vote == m.From) && sm.raftLog.isUpToDate(m.Index, m.LogTerm) {
-			sm.setVote(m.From)
-			sm.send(Message{To: m.From, Type: msgVoteResp, Index: sm.raftLog.lastIndex()})
-		} else {
-			sm.send(Message{To: m.From, Type: msgVoteResp, Index: -1})
-		}
-	}
-	return true
-}
-
-func (sm *stateMachine) compact(d []byte) {
-	sm.raftLog.snap(d, sm.clusterId, sm.raftLog.applied, sm.raftLog.term(sm.raftLog.applied), sm.nodes())
-	sm.raftLog.compact(sm.raftLog.applied)
-}
-
-// restore recovers the statemachine from a snapshot. It restores the log and the
-// configuration of statemachine.
-func (sm *stateMachine) restore(s Snapshot) bool {
-	if s.Index <= sm.raftLog.committed {
-		return false
-	}
-
-	sm.raftLog.restore(s)
-	sm.index.Set(sm.raftLog.lastIndex())
-	sm.clusterId = s.ClusterId
-	sm.ins = make(map[int64]*index)
-	for _, n := range s.Nodes {
-		if n == sm.id {
-			sm.addIns(n, sm.raftLog.lastIndex(), sm.raftLog.lastIndex()+1)
-			sm.promotable = true
-		} else {
-			sm.addIns(n, 0, sm.raftLog.lastIndex()+1)
-		}
-	}
-	sm.pendingConf = false
-	return true
-}
-
-func (sm *stateMachine) needSnapshot(i int64) bool {
-	if i < sm.raftLog.offset {
-		if sm.raftLog.snapshot.IsEmpty() {
-			panic("need non-empty snapshot")
-		}
-		return true
-	}
-	return false
-}
-
-func (sm *stateMachine) nodes() []int64 {
-	nodes := make([]int64, 0, len(sm.ins))
-	for k := range sm.ins {
-		nodes = append(nodes, k)
-	}
-	return nodes
-}
-
-func (sm *stateMachine) setTerm(term int64) {
-	sm.term.Set(term)
-	sm.saveState()
-}
-
-func (sm *stateMachine) setVote(vote int64) {
-	sm.vote = vote
-	sm.saveState()
-}
-
-func (sm *stateMachine) addIns(id, match, next int64) {
-	sm.ins[id] = &index{next: next, match: match}
-	sm.saveState()
-}
-
-func (sm *stateMachine) deleteIns(id int64) {
-	delete(sm.ins, id)
-	sm.saveState()
-}
-
-// saveState saves the state to sm.unstableState
-// When there is a term change, vote change or configuration change, raft
-// must call saveState.
-func (sm *stateMachine) saveState() {
-	sm.setState(sm.vote, sm.term.Get(), sm.raftLog.committed)
-}
-
-func (sm *stateMachine) clearState() {
-	sm.setState(0, 0, 0)
-}
-
-func (sm *stateMachine) setState(vote, term, commit int64) {
-	sm.unstableState.Vote = vote
-	sm.unstableState.Term = term
-	sm.unstableState.Commit = commit
-}
-
-func (sm *stateMachine) loadEnts(ents []Entry) {
-	sm.raftLog.append(sm.raftLog.lastIndex(), ents...)
-	sm.raftLog.unstable = sm.raftLog.lastIndex() + 1
-}
-
-func (sm *stateMachine) loadState(state State) {
-	sm.raftLog.committed = state.Commit
-	sm.setTerm(state.Term)
-	sm.setVote(state.Vote)
-}
-
-func (s *State) IsEmpty() bool {
-	return s.Term == 0
-}
diff --git a/raft/raft_test.go b/raft/raft_test.go
deleted file mode 100644
index dd628c3..0000000
--- a/raft/raft_test.go
+++ /dev/null
@@ -1,1055 +0,0 @@
-package raft
-
-import (
-	"bytes"
-	"math/rand"
-	"reflect"
-	"sort"
-	"testing"
-)
-
-func TestLeaderElection(t *testing.T) {
-	tests := []struct {
-		*network
-		state stateType
-	}{
-		{newNetwork(nil, nil, nil), stateLeader},
-		{newNetwork(nil, nil, nopStepper), stateLeader},
-		{newNetwork(nil, nopStepper, nopStepper), stateCandidate},
-		{newNetwork(nil, nopStepper, nopStepper, nil), stateCandidate},
-		{newNetwork(nil, nopStepper, nopStepper, nil, nil), stateLeader},
-
-		// three logs further along than 0
-		{newNetwork(nil, ents(1), ents(2), ents(1, 3), nil), stateFollower},
-
-		// logs converge
-		{newNetwork(ents(1), nil, ents(2), ents(1), nil), stateLeader},
-	}
-
-	for i, tt := range tests {
-		tt.send(Message{From: 0, To: 0, Type: msgHup})
-		sm := tt.network.peers[0].(*stateMachine)
-		if sm.state != tt.state {
-			t.Errorf("#%d: state = %s, want %s", i, sm.state, tt.state)
-		}
-		if g := sm.term.Get(); g != 1 {
-			t.Errorf("#%d: term = %d, want %d", i, g, 1)
-		}
-	}
-}
-
-func TestLogReplication(t *testing.T) {
-	tests := []struct {
-		*network
-		msgs       []Message
-		wcommitted int64
-	}{
-		{
-			newNetwork(nil, nil, nil),
-			[]Message{
-				{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("somedata")}}},
-			},
-			2,
-		},
-		{
-			newNetwork(nil, nil, nil),
-			[]Message{
-
-				{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("somedata")}}},
-				{From: 0, To: 1, Type: msgHup},
-				{From: 0, To: 1, Type: msgProp, Entries: []Entry{{Data: []byte("somedata")}}},
-			},
-			4,
-		},
-	}
-
-	for i, tt := range tests {
-		tt.send(Message{From: 0, To: 0, Type: msgHup})
-
-		for _, m := range tt.msgs {
-			tt.send(m)
-		}
-
-		for j, x := range tt.network.peers {
-			sm := x.(*stateMachine)
-
-			if sm.raftLog.committed != tt.wcommitted {
-				t.Errorf("#%d.%d: committed = %d, want %d", i, j, sm.raftLog.committed, tt.wcommitted)
-			}
-
-			ents := make([]Entry, 0)
-			for _, e := range sm.nextEnts() {
-				if e.Data != nil {
-					ents = append(ents, e)
-				}
-			}
-			props := make([]Message, 0)
-			for _, m := range tt.msgs {
-				if m.Type == msgProp {
-					props = append(props, m)
-				}
-			}
-			for k, m := range props {
-				if !bytes.Equal(ents[k].Data, m.Entries[0].Data) {
-					t.Errorf("#%d.%d: data = %d, want %d", i, j, ents[k].Data, m.Entries[0].Data)
-				}
-			}
-		}
-	}
-}
-
-func TestSingleNodeCommit(t *testing.T) {
-	tt := newNetwork(nil)
-	tt.send(Message{From: 0, To: 0, Type: msgHup})
-	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
-	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
-
-	sm := tt.peers[0].(*stateMachine)
-	if sm.raftLog.committed != 3 {
-		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 3)
-	}
-}
-
-// TestCannotCommitWithoutNewTermEntry tests the entries cannot be committed
-// when leader changes, no new proposal comes in and ChangeTerm proposal is
-// filtered.
-func TestCannotCommitWithoutNewTermEntry(t *testing.T) {
-	tt := newNetwork(nil, nil, nil, nil, nil)
-	tt.send(Message{From: 0, To: 0, Type: msgHup})
-
-	// 0 cannot reach 2,3,4
-	tt.cut(0, 2)
-	tt.cut(0, 3)
-	tt.cut(0, 4)
-
-	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
-	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
-
-	sm := tt.peers[0].(*stateMachine)
-	if sm.raftLog.committed != 1 {
-		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 1)
-	}
-
-	// network recovery
-	tt.recover()
-	// avoid committing ChangeTerm proposal
-	tt.ignore(msgApp)
-
-	// elect 1 as the new leader with term 2
-	tt.send(Message{From: 1, To: 1, Type: msgHup})
-
-	// no log entries from previous term should be committed
-	sm = tt.peers[1].(*stateMachine)
-	if sm.raftLog.committed != 1 {
-		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 1)
-	}
-
-	tt.recover()
-
-	// send out a heartbeat
-	// after append a ChangeTerm entry from the current term, all entries
-	// should be committed
-	tt.send(Message{From: 1, To: 1, Type: msgBeat})
-
-	if sm.raftLog.committed != 4 {
-		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 4)
-	}
-
-	// still be able to append a entry
-	tt.send(Message{From: 1, To: 1, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
-
-	if sm.raftLog.committed != 5 {
-		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 5)
-	}
-}
-
-// TestCommitWithoutNewTermEntry tests the entries could be committed
-// when leader changes, no new proposal comes in.
-func TestCommitWithoutNewTermEntry(t *testing.T) {
-	tt := newNetwork(nil, nil, nil, nil, nil)
-	tt.send(Message{From: 0, To: 0, Type: msgHup})
-
-	// 0 cannot reach 2,3,4
-	tt.cut(0, 2)
-	tt.cut(0, 3)
-	tt.cut(0, 4)
-
-	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
-	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
-
-	sm := tt.peers[0].(*stateMachine)
-	if sm.raftLog.committed != 1 {
-		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 1)
-	}
-
-	// network recovery
-	tt.recover()
-
-	// elect 1 as the new leader with term 2
-	// after append a ChangeTerm entry from the current term, all entries
-	// should be committed
-	tt.send(Message{From: 1, To: 1, Type: msgHup})
-
-	if sm.raftLog.committed != 4 {
-		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 4)
-	}
-}
-
-func TestDuelingCandidates(t *testing.T) {
-	a := newStateMachine(0, nil) // k, id are set later
-	b := newStateMachine(0, nil)
-	c := newStateMachine(0, nil)
-
-	nt := newNetwork(a, b, c)
-	nt.cut(0, 2)
-
-	nt.send(Message{From: 0, To: 0, Type: msgHup})
-	nt.send(Message{From: 2, To: 2, Type: msgHup})
-
-	nt.recover()
-	nt.send(Message{From: 2, To: 2, Type: msgHup})
-
-	wlog := &raftLog{ents: []Entry{{}, Entry{Type: Normal, Data: nil, Term: 1, Index: 1}}, committed: 1}
-	tests := []struct {
-		sm      *stateMachine
-		state   stateType
-		term    int64
-		raftLog *raftLog
-	}{
-		{a, stateFollower, 2, wlog},
-		{b, stateFollower, 2, wlog},
-		{c, stateFollower, 2, newLog()},
-	}
-
-	for i, tt := range tests {
-		if g := tt.sm.state; g != tt.state {
-			t.Errorf("#%d: state = %s, want %s", i, g, tt.state)
-		}
-		if g := tt.sm.term.Get(); g != tt.term {
-			t.Errorf("#%d: term = %d, want %d", i, g, tt.term)
-		}
-		base := ltoa(tt.raftLog)
-		if sm, ok := nt.peers[int64(i)].(*stateMachine); ok {
-			l := ltoa(sm.raftLog)
-			if g := diffu(base, l); g != "" {
-				t.Errorf("#%d: diff:\n%s", i, g)
-			}
-		} else {
-			t.Logf("#%d: empty log", i)
-		}
-	}
-}
-
-func TestCandidateConcede(t *testing.T) {
-	tt := newNetwork(nil, nil, nil)
-	tt.isolate(0)
-
-	tt.send(Message{From: 0, To: 0, Type: msgHup})
-	tt.send(Message{From: 2, To: 2, Type: msgHup})
-
-	// heal the partition
-	tt.recover()
-
-	data := []byte("force follower")
-	// send a proposal to 2 to flush out a msgApp to 0
-	tt.send(Message{From: 2, To: 2, Type: msgProp, Entries: []Entry{{Data: data}}})
-
-	a := tt.peers[0].(*stateMachine)
-	if g := a.state; g != stateFollower {
-		t.Errorf("state = %s, want %s", g, stateFollower)
-	}
-	if g := a.term; g != 1 {
-		t.Errorf("term = %d, want %d", g, 1)
-	}
-	wantLog := ltoa(&raftLog{ents: []Entry{{}, {Type: Normal, Data: nil, Term: 1, Index: 1}, {Term: 1, Index: 2, Data: data}}, committed: 2})
-	for i, p := range tt.peers {
-		if sm, ok := p.(*stateMachine); ok {
-			l := ltoa(sm.raftLog)
-			if g := diffu(wantLog, l); g != "" {
-				t.Errorf("#%d: diff:\n%s", i, g)
-			}
-		} else {
-			t.Logf("#%d: empty log", i)
-		}
-	}
-}
-
-func TestSingleNodeCandidate(t *testing.T) {
-	tt := newNetwork(nil)
-	tt.send(Message{From: 0, To: 0, Type: msgHup})
-
-	sm := tt.peers[0].(*stateMachine)
-	if sm.state != stateLeader {
-		t.Errorf("state = %d, want %d", sm.state, stateLeader)
-	}
-}
-
-func TestOldMessages(t *testing.T) {
-	tt := newNetwork(nil, nil, nil)
-	// make 0 leader @ term 3
-	tt.send(Message{From: 0, To: 0, Type: msgHup})
-	tt.send(Message{From: 1, To: 1, Type: msgHup})
-	tt.send(Message{From: 0, To: 0, Type: msgHup})
-	// pretend we're an old leader trying to make progress
-	tt.send(Message{From: 0, To: 0, Type: msgApp, Term: 1, Entries: []Entry{{Term: 1}}})
-
-	l := &raftLog{
-		ents: []Entry{
-			{}, {Type: Normal, Data: nil, Term: 1, Index: 1},
-			{Type: Normal, Data: nil, Term: 2, Index: 2}, {Type: Normal, Data: nil, Term: 3, Index: 3},
-		},
-		committed: 3,
-	}
-	base := ltoa(l)
-	for i, p := range tt.peers {
-		if sm, ok := p.(*stateMachine); ok {
-			l := ltoa(sm.raftLog)
-			if g := diffu(base, l); g != "" {
-				t.Errorf("#%d: diff:\n%s", i, g)
-			}
-		} else {
-			t.Logf("#%d: empty log", i)
-		}
-	}
-}
-
-// TestOldMessagesReply - optimization - reply with new term.
-
-func TestProposal(t *testing.T) {
-	tests := []struct {
-		*network
-		success bool
-	}{
-		{newNetwork(nil, nil, nil), true},
-		{newNetwork(nil, nil, nopStepper), true},
-		{newNetwork(nil, nopStepper, nopStepper), false},
-		{newNetwork(nil, nopStepper, nopStepper, nil), false},
-		{newNetwork(nil, nopStepper, nopStepper, nil, nil), true},
-	}
-
-	for i, tt := range tests {
-		send := func(m Message) {
-			defer func() {
-				// only recover is we expect it to panic so
-				// panics we don't expect go up.
-				if !tt.success {
-					e := recover()
-					if e != nil {
-						t.Logf("#%d: err: %s", i, e)
-					}
-				}
-			}()
-			tt.send(m)
-		}
-
-		data := []byte("somedata")
-
-		// promote 0 the leader
-		send(Message{From: 0, To: 0, Type: msgHup})
-		send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: data}}})
-
-		wantLog := newLog()
-		if tt.success {
-			wantLog = &raftLog{ents: []Entry{{}, {Type: Normal, Data: nil, Term: 1, Index: 1}, {Term: 1, Index: 2, Data: data}}, committed: 2}
-		}
-		base := ltoa(wantLog)
-		for i, p := range tt.peers {
-			if sm, ok := p.(*stateMachine); ok {
-				l := ltoa(sm.raftLog)
-				if g := diffu(base, l); g != "" {
-					t.Errorf("#%d: diff:\n%s", i, g)
-				}
-			} else {
-				t.Logf("#%d: empty log", i)
-			}
-		}
-		sm := tt.network.peers[0].(*stateMachine)
-		if g := sm.term.Get(); g != 1 {
-			t.Errorf("#%d: term = %d, want %d", i, g, 1)
-		}
-	}
-}
-
-func TestProposalByProxy(t *testing.T) {
-	data := []byte("somedata")
-	tests := []*network{
-		newNetwork(nil, nil, nil),
-		newNetwork(nil, nil, nopStepper),
-	}
-
-	for i, tt := range tests {
-		// promote 0 the leader
-		tt.send(Message{From: 0, To: 0, Type: msgHup})
-
-		// propose via follower
-		tt.send(Message{From: 1, To: 1, Type: msgProp, Entries: []Entry{{Data: []byte("somedata")}}})
-
-		wantLog := &raftLog{ents: []Entry{{}, {Type: Normal, Data: nil, Term: 1, Index: 1}, {Term: 1, Data: data, Index: 2}}, committed: 2}
-		base := ltoa(wantLog)
-		for i, p := range tt.peers {
-			if sm, ok := p.(*stateMachine); ok {
-				l := ltoa(sm.raftLog)
-				if g := diffu(base, l); g != "" {
-					t.Errorf("#%d: diff:\n%s", i, g)
-				}
-			} else {
-				t.Logf("#%d: empty log", i)
-			}
-		}
-		sm := tt.peers[0].(*stateMachine)
-		if g := sm.term.Get(); g != 1 {
-			t.Errorf("#%d: term = %d, want %d", i, g, 1)
-		}
-	}
-}
-
-func TestCommit(t *testing.T) {
-	tests := []struct {
-		matches []int64
-		logs    []Entry
-		smTerm  int64
-		w       int64
-	}{
-		// single
-		{[]int64{1}, []Entry{{}, {Term: 1}}, 1, 1},
-		{[]int64{1}, []Entry{{}, {Term: 1}}, 2, 0},
-		{[]int64{2}, []Entry{{}, {Term: 1}, {Term: 2}}, 2, 2},
-		{[]int64{1}, []Entry{{}, {Term: 2}}, 2, 1},
-
-		// odd
-		{[]int64{2, 1, 1}, []Entry{{}, {Term: 1}, {Term: 2}}, 1, 1},
-		{[]int64{2, 1, 1}, []Entry{{}, {Term: 1}, {Term: 1}}, 2, 0},
-		{[]int64{2, 1, 2}, []Entry{{}, {Term: 1}, {Term: 2}}, 2, 2},
-		{[]int64{2, 1, 2}, []Entry{{}, {Term: 1}, {Term: 1}}, 2, 0},
-
-		// even
-		{[]int64{2, 1, 1, 1}, []Entry{{}, {Term: 1}, {Term: 2}}, 1, 1},
-		{[]int64{2, 1, 1, 1}, []Entry{{}, {Term: 1}, {Term: 1}}, 2, 0},
-		{[]int64{2, 1, 1, 2}, []Entry{{}, {Term: 1}, {Term: 2}}, 1, 1},
-		{[]int64{2, 1, 1, 2}, []Entry{{}, {Term: 1}, {Term: 1}}, 2, 0},
-		{[]int64{2, 1, 2, 2}, []Entry{{}, {Term: 1}, {Term: 2}}, 2, 2},
-		{[]int64{2, 1, 2, 2}, []Entry{{}, {Term: 1}, {Term: 1}}, 2, 0},
-	}
-
-	for i, tt := range tests {
-		ins := make(map[int64]*index)
-		for j := 0; j < len(tt.matches); j++ {
-			ins[int64(j)] = &index{tt.matches[j], tt.matches[j] + 1}
-		}
-		sm := &stateMachine{raftLog: &raftLog{ents: tt.logs}, ins: ins, term: atomicInt(tt.smTerm)}
-		sm.maybeCommit()
-		if g := sm.raftLog.committed; g != tt.w {
-			t.Errorf("#%d: committed = %d, want %d", i, g, tt.w)
-		}
-	}
-}
-
-// TestHandleMsgApp ensures:
-// 1. Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm.
-// 2. If an existing entry conflicts with a new one (same index but different terms),
-//    delete the existing entry and all that follow it; append any new entries not already in the log.
-// 3. If leaderCommit > commitIndex, set commitIndex = min(leaderCommit, index of last new entry).
-func TestHandleMsgApp(t *testing.T) {
-	tests := []struct {
-		m       Message
-		wIndex  int64
-		wCommit int64
-		wAccept bool
-	}{
-		// Ensure 1
-		{Message{Type: msgApp, Term: 2, LogTerm: 3, Index: 2, Commit: 3}, 2, 0, false}, // previous log mismatch
-		{Message{Type: msgApp, Term: 2, LogTerm: 3, Index: 3, Commit: 3}, 2, 0, false}, // previous log non-exist
-
-		// Ensure 2
-		{Message{Type: msgApp, Term: 2, LogTerm: 1, Index: 1, Commit: 1}, 2, 1, true},
-		{Message{Type: msgApp, Term: 2, LogTerm: 0, Index: 0, Commit: 1, Entries: []Entry{{Term: 2}}}, 1, 1, true},
-		{Message{Type: msgApp, Term: 2, LogTerm: 2, Index: 2, Commit: 3, Entries: []Entry{{Term: 2}, {Term: 2}}}, 4, 3, true},
-		{Message{Type: msgApp, Term: 2, LogTerm: 2, Index: 2, Commit: 4, Entries: []Entry{{Term: 2}}}, 3, 3, true},
-		{Message{Type: msgApp, Term: 2, LogTerm: 1, Index: 1, Commit: 4, Entries: []Entry{{Term: 2}}}, 2, 2, true},
-
-		// Ensure 3
-		{Message{Type: msgApp, Term: 2, LogTerm: 2, Index: 2, Commit: 2}, 2, 2, true},
-		{Message{Type: msgApp, Term: 2, LogTerm: 2, Index: 2, Commit: 4}, 2, 2, true}, // commit upto min(commit, last)
-	}
-
-	for i, tt := range tests {
-		sm := &stateMachine{
-			state:   stateFollower,
-			term:    2,
-			raftLog: &raftLog{committed: 0, ents: []Entry{{}, {Term: 1}, {Term: 2}}},
-		}
-
-		sm.handleAppendEntries(tt.m)
-		if sm.raftLog.lastIndex() != tt.wIndex {
-			t.Errorf("#%d: lastIndex = %d, want %d", i, sm.raftLog.lastIndex(), tt.wIndex)
-		}
-		if sm.raftLog.committed != tt.wCommit {
-			t.Errorf("#%d: committed = %d, want %d", i, sm.raftLog.committed, tt.wCommit)
-		}
-		m := sm.Msgs()
-		if len(m) != 1 {
-			t.Errorf("#%d: msg = nil, want 1")
-		}
-		gaccept := true
-		if m[0].Index == -1 {
-			gaccept = false
-		}
-		if gaccept != tt.wAccept {
-			t.Errorf("#%d: accept = %v, want %v", gaccept, tt.wAccept)
-		}
-	}
-}
-
-func TestRecvMsgVote(t *testing.T) {
-	tests := []struct {
-		state   stateType
-		i, term int64
-		voteFor int64
-		w       int64
-	}{
-		{stateFollower, 0, 0, none, -1},
-		{stateFollower, 0, 1, none, -1},
-		{stateFollower, 0, 2, none, -1},
-		{stateFollower, 0, 3, none, 2},
-
-		{stateFollower, 1, 0, none, -1},
-		{stateFollower, 1, 1, none, -1},
-		{stateFollower, 1, 2, none, -1},
-		{stateFollower, 1, 3, none, 2},
-
-		{stateFollower, 2, 0, none, -1},
-		{stateFollower, 2, 1, none, -1},
-		{stateFollower, 2, 2, none, 2},
-		{stateFollower, 2, 3, none, 2},
-
-		{stateFollower, 3, 0, none, -1},
-		{stateFollower, 3, 1, none, -1},
-		{stateFollower, 3, 2, none, 2},
-		{stateFollower, 3, 3, none, 2},
-
-		{stateFollower, 3, 2, 1, 2},
-		{stateFollower, 3, 2, 0, -1},
-
-		{stateLeader, 3, 3, 0, -1},
-		{stateCandidate, 3, 3, 0, -1},
-	}
-
-	for i, tt := range tests {
-		sm := &stateMachine{
-			state:   tt.state,
-			vote:    tt.voteFor,
-			raftLog: &raftLog{ents: []Entry{{}, {Term: 2}, {Term: 2}}},
-		}
-
-		sm.Step(Message{Type: msgVote, From: 1, Index: tt.i, LogTerm: tt.term})
-
-		msgs := sm.Msgs()
-		if g := len(msgs); g != 1 {
-			t.Errorf("#%d: len(msgs) = %d, want 1", i, g)
-			continue
-		}
-		if g := msgs[0].Index; g != tt.w {
-			t.Errorf("#%d, m.Index = %d, want %d", i, g, tt.w)
-		}
-	}
-}
-
-func TestStateTransition(t *testing.T) {
-	tests := []struct {
-		from   stateType
-		to     stateType
-		wallow bool
-		wterm  int64
-		wlead  int64
-	}{
-		{stateFollower, stateFollower, true, 1, none},
-		{stateFollower, stateCandidate, true, 1, none},
-		{stateFollower, stateLeader, false, -1, none},
-
-		{stateCandidate, stateFollower, true, 0, none},
-		{stateCandidate, stateCandidate, true, 1, none},
-		{stateCandidate, stateLeader, true, 0, 0},
-
-		{stateLeader, stateFollower, true, 1, none},
-		{stateLeader, stateCandidate, false, 1, none},
-		{stateLeader, stateLeader, true, 0, 0},
-	}
-
-	for i, tt := range tests {
-		func() {
-			defer func() {
-				if r := recover(); r != nil {
-					if tt.wallow == true {
-						t.Errorf("%d: allow = %v, want %v", i, false, true)
-					}
-				}
-			}()
-
-			sm := newStateMachine(0, []int64{0})
-			sm.state = tt.from
-
-			switch tt.to {
-			case stateFollower:
-				sm.becomeFollower(tt.wterm, tt.wlead)
-			case stateCandidate:
-				sm.becomeCandidate()
-			case stateLeader:
-				sm.becomeLeader()
-			}
-
-			if sm.term.Get() != tt.wterm {
-				t.Errorf("%d: term = %d, want %d", i, sm.term.Get(), tt.wterm)
-			}
-			if sm.lead.Get() != tt.wlead {
-				t.Errorf("%d: lead = %d, want %d", i, sm.lead, tt.wlead)
-			}
-		}()
-	}
-}
-
-func TestConf(t *testing.T) {
-	sm := newStateMachine(0, []int64{0})
-	sm.becomeCandidate()
-	sm.becomeLeader()
-
-	sm.Step(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Type: AddNode}}})
-	if sm.raftLog.lastIndex() != 2 {
-		t.Errorf("lastindex = %d, want %d", sm.raftLog.lastIndex(), 1)
-	}
-	if !sm.pendingConf {
-		t.Errorf("pendingConf = %v, want %v", sm.pendingConf, true)
-	}
-	if sm.raftLog.ents[2].Type != AddNode {
-		t.Errorf("type = %d, want %d", sm.raftLog.ents[1].Type, AddNode)
-	}
-
-	// deny the second configuration change request if there is a pending one
-	sm.Step(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Type: AddNode}}})
-	if sm.raftLog.lastIndex() != 2 {
-		t.Errorf("lastindex = %d, want %d", sm.raftLog.lastIndex(), 1)
-	}
-}
-
-// Ensures that the new leader sets the pendingConf flag correctly according to
-// the uncommitted log entries
-func TestConfChangeLeader(t *testing.T) {
-	tests := []struct {
-		et       int64
-		wPending bool
-	}{
-		{Normal, false},
-		{AddNode, true},
-		{RemoveNode, true},
-	}
-
-	for i, tt := range tests {
-		sm := newStateMachine(0, []int64{0})
-		sm.raftLog = &raftLog{ents: []Entry{{}, {Type: tt.et}}}
-
-		sm.becomeCandidate()
-		sm.becomeLeader()
-
-		if sm.pendingConf != tt.wPending {
-			t.Errorf("#%d: pendingConf = %v, want %v", i, sm.pendingConf, tt.wPending)
-		}
-	}
-}
-
-func TestAllServerStepdown(t *testing.T) {
-	tests := []struct {
-		state stateType
-
-		wstate stateType
-		wterm  int64
-		windex int64
-	}{
-		{stateFollower, stateFollower, 3, 1},
-		{stateCandidate, stateFollower, 3, 1},
-		{stateLeader, stateFollower, 3, 2},
-	}
-
-	tmsgTypes := [...]messageType{msgVote, msgApp}
-	tterm := int64(3)
-
-	for i, tt := range tests {
-		sm := newStateMachine(0, []int64{0, 1, 2})
-		switch tt.state {
-		case stateFollower:
-			sm.becomeFollower(1, 0)
-		case stateCandidate:
-			sm.becomeCandidate()
-		case stateLeader:
-			sm.becomeCandidate()
-			sm.becomeLeader()
-		}
-
-		for j, msgType := range tmsgTypes {
-			sm.Step(Message{From: 1, Type: msgType, Term: tterm, LogTerm: tterm})
-
-			if sm.state != tt.wstate {
-				t.Errorf("#%d.%d state = %v , want %v", i, j, sm.state, tt.wstate)
-			}
-			if sm.term.Get() != tt.wterm {
-				t.Errorf("#%d.%d term = %v , want %v", i, j, sm.term.Get(), tt.wterm)
-			}
-			if int64(len(sm.raftLog.ents)) != tt.windex {
-				t.Errorf("#%d.%d index = %v , want %v", i, j, len(sm.raftLog.ents), tt.windex)
-			}
-			wlead := int64(1)
-			if msgType == msgVote {
-				wlead = none
-			}
-			if sm.lead.Get() != wlead {
-				t.Errorf("#%d, sm.lead = %d, want %d", i, sm.lead.Get(), none)
-			}
-		}
-	}
-}
-
-func TestLeaderAppResp(t *testing.T) {
-	tests := []struct {
-		index      int64
-		wmsgNum    int
-		windex     int64
-		wcommitted int64
-	}{
-		{-1, 1, 1, 0}, // bad resp; leader does not commit; reply with log entries
-		{2, 2, 2, 2},  // good resp; leader commits; broadcast with commit index
-	}
-
-	for i, tt := range tests {
-		// sm term is 1 after it becomes the leader.
-		// thus the last log term must be 1 to be committed.
-		sm := newStateMachine(0, []int64{0, 1, 2})
-		sm.raftLog = &raftLog{ents: []Entry{{}, {Term: 0}, {Term: 1}}}
-		sm.becomeCandidate()
-		sm.becomeLeader()
-		sm.Msgs()
-		sm.Step(Message{From: 1, Type: msgAppResp, Index: tt.index, Term: sm.term.Get()})
-		msgs := sm.Msgs()
-
-		if len(msgs) != tt.wmsgNum {
-			t.Errorf("#%d msgNum = %d, want %d", i, len(msgs), tt.wmsgNum)
-		}
-		for j, msg := range msgs {
-			if msg.Index != tt.windex {
-				t.Errorf("#%d.%d index = %d, want %d", i, j, msg.Index, tt.windex)
-			}
-			if msg.Commit != tt.wcommitted {
-				t.Errorf("#%d.%d commit = %d, want %d", i, j, msg.Commit, tt.wcommitted)
-			}
-		}
-	}
-}
-
-// tests the output of the statemachine when receiving msgBeat
-func TestRecvMsgBeat(t *testing.T) {
-	tests := []struct {
-		state stateType
-		wMsg  int
-	}{
-		{stateLeader, 2},
-		// candidate and follower should ignore msgBeat
-		{stateCandidate, 0},
-		{stateFollower, 0},
-	}
-
-	for i, tt := range tests {
-		sm := newStateMachine(0, []int64{0, 1, 2})
-		sm.raftLog = &raftLog{ents: []Entry{{}, {Term: 0}, {Term: 1}}}
-		sm.term.Set(1)
-		sm.state = tt.state
-		sm.Step(Message{From: 0, To: 0, Type: msgBeat})
-
-		msgs := sm.Msgs()
-		if len(msgs) != tt.wMsg {
-			t.Errorf("%d: len(msgs) = %d, want %d", i, len(msgs), tt.wMsg)
-		}
-		for _, m := range msgs {
-			if m.Type != msgApp {
-				t.Errorf("%d: msg.type = %v, want %v", m.Type, msgApp)
-			}
-		}
-	}
-}
-
-func TestRestore(t *testing.T) {
-	s := Snapshot{
-		ClusterId: 0xBEEF,
-		Index:     defaultCompactThreshold + 1,
-		Term:      defaultCompactThreshold + 1,
-		Nodes:     []int64{0, 1, 2},
-	}
-
-	sm := newStateMachine(0, []int64{0, 1})
-	if ok := sm.restore(s); !ok {
-		t.Fatal("restore fail, want succeed")
-	}
-
-	if sm.clusterId != s.ClusterId {
-		t.Errorf("sm.cluster = %x, want %x", sm.clusterId, s.ClusterId)
-	}
-	if sm.raftLog.lastIndex() != s.Index {
-		t.Errorf("log.lastIndex = %d, want %d", sm.raftLog.lastIndex(), s.Index)
-	}
-	if sm.raftLog.term(s.Index) != s.Term {
-		t.Errorf("log.lastTerm = %d, want %d", sm.raftLog.term(s.Index), s.Term)
-	}
-	sg := int64Slice(sm.nodes())
-	sw := int64Slice(s.Nodes)
-	sort.Sort(sg)
-	sort.Sort(sw)
-	if !reflect.DeepEqual(sg, sw) {
-		t.Errorf("sm.Nodes = %+v, want %+v", sg, sw)
-	}
-	if !reflect.DeepEqual(sm.raftLog.snapshot, s) {
-		t.Errorf("snapshot = %+v, want %+v", sm.raftLog.snapshot, s)
-	}
-
-	if ok := sm.restore(s); ok {
-		t.Fatal("restore succeed, want fail")
-	}
-}
-
-func TestProvideSnap(t *testing.T) {
-	s := Snapshot{
-		Index: defaultCompactThreshold + 1,
-		Term:  defaultCompactThreshold + 1,
-		Nodes: []int64{0, 1},
-	}
-	sm := newStateMachine(0, []int64{0})
-	// restore the statemachin from a snapshot
-	// so it has a compacted log and a snapshot
-	sm.restore(s)
-
-	sm.becomeCandidate()
-	sm.becomeLeader()
-
-	sm.Step(Message{From: 0, To: 0, Type: msgBeat})
-	msgs := sm.Msgs()
-	if len(msgs) != 1 {
-		t.Errorf("len(msgs) = %d, want 1", len(msgs))
-	}
-	m := msgs[0]
-	if m.Type != msgApp {
-		t.Errorf("m.Type = %v, want %v", m.Type, msgApp)
-	}
-
-	// force set the next of node 1, so that
-	// node 1 needs a snapshot
-	sm.ins[1].next = sm.raftLog.offset
-
-	sm.Step(Message{From: 1, To: 0, Type: msgAppResp, Index: -1})
-	msgs = sm.Msgs()
-	if len(msgs) != 1 {
-		t.Errorf("len(msgs) = %d, want 1", len(msgs))
-	}
-	m = msgs[0]
-	if m.Type != msgSnap {
-		t.Errorf("m.Type = %v, want %v", m.Type, msgSnap)
-	}
-}
-
-func TestRestoreFromSnapMsg(t *testing.T) {
-	s := Snapshot{
-		Index: defaultCompactThreshold + 1,
-		Term:  defaultCompactThreshold + 1,
-		Nodes: []int64{0, 1},
-	}
-	m := Message{Type: msgSnap, From: 0, Term: 1, Snapshot: s}
-
-	sm := newStateMachine(1, []int64{0, 1})
-	sm.Step(m)
-
-	if !reflect.DeepEqual(sm.raftLog.snapshot, s) {
-		t.Errorf("snapshot = %+v, want %+v", sm.raftLog.snapshot, s)
-	}
-}
-
-func TestSlowNodeRestore(t *testing.T) {
-	nt := newNetwork(nil, nil, nil)
-	nt.send(Message{From: 0, To: 0, Type: msgHup})
-
-	nt.isolate(2)
-	for j := 0; j < defaultCompactThreshold+1; j++ {
-		nt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{}}})
-	}
-	lead := nt.peers[0].(*stateMachine)
-	lead.nextEnts()
-	lead.compact(nil)
-
-	nt.recover()
-	nt.send(Message{From: 0, To: 0, Type: msgBeat})
-
-	follower := nt.peers[2].(*stateMachine)
-	if !reflect.DeepEqual(follower.raftLog.snapshot, lead.raftLog.snapshot) {
-		t.Errorf("follower.snap = %+v, want %+v", follower.raftLog.snapshot, lead.raftLog.snapshot)
-	}
-
-	committed := follower.raftLog.lastIndex()
-	nt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{}}})
-	if follower.raftLog.committed != committed+1 {
-		t.Errorf("follower.comitted = %d, want %d", follower.raftLog.committed, committed+1)
-	}
-}
-
-func TestUnstableState(t *testing.T) {
-	sm := newStateMachine(0, []int64{0})
-	w := State{}
-
-	sm.setVote(1)
-	w.Vote = 1
-	if !reflect.DeepEqual(sm.unstableState, w) {
-		t.Errorf("unstableState = %v, want %v", sm.unstableState, w)
-	}
-	sm.clearState()
-
-	sm.setTerm(1)
-	w.Term = 1
-	if !reflect.DeepEqual(sm.unstableState, w) {
-		t.Errorf("unstableState = %v, want %v", sm.unstableState, w)
-	}
-	sm.clearState()
-
-	sm.raftLog.committed = 1
-	sm.addIns(1, 0, 0)
-	w.Commit = 1
-	if !reflect.DeepEqual(sm.unstableState, w) {
-		t.Errorf("unstableState = %v, want %v", sm.unstableState, w)
-	}
-	sm.clearState()
-
-	sm.raftLog.committed = 2
-	sm.deleteIns(1)
-	w.Commit = 2
-	if !reflect.DeepEqual(sm.unstableState, w) {
-		t.Errorf("unstableState = %v, want %v", sm.unstableState, w)
-	}
-	sm.clearState()
-}
-
-func ents(terms ...int64) *stateMachine {
-	ents := []Entry{{}}
-	for _, term := range terms {
-		ents = append(ents, Entry{Term: term})
-	}
-
-	sm := &stateMachine{raftLog: &raftLog{ents: ents}}
-	sm.reset(0)
-	return sm
-}
-
-type network struct {
-	peers   map[int64]Interface
-	dropm   map[connem]float64
-	ignorem map[messageType]bool
-}
-
-// newNetwork initializes a network from peers.
-// A nil node will be replaced with a new *stateMachine.
-// A *stateMachine will get its k, id.
-// When using stateMachine, the address list is always [0, n).
-func newNetwork(peers ...Interface) *network {
-	size := len(peers)
-	defaultPeerAddrs := make([]int64, size)
-	for i := 0; i < size; i++ {
-		defaultPeerAddrs[i] = int64(i)
-	}
-
-	npeers := make(map[int64]Interface, size)
-
-	for id, p := range peers {
-		nid := int64(id)
-		switch v := p.(type) {
-		case nil:
-			sm := newStateMachine(nid, defaultPeerAddrs)
-			npeers[nid] = sm
-		case *stateMachine:
-			v.id = nid
-			v.ins = make(map[int64]*index)
-			for i := 0; i < size; i++ {
-				v.ins[int64(i)] = &index{}
-			}
-			v.reset(0)
-			npeers[nid] = v
-		case *Node:
-			npeers[v.sm.id] = v
-		default:
-			npeers[nid] = v
-		}
-	}
-	return &network{
-		peers:   npeers,
-		dropm:   make(map[connem]float64),
-		ignorem: make(map[messageType]bool),
-	}
-}
-
-func (nw *network) send(msgs ...Message) {
-	for len(msgs) > 0 {
-		m := msgs[0]
-		p := nw.peers[m.To]
-		p.Step(m)
-		msgs = append(msgs[1:], nw.filter(p.Msgs())...)
-	}
-}
-
-func (nw *network) drop(from, to int64, perc float64) {
-	nw.dropm[connem{from, to}] = perc
-}
-
-func (nw *network) cut(one, other int64) {
-	nw.drop(one, other, 1)
-	nw.drop(other, one, 1)
-}
-
-func (nw *network) isolate(id int64) {
-	for i := 0; i < len(nw.peers); i++ {
-		nid := int64(i)
-		if nid != id {
-			nw.drop(id, nid, 1.0)
-			nw.drop(nid, id, 1.0)
-		}
-	}
-}
-
-func (nw *network) ignore(t messageType) {
-	nw.ignorem[t] = true
-}
-
-func (nw *network) recover() {
-	nw.dropm = make(map[connem]float64)
-	nw.ignorem = make(map[messageType]bool)
-}
-
-func (nw *network) filter(msgs []Message) []Message {
-	mm := make([]Message, 0)
-	for _, m := range msgs {
-		if nw.ignorem[m.Type] {
-			continue
-		}
-		switch m.Type {
-		case msgHup:
-			// hups never go over the network, so don't drop them but panic
-			panic("unexpected msgHup")
-		default:
-			perc := nw.dropm[connem{m.From, m.To}]
-			if n := rand.Float64(); n < perc {
-				continue
-			}
-		}
-		mm = append(mm, m)
-	}
-	return mm
-}
-
-type connem struct {
-	from, to int64
-}
-
-type blackHole struct{}
-
-func (blackHole) Step(Message) bool { return true }
-func (blackHole) Msgs() []Message   { return nil }
-
-var nopStepper = &blackHole{}
diff --git a/raft/snapshot.go b/raft/snapshot.go
deleted file mode 100644
index 95a8ca4..0000000
--- a/raft/snapshot.go
+++ /dev/null
@@ -1,18 +0,0 @@
-package raft
-
-var emptySnapshot = Snapshot{}
-
-type Snapshot struct {
-	ClusterId int64
-	Data      []byte
-	// the configuration
-	Nodes []int64
-	// the index at which the snapshot was taken.
-	Index int64
-	// the log term of the index
-	Term int64
-}
-
-func (s Snapshot) IsEmpty() bool {
-	return s.Term == 0
-}
diff --git a/raft/state.pb.go b/raft/state.pb.go
deleted file mode 100644
index c7ecb13..0000000
--- a/raft/state.pb.go
+++ /dev/null
@@ -1,210 +0,0 @@
-// Code generated by protoc-gen-gogo.
-// source: state.proto
-// DO NOT EDIT!
-
-/*
-	Package raft is a generated protocol buffer package.
-
-	It is generated from these files:
-		state.proto
-
-	It has these top-level messages:
-		State
-*/
-package raft
-
-import proto "code.google.com/p/gogoprotobuf/proto"
-import json "encoding/json"
-import math "math"
-
-// discarding unused import gogoproto "code.google.com/p/gogoprotobuf/gogoproto/gogo.pb"
-
-import io "io"
-import code_google_com_p_gogoprotobuf_proto "code.google.com/p/gogoprotobuf/proto"
-
-// Reference proto, json, and math imports to suppress error if they are not otherwise used.
-var _ = proto.Marshal
-var _ = &json.SyntaxError{}
-var _ = math.Inf
-
-type State struct {
-	Term             int64  `protobuf:"varint,1,req,name=term" json:"term"`
-	Vote             int64  `protobuf:"varint,2,req,name=vote" json:"vote"`
-	Commit           int64  `protobuf:"varint,3,req,name=commit" json:"commit"`
-	XXX_unrecognized []byte `json:"-"`
-}
-
-func (m *State) Reset()         { *m = State{} }
-func (m *State) String() string { return proto.CompactTextString(m) }
-func (*State) ProtoMessage()    {}
-
-func init() {
-}
-func (m *State) Unmarshal(data []byte) error {
-	l := len(data)
-	index := 0
-	for index < l {
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if index >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := data[index]
-			index++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
-			}
-			for shift := uint(0); ; shift += 7 {
-				if index >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := data[index]
-				index++
-				m.Term |= (int64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 2:
-			if wireType != 0 {
-				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
-			}
-			for shift := uint(0); ; shift += 7 {
-				if index >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := data[index]
-				index++
-				m.Vote |= (int64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 3:
-			if wireType != 0 {
-				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
-			}
-			for shift := uint(0); ; shift += 7 {
-				if index >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := data[index]
-				index++
-				m.Commit |= (int64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		default:
-			var sizeOfWire int
-			for {
-				sizeOfWire++
-				wire >>= 7
-				if wire == 0 {
-					break
-				}
-			}
-			index -= sizeOfWire
-			skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
-			if err != nil {
-				return err
-			}
-			if (index + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
-			index += skippy
-		}
-	}
-	return nil
-}
-func (m *State) Size() (n int) {
-	var l int
-	_ = l
-	n += 1 + sovState(uint64(m.Term))
-	n += 1 + sovState(uint64(m.Vote))
-	n += 1 + sovState(uint64(m.Commit))
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
-}
-
-func sovState(x uint64) (n int) {
-	for {
-		n++
-		x >>= 7
-		if x == 0 {
-			break
-		}
-	}
-	return n
-}
-func sozState(x uint64) (n int) {
-	return sovState(uint64((x << 1) ^ uint64((int64(x) >> 63))))
-}
-func (m *State) Marshal() (data []byte, err error) {
-	size := m.Size()
-	data = make([]byte, size)
-	n, err := m.MarshalTo(data)
-	if err != nil {
-		return nil, err
-	}
-	return data[:n], nil
-}
-
-func (m *State) MarshalTo(data []byte) (n int, err error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	data[i] = 0x8
-	i++
-	i = encodeVarintState(data, i, uint64(m.Term))
-	data[i] = 0x10
-	i++
-	i = encodeVarintState(data, i, uint64(m.Vote))
-	data[i] = 0x18
-	i++
-	i = encodeVarintState(data, i, uint64(m.Commit))
-	if m.XXX_unrecognized != nil {
-		i += copy(data[i:], m.XXX_unrecognized)
-	}
-	return i, nil
-}
-func encodeFixed64State(data []byte, offset int, v uint64) int {
-	data[offset] = uint8(v)
-	data[offset+1] = uint8(v >> 8)
-	data[offset+2] = uint8(v >> 16)
-	data[offset+3] = uint8(v >> 24)
-	data[offset+4] = uint8(v >> 32)
-	data[offset+5] = uint8(v >> 40)
-	data[offset+6] = uint8(v >> 48)
-	data[offset+7] = uint8(v >> 56)
-	return offset + 8
-}
-func encodeFixed32State(data []byte, offset int, v uint32) int {
-	data[offset] = uint8(v)
-	data[offset+1] = uint8(v >> 8)
-	data[offset+2] = uint8(v >> 16)
-	data[offset+3] = uint8(v >> 24)
-	return offset + 4
-}
-func encodeVarintState(data []byte, offset int, v uint64) int {
-	for v >= 1<<7 {
-		data[offset] = uint8(v&0x7f | 0x80)
-		v >>= 7
-		offset++
-	}
-	data[offset] = uint8(v)
-	return offset + 1
-}
diff --git a/raft/state.proto b/raft/state.proto
deleted file mode 100644
index d923e23..0000000
--- a/raft/state.proto
+++ /dev/null
@@ -1,14 +0,0 @@
-package raft;
-
-import "code.google.com/p/gogoprotobuf/gogoproto/gogo.proto";
-
-option (gogoproto.marshaler_all) = true;
-option (gogoproto.sizer_all) = true;
-option (gogoproto.unmarshaler_all) = true;
-option (gogoproto.goproto_getters_all) = false;
-
-message State {
-	required int64 term   = 1 [(gogoproto.nullable) = false];
-	required int64 vote   = 2 [(gogoproto.nullable) = false];
-	required int64 commit = 3 [(gogoproto.nullable) = false];
-}
diff --git a/raft2/diff_test.go b/raft2/diff_test.go
new file mode 100644
index 0000000..96c5d68
--- /dev/null
+++ b/raft2/diff_test.go
@@ -0,0 +1,51 @@
+package raft
+
+import (
+	"fmt"
+	"io"
+	"io/ioutil"
+	"os"
+	"os/exec"
+	"strings"
+)
+
+func diffu(a, b string) string {
+	if a == b {
+		return ""
+	}
+	aname, bname := mustTemp("base", a), mustTemp("other", b)
+	defer os.Remove(aname)
+	defer os.Remove(bname)
+	cmd := exec.Command("diff", "-u", aname, bname)
+	buf, err := cmd.CombinedOutput()
+	if err != nil {
+		if _, ok := err.(*exec.ExitError); ok {
+			// do nothing
+			return string(buf)
+		}
+		panic(err)
+	}
+	return string(buf)
+}
+
+func mustTemp(pre, body string) string {
+	f, err := ioutil.TempFile("", pre)
+	if err != nil {
+		panic(err)
+	}
+	_, err = io.Copy(f, strings.NewReader(body))
+	if err != nil {
+		panic(err)
+	}
+	f.Close()
+	return f.Name()
+}
+
+func ltoa(l *raftLog) string {
+	s := fmt.Sprintf("committed: %d\n", l.committed)
+	s += fmt.Sprintf("applied:  %d\n", l.applied)
+	for i, e := range l.ents {
+		s += fmt.Sprintf("#%d: %+v\n", i, e)
+	}
+	return s
+}
diff --git a/raft2/entry.pb.go b/raft2/entry.pb.go
new file mode 100644
index 0000000..0d6ff69
--- /dev/null
+++ b/raft2/entry.pb.go
@@ -0,0 +1,243 @@
+// Code generated by protoc-gen-gogo.
+// source: entry.proto
+// DO NOT EDIT!
+
+/*
+	Package raft is a generated protocol buffer package.
+
+	It is generated from these files:
+		entry.proto
+
+	It has these top-level messages:
+		Entry
+*/
+package raft
+
+import proto "code.google.com/p/gogoprotobuf/proto"
+import json "encoding/json"
+import math "math"
+
+// discarding unused import gogoproto "code.google.com/p/gogoprotobuf/gogoproto/gogo.pb"
+
+import io "io"
+import code_google_com_p_gogoprotobuf_proto "code.google.com/p/gogoprotobuf/proto"
+
+// Reference proto, json, and math imports to suppress error if they are not otherwise used.
+var _ = proto.Marshal
+var _ = &json.SyntaxError{}
+var _ = math.Inf
+
+type Entry struct {
+	Type             int64  `protobuf:"varint,1,req,name=type" json:"type"`
+	Term             int64  `protobuf:"varint,2,req,name=term" json:"term"`
+	Index            int64  `protobuf:"varint,3,req,name=index" json:"index"`
+	Data             []byte `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
+	XXX_unrecognized []byte `json:"-"`
+}
+
+func (m *Entry) Reset()         { *m = Entry{} }
+func (m *Entry) String() string { return proto.CompactTextString(m) }
+func (*Entry) ProtoMessage()    {}
+
+func init() {
+}
+func (m *Entry) Unmarshal(data []byte) error {
+	l := len(data)
+	index := 0
+	for index < l {
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if index >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := data[index]
+			index++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
+			}
+			for shift := uint(0); ; shift += 7 {
+				if index >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := data[index]
+				index++
+				m.Type |= (int64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 0 {
+				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
+			}
+			for shift := uint(0); ; shift += 7 {
+				if index >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := data[index]
+				index++
+				m.Term |= (int64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 0 {
+				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
+			}
+			for shift := uint(0); ; shift += 7 {
+				if index >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := data[index]
+				index++
+				m.Index |= (int64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 4:
+			if wireType != 2 {
+				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if index >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := data[index]
+				index++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			postIndex := index + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Data = append(m.Data, data[index:postIndex]...)
+			index = postIndex
+		default:
+			var sizeOfWire int
+			for {
+				sizeOfWire++
+				wire >>= 7
+				if wire == 0 {
+					break
+				}
+			}
+			index -= sizeOfWire
+			skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
+			if err != nil {
+				return err
+			}
+			if (index + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
+			index += skippy
+		}
+	}
+	return nil
+}
+func (m *Entry) Size() (n int) {
+	var l int
+	_ = l
+	n += 1 + sovEntry(uint64(m.Type))
+	n += 1 + sovEntry(uint64(m.Term))
+	n += 1 + sovEntry(uint64(m.Index))
+	if m.Data != nil {
+		l = len(m.Data)
+		n += 1 + l + sovEntry(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func sovEntry(x uint64) (n int) {
+	for {
+		n++
+		x >>= 7
+		if x == 0 {
+			break
+		}
+	}
+	return n
+}
+func sozEntry(x uint64) (n int) {
+	return sovEntry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (m *Entry) Marshal() (data []byte, err error) {
+	size := m.Size()
+	data = make([]byte, size)
+	n, err := m.MarshalTo(data)
+	if err != nil {
+		return nil, err
+	}
+	return data[:n], nil
+}
+
+func (m *Entry) MarshalTo(data []byte) (n int, err error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	data[i] = 0x8
+	i++
+	i = encodeVarintEntry(data, i, uint64(m.Type))
+	data[i] = 0x10
+	i++
+	i = encodeVarintEntry(data, i, uint64(m.Term))
+	data[i] = 0x18
+	i++
+	i = encodeVarintEntry(data, i, uint64(m.Index))
+	if m.Data != nil {
+		data[i] = 0x22
+		i++
+		i = encodeVarintEntry(data, i, uint64(len(m.Data)))
+		i += copy(data[i:], m.Data)
+	}
+	if m.XXX_unrecognized != nil {
+		i += copy(data[i:], m.XXX_unrecognized)
+	}
+	return i, nil
+}
+func encodeFixed64Entry(data []byte, offset int, v uint64) int {
+	data[offset] = uint8(v)
+	data[offset+1] = uint8(v >> 8)
+	data[offset+2] = uint8(v >> 16)
+	data[offset+3] = uint8(v >> 24)
+	data[offset+4] = uint8(v >> 32)
+	data[offset+5] = uint8(v >> 40)
+	data[offset+6] = uint8(v >> 48)
+	data[offset+7] = uint8(v >> 56)
+	return offset + 8
+}
+func encodeFixed32Entry(data []byte, offset int, v uint32) int {
+	data[offset] = uint8(v)
+	data[offset+1] = uint8(v >> 8)
+	data[offset+2] = uint8(v >> 16)
+	data[offset+3] = uint8(v >> 24)
+	return offset + 4
+}
+func encodeVarintEntry(data []byte, offset int, v uint64) int {
+	for v >= 1<<7 {
+		data[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	data[offset] = uint8(v)
+	return offset + 1
+}
diff --git a/raft2/info.pb.go b/raft2/info.pb.go
new file mode 100644
index 0000000..a8d9b84
--- /dev/null
+++ b/raft2/info.pb.go
@@ -0,0 +1,170 @@
+// Code generated by protoc-gen-gogo.
+// source: info.proto
+// DO NOT EDIT!
+
+/*
+Package raft is a generated protocol buffer package.
+
+It is generated from these files:
+	info.proto
+
+It has these top-level messages:
+	Info
+*/
+package raft
+
+import proto "code.google.com/p/gogoprotobuf/proto"
+import json "encoding/json"
+import math "math"
+
+// discarding unused import gogoproto "code.google.com/p/gogoprotobuf/gogoproto/gogo.pb"
+
+import io "io"
+import code_google_com_p_gogoprotobuf_proto "code.google.com/p/gogoprotobuf/proto"
+
+// Reference proto, json, and math imports to suppress error if they are not otherwise used.
+var _ = proto.Marshal
+var _ = &json.SyntaxError{}
+var _ = math.Inf
+
+type Info struct {
+	Id               int64  `protobuf:"varint,1,req,name=id" json:"id"`
+	XXX_unrecognized []byte `json:"-"`
+}
+
+func (m *Info) Reset()         { *m = Info{} }
+func (m *Info) String() string { return proto.CompactTextString(m) }
+func (*Info) ProtoMessage()    {}
+
+func init() {
+}
+func (m *Info) Unmarshal(data []byte) error {
+	l := len(data)
+	index := 0
+	for index < l {
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if index >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := data[index]
+			index++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
+			}
+			for shift := uint(0); ; shift += 7 {
+				if index >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := data[index]
+				index++
+				m.Id |= (int64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		default:
+			var sizeOfWire int
+			for {
+				sizeOfWire++
+				wire >>= 7
+				if wire == 0 {
+					break
+				}
+			}
+			index -= sizeOfWire
+			skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
+			if err != nil {
+				return err
+			}
+			if (index + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
+			index += skippy
+		}
+	}
+	return nil
+}
+func (m *Info) Size() (n int) {
+	var l int
+	_ = l
+	n += 1 + sovInfo(uint64(m.Id))
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func sovInfo(x uint64) (n int) {
+	for {
+		n++
+		x >>= 7
+		if x == 0 {
+			break
+		}
+	}
+	return n
+}
+func sozInfo(x uint64) (n int) {
+	return sovInfo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (m *Info) Marshal() (data []byte, err error) {
+	size := m.Size()
+	data = make([]byte, size)
+	n, err := m.MarshalTo(data)
+	if err != nil {
+		return nil, err
+	}
+	return data[:n], nil
+}
+
+func (m *Info) MarshalTo(data []byte) (n int, err error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	data[i] = 0x8
+	i++
+	i = encodeVarintInfo(data, i, uint64(m.Id))
+	if m.XXX_unrecognized != nil {
+		i += copy(data[i:], m.XXX_unrecognized)
+	}
+	return i, nil
+}
+func encodeFixed64Info(data []byte, offset int, v uint64) int {
+	data[offset] = uint8(v)
+	data[offset+1] = uint8(v >> 8)
+	data[offset+2] = uint8(v >> 16)
+	data[offset+3] = uint8(v >> 24)
+	data[offset+4] = uint8(v >> 32)
+	data[offset+5] = uint8(v >> 40)
+	data[offset+6] = uint8(v >> 48)
+	data[offset+7] = uint8(v >> 56)
+	return offset + 8
+}
+func encodeFixed32Info(data []byte, offset int, v uint32) int {
+	data[offset] = uint8(v)
+	data[offset+1] = uint8(v >> 8)
+	data[offset+2] = uint8(v >> 16)
+	data[offset+3] = uint8(v >> 24)
+	return offset + 4
+}
+func encodeVarintInfo(data []byte, offset int, v uint64) int {
+	for v >= 1<<7 {
+		data[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	data[offset] = uint8(v)
+	return offset + 1
+}
diff --git a/raft2/log.go b/raft2/log.go
new file mode 100644
index 0000000..54ed1f9
--- /dev/null
+++ b/raft2/log.go
@@ -0,0 +1,220 @@
+package raft
+
+import "fmt"
+
+const (
+	Normal int64 = iota
+
+	ClusterInit
+	AddNode
+	RemoveNode
+)
+
+const (
+	defaultCompactThreshold = 10000
+)
+
+func (e *Entry) isConfig() bool {
+	return e.Type == AddNode || e.Type == RemoveNode
+}
+
+type raftLog struct {
+	ents             []Entry
+	unstable         int64
+	committed        int64
+	applied          int64
+	offset           int64
+	snapshot         Snapshot
+	unstableSnapshot Snapshot
+
+	// want a compact after the number of entries exceeds the threshold
+	// TODO(xiangli) size might be a better criteria
+	compactThreshold int64
+}
+
+func newLog() *raftLog {
+	return &raftLog{
+		ents:             make([]Entry, 1),
+		unstable:         1,
+		committed:        0,
+		applied:          0,
+		compactThreshold: defaultCompactThreshold,
+	}
+}
+
+func (l *raftLog) isEmpty() bool {
+	return l.offset == 0 && len(l.ents) == 1
+}
+
+func (l *raftLog) String() string {
+	return fmt.Sprintf("offset=%d committed=%d applied=%d len(ents)=%d", l.offset, l.committed, l.applied, len(l.ents))
+}
+
+func (l *raftLog) maybeAppend(index, logTerm, committed int64, ents ...Entry) bool {
+	if l.matchTerm(index, logTerm) {
+		from := index + 1
+		ci := l.findConflict(from, ents)
+		switch {
+		case ci == -1:
+		case ci <= l.committed:
+			panic("conflict with committed entry")
+		default:
+			l.append(ci-1, ents[ci-from:]...)
+		}
+		if l.committed < committed {
+			l.committed = min(committed, l.lastIndex())
+		}
+		return true
+	}
+	return false
+}
+
+func (l *raftLog) append(after int64, ents ...Entry) int64 {
+	l.ents = append(l.slice(l.offset, after+1), ents...)
+	l.unstable = min(l.unstable, after+1)
+	return l.lastIndex()
+}
+
+func (l *raftLog) findConflict(from int64, ents []Entry) int64 {
+	for i, ne := range ents {
+		if oe := l.at(from + int64(i)); oe == nil || oe.Term != ne.Term {
+			return from + int64(i)
+		}
+	}
+	return -1
+}
+
+func (l *raftLog) unstableEnts() []Entry {
+	return l.entries(l.unstable)
+}
+
+func (l *raftLog) resetUnstable() {
+	l.unstable = l.lastIndex() + 1
+}
+
+// nextEnts returns all the available entries for execution.
+// all the returned entries will be marked as applied.
+func (l *raftLog) nextEnts() (ents []Entry) {
+	if l.committed > l.applied {
+		return l.slice(l.applied+1, l.committed+1)
+	}
+	return nil
+}
+
+func (l *raftLog) resetNextEnts() {
+	if l.committed > l.applied {
+		l.applied = l.committed
+	}
+}
+
+func (l *raftLog) lastIndex() int64 {
+	return int64(len(l.ents)) - 1 + l.offset
+}
+
+func (l *raftLog) term(i int64) int64 {
+	if e := l.at(i); e != nil {
+		return e.Term
+	}
+	return -1
+}
+
+func (l *raftLog) entries(i int64) []Entry {
+	// never send out the first entry
+	// first entry is only used for matching
+	// prevLogTerm
+	if i == l.offset {
+		panic("cannot return the first entry in log")
+	}
+	return l.slice(i, l.lastIndex()+1)
+}
+
+func (l *raftLog) isUpToDate(i, term int64) bool {
+	e := l.at(l.lastIndex())
+	return term > e.Term || (term == e.Term && i >= l.lastIndex())
+}
+
+func (l *raftLog) matchTerm(i, term int64) bool {
+	if e := l.at(i); e != nil {
+		return e.Term == term
+	}
+	return false
+}
+
+func (l *raftLog) maybeCommit(maxIndex, term int64) bool {
+	if maxIndex > l.committed && l.term(maxIndex) == term {
+		l.committed = maxIndex
+		return true
+	}
+	return false
+}
+
+// compact compacts all log entries until i.
+// It removes the log entries before i, exclusive.
+// i must be not smaller than the index of the first entry
+// and not greater than the index of the last entry.
+// the number of entries after compaction will be returned.
+func (l *raftLog) compact(i int64) int64 {
+	if l.isOutOfBounds(i) {
+		panic(fmt.Sprintf("compact %d out of bounds [%d:%d]", i, l.offset, l.lastIndex()))
+	}
+	l.ents = l.slice(i, l.lastIndex()+1)
+	l.unstable = max(i+1, l.unstable)
+	l.offset = i
+	return int64(len(l.ents))
+}
+
+func (l *raftLog) snap(d []byte, clusterId, index, term int64, nodes []int64) {
+	l.snapshot = Snapshot{clusterId, d, nodes, index, term}
+}
+
+func (l *raftLog) shouldCompact() bool {
+	return (l.applied - l.offset) > l.compactThreshold
+}
+
+func (l *raftLog) restore(s Snapshot) {
+	l.ents = []Entry{{Term: s.Term}}
+	l.unstable = s.Index + 1
+	l.committed = s.Index
+	l.applied = s.Index
+	l.offset = s.Index
+	l.snapshot = s
+}
+
+func (l *raftLog) at(i int64) *Entry {
+	if l.isOutOfBounds(i) {
+		return nil
+	}
+	return &l.ents[i-l.offset]
+}
+
+// slice get a slice of log entries from lo through hi-1, inclusive.
+func (l *raftLog) slice(lo int64, hi int64) []Entry {
+	if lo >= hi {
+		return nil
+	}
+	if l.isOutOfBounds(lo) || l.isOutOfBounds(hi-1) {
+		return nil
+	}
+	return l.ents[lo-l.offset : hi-l.offset]
+}
+
+func (l *raftLog) isOutOfBounds(i int64) bool {
+	if i < l.offset || i > l.lastIndex() {
+		return true
+	}
+	return false
+}
+
+func min(a, b int64) int64 {
+	if a > b {
+		return b
+	}
+	return a
+}
+
+func max(a, b int64) int64 {
+	if a > b {
+		return a
+	}
+	return b
+}
diff --git a/raft2/log_test.go b/raft2/log_test.go
new file mode 100644
index 0000000..5af620b
--- /dev/null
+++ b/raft2/log_test.go
@@ -0,0 +1,303 @@
+package raft
+
+import (
+	"reflect"
+	"testing"
+)
+
+// TestAppend ensures:
+// 1. If an existing entry conflicts with a new one (same index
+// but different terms), delete the existing entry and all that
+// follow it
+// 2.Append any new entries not already in the log
+func TestAppend(t *testing.T) {
+	previousEnts := []Entry{{Term: 1}, {Term: 2}}
+	previousUnstable := int64(3)
+	tests := []struct {
+		after     int64
+		ents      []Entry
+		windex    int64
+		wents     []Entry
+		wunstable int64
+	}{
+		{
+			2,
+			[]Entry{},
+			2,
+			[]Entry{{Term: 1}, {Term: 2}},
+			3,
+		},
+		{
+			2,
+			[]Entry{{Term: 2}},
+			3,
+			[]Entry{{Term: 1}, {Term: 2}, {Term: 2}},
+			3,
+		},
+		// conflicts with index 1
+		{
+			0,
+			[]Entry{{Term: 2}},
+			1,
+			[]Entry{{Term: 2}},
+			1,
+		},
+		// conflicts with index 2
+		{
+			1,
+			[]Entry{{Term: 3}, {Term: 3}},
+			3,
+			[]Entry{{Term: 1}, {Term: 3}, {Term: 3}},
+			2,
+		},
+	}
+
+	for i, tt := range tests {
+		raftLog := newLog()
+		raftLog.ents = append(raftLog.ents, previousEnts...)
+		raftLog.unstable = previousUnstable
+		index := raftLog.append(tt.after, tt.ents...)
+		if index != tt.windex {
+			t.Errorf("#%d: lastIndex = %d, want %d", i, index, tt.windex)
+		}
+		if g := raftLog.entries(1); !reflect.DeepEqual(g, tt.wents) {
+			t.Errorf("#%d: logEnts = %+v, want %+v", i, g, tt.wents)
+		}
+		if g := raftLog.unstable; g != tt.wunstable {
+			t.Errorf("#%d: unstable = %d, want %d", i, g, tt.wunstable)
+		}
+	}
+}
+
+// TestCompactionSideEffects ensures that all the log related funcationality works correctly after
+// a compaction.
+func TestCompactionSideEffects(t *testing.T) {
+	var i int64
+	lastIndex := int64(1000)
+	raftLog := newLog()
+
+	for i = 0; i < lastIndex; i++ {
+		raftLog.append(int64(i), Entry{Term: int64(i + 1), Index: int64(i + 1)})
+	}
+
+	raftLog.compact(500)
+
+	if raftLog.lastIndex() != lastIndex {
+		t.Errorf("lastIndex = %d, want %d", raftLog.lastIndex(), lastIndex)
+	}
+
+	for i := raftLog.offset; i <= raftLog.lastIndex(); i++ {
+		if raftLog.term(i) != i {
+			t.Errorf("term(%d) = %d, want %d", i, raftLog.term(i), i)
+		}
+	}
+
+	for i := raftLog.offset; i <= raftLog.lastIndex(); i++ {
+		if !raftLog.matchTerm(i, i) {
+			t.Errorf("matchTerm(%d) = false, want true", i)
+		}
+	}
+
+	unstableEnts := raftLog.unstableEnts()
+	if g := len(unstableEnts); g != 500 {
+		t.Errorf("len(unstableEntries) = %d, want = %d", g, 500)
+	}
+	if unstableEnts[0].Index != 501 {
+		t.Errorf("Index = %d, want = %d", unstableEnts[0].Index, 501)
+	}
+
+	prev := raftLog.lastIndex()
+	raftLog.append(raftLog.lastIndex(), Entry{Term: raftLog.lastIndex() + 1})
+	if raftLog.lastIndex() != prev+1 {
+		t.Errorf("lastIndex = %d, want = %d", raftLog.lastIndex(), prev+1)
+	}
+
+	ents := raftLog.entries(raftLog.lastIndex())
+	if len(ents) != 1 {
+		t.Errorf("len(entries) = %d, want = %d", len(ents), 1)
+	}
+}
+
+func TestUnstableEnts(t *testing.T) {
+	previousEnts := []Entry{{Term: 1, Index: 1}, {Term: 2, Index: 2}}
+	tests := []struct {
+		unstable  int64
+		wents     []Entry
+		wunstable int64
+	}{
+		{3, nil, 3},
+		{1, previousEnts, 3},
+	}
+
+	for i, tt := range tests {
+		raftLog := newLog()
+		raftLog.ents = append(raftLog.ents, previousEnts...)
+		raftLog.unstable = tt.unstable
+		ents := raftLog.unstableEnts()
+		raftLog.resetUnstable()
+		if !reflect.DeepEqual(ents, tt.wents) {
+			t.Errorf("#%d: unstableEnts = %+v, want %+v", i, ents, tt.wents)
+		}
+		if g := raftLog.unstable; g != tt.wunstable {
+			t.Errorf("#%d: unstable = %d, want %d", i, g, tt.wunstable)
+		}
+	}
+}
+
+//TestCompaction ensures that the number of log entreis is correct after compactions.
+func TestCompaction(t *testing.T) {
+	tests := []struct {
+		app     int
+		compact []int64
+		wleft   []int
+		wallow  bool
+	}{
+		// out of upper bound
+		{1000, []int64{1001}, []int{-1}, false},
+		{1000, []int64{300, 500, 800, 900}, []int{701, 501, 201, 101}, true},
+		// out of lower bound
+		{1000, []int64{300, 299}, []int{701, -1}, false},
+	}
+
+	for i, tt := range tests {
+		func() {
+			defer func() {
+				if r := recover(); r != nil {
+					if tt.wallow == true {
+						t.Errorf("%d: allow = %v, want %v", i, false, true)
+					}
+				}
+			}()
+
+			raftLog := newLog()
+			for i := 0; i < tt.app; i++ {
+				raftLog.append(int64(i), Entry{})
+			}
+
+			for j := 0; j < len(tt.compact); j++ {
+				raftLog.compact(tt.compact[j])
+				if len(raftLog.ents) != tt.wleft[j] {
+					t.Errorf("#%d.%d len = %d, want %d", i, j, len(raftLog.ents), tt.wleft[j])
+				}
+			}
+		}()
+	}
+}
+
+func TestLogRestore(t *testing.T) {
+	var i int64
+	raftLog := newLog()
+	for i = 0; i < 100; i++ {
+		raftLog.append(i, Entry{Term: i + 1})
+	}
+
+	index := int64(1000)
+	term := int64(1000)
+	raftLog.restore(Snapshot{Index: index, Term: term})
+
+	// only has the guard entry
+	if len(raftLog.ents) != 1 {
+		t.Errorf("len = %d, want 0", len(raftLog.ents))
+	}
+	if raftLog.offset != index {
+		t.Errorf("offset = %d, want %d", raftLog.offset, index)
+	}
+	if raftLog.applied != index {
+		t.Errorf("applied = %d, want %d", raftLog.applied, index)
+	}
+	if raftLog.committed != index {
+		t.Errorf("comitted = %d, want %d", raftLog.committed, index)
+	}
+	if raftLog.unstable != index+1 {
+		t.Errorf("unstable = %d, want %d", raftLog.unstable, index+1)
+	}
+	if raftLog.term(index) != term {
+		t.Errorf("term = %d, want %d", raftLog.term(index), term)
+	}
+}
+
+func TestIsOutOfBounds(t *testing.T) {
+	offset := int64(100)
+	num := int64(100)
+	l := &raftLog{offset: offset, ents: make([]Entry, num)}
+
+	tests := []struct {
+		index int64
+		w     bool
+	}{
+		{offset - 1, true},
+		{offset, false},
+		{offset + num/2, false},
+		{offset + num - 1, false},
+		{offset + num, true},
+	}
+
+	for i, tt := range tests {
+		g := l.isOutOfBounds(tt.index)
+		if g != tt.w {
+			t.Errorf("#%d: isOutOfBounds = %v, want %v", i, g, tt.w)
+		}
+	}
+}
+
+func TestAt(t *testing.T) {
+	var i int64
+	offset := int64(100)
+	num := int64(100)
+
+	l := &raftLog{offset: offset}
+	for i = 0; i < num; i++ {
+		l.ents = append(l.ents, Entry{Term: i})
+	}
+
+	tests := []struct {
+		index int64
+		w     *Entry
+	}{
+		{offset - 1, nil},
+		{offset, &Entry{Term: 0}},
+		{offset + num/2, &Entry{Term: num / 2}},
+		{offset + num - 1, &Entry{Term: num - 1}},
+		{offset + num, nil},
+	}
+
+	for i, tt := range tests {
+		g := l.at(tt.index)
+		if !reflect.DeepEqual(g, tt.w) {
+			t.Errorf("#%d: at = %v, want %v", i, g, tt.w)
+		}
+	}
+}
+
+func TestSlice(t *testing.T) {
+	var i int64
+	offset := int64(100)
+	num := int64(100)
+
+	l := &raftLog{offset: offset}
+	for i = 0; i < num; i++ {
+		l.ents = append(l.ents, Entry{Term: i})
+	}
+
+	tests := []struct {
+		from int64
+		to   int64
+		w    []Entry
+	}{
+		{offset - 1, offset + 1, nil},
+		{offset, offset + 1, []Entry{{Term: 0}}},
+		{offset + num/2, offset + num/2 + 1, []Entry{{Term: num / 2}}},
+		{offset + num - 1, offset + num, []Entry{{Term: num - 1}}},
+		{offset + num, offset + num + 1, nil},
+
+		{offset + num/2, offset + num/2, nil},
+		{offset + num/2, offset + num/2 - 1, nil},
+	}
+
+	for i, tt := range tests {
+		g := l.slice(tt.from, tt.to)
+		if !reflect.DeepEqual(g, tt.w) {
+			t.Errorf("#%d: from %d to %d = %v, want %v", i, tt.from, tt.to, g, tt.w)
+		}
+	}
+}
diff --git a/raft2/node.go b/raft2/node.go
index 3006847..0ca4c34 100644
--- a/raft2/node.go
+++ b/raft2/node.go
@@ -9,14 +9,9 @@ type stateResp struct {
 	msgs  []Message
 }
 
-type proposal struct {
-	id   int64
-	data []byte
-}
-
 type Node struct {
 	ctx    context.Context
-	propc  chan proposal
+	propc  chan []byte
 	recvc  chan Message
 	statec chan stateResp
 	tickc  chan struct{}
@@ -25,7 +20,7 @@ type Node struct {
 func Start(ctx context.Context, name string, election, heartbeat int) *Node {
 	n := &Node{
 		ctx:    ctx,
-		propc:  make(chan proposal),
+		propc:  make(chan []byte),
 		recvc:  make(chan Message),
 		statec: make(chan stateResp),
 		tickc:  make(chan struct{}),
@@ -54,13 +49,13 @@ func (n *Node) run(r *raft) {
 
 		select {
 		case p := <-propc:
-			r.propose(p.id, p.data)
+			r.propose(p)
 		case m := <-n.recvc:
-			r.step(m)
+			r.Step(m) // raft never returns an error
 		case <-n.tickc:
-			r.tick()
-		case n.statec <- stateResp{r.State, r.ents, r.msgs}:
-			r.resetState()
+			// r.tick()
+		// case n.statec <- stateResp{r.State, r.ents, r.msgs}:
+		// r.resetState()
 		case <-n.ctx.Done():
 			return
 		}
@@ -77,9 +72,9 @@ func (n *Node) Tick() error {
 }
 
 // Propose proposes data be appended to the log.
-func (n *Node) Propose(id int64, data []byte) error {
+func (n *Node) Propose(data []byte) error {
 	select {
-	case n.propc <- proposal{id, data}:
+	case n.propc <- data:
 		return nil
 	case <-n.ctx.Done():
 		return n.ctx.Err()
diff --git a/raft2/raft.go b/raft2/raft.go
index 616768c..d41fbee 100644
--- a/raft2/raft.go
+++ b/raft2/raft.go
@@ -1,35 +1,603 @@
 package raft
 
-type State struct {
-	CommitIndex int64
+import (
+	"errors"
+	"fmt"
+	"sort"
+	"sync/atomic"
+)
+
+const none = -1
+
+type messageType int64
+
+const (
+	msgHup messageType = iota
+	msgBeat
+	msgProp
+	msgApp
+	msgAppResp
+	msgVote
+	msgVoteResp
+	msgSnap
+	msgDenied
+)
+
+var mtmap = [...]string{
+	msgHup:      "msgHup",
+	msgBeat:     "msgBeat",
+	msgProp:     "msgProp",
+	msgApp:      "msgApp",
+	msgAppResp:  "msgAppResp",
+	msgVote:     "msgVote",
+	msgVoteResp: "msgVoteResp",
+	msgSnap:     "msgSnap",
+	msgDenied:   "msgDenied",
 }
 
+func (mt messageType) String() string {
+	return mtmap[int64(mt)]
+}
+
+var errNoLeader = errors.New("no leader")
+
+const (
+	stateFollower stateType = iota
+	stateCandidate
+	stateLeader
+)
+
+type stateType int64
+
+var stmap = [...]string{
+	stateFollower:  "stateFollower",
+	stateCandidate: "stateCandidate",
+	stateLeader:    "stateLeader",
+}
+
+var stepmap = [...]stepFunc{
+	stateFollower:  stepFollower,
+	stateCandidate: stepCandidate,
+	stateLeader:    stepLeader,
+}
+
+func (st stateType) String() string {
+	return stmap[int64(st)]
+}
+
+var EmptyState = State{}
+
 type Message struct {
-	State State
-	To    string
-	Data  []byte
+	Type      messageType
+	ClusterId int64
+	To        int64
+	From      int64
+	Term      int64
+	LogTerm   int64
+	Index     int64
+	Entries   []Entry
+	Commit    int64
+	Snapshot  Snapshot
 }
 
-type Entry struct {
-	Id    int64
-	Index int64
-	Data  []byte
+func (m Message) IsMsgApp() bool {
+	return m.Type == msgApp
 }
 
-type raft struct {
-	name string
+func (m Message) String() string {
+	return fmt.Sprintf("type=%v from=%x to=%x term=%d logTerm=%d i=%d ci=%d len(ents)=%d",
+		m.Type, m.From, m.To, m.Term, m.LogTerm, m.Index, m.Commit, len(m.Entries))
+}
+
+type index struct {
+	match, next int64
+}
+
+func (in *index) update(n int64) {
+	in.match = n
+	in.next = n + 1
+}
+
+func (in *index) decr() {
+	if in.next--; in.next < 1 {
+		in.next = 1
+	}
+}
+
+func (in *index) String() string {
+	return fmt.Sprintf("n=%d m=%d", in.next, in.match)
+}
+
+// An AtomicInt is an int64 to be accessed atomically.
+type atomicInt int64
+
+func (i *atomicInt) Set(n int64) {
+	atomic.StoreInt64((*int64)(i), n)
+}
 
-	State
+func (i *atomicInt) Get() int64 {
+	return atomic.LoadInt64((*int64)(i))
+}
+
+// int64Slice implements sort interface
+type int64Slice []int64
 
+func (p int64Slice) Len() int           { return len(p) }
+func (p int64Slice) Less(i, j int) bool { return p[i] < p[j] }
+func (p int64Slice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
+
+type raft struct {
+	// --- new stuff ---
+	name      string
 	election  int
 	heartbeat int
+	// -----------------
+
+	clusterId int64
+	id        int64
+
+	// the term we are participating in at any time
+	term  atomicInt
+	index atomicInt
+
+	// who we voted for in term
+	vote int64
+
+	// the log
+	raftLog *raftLog
+
+	ins map[int64]*index
+
+	state stateType
+
+	votes map[int64]bool
 
 	msgs []Message
-	ents []Entry
+
+	// the leader id
+	lead atomicInt
+
+	// pending reconfiguration
+	pendingConf bool
+
+	unstableState State
+
+	// promotable indicates whether state machine could be promoted.
+	// New machine has to wait until it has been added to the cluster, or it
+	// may become the leader of the cluster without it.
+	promotable bool
+}
+
+func newStateMachine(id int64, peers []int64) *raft {
+	if id == none {
+		panic("cannot use none id")
+	}
+	sm := &raft{id: id, clusterId: none, lead: none, raftLog: newLog(), ins: make(map[int64]*index)}
+	for _, p := range peers {
+		sm.ins[p] = &index{}
+	}
+	sm.reset(0)
+	return sm
+}
+
+func (r *raft) hasLeader() bool { return r.state != stateCandidate }
+
+func (r *raft) propose(data []byte) {
+	r.Step(Message{From: r.id, Type: msgProp, Entries: []Entry{{Data: data}}})
+}
+
+func (sm *raft) String() string {
+	s := fmt.Sprintf(`state=%v term=%d`, sm.state, sm.term)
+	switch sm.state {
+	case stateFollower:
+		s += fmt.Sprintf(" vote=%v lead=%v", sm.vote, sm.lead)
+	case stateCandidate:
+		s += fmt.Sprintf(` votes="%v"`, sm.votes)
+	case stateLeader:
+		s += fmt.Sprintf(` ins="%v"`, sm.ins)
+	}
+	return s
+}
+
+func (sm *raft) poll(id int64, v bool) (granted int) {
+	if _, ok := sm.votes[id]; !ok {
+		sm.votes[id] = v
+	}
+	for _, vv := range sm.votes {
+		if vv {
+			granted++
+		}
+	}
+	return granted
+}
+
+// send persists state to stable storage and then sends to its mailbox.
+func (sm *raft) send(m Message) {
+	m.ClusterId = sm.clusterId
+	m.From = sm.id
+	m.Term = sm.term.Get()
+	sm.msgs = append(sm.msgs, m)
+}
+
+// sendAppend sends RRPC, with entries to the given peer.
+func (sm *raft) sendAppend(to int64) {
+	in := sm.ins[to]
+	m := Message{}
+	m.To = to
+	m.Index = in.next - 1
+	if sm.needSnapshot(m.Index) {
+		m.Type = msgSnap
+		m.Snapshot = sm.raftLog.snapshot
+	} else {
+		m.Type = msgApp
+		m.LogTerm = sm.raftLog.term(in.next - 1)
+		m.Entries = sm.raftLog.entries(in.next)
+		m.Commit = sm.raftLog.committed
+	}
+	sm.send(m)
+}
+
+// sendHeartbeat sends RRPC, without entries to the given peer.
+func (sm *raft) sendHeartbeat(to int64) {
+	in := sm.ins[to]
+	index := max(in.next-1, sm.raftLog.lastIndex())
+	m := Message{
+		To:      to,
+		Type:    msgApp,
+		Index:   index,
+		LogTerm: sm.raftLog.term(index),
+		Commit:  sm.raftLog.committed,
+	}
+	sm.send(m)
+}
+
+// bcastAppend sends RRPC, with entries to all peers that are not up-to-date according to sm.mis.
+func (sm *raft) bcastAppend() {
+	for i := range sm.ins {
+		if i == sm.id {
+			continue
+		}
+		sm.sendAppend(i)
+	}
+}
+
+// bcastHeartbeat sends RRPC, without entries to all the peers.
+func (sm *raft) bcastHeartbeat() {
+	for i := range sm.ins {
+		if i == sm.id {
+			continue
+		}
+		sm.sendHeartbeat(i)
+	}
+}
+
+func (sm *raft) maybeCommit() bool {
+	// TODO(bmizerany): optimize.. Currently naive
+	mis := make(int64Slice, 0, len(sm.ins))
+	for i := range sm.ins {
+		mis = append(mis, sm.ins[i].match)
+	}
+	sort.Sort(sort.Reverse(mis))
+	mci := mis[sm.q()-1]
+
+	return sm.raftLog.maybeCommit(mci, sm.term.Get())
 }
 
-func (sm *raft) hasLeader() bool               { return false }
-func (sm *raft) step(m Message)                {}
-func (sm *raft) resetState()                   {}
-func (sm *raft) propose(id int64, data []byte) {}
-func (sm *raft) tick()                         {}
+// nextEnts returns the appliable entries and updates the applied index
+func (sm *raft) nextEnts() (ents []Entry) {
+	ents = sm.raftLog.nextEnts()
+	sm.raftLog.resetNextEnts()
+	return ents
+}
+
+func (sm *raft) reset(term int64) {
+	sm.setTerm(term)
+	sm.lead.Set(none)
+	sm.setVote(none)
+	sm.votes = make(map[int64]bool)
+	for i := range sm.ins {
+		sm.ins[i] = &index{next: sm.raftLog.lastIndex() + 1}
+		if i == sm.id {
+			sm.ins[i].match = sm.raftLog.lastIndex()
+		}
+	}
+}
+
+func (sm *raft) q() int {
+	return len(sm.ins)/2 + 1
+}
+
+func (sm *raft) appendEntry(e Entry) {
+	e.Term = sm.term.Get()
+	e.Index = sm.raftLog.lastIndex() + 1
+	sm.index.Set(sm.raftLog.append(sm.raftLog.lastIndex(), e))
+	sm.ins[sm.id].update(sm.raftLog.lastIndex())
+	sm.maybeCommit()
+}
+
+func (sm *raft) becomeFollower(term int64, lead int64) {
+	sm.reset(term)
+	sm.lead.Set(lead)
+	sm.state = stateFollower
+	sm.pendingConf = false
+}
+
+func (sm *raft) becomeCandidate() {
+	// TODO(xiangli) remove the panic when the raft implementation is stable
+	if sm.state == stateLeader {
+		panic("invalid transition [leader -> candidate]")
+	}
+	sm.reset(sm.term.Get() + 1)
+	sm.setVote(sm.id)
+	sm.state = stateCandidate
+}
+
+func (sm *raft) becomeLeader() {
+	// TODO(xiangli) remove the panic when the raft implementation is stable
+	if sm.state == stateFollower {
+		panic("invalid transition [follower -> leader]")
+	}
+	sm.reset(sm.term.Get())
+	sm.lead.Set(sm.id)
+	sm.state = stateLeader
+
+	for _, e := range sm.raftLog.entries(sm.raftLog.committed + 1) {
+		if e.isConfig() {
+			sm.pendingConf = true
+		}
+	}
+
+	sm.appendEntry(Entry{Type: Normal, Data: nil})
+}
+
+func (sm *raft) ReadMessages() []Message {
+	msgs := sm.msgs
+	sm.msgs = make([]Message, 0)
+
+	return msgs
+}
+
+func (sm *raft) Step(m Message) error {
+	if m.Type == msgHup {
+		sm.becomeCandidate()
+		if sm.q() == sm.poll(sm.id, true) {
+			sm.becomeLeader()
+		}
+		for i := range sm.ins {
+			if i == sm.id {
+				continue
+			}
+			lasti := sm.raftLog.lastIndex()
+			sm.send(Message{To: i, Type: msgVote, Index: lasti, LogTerm: sm.raftLog.term(lasti)})
+		}
+	}
+
+	switch {
+	case m.Term == 0:
+		// local message
+	case m.Term > sm.term.Get():
+		lead := m.From
+		if m.Type == msgVote {
+			lead = none
+		}
+		sm.becomeFollower(m.Term, lead)
+	case m.Term < sm.term.Get():
+		// ignore
+	}
+
+	stepmap[sm.state](sm, m)
+	return nil
+}
+
+func (sm *raft) handleAppendEntries(m Message) {
+	if sm.raftLog.maybeAppend(m.Index, m.LogTerm, m.Commit, m.Entries...) {
+		sm.index.Set(sm.raftLog.lastIndex())
+		sm.send(Message{To: m.From, Type: msgAppResp, Index: sm.raftLog.lastIndex()})
+	} else {
+		sm.send(Message{To: m.From, Type: msgAppResp, Index: -1})
+	}
+}
+
+func (sm *raft) handleSnapshot(m Message) {
+	if sm.restore(m.Snapshot) {
+		sm.send(Message{To: m.From, Type: msgAppResp, Index: sm.raftLog.lastIndex()})
+	} else {
+		sm.send(Message{To: m.From, Type: msgAppResp, Index: sm.raftLog.committed})
+	}
+}
+
+func (sm *raft) addNode(id int64) {
+	sm.addIns(id, 0, sm.raftLog.lastIndex()+1)
+	sm.pendingConf = false
+	if id == sm.id {
+		sm.promotable = true
+	}
+}
+
+func (sm *raft) removeNode(id int64) {
+	sm.deleteIns(id)
+	sm.pendingConf = false
+}
+
+type stepFunc func(sm *raft, m Message) bool
+
+func stepLeader(sm *raft, m Message) bool {
+	switch m.Type {
+	case msgBeat:
+		sm.bcastHeartbeat()
+	case msgProp:
+		if len(m.Entries) != 1 {
+			panic("unexpected length(entries) of a msgProp")
+		}
+		e := m.Entries[0]
+		if e.isConfig() {
+			if sm.pendingConf {
+				return false
+			}
+			sm.pendingConf = true
+		}
+		sm.appendEntry(e)
+		sm.bcastAppend()
+	case msgAppResp:
+		if m.Index < 0 {
+			sm.ins[m.From].decr()
+			sm.sendAppend(m.From)
+		} else {
+			sm.ins[m.From].update(m.Index)
+			if sm.maybeCommit() {
+				sm.bcastAppend()
+			}
+		}
+	case msgVote:
+		sm.send(Message{To: m.From, Type: msgVoteResp, Index: -1})
+	}
+	return true
+}
+
+func stepCandidate(sm *raft, m Message) bool {
+	switch m.Type {
+	case msgProp:
+		return false
+	case msgApp:
+		sm.becomeFollower(sm.term.Get(), m.From)
+		sm.handleAppendEntries(m)
+	case msgSnap:
+		sm.becomeFollower(m.Term, m.From)
+		sm.handleSnapshot(m)
+	case msgVote:
+		sm.send(Message{To: m.From, Type: msgVoteResp, Index: -1})
+	case msgVoteResp:
+		gr := sm.poll(m.From, m.Index >= 0)
+		switch sm.q() {
+		case gr:
+			sm.becomeLeader()
+			sm.bcastAppend()
+		case len(sm.votes) - gr:
+			sm.becomeFollower(sm.term.Get(), none)
+		}
+	}
+	return true
+}
+
+func stepFollower(sm *raft, m Message) bool {
+	switch m.Type {
+	case msgProp:
+		if sm.lead.Get() == none {
+			return false
+		}
+		m.To = sm.lead.Get()
+		sm.send(m)
+	case msgApp:
+		sm.lead.Set(m.From)
+		sm.handleAppendEntries(m)
+	case msgSnap:
+		sm.handleSnapshot(m)
+	case msgVote:
+		if (sm.vote == none || sm.vote == m.From) && sm.raftLog.isUpToDate(m.Index, m.LogTerm) {
+			sm.setVote(m.From)
+			sm.send(Message{To: m.From, Type: msgVoteResp, Index: sm.raftLog.lastIndex()})
+		} else {
+			sm.send(Message{To: m.From, Type: msgVoteResp, Index: -1})
+		}
+	}
+	return true
+}
+
+func (sm *raft) compact(d []byte) {
+	sm.raftLog.snap(d, sm.raftLog.applied, sm.raftLog.term(sm.raftLog.applied), sm.nodes())
+	sm.raftLog.compact(sm.raftLog.applied)
+}
+
+// restore recovers the statemachine from a snapshot. It restores the log and the
+// configuration of statemachine.
+func (sm *raft) restore(s Snapshot) bool {
+	if s.Index <= sm.raftLog.committed {
+		return false
+	}
+
+	sm.raftLog.restore(s)
+	sm.index.Set(sm.raftLog.lastIndex())
+	sm.ins = make(map[int64]*index)
+	for _, n := range s.Nodes {
+		if n == sm.id {
+			sm.addIns(n, sm.raftLog.lastIndex(), sm.raftLog.lastIndex()+1)
+		} else {
+			sm.addIns(n, 0, sm.raftLog.lastIndex()+1)
+		}
+	}
+	sm.pendingConf = false
+	return true
+}
+
+func (sm *raft) needSnapshot(i int64) bool {
+	if i < sm.raftLog.offset {
+		if sm.raftLog.snapshot.IsEmpty() {
+			panic("need non-empty snapshot")
+		}
+		return true
+	}
+	return false
+}
+
+func (sm *raft) nodes() []int64 {
+	nodes := make([]int64, 0, len(sm.ins))
+	for k := range sm.ins {
+		nodes = append(nodes, k)
+	}
+	return nodes
+}
+
+func (sm *raft) setTerm(term int64) {
+	sm.term.Set(term)
+	sm.saveState()
+}
+
+func (sm *raft) setVote(vote int64) {
+	sm.vote = vote
+	sm.saveState()
+}
+
+func (sm *raft) addIns(id, match, next int64) {
+	sm.ins[id] = &index{next: next, match: match}
+	sm.saveState()
+}
+
+func (sm *raft) deleteIns(id int64) {
+	delete(sm.ins, id)
+	sm.saveState()
+}
+
+// saveState saves the state to sm.unstableState
+// When there is a term change, vote change or configuration change, raft
+// must call saveState.
+func (sm *raft) saveState() {
+	sm.setState(sm.vote, sm.term.Get(), sm.raftLog.committed)
+}
+
+func (sm *raft) clearState() {
+	sm.setState(0, 0, 0)
+}
+
+func (sm *raft) setState(vote, term, commit int64) {
+	sm.unstableState.Vote = vote
+	sm.unstableState.Term = term
+	sm.unstableState.Commit = commit
+}
+
+func (sm *raft) loadEnts(ents []Entry) {
+	if !sm.raftLog.isEmpty() {
+		panic("cannot load entries when log is not empty")
+	}
+	sm.raftLog.append(0, ents...)
+	sm.raftLog.unstable = sm.raftLog.lastIndex() + 1
+}
+
+func (sm *raft) loadState(state State) {
+	sm.raftLog.committed = state.Commit
+	sm.setTerm(state.Term)
+	sm.setVote(state.Vote)
+}
+
+func (s *State) IsEmpty() bool {
+	return s.Term == 0
+}
diff --git a/raft2/raft_test.go b/raft2/raft_test.go
new file mode 100644
index 0000000..1a36ded
--- /dev/null
+++ b/raft2/raft_test.go
@@ -0,0 +1,1058 @@
+package raft
+
+import (
+	"bytes"
+	"math/rand"
+	"reflect"
+	"sort"
+	"testing"
+)
+
+type Interface interface {
+	Step(m Message) error
+	ReadMessages() []Message
+}
+
+func TestLeaderElection(t *testing.T) {
+	tests := []struct {
+		*network
+		state stateType
+	}{
+		{newNetwork(nil, nil, nil), stateLeader},
+		{newNetwork(nil, nil, nopStepper), stateLeader},
+		{newNetwork(nil, nopStepper, nopStepper), stateCandidate},
+		{newNetwork(nil, nopStepper, nopStepper, nil), stateCandidate},
+		{newNetwork(nil, nopStepper, nopStepper, nil, nil), stateLeader},
+
+		// three logs further along than 0
+		{newNetwork(nil, ents(1), ents(2), ents(1, 3), nil), stateFollower},
+
+		// logs converge
+		{newNetwork(ents(1), nil, ents(2), ents(1), nil), stateLeader},
+	}
+
+	for i, tt := range tests {
+		tt.send(Message{From: 0, To: 0, Type: msgHup})
+		sm := tt.network.peers[0].(*raft)
+		if sm.state != tt.state {
+			t.Errorf("#%d: state = %s, want %s", i, sm.state, tt.state)
+		}
+		if g := sm.term.Get(); g != 1 {
+			t.Errorf("#%d: term = %d, want %d", i, g, 1)
+		}
+	}
+}
+
+func TestLogReplication(t *testing.T) {
+	tests := []struct {
+		*network
+		msgs       []Message
+		wcommitted int64
+	}{
+		{
+			newNetwork(nil, nil, nil),
+			[]Message{
+				{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("somedata")}}},
+			},
+			2,
+		},
+		{
+			newNetwork(nil, nil, nil),
+			[]Message{
+
+				{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("somedata")}}},
+				{From: 0, To: 1, Type: msgHup},
+				{From: 0, To: 1, Type: msgProp, Entries: []Entry{{Data: []byte("somedata")}}},
+			},
+			4,
+		},
+	}
+
+	for i, tt := range tests {
+		tt.send(Message{From: 0, To: 0, Type: msgHup})
+
+		for _, m := range tt.msgs {
+			tt.send(m)
+		}
+
+		for j, x := range tt.network.peers {
+			sm := x.(*raft)
+
+			if sm.raftLog.committed != tt.wcommitted {
+				t.Errorf("#%d.%d: committed = %d, want %d", i, j, sm.raftLog.committed, tt.wcommitted)
+			}
+
+			ents := make([]Entry, 0)
+			for _, e := range sm.nextEnts() {
+				if e.Data != nil {
+					ents = append(ents, e)
+				}
+			}
+			props := make([]Message, 0)
+			for _, m := range tt.msgs {
+				if m.Type == msgProp {
+					props = append(props, m)
+				}
+			}
+			for k, m := range props {
+				if !bytes.Equal(ents[k].Data, m.Entries[0].Data) {
+					t.Errorf("#%d.%d: data = %d, want %d", i, j, ents[k].Data, m.Entries[0].Data)
+				}
+			}
+		}
+	}
+}
+
+func TestSingleNodeCommit(t *testing.T) {
+	tt := newNetwork(nil)
+	tt.send(Message{From: 0, To: 0, Type: msgHup})
+	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
+	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
+
+	sm := tt.peers[0].(*raft)
+	if sm.raftLog.committed != 3 {
+		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 3)
+	}
+}
+
+// TestCannotCommitWithoutNewTermEntry tests the entries cannot be committed
+// when leader changes, no new proposal comes in and ChangeTerm proposal is
+// filtered.
+func TestCannotCommitWithoutNewTermEntry(t *testing.T) {
+	tt := newNetwork(nil, nil, nil, nil, nil)
+	tt.send(Message{From: 0, To: 0, Type: msgHup})
+
+	// 0 cannot reach 2,3,4
+	tt.cut(0, 2)
+	tt.cut(0, 3)
+	tt.cut(0, 4)
+
+	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
+	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
+
+	sm := tt.peers[0].(*raft)
+	if sm.raftLog.committed != 1 {
+		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 1)
+	}
+
+	// network recovery
+	tt.recover()
+	// avoid committing ChangeTerm proposal
+	tt.ignore(msgApp)
+
+	// elect 1 as the new leader with term 2
+	tt.send(Message{From: 1, To: 1, Type: msgHup})
+
+	// no log entries from previous term should be committed
+	sm = tt.peers[1].(*raft)
+	if sm.raftLog.committed != 1 {
+		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 1)
+	}
+
+	tt.recover()
+
+	// send out a heartbeat
+	// after append a ChangeTerm entry from the current term, all entries
+	// should be committed
+	tt.send(Message{From: 1, To: 1, Type: msgBeat})
+
+	if sm.raftLog.committed != 4 {
+		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 4)
+	}
+
+	// still be able to append a entry
+	tt.send(Message{From: 1, To: 1, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
+
+	if sm.raftLog.committed != 5 {
+		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 5)
+	}
+}
+
+// TestCommitWithoutNewTermEntry tests the entries could be committed
+// when leader changes, no new proposal comes in.
+func TestCommitWithoutNewTermEntry(t *testing.T) {
+	tt := newNetwork(nil, nil, nil, nil, nil)
+	tt.send(Message{From: 0, To: 0, Type: msgHup})
+
+	// 0 cannot reach 2,3,4
+	tt.cut(0, 2)
+	tt.cut(0, 3)
+	tt.cut(0, 4)
+
+	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
+	tt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: []byte("some data")}}})
+
+	sm := tt.peers[0].(*raft)
+	if sm.raftLog.committed != 1 {
+		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 1)
+	}
+
+	// network recovery
+	tt.recover()
+
+	// elect 1 as the new leader with term 2
+	// after append a ChangeTerm entry from the current term, all entries
+	// should be committed
+	tt.send(Message{From: 1, To: 1, Type: msgHup})
+
+	if sm.raftLog.committed != 4 {
+		t.Errorf("committed = %d, want %d", sm.raftLog.committed, 4)
+	}
+}
+
+func TestDuelingCandidates(t *testing.T) {
+	a := newStateMachine(0, nil) // k, id are set later
+	b := newStateMachine(0, nil)
+	c := newStateMachine(0, nil)
+
+	nt := newNetwork(a, b, c)
+	nt.cut(0, 2)
+
+	nt.send(Message{From: 0, To: 0, Type: msgHup})
+	nt.send(Message{From: 2, To: 2, Type: msgHup})
+
+	nt.recover()
+	nt.send(Message{From: 2, To: 2, Type: msgHup})
+
+	wlog := &raftLog{ents: []Entry{{}, Entry{Type: Normal, Data: nil, Term: 1, Index: 1}}, committed: 1}
+	tests := []struct {
+		sm      *raft
+		state   stateType
+		term    int64
+		raftLog *raftLog
+	}{
+		{a, stateFollower, 2, wlog},
+		{b, stateFollower, 2, wlog},
+		{c, stateFollower, 2, newLog()},
+	}
+
+	for i, tt := range tests {
+		if g := tt.sm.state; g != tt.state {
+			t.Errorf("#%d: state = %s, want %s", i, g, tt.state)
+		}
+		if g := tt.sm.term.Get(); g != tt.term {
+			t.Errorf("#%d: term = %d, want %d", i, g, tt.term)
+		}
+		base := ltoa(tt.raftLog)
+		if sm, ok := nt.peers[int64(i)].(*raft); ok {
+			l := ltoa(sm.raftLog)
+			if g := diffu(base, l); g != "" {
+				t.Errorf("#%d: diff:\n%s", i, g)
+			}
+		} else {
+			t.Logf("#%d: empty log", i)
+		}
+	}
+}
+
+func TestCandidateConcede(t *testing.T) {
+	tt := newNetwork(nil, nil, nil)
+	tt.isolate(0)
+
+	tt.send(Message{From: 0, To: 0, Type: msgHup})
+	tt.send(Message{From: 2, To: 2, Type: msgHup})
+
+	// heal the partition
+	tt.recover()
+
+	data := []byte("force follower")
+	// send a proposal to 2 to flush out a msgApp to 0
+	tt.send(Message{From: 2, To: 2, Type: msgProp, Entries: []Entry{{Data: data}}})
+
+	a := tt.peers[0].(*raft)
+	if g := a.state; g != stateFollower {
+		t.Errorf("state = %s, want %s", g, stateFollower)
+	}
+	if g := a.term; g != 1 {
+		t.Errorf("term = %d, want %d", g, 1)
+	}
+	wantLog := ltoa(&raftLog{ents: []Entry{{}, {Type: Normal, Data: nil, Term: 1, Index: 1}, {Term: 1, Index: 2, Data: data}}, committed: 2})
+	for i, p := range tt.peers {
+		if sm, ok := p.(*raft); ok {
+			l := ltoa(sm.raftLog)
+			if g := diffu(wantLog, l); g != "" {
+				t.Errorf("#%d: diff:\n%s", i, g)
+			}
+		} else {
+			t.Logf("#%d: empty log", i)
+		}
+	}
+}
+
+func TestSingleNodeCandidate(t *testing.T) {
+	tt := newNetwork(nil)
+	tt.send(Message{From: 0, To: 0, Type: msgHup})
+
+	sm := tt.peers[0].(*raft)
+	if sm.state != stateLeader {
+		t.Errorf("state = %d, want %d", sm.state, stateLeader)
+	}
+}
+
+func TestOldMessages(t *testing.T) {
+	tt := newNetwork(nil, nil, nil)
+	// make 0 leader @ term 3
+	tt.send(Message{From: 0, To: 0, Type: msgHup})
+	tt.send(Message{From: 1, To: 1, Type: msgHup})
+	tt.send(Message{From: 0, To: 0, Type: msgHup})
+	// pretend we're an old leader trying to make progress
+	tt.send(Message{From: 0, To: 0, Type: msgApp, Term: 1, Entries: []Entry{{Term: 1}}})
+
+	l := &raftLog{
+		ents: []Entry{
+			{}, {Type: Normal, Data: nil, Term: 1, Index: 1},
+			{Type: Normal, Data: nil, Term: 2, Index: 2}, {Type: Normal, Data: nil, Term: 3, Index: 3},
+		},
+		committed: 3,
+	}
+	base := ltoa(l)
+	for i, p := range tt.peers {
+		if sm, ok := p.(*raft); ok {
+			l := ltoa(sm.raftLog)
+			if g := diffu(base, l); g != "" {
+				t.Errorf("#%d: diff:\n%s", i, g)
+			}
+		} else {
+			t.Logf("#%d: empty log", i)
+		}
+	}
+}
+
+// TestOldMessagesReply - optimization - reply with new term.
+
+func TestProposal(t *testing.T) {
+	tests := []struct {
+		*network
+		success bool
+	}{
+		{newNetwork(nil, nil, nil), true},
+		{newNetwork(nil, nil, nopStepper), true},
+		{newNetwork(nil, nopStepper, nopStepper), false},
+		{newNetwork(nil, nopStepper, nopStepper, nil), false},
+		{newNetwork(nil, nopStepper, nopStepper, nil, nil), true},
+	}
+
+	for i, tt := range tests {
+		send := func(m Message) {
+			defer func() {
+				// only recover is we expect it to panic so
+				// panics we don't expect go up.
+				if !tt.success {
+					e := recover()
+					if e != nil {
+						t.Logf("#%d: err: %s", i, e)
+					}
+				}
+			}()
+			tt.send(m)
+		}
+
+		data := []byte("somedata")
+
+		// promote 0 the leader
+		send(Message{From: 0, To: 0, Type: msgHup})
+		send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Data: data}}})
+
+		wantLog := newLog()
+		if tt.success {
+			wantLog = &raftLog{ents: []Entry{{}, {Type: Normal, Data: nil, Term: 1, Index: 1}, {Term: 1, Index: 2, Data: data}}, committed: 2}
+		}
+		base := ltoa(wantLog)
+		for i, p := range tt.peers {
+			if sm, ok := p.(*raft); ok {
+				l := ltoa(sm.raftLog)
+				if g := diffu(base, l); g != "" {
+					t.Errorf("#%d: diff:\n%s", i, g)
+				}
+			} else {
+				t.Logf("#%d: empty log", i)
+			}
+		}
+		sm := tt.network.peers[0].(*raft)
+		if g := sm.term.Get(); g != 1 {
+			t.Errorf("#%d: term = %d, want %d", i, g, 1)
+		}
+	}
+}
+
+func TestProposalByProxy(t *testing.T) {
+	data := []byte("somedata")
+	tests := []*network{
+		newNetwork(nil, nil, nil),
+		newNetwork(nil, nil, nopStepper),
+	}
+
+	for i, tt := range tests {
+		// promote 0 the leader
+		tt.send(Message{From: 0, To: 0, Type: msgHup})
+
+		// propose via follower
+		tt.send(Message{From: 1, To: 1, Type: msgProp, Entries: []Entry{{Data: []byte("somedata")}}})
+
+		wantLog := &raftLog{ents: []Entry{{}, {Type: Normal, Data: nil, Term: 1, Index: 1}, {Term: 1, Data: data, Index: 2}}, committed: 2}
+		base := ltoa(wantLog)
+		for i, p := range tt.peers {
+			if sm, ok := p.(*raft); ok {
+				l := ltoa(sm.raftLog)
+				if g := diffu(base, l); g != "" {
+					t.Errorf("#%d: diff:\n%s", i, g)
+				}
+			} else {
+				t.Logf("#%d: empty log", i)
+			}
+		}
+		sm := tt.peers[0].(*raft)
+		if g := sm.term.Get(); g != 1 {
+			t.Errorf("#%d: term = %d, want %d", i, g, 1)
+		}
+	}
+}
+
+func TestCommit(t *testing.T) {
+	tests := []struct {
+		matches []int64
+		logs    []Entry
+		smTerm  int64
+		w       int64
+	}{
+		// single
+		{[]int64{1}, []Entry{{}, {Term: 1}}, 1, 1},
+		{[]int64{1}, []Entry{{}, {Term: 1}}, 2, 0},
+		{[]int64{2}, []Entry{{}, {Term: 1}, {Term: 2}}, 2, 2},
+		{[]int64{1}, []Entry{{}, {Term: 2}}, 2, 1},
+
+		// odd
+		{[]int64{2, 1, 1}, []Entry{{}, {Term: 1}, {Term: 2}}, 1, 1},
+		{[]int64{2, 1, 1}, []Entry{{}, {Term: 1}, {Term: 1}}, 2, 0},
+		{[]int64{2, 1, 2}, []Entry{{}, {Term: 1}, {Term: 2}}, 2, 2},
+		{[]int64{2, 1, 2}, []Entry{{}, {Term: 1}, {Term: 1}}, 2, 0},
+
+		// even
+		{[]int64{2, 1, 1, 1}, []Entry{{}, {Term: 1}, {Term: 2}}, 1, 1},
+		{[]int64{2, 1, 1, 1}, []Entry{{}, {Term: 1}, {Term: 1}}, 2, 0},
+		{[]int64{2, 1, 1, 2}, []Entry{{}, {Term: 1}, {Term: 2}}, 1, 1},
+		{[]int64{2, 1, 1, 2}, []Entry{{}, {Term: 1}, {Term: 1}}, 2, 0},
+		{[]int64{2, 1, 2, 2}, []Entry{{}, {Term: 1}, {Term: 2}}, 2, 2},
+		{[]int64{2, 1, 2, 2}, []Entry{{}, {Term: 1}, {Term: 1}}, 2, 0},
+	}
+
+	for i, tt := range tests {
+		ins := make(map[int64]*index)
+		for j := 0; j < len(tt.matches); j++ {
+			ins[int64(j)] = &index{tt.matches[j], tt.matches[j] + 1}
+		}
+		sm := &raft{raftLog: &raftLog{ents: tt.logs}, ins: ins, term: atomicInt(tt.smTerm)}
+		sm.maybeCommit()
+		if g := sm.raftLog.committed; g != tt.w {
+			t.Errorf("#%d: committed = %d, want %d", i, g, tt.w)
+		}
+	}
+}
+
+// TestHandleMsgApp ensures:
+// 1. Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm.
+// 2. If an existing entry conflicts with a new one (same index but different terms),
+//    delete the existing entry and all that follow it; append any new entries not already in the log.
+// 3. If leaderCommit > commitIndex, set commitIndex = min(leaderCommit, index of last new entry).
+func TestHandleMsgApp(t *testing.T) {
+	tests := []struct {
+		m       Message
+		wIndex  int64
+		wCommit int64
+		wAccept bool
+	}{
+		// Ensure 1
+		{Message{Type: msgApp, Term: 2, LogTerm: 3, Index: 2, Commit: 3}, 2, 0, false}, // previous log mismatch
+		{Message{Type: msgApp, Term: 2, LogTerm: 3, Index: 3, Commit: 3}, 2, 0, false}, // previous log non-exist
+
+		// Ensure 2
+		{Message{Type: msgApp, Term: 2, LogTerm: 1, Index: 1, Commit: 1}, 2, 1, true},
+		{Message{Type: msgApp, Term: 2, LogTerm: 0, Index: 0, Commit: 1, Entries: []Entry{{Term: 2}}}, 1, 1, true},
+		{Message{Type: msgApp, Term: 2, LogTerm: 2, Index: 2, Commit: 3, Entries: []Entry{{Term: 2}, {Term: 2}}}, 4, 3, true},
+		{Message{Type: msgApp, Term: 2, LogTerm: 2, Index: 2, Commit: 4, Entries: []Entry{{Term: 2}}}, 3, 3, true},
+		{Message{Type: msgApp, Term: 2, LogTerm: 1, Index: 1, Commit: 4, Entries: []Entry{{Term: 2}}}, 2, 2, true},
+
+		// Ensure 3
+		{Message{Type: msgApp, Term: 2, LogTerm: 2, Index: 2, Commit: 2}, 2, 2, true},
+		{Message{Type: msgApp, Term: 2, LogTerm: 2, Index: 2, Commit: 4}, 2, 2, true}, // commit upto min(commit, last)
+	}
+
+	for i, tt := range tests {
+		sm := &raft{
+			state:   stateFollower,
+			term:    2,
+			raftLog: &raftLog{committed: 0, ents: []Entry{{}, {Term: 1}, {Term: 2}}},
+		}
+
+		sm.handleAppendEntries(tt.m)
+		if sm.raftLog.lastIndex() != tt.wIndex {
+			t.Errorf("#%d: lastIndex = %d, want %d", i, sm.raftLog.lastIndex(), tt.wIndex)
+		}
+		if sm.raftLog.committed != tt.wCommit {
+			t.Errorf("#%d: committed = %d, want %d", i, sm.raftLog.committed, tt.wCommit)
+		}
+		m := sm.ReadMessages()
+		if len(m) != 1 {
+			t.Errorf("#%d: msg = nil, want 1")
+		}
+		gaccept := true
+		if m[0].Index == -1 {
+			gaccept = false
+		}
+		if gaccept != tt.wAccept {
+			t.Errorf("#%d: accept = %v, want %v", gaccept, tt.wAccept)
+		}
+	}
+}
+
+func TestRecvMsgVote(t *testing.T) {
+	tests := []struct {
+		state   stateType
+		i, term int64
+		voteFor int64
+		w       int64
+	}{
+		{stateFollower, 0, 0, none, -1},
+		{stateFollower, 0, 1, none, -1},
+		{stateFollower, 0, 2, none, -1},
+		{stateFollower, 0, 3, none, 2},
+
+		{stateFollower, 1, 0, none, -1},
+		{stateFollower, 1, 1, none, -1},
+		{stateFollower, 1, 2, none, -1},
+		{stateFollower, 1, 3, none, 2},
+
+		{stateFollower, 2, 0, none, -1},
+		{stateFollower, 2, 1, none, -1},
+		{stateFollower, 2, 2, none, 2},
+		{stateFollower, 2, 3, none, 2},
+
+		{stateFollower, 3, 0, none, -1},
+		{stateFollower, 3, 1, none, -1},
+		{stateFollower, 3, 2, none, 2},
+		{stateFollower, 3, 3, none, 2},
+
+		{stateFollower, 3, 2, 1, 2},
+		{stateFollower, 3, 2, 0, -1},
+
+		{stateLeader, 3, 3, 0, -1},
+		{stateCandidate, 3, 3, 0, -1},
+	}
+
+	for i, tt := range tests {
+		sm := &raft{
+			state:   tt.state,
+			vote:    tt.voteFor,
+			raftLog: &raftLog{ents: []Entry{{}, {Term: 2}, {Term: 2}}},
+		}
+
+		sm.Step(Message{Type: msgVote, From: 1, Index: tt.i, LogTerm: tt.term})
+
+		msgs := sm.ReadMessages()
+		if g := len(msgs); g != 1 {
+			t.Errorf("#%d: len(msgs) = %d, want 1", i, g)
+			continue
+		}
+		if g := msgs[0].Index; g != tt.w {
+			t.Errorf("#%d, m.Index = %d, want %d", i, g, tt.w)
+		}
+	}
+}
+
+func TestStateTransition(t *testing.T) {
+	tests := []struct {
+		from   stateType
+		to     stateType
+		wallow bool
+		wterm  int64
+		wlead  int64
+	}{
+		{stateFollower, stateFollower, true, 1, none},
+		{stateFollower, stateCandidate, true, 1, none},
+		{stateFollower, stateLeader, false, -1, none},
+
+		{stateCandidate, stateFollower, true, 0, none},
+		{stateCandidate, stateCandidate, true, 1, none},
+		{stateCandidate, stateLeader, true, 0, 0},
+
+		{stateLeader, stateFollower, true, 1, none},
+		{stateLeader, stateCandidate, false, 1, none},
+		{stateLeader, stateLeader, true, 0, 0},
+	}
+
+	for i, tt := range tests {
+		func() {
+			defer func() {
+				if r := recover(); r != nil {
+					if tt.wallow == true {
+						t.Errorf("%d: allow = %v, want %v", i, false, true)
+					}
+				}
+			}()
+
+			sm := newStateMachine(0, []int64{0})
+			sm.state = tt.from
+
+			switch tt.to {
+			case stateFollower:
+				sm.becomeFollower(tt.wterm, tt.wlead)
+			case stateCandidate:
+				sm.becomeCandidate()
+			case stateLeader:
+				sm.becomeLeader()
+			}
+
+			if sm.term.Get() != tt.wterm {
+				t.Errorf("%d: term = %d, want %d", i, sm.term.Get(), tt.wterm)
+			}
+			if sm.lead.Get() != tt.wlead {
+				t.Errorf("%d: lead = %d, want %d", i, sm.lead, tt.wlead)
+			}
+		}()
+	}
+}
+
+func TestConf(t *testing.T) {
+	sm := newStateMachine(0, []int64{0})
+	sm.becomeCandidate()
+	sm.becomeLeader()
+
+	sm.Step(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Type: AddNode}}})
+	if sm.raftLog.lastIndex() != 2 {
+		t.Errorf("lastindex = %d, want %d", sm.raftLog.lastIndex(), 1)
+	}
+	if !sm.pendingConf {
+		t.Errorf("pendingConf = %v, want %v", sm.pendingConf, true)
+	}
+	if sm.raftLog.ents[2].Type != AddNode {
+		t.Errorf("type = %d, want %d", sm.raftLog.ents[1].Type, AddNode)
+	}
+
+	// deny the second configuration change request if there is a pending one
+	sm.Step(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{Type: AddNode}}})
+	if sm.raftLog.lastIndex() != 2 {
+		t.Errorf("lastindex = %d, want %d", sm.raftLog.lastIndex(), 1)
+	}
+}
+
+// Ensures that the new leader sets the pendingConf flag correctly according to
+// the uncommitted log entries
+func TestConfChangeLeader(t *testing.T) {
+	tests := []struct {
+		et       int64
+		wPending bool
+	}{
+		{Normal, false},
+		{AddNode, true},
+		{RemoveNode, true},
+	}
+
+	for i, tt := range tests {
+		sm := newStateMachine(0, []int64{0})
+		sm.raftLog = &raftLog{ents: []Entry{{}, {Type: tt.et}}}
+
+		sm.becomeCandidate()
+		sm.becomeLeader()
+
+		if sm.pendingConf != tt.wPending {
+			t.Errorf("#%d: pendingConf = %v, want %v", i, sm.pendingConf, tt.wPending)
+		}
+	}
+}
+
+func TestAllServerStepdown(t *testing.T) {
+	tests := []struct {
+		state stateType
+
+		wstate stateType
+		wterm  int64
+		windex int64
+	}{
+		{stateFollower, stateFollower, 3, 1},
+		{stateCandidate, stateFollower, 3, 1},
+		{stateLeader, stateFollower, 3, 2},
+	}
+
+	tmsgTypes := [...]messageType{msgVote, msgApp}
+	tterm := int64(3)
+
+	for i, tt := range tests {
+		sm := newStateMachine(0, []int64{0, 1, 2})
+		switch tt.state {
+		case stateFollower:
+			sm.becomeFollower(1, 0)
+		case stateCandidate:
+			sm.becomeCandidate()
+		case stateLeader:
+			sm.becomeCandidate()
+			sm.becomeLeader()
+		}
+
+		for j, msgType := range tmsgTypes {
+			sm.Step(Message{From: 1, Type: msgType, Term: tterm, LogTerm: tterm})
+
+			if sm.state != tt.wstate {
+				t.Errorf("#%d.%d state = %v , want %v", i, j, sm.state, tt.wstate)
+			}
+			if sm.term.Get() != tt.wterm {
+				t.Errorf("#%d.%d term = %v , want %v", i, j, sm.term.Get(), tt.wterm)
+			}
+			if int64(len(sm.raftLog.ents)) != tt.windex {
+				t.Errorf("#%d.%d index = %v , want %v", i, j, len(sm.raftLog.ents), tt.windex)
+			}
+			wlead := int64(1)
+			if msgType == msgVote {
+				wlead = none
+			}
+			if sm.lead.Get() != wlead {
+				t.Errorf("#%d, sm.lead = %d, want %d", i, sm.lead.Get(), none)
+			}
+		}
+	}
+}
+
+func TestLeaderAppResp(t *testing.T) {
+	tests := []struct {
+		index      int64
+		wmsgNum    int
+		windex     int64
+		wcommitted int64
+	}{
+		{-1, 1, 1, 0}, // bad resp; leader does not commit; reply with log entries
+		{2, 2, 2, 2},  // good resp; leader commits; broadcast with commit index
+	}
+
+	for i, tt := range tests {
+		// sm term is 1 after it becomes the leader.
+		// thus the last log term must be 1 to be committed.
+		sm := newStateMachine(0, []int64{0, 1, 2})
+		sm.raftLog = &raftLog{ents: []Entry{{}, {Term: 0}, {Term: 1}}}
+		sm.becomeCandidate()
+		sm.becomeLeader()
+		sm.ReadMessages()
+		sm.Step(Message{From: 1, Type: msgAppResp, Index: tt.index, Term: sm.term.Get()})
+		msgs := sm.ReadMessages()
+
+		if len(msgs) != tt.wmsgNum {
+			t.Errorf("#%d msgNum = %d, want %d", i, len(msgs), tt.wmsgNum)
+		}
+		for j, msg := range msgs {
+			if msg.Index != tt.windex {
+				t.Errorf("#%d.%d index = %d, want %d", i, j, msg.Index, tt.windex)
+			}
+			if msg.Commit != tt.wcommitted {
+				t.Errorf("#%d.%d commit = %d, want %d", i, j, msg.Commit, tt.wcommitted)
+			}
+		}
+	}
+}
+
+// tests the output of the statemachine when receiving msgBeat
+func TestRecvMsgBeat(t *testing.T) {
+	tests := []struct {
+		state stateType
+		wMsg  int
+	}{
+		{stateLeader, 2},
+		// candidate and follower should ignore msgBeat
+		{stateCandidate, 0},
+		{stateFollower, 0},
+	}
+
+	for i, tt := range tests {
+		sm := newStateMachine(0, []int64{0, 1, 2})
+		sm.raftLog = &raftLog{ents: []Entry{{}, {Term: 0}, {Term: 1}}}
+		sm.term.Set(1)
+		sm.state = tt.state
+		sm.Step(Message{From: 0, To: 0, Type: msgBeat})
+
+		msgs := sm.ReadMessages()
+		if len(msgs) != tt.wMsg {
+			t.Errorf("%d: len(msgs) = %d, want %d", i, len(msgs), tt.wMsg)
+		}
+		for _, m := range msgs {
+			if m.Type != msgApp {
+				t.Errorf("%d: msg.type = %v, want %v", m.Type, msgApp)
+			}
+		}
+	}
+}
+
+func TestRestore(t *testing.T) {
+	s := Snapshot{
+		ClusterId: 0xBEEF,
+		Index:     defaultCompactThreshold + 1,
+		Term:      defaultCompactThreshold + 1,
+		Nodes:     []int64{0, 1, 2},
+	}
+
+	sm := newStateMachine(0, []int64{0, 1})
+	if ok := sm.restore(s); !ok {
+		t.Fatal("restore fail, want succeed")
+	}
+
+	if sm.clusterId != s.ClusterId {
+		t.Errorf("sm.cluster = %x, want %x", sm.clusterId, s.ClusterId)
+	}
+	if sm.raftLog.lastIndex() != s.Index {
+		t.Errorf("log.lastIndex = %d, want %d", sm.raftLog.lastIndex(), s.Index)
+	}
+	if sm.raftLog.term(s.Index) != s.Term {
+		t.Errorf("log.lastTerm = %d, want %d", sm.raftLog.term(s.Index), s.Term)
+	}
+	sg := int64Slice(sm.nodes())
+	sw := int64Slice(s.Nodes)
+	sort.Sort(sg)
+	sort.Sort(sw)
+	if !reflect.DeepEqual(sg, sw) {
+		t.Errorf("sm.Nodes = %+v, want %+v", sg, sw)
+	}
+	if !reflect.DeepEqual(sm.raftLog.snapshot, s) {
+		t.Errorf("snapshot = %+v, want %+v", sm.raftLog.snapshot, s)
+	}
+
+	if ok := sm.restore(s); ok {
+		t.Fatal("restore succeed, want fail")
+	}
+}
+
+func TestProvideSnap(t *testing.T) {
+	s := Snapshot{
+		Index: defaultCompactThreshold + 1,
+		Term:  defaultCompactThreshold + 1,
+		Nodes: []int64{0, 1},
+	}
+	sm := newStateMachine(0, []int64{0})
+	// restore the statemachin from a snapshot
+	// so it has a compacted log and a snapshot
+	sm.restore(s)
+
+	sm.becomeCandidate()
+	sm.becomeLeader()
+
+	sm.Step(Message{From: 0, To: 0, Type: msgBeat})
+	msgs := sm.ReadMessages()
+	if len(msgs) != 1 {
+		t.Errorf("len(msgs) = %d, want 1", len(msgs))
+	}
+	m := msgs[0]
+	if m.Type != msgApp {
+		t.Errorf("m.Type = %v, want %v", m.Type, msgApp)
+	}
+
+	// force set the next of node 1, so that
+	// node 1 needs a snapshot
+	sm.ins[1].next = sm.raftLog.offset
+
+	sm.Step(Message{From: 1, To: 0, Type: msgAppResp, Index: -1})
+	msgs = sm.ReadMessages()
+	if len(msgs) != 1 {
+		t.Errorf("len(msgs) = %d, want 1", len(msgs))
+	}
+	m = msgs[0]
+	if m.Type != msgSnap {
+		t.Errorf("m.Type = %v, want %v", m.Type, msgSnap)
+	}
+}
+
+func TestRestoreFromSnapMsg(t *testing.T) {
+	s := Snapshot{
+		Index: defaultCompactThreshold + 1,
+		Term:  defaultCompactThreshold + 1,
+		Nodes: []int64{0, 1},
+	}
+	m := Message{Type: msgSnap, From: 0, Term: 1, Snapshot: s}
+
+	sm := newStateMachine(1, []int64{0, 1})
+	sm.Step(m)
+
+	if !reflect.DeepEqual(sm.raftLog.snapshot, s) {
+		t.Errorf("snapshot = %+v, want %+v", sm.raftLog.snapshot, s)
+	}
+}
+
+func TestSlowNodeRestore(t *testing.T) {
+	nt := newNetwork(nil, nil, nil)
+	nt.send(Message{From: 0, To: 0, Type: msgHup})
+
+	nt.isolate(2)
+	for j := 0; j < defaultCompactThreshold+1; j++ {
+		nt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{}}})
+	}
+	lead := nt.peers[0].(*raft)
+	lead.nextEnts()
+	lead.compact(nil)
+
+	nt.recover()
+	nt.send(Message{From: 0, To: 0, Type: msgBeat})
+
+	follower := nt.peers[2].(*raft)
+	if !reflect.DeepEqual(follower.raftLog.snapshot, lead.raftLog.snapshot) {
+		t.Errorf("follower.snap = %+v, want %+v", follower.raftLog.snapshot, lead.raftLog.snapshot)
+	}
+
+	committed := follower.raftLog.lastIndex()
+	nt.send(Message{From: 0, To: 0, Type: msgProp, Entries: []Entry{{}}})
+	if follower.raftLog.committed != committed+1 {
+		t.Errorf("follower.comitted = %d, want %d", follower.raftLog.committed, committed+1)
+	}
+}
+
+func TestUnstableState(t *testing.T) {
+	sm := newStateMachine(0, []int64{0})
+	w := State{}
+
+	sm.setVote(1)
+	w.Vote = 1
+	if !reflect.DeepEqual(sm.unstableState, w) {
+		t.Errorf("unstableState = %v, want %v", sm.unstableState, w)
+	}
+	sm.clearState()
+
+	sm.setTerm(1)
+	w.Term = 1
+	if !reflect.DeepEqual(sm.unstableState, w) {
+		t.Errorf("unstableState = %v, want %v", sm.unstableState, w)
+	}
+	sm.clearState()
+
+	sm.raftLog.committed = 1
+	sm.addIns(1, 0, 0)
+	w.Commit = 1
+	if !reflect.DeepEqual(sm.unstableState, w) {
+		t.Errorf("unstableState = %v, want %v", sm.unstableState, w)
+	}
+	sm.clearState()
+
+	sm.raftLog.committed = 2
+	sm.deleteIns(1)
+	w.Commit = 2
+	if !reflect.DeepEqual(sm.unstableState, w) {
+		t.Errorf("unstableState = %v, want %v", sm.unstableState, w)
+	}
+	sm.clearState()
+}
+
+func ents(terms ...int64) *raft {
+	ents := []Entry{{}}
+	for _, term := range terms {
+		ents = append(ents, Entry{Term: term})
+	}
+
+	sm := &raft{raftLog: &raftLog{ents: ents}}
+	sm.reset(0)
+	return sm
+}
+
+type network struct {
+	peers   map[int64]Interface
+	dropm   map[connem]float64
+	ignorem map[messageType]bool
+}
+
+// newNetwork initializes a network from peers.
+// A nil node will be replaced with a new *stateMachine.
+// A *stateMachine will get its k, id.
+// When using stateMachine, the address list is always [0, n).
+func newNetwork(peers ...Interface) *network {
+	size := len(peers)
+	defaultPeerAddrs := make([]int64, size)
+	for i := 0; i < size; i++ {
+		defaultPeerAddrs[i] = int64(i)
+	}
+
+	npeers := make(map[int64]Interface, size)
+
+	for id, p := range peers {
+		nid := int64(id)
+		switch v := p.(type) {
+		case nil:
+			sm := newStateMachine(nid, defaultPeerAddrs)
+			npeers[nid] = sm
+		case *raft:
+			v.id = nid
+			v.ins = make(map[int64]*index)
+			for i := 0; i < size; i++ {
+				v.ins[int64(i)] = &index{}
+			}
+			v.reset(0)
+			npeers[nid] = v
+		default:
+			npeers[nid] = v
+		}
+	}
+	return &network{
+		peers:   npeers,
+		dropm:   make(map[connem]float64),
+		ignorem: make(map[messageType]bool),
+	}
+}
+
+func (nw *network) send(msgs ...Message) {
+	for len(msgs) > 0 {
+		m := msgs[0]
+		p := nw.peers[m.To]
+		p.Step(m)
+		msgs = append(msgs[1:], nw.filter(p.ReadMessages())...)
+	}
+}
+
+func (nw *network) drop(from, to int64, perc float64) {
+	nw.dropm[connem{from, to}] = perc
+}
+
+func (nw *network) cut(one, other int64) {
+	nw.drop(one, other, 1)
+	nw.drop(other, one, 1)
+}
+
+func (nw *network) isolate(id int64) {
+	for i := 0; i < len(nw.peers); i++ {
+		nid := int64(i)
+		if nid != id {
+			nw.drop(id, nid, 1.0)
+			nw.drop(nid, id, 1.0)
+		}
+	}
+}
+
+func (nw *network) ignore(t messageType) {
+	nw.ignorem[t] = true
+}
+
+func (nw *network) recover() {
+	nw.dropm = make(map[connem]float64)
+	nw.ignorem = make(map[messageType]bool)
+}
+
+func (nw *network) filter(msgs []Message) []Message {
+	mm := make([]Message, 0)
+	for _, m := range msgs {
+		if nw.ignorem[m.Type] {
+			continue
+		}
+		switch m.Type {
+		case msgHup:
+			// hups never go over the network, so don't drop them but panic
+			panic("unexpected msgHup")
+		default:
+			perc := nw.dropm[connem{m.From, m.To}]
+			if n := rand.Float64(); n < perc {
+				continue
+			}
+		}
+		mm = append(mm, m)
+	}
+	return mm
+}
+
+type connem struct {
+	from, to int64
+}
+
+type blackHole struct{}
+
+func (blackHole) Step(Message) error      { return nil }
+func (blackHole) ReadMessages() []Message { return nil }
+
+var nopStepper = &blackHole{}
diff --git a/raft2/snapshot.go b/raft2/snapshot.go
new file mode 100644
index 0000000..95a8ca4
--- /dev/null
+++ b/raft2/snapshot.go
@@ -0,0 +1,18 @@
+package raft
+
+var emptySnapshot = Snapshot{}
+
+type Snapshot struct {
+	ClusterId int64
+	Data      []byte
+	// the configuration
+	Nodes []int64
+	// the index at which the snapshot was taken.
+	Index int64
+	// the log term of the index
+	Term int64
+}
+
+func (s Snapshot) IsEmpty() bool {
+	return s.Term == 0
+}
diff --git a/raft2/state.pb.go b/raft2/state.pb.go
new file mode 100644
index 0000000..c7ecb13
--- /dev/null
+++ b/raft2/state.pb.go
@@ -0,0 +1,210 @@
+// Code generated by protoc-gen-gogo.
+// source: state.proto
+// DO NOT EDIT!
+
+/*
+	Package raft is a generated protocol buffer package.
+
+	It is generated from these files:
+		state.proto
+
+	It has these top-level messages:
+		State
+*/
+package raft
+
+import proto "code.google.com/p/gogoprotobuf/proto"
+import json "encoding/json"
+import math "math"
+
+// discarding unused import gogoproto "code.google.com/p/gogoprotobuf/gogoproto/gogo.pb"
+
+import io "io"
+import code_google_com_p_gogoprotobuf_proto "code.google.com/p/gogoprotobuf/proto"
+
+// Reference proto, json, and math imports to suppress error if they are not otherwise used.
+var _ = proto.Marshal
+var _ = &json.SyntaxError{}
+var _ = math.Inf
+
+type State struct {
+	Term             int64  `protobuf:"varint,1,req,name=term" json:"term"`
+	Vote             int64  `protobuf:"varint,2,req,name=vote" json:"vote"`
+	Commit           int64  `protobuf:"varint,3,req,name=commit" json:"commit"`
+	XXX_unrecognized []byte `json:"-"`
+}
+
+func (m *State) Reset()         { *m = State{} }
+func (m *State) String() string { return proto.CompactTextString(m) }
+func (*State) ProtoMessage()    {}
+
+func init() {
+}
+func (m *State) Unmarshal(data []byte) error {
+	l := len(data)
+	index := 0
+	for index < l {
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if index >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := data[index]
+			index++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
+			}
+			for shift := uint(0); ; shift += 7 {
+				if index >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := data[index]
+				index++
+				m.Term |= (int64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 0 {
+				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
+			}
+			for shift := uint(0); ; shift += 7 {
+				if index >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := data[index]
+				index++
+				m.Vote |= (int64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 0 {
+				return code_google_com_p_gogoprotobuf_proto.ErrWrongType
+			}
+			for shift := uint(0); ; shift += 7 {
+				if index >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := data[index]
+				index++
+				m.Commit |= (int64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		default:
+			var sizeOfWire int
+			for {
+				sizeOfWire++
+				wire >>= 7
+				if wire == 0 {
+					break
+				}
+			}
+			index -= sizeOfWire
+			skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
+			if err != nil {
+				return err
+			}
+			if (index + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
+			index += skippy
+		}
+	}
+	return nil
+}
+func (m *State) Size() (n int) {
+	var l int
+	_ = l
+	n += 1 + sovState(uint64(m.Term))
+	n += 1 + sovState(uint64(m.Vote))
+	n += 1 + sovState(uint64(m.Commit))
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func sovState(x uint64) (n int) {
+	for {
+		n++
+		x >>= 7
+		if x == 0 {
+			break
+		}
+	}
+	return n
+}
+func sozState(x uint64) (n int) {
+	return sovState(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (m *State) Marshal() (data []byte, err error) {
+	size := m.Size()
+	data = make([]byte, size)
+	n, err := m.MarshalTo(data)
+	if err != nil {
+		return nil, err
+	}
+	return data[:n], nil
+}
+
+func (m *State) MarshalTo(data []byte) (n int, err error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	data[i] = 0x8
+	i++
+	i = encodeVarintState(data, i, uint64(m.Term))
+	data[i] = 0x10
+	i++
+	i = encodeVarintState(data, i, uint64(m.Vote))
+	data[i] = 0x18
+	i++
+	i = encodeVarintState(data, i, uint64(m.Commit))
+	if m.XXX_unrecognized != nil {
+		i += copy(data[i:], m.XXX_unrecognized)
+	}
+	return i, nil
+}
+func encodeFixed64State(data []byte, offset int, v uint64) int {
+	data[offset] = uint8(v)
+	data[offset+1] = uint8(v >> 8)
+	data[offset+2] = uint8(v >> 16)
+	data[offset+3] = uint8(v >> 24)
+	data[offset+4] = uint8(v >> 32)
+	data[offset+5] = uint8(v >> 40)
+	data[offset+6] = uint8(v >> 48)
+	data[offset+7] = uint8(v >> 56)
+	return offset + 8
+}
+func encodeFixed32State(data []byte, offset int, v uint32) int {
+	data[offset] = uint8(v)
+	data[offset+1] = uint8(v >> 8)
+	data[offset+2] = uint8(v >> 16)
+	data[offset+3] = uint8(v >> 24)
+	return offset + 4
+}
+func encodeVarintState(data []byte, offset int, v uint64) int {
+	for v >= 1<<7 {
+		data[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	data[offset] = uint8(v)
+	return offset + 1
+}
diff --git a/raft2/state.proto b/raft2/state.proto
new file mode 100644
index 0000000..d923e23
--- /dev/null
+++ b/raft2/state.proto
@@ -0,0 +1,14 @@
+package raft;
+
+import "code.google.com/p/gogoprotobuf/gogoproto/gogo.proto";
+
+option (gogoproto.marshaler_all) = true;
+option (gogoproto.sizer_all) = true;
+option (gogoproto.unmarshaler_all) = true;
+option (gogoproto.goproto_getters_all) = false;
+
+message State {
+	required int64 term   = 1 [(gogoproto.nullable) = false];
+	required int64 vote   = 2 [(gogoproto.nullable) = false];
+	required int64 commit = 3 [(gogoproto.nullable) = false];
+}
