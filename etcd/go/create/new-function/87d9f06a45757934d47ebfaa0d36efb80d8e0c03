commit 87d9f06a45757934d47ebfaa0d36efb80d8e0c03
Author: Xiang Li <xiangli.cs@gmail.com>
Date:   Mon Mar 28 10:49:03 2016 -0700

    *: combine etcdctl and etcdctlv3

diff --git a/V3DemoProcfile b/V3DemoProcfile
index f900c73..41dd49f 100644
--- a/V3DemoProcfile
+++ b/V3DemoProcfile
@@ -1,5 +1,4 @@
 # Use goreman to run `go get github.com/mattn/goreman`
-# etcd1 is the default client server for etcdctlv3 commands
 etcd1: bin/etcd --name infra1 --listen-client-urls http://127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --listen-peer-urls http://127.0.0.1:12380 --initial-advertise-peer-urls http://127.0.0.1:12380 --initial-cluster-token etcd-cluster-1 --initial-cluster 'infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380' --initial-cluster-state new --enable-pprof
 etcd2: bin/etcd --name infra2 --listen-client-urls http://127.0.0.1:22379 --advertise-client-urls http://127.0.0.1:22379 --listen-peer-urls http://127.0.0.1:22380 --initial-advertise-peer-urls http://127.0.0.1:22380 --initial-cluster-token etcd-cluster-1 --initial-cluster 'infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380' --initial-cluster-state new --enable-pprof
 etcd3: bin/etcd --name infra3 --listen-client-urls http://127.0.0.1:32379 --advertise-client-urls http://127.0.0.1:32379 --listen-peer-urls http://127.0.0.1:32380 --initial-advertise-peer-urls http://127.0.0.1:32380 --initial-cluster-token etcd-cluster-1 --initial-cluster 'infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380' --initial-cluster-state new --enable-pprof
diff --git a/build b/build
index e6357c0..3262c3b 100755
--- a/build
+++ b/build
@@ -32,4 +32,3 @@ fi
 # Static compilation is useful when etcd is run in a container
 CGO_ENABLED=0 go build $GO_BUILD_FLAGS -installsuffix cgo -ldflags "-s -X ${REPO_PATH}/version.GitSHA${LINK_OPERATOR}${GIT_SHA}" -o bin/etcd ${REPO_PATH}
 CGO_ENABLED=0 go build $GO_BUILD_FLAGS -installsuffix cgo -ldflags "-s" -o bin/etcdctl ${REPO_PATH}/etcdctl
-CGO_ENABLED=0 go build $GO_BUILD_FLAGS -installsuffix cgo -ldflags "-s" -o bin/etcdctlv3 ${REPO_PATH}/etcdctlv3
diff --git a/e2e/etcdctlv3_test.go b/e2e/etcdctlv3_test.go
index 6024df7..ba6f17e 100644
--- a/e2e/etcdctlv3_test.go
+++ b/e2e/etcdctlv3_test.go
@@ -15,11 +15,11 @@
 package e2e
 
 import (
+	"os"
 	"strings"
 	"testing"
 	"time"
 
-	"github.com/coreos/etcd/pkg/fileutil"
 	"github.com/coreos/etcd/pkg/testutil"
 )
 
@@ -58,8 +58,10 @@ func TestCtlV3SetPeerTLSQuorum(t *testing.T) {
 func testCtlV3Set(t *testing.T, cfg *etcdProcessClusterConfig, dialTimeout time.Duration, quorum bool) {
 	defer testutil.AfterTest(t)
 
+	os.Setenv("ETCDCTL_API", "3")
 	epc := setupCtlV3Test(t, cfg, quorum)
 	defer func() {
+		os.Unsetenv("ETCDCTL_API")
 		if errC := epc.Close(); errC != nil {
 			t.Fatalf("error closing etcd processes (%v)", errC)
 		}
@@ -108,7 +110,7 @@ func ctlV3PrefixArgs(clus *etcdProcessCluster, dialTimeout time.Duration) []stri
 		}
 		endpoints = strings.Join(es, ",")
 	}
-	cmdArgs := []string{"../bin/etcdctlv3", "--endpoints", endpoints, "--dial-timeout", dialTimeout.String()}
+	cmdArgs := []string{"../bin/etcdctl", "--endpoints", endpoints, "--dial-timeout", dialTimeout.String()}
 	if clus.cfg.clientTLS == clientTLS {
 		cmdArgs = append(cmdArgs, "--cacert", caPath, "--cert", certPath, "--key", privateKeyPath)
 	}
@@ -129,14 +131,8 @@ func ctlV3Get(clus *etcdProcessCluster, key, value string, dialTimeout time.Dura
 	return spawnWithExpectedString(cmdArgs, key)
 }
 
-func mustCtlV3(t *testing.T) {
-	if !fileutil.Exist("../bin/etcdctlv3") {
-		t.Fatalf("could not find etcdctlv3 binary")
-	}
-}
-
 func setupCtlV3Test(t *testing.T, cfg *etcdProcessClusterConfig, quorum bool) *etcdProcessCluster {
-	mustCtlV3(t)
+	mustEtcdctl(t)
 	if !quorum {
 		cfg = configStandalone(*cfg)
 	}
diff --git a/etcdctl/READMEv3.md b/etcdctl/READMEv3.md
new file mode 100644
index 0000000..0671b93
--- /dev/null
+++ b/etcdctl/READMEv3.md
@@ -0,0 +1,391 @@
+etcdctl
+========
+
+TODO: merge into README.md.
+
+## Commands
+
+### PUT [options] \<key\> \<value\>
+
+PUT assigns the specified value with the specified key. If key already holds a value, it is overwritten.
+
+#### Options
+
+- lease -- lease ID (in hexadecimal) to attach to the key.
+
+#### Return value
+
+##### Simple reply
+
+- OK if PUT executed correctly. Exit code is zero.
+
+- Error string if PUT failed. Exit code is non-zero.
+
+##### JSON reply
+
+The JSON encoding of the PUT [RPC response][etcdrpc].
+
+##### Protobuf reply
+
+The protobuf encoding of the PUT [RPC response][etcdrpc].
+
+#### Examples
+
+``` bash
+./etcdctl PUT foo bar --lease=0x1234abcd
+OK
+./etcdctl range foo
+bar
+```
+
+#### Notes
+
+If \<value\> isn't given as command line argument, this command tries to read the value from standard input.
+
+When \<value\> begins with '-', \<value\> is interpreted as a flag.
+Insert '--' for workaround:
+
+``` bash
+./etcdctl put <key> -- <value>
+./etcdctl put -- <key> <value>
+```
+
+### GET [options] \<key\> [range_end]
+
+GET gets the key or a range of keys [key, range_end) if `range-end` is given.
+
+#### Options
+
+- hex -- print out key and value as hex encode string
+
+- limit -- maximum number of results
+
+- order -- order of results; ASCEND or DESCEND
+
+- sort-by -- sort target; CREATE, KEY, MODIFY, VALUE, or VERSION
+
+TODO: add consistency, from, prefix
+
+#### Return value
+
+##### Simple reply
+
+- \<key\>\n\<value\>\n\<next_key\>\n\<next_value\>...
+
+- Error string if GET failed. Exit code is non-zero.
+
+##### JSON reply
+
+The JSON encoding of the [RPC message][etcdrpc] for a key-value pair for each fetched key-value.
+
+##### Protobuf reply
+
+The protobuf encoding of the [RPC message][etcdrpc] for a key-value pair for each fetched key-value.
+
+#### Examples
+
+``` bash
+./etcdctl get foo
+foo
+bar
+```
+
+#### Notes
+
+If any key or value contains non-printable characters or control characters, the output in text format (e.g. simple reply) might be ambiguous.
+Adding `--hex` to print key or value as hex encode string in text format can resolve this issue.
+
+### DEL [options] \<key\> [range_end]
+
+Removes the specified key or range of keys [key, range_end) if `range-end` is given.
+
+#### Options
+
+TODO: --prefix, --from
+
+#### Return value
+
+##### Simple reply
+
+- The number of keys that were removed in decimal if DEL executed correctly. Exit code is zero.
+
+- Error string if DEL failed. Exit code is non-zero.
+
+##### JSON reply
+
+The JSON encoding of the DeleteRange [RPC response][etcdrpc].
+
+##### Protobuf reply
+
+The protobuf encoding of the DeleteRange [RPC response][etcdrpc].
+
+#### Examples
+
+``` bash
+./etcdctl put foo bar
+OK
+./etcdctl del foo
+1
+./etcdctl range foo
+```
+
+### TXN [options]
+
+TXN reads multiple etcd requests from standard input and applies them as a single atomic transaction.
+A transaction consists of list of conditions, a list of requests to apply if all the conditions are true, and a list of requests to apply if any condition is false.
+
+#### Options
+
+- hex -- print out keys and values as hex encoded string
+
+- interactive -- input transaction with interactive prompting
+
+#### Input Format
+```ebnf
+<Txn> ::= <CMP>* "\n" <THEN> "\n" <ELSE> "\n"
+<CMP> ::= (<CMPCREATE>|<CMPMOD>|<CMPVAL>|<CMPVER>) "\n"
+<CMPOP> ::= "<" | "=" | ">"
+<CMPCREATE> := ("c"|"create")"("<KEY>")" <REVISION>
+<CMPMOD> ::= ("m"|"mod")"("<KEY>")" <CMPOP> <REVISION>
+<CMPVAL> ::= ("val"|"value")"("<KEY>")" <CMPOP> <VALUE>
+<CMPVER> ::= ("ver"|"version")"("<KEY>")" <CMPOP> <VERSION>
+<THEN> ::= <OP>*
+<ELSE> ::= <OP>*
+<OP> ::= ((see put, get, del etcdctl command syntax)) "\n"
+<KEY> ::= (%q formatted string)
+<VALUE> ::= (%q formatted string)
+<REVISION> ::= "\""[0-9]+"\""
+<VERSION> ::= "\""[0-9]+"\""
+```
+
+#### Return value
+
+##### Simple reply
+
+- SUCCESS if etcd processed the transaction success list, FAILURE if etcd processed the transaction failure list.
+
+- Simple reply for each command executed request list, each separated by a blank line.
+
+- Additional error string if TXN failed. Exit code is non-zero.
+
+##### JSON reply
+
+The JSON encoding of the Txn [RPC response][etcdrpc].
+
+##### Protobuf reply
+
+The protobuf encoding of the Txn [RPC response][etcdrpc].
+
+#### Examples
+
+txn in interactive mode:
+``` bash
+./etcdctl txn -i
+mod("key1") > "0"
+
+put key1 "overwrote-key1"
+
+put key1 "created-key1"
+put key2 "some extra key"
+
+FAILURE
+
+OK
+
+OK
+```
+
+txn in non-interactive mode:
+```
+./etcdctl txn <<<'mod("key1") > "0"
+
+put key1 "overwrote-key1"
+
+put key1 "created-key1"
+put key2 "some extra key"
+
+'
+FAILURE
+
+OK
+
+OK
+````
+
+### WATCH [options] [key or prefix]
+
+Watch watches events stream on keys or prefixes. The watch command runs until it encounters an error or is terminated by the user.
+
+#### Options
+
+- hex -- print out key and value as hex encode string
+
+- interactive -- begins an interactive watch session
+
+- prefix -- watch on a prefix if prefix is set.
+
+- rev -- the revision to start watching. Specifying a revision is useful for observing past events.
+
+#### Input Format
+
+Input is only accepted for interactive mode.
+
+```
+watch [options] <key or prefix>\n
+```
+
+#### Return value
+
+##### Simple reply
+
+- \<event\>\n\<key\>\n\<value\>\n\<event\>\n\<next_key\>\n\<next_value\>\n...
+
+- Additional error string if WATCH failed. Exit code is non-zero.
+
+##### JSON reply
+
+The JSON encoding of the [RPC message][storagerpc] for each received Event.
+
+##### Protobuf reply
+
+The protobuf encoding of the [RPC message][storagerpc] for each received Event.
+
+#### Examples
+
+##### Non-interactive
+
+``` bash
+./etcdctl watch foo
+PUT
+foo
+bar
+```
+
+##### Interactive
+
+``` bash
+./etcdctl watch -i
+watch foo
+watch foo
+PUT
+foo
+bar
+PUT
+foo
+bar
+```
+
+## Utility Commands
+
+### LOCK \<lockname\>
+
+LOCK acquires a distributed named mutex with a given name. Once the lock is acquired, it will be held until etcdctl is terminated.
+
+#### Return value
+
+- Once the lock is acquired, the result for the GET on the unique lock holder key is displayed.
+
+- LOCK returns a zero exit code only if it is terminated by a signal and can release the lock.
+
+#### Example
+```bash
+./etcdctl lock mylock
+mylock/1234534535445
+
+
+```
+
+### Notes
+
+The lease length of a lock defaults to 60 seconds. If LOCK is abnormally terminated, lock progress may be delayed
+by up to 60 seconds.
+
+
+### ELECT [options] \<election-name\> [proposal]
+
+ELECT participates on a named election. A node announces its candidacy in the election by providing
+a proposal value. If a node wishes to observe the election, ELECT listens for new leaders values.
+Whenever a leader is elected, its proposal is given as output.
+
+#### Options
+
+- listen -- observe the election
+
+#### Return value
+
+- If a candidate, ELECT displays the GET on the leader key once the node is elected election.
+
+- If observing, ELECT streams the result for a GET on the leader key for the current election and all future elections.
+
+- ELECT returns a zero exit code only if it is terminated by a signal and can revoke its candidacy or leadership, if any.
+
+#### Example
+```bash
+./etcdctl elect myelection foo
+myelection/1456952310051373265
+foo
+
+```
+
+### Notes
+
+The lease length of a leader defaults to 60 seconds. If a candidate is abnormally terminated, election
+progress may be delayed by up to 60 seconds.
+
+
+### MAKE-MIRROR [options] \<destination\>
+
+[make-mirror][mirror] mirrors a key prefix in an etcd cluster to a destination etcd cluster.
+
+#### Options
+
+- dest-cacert -- TLS certificate authority file for destination cluster
+
+- dest-cert -- TLS certificate file for destination cluster
+
+- dest-key -- TLS key file for destination cluster
+
+- prefix -- The key-value prefix to mirror
+
+#### Return value
+
+Simple reply
+
+- The approximate total number of keys transferred to the destination cluster, updated every 30 seconds.
+
+- Error string if mirroring failed. Exit code is non-zero.
+
+#### Examples
+
+```
+./etcdctl make-mirror mirror.example.com:2379
+10
+18
+```
+
+[mirror]: ./doc/mirror_maker.md
+
+
+## Notes
+
+- JSON encoding for keys and values uses base64 since they are byte strings.
+
+
+[etcdrpc]: ../etcdserver/etcdserverpb/rpc.proto
+[storagerpc]: ../storage/storagepb/kv.proto
+
+## Compatibility Support
+
+etcdctl is still in its early stage. We try out best to ensure fully compatible releases, however we might break compatibility to fix bugs or improve commands. If we intend to release a version of etcdctl with backward incompatibilities, we will provide notice prior to release and have instructions on how to upgrade.
+
+### Input Compatibility
+
+Input includes the command name, its flags, and its arguments. We ensure backward compatibility of the input of normal commands in non-interactive mode.
+
+### Output Compatibility
+
+Output includes output from etcdctl and its exit code. etcdctl provides `simple` output format by default.
+We ensure compatibility for the `simple` output format of normal commands in non-interactive mode. Currently, we do not ensure
+backward compatibility for `JSON` format and the format in non-interactive mode. Currently, we do not ensure backward compatibility of utility commands.
+
+### TODO: compatibility with etcd server
diff --git a/etcdctl/command/auth_commands.go b/etcdctl/command/auth_commands.go
deleted file mode 100644
index bb53c4f..0000000
--- a/etcdctl/command/auth_commands.go
+++ /dev/null
@@ -1,88 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"os"
-	"strings"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-func NewAuthCommands() cli.Command {
-	return cli.Command{
-		Name:  "auth",
-		Usage: "overall auth controls",
-		Subcommands: []cli.Command{
-			{
-				Name:      "enable",
-				Usage:     "enable auth access controls",
-				ArgsUsage: " ",
-				Action:    actionAuthEnable,
-			},
-			{
-				Name:      "disable",
-				Usage:     "disable auth access controls",
-				ArgsUsage: " ",
-				Action:    actionAuthDisable,
-			},
-		},
-	}
-}
-
-func actionAuthEnable(c *cli.Context) {
-	authEnableDisable(c, true)
-}
-
-func actionAuthDisable(c *cli.Context) {
-	authEnableDisable(c, false)
-}
-
-func mustNewAuthAPI(c *cli.Context) client.AuthAPI {
-	hc := mustNewClient(c)
-
-	if c.GlobalBool("debug") {
-		fmt.Fprintf(os.Stderr, "Cluster-Endpoints: %s\n", strings.Join(hc.Endpoints(), ", "))
-	}
-
-	return client.NewAuthAPI(hc)
-}
-
-func authEnableDisable(c *cli.Context, enable bool) {
-	if len(c.Args()) != 0 {
-		fmt.Fprintln(os.Stderr, "No arguments accepted")
-		os.Exit(1)
-	}
-	s := mustNewAuthAPI(c)
-	ctx, cancel := contextWithTotalTimeout(c)
-	var err error
-	if enable {
-		err = s.Enable(ctx)
-	} else {
-		err = s.Disable(ctx)
-	}
-	cancel()
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-	if enable {
-		fmt.Println("Authentication Enabled")
-	} else {
-		fmt.Println("Authentication Disabled")
-	}
-}
diff --git a/etcdctl/command/backup_command.go b/etcdctl/command/backup_command.go
deleted file mode 100644
index c4ee61d..0000000
--- a/etcdctl/command/backup_command.go
+++ /dev/null
@@ -1,101 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"log"
-	"os"
-	"path"
-	"time"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/etcdserver/etcdserverpb"
-	"github.com/coreos/etcd/pkg/idutil"
-	"github.com/coreos/etcd/pkg/pbutil"
-	"github.com/coreos/etcd/snap"
-	"github.com/coreos/etcd/wal"
-	"github.com/coreos/etcd/wal/walpb"
-)
-
-func NewBackupCommand() cli.Command {
-	return cli.Command{
-		Name:      "backup",
-		Usage:     "backup an etcd directory",
-		ArgsUsage: " ",
-		Flags: []cli.Flag{
-			cli.StringFlag{Name: "data-dir", Value: "", Usage: "Path to the etcd data dir"},
-			cli.StringFlag{Name: "backup-dir", Value: "", Usage: "Path to the backup dir"},
-		},
-		Action: handleBackup,
-	}
-}
-
-// handleBackup handles a request that intends to do a backup.
-func handleBackup(c *cli.Context) {
-	srcSnap := path.Join(c.String("data-dir"), "member", "snap")
-	destSnap := path.Join(c.String("backup-dir"), "member", "snap")
-	srcWAL := path.Join(c.String("data-dir"), "member", "wal")
-	destWAL := path.Join(c.String("backup-dir"), "member", "wal")
-
-	if err := os.MkdirAll(destSnap, 0700); err != nil {
-		log.Fatalf("failed creating backup snapshot dir %v: %v", destSnap, err)
-	}
-	ss := snap.New(srcSnap)
-	snapshot, err := ss.Load()
-	if err != nil && err != snap.ErrNoSnapshot {
-		log.Fatal(err)
-	}
-	var walsnap walpb.Snapshot
-	if snapshot != nil {
-		walsnap.Index, walsnap.Term = snapshot.Metadata.Index, snapshot.Metadata.Term
-		newss := snap.New(destSnap)
-		if err = newss.SaveSnap(*snapshot); err != nil {
-			log.Fatal(err)
-		}
-	}
-
-	w, err := wal.OpenForRead(srcWAL, walsnap)
-	if err != nil {
-		log.Fatal(err)
-	}
-	defer w.Close()
-	wmetadata, state, ents, err := w.ReadAll()
-	switch err {
-	case nil:
-	case wal.ErrSnapshotNotFound:
-		fmt.Printf("Failed to find the match snapshot record %+v in wal %v.", walsnap, srcWAL)
-		fmt.Printf("etcdctl will add it back. Start auto fixing...")
-	default:
-		log.Fatal(err)
-	}
-	var metadata etcdserverpb.Metadata
-	pbutil.MustUnmarshal(&metadata, wmetadata)
-	idgen := idutil.NewGenerator(0, time.Now())
-	metadata.NodeID = idgen.Next()
-	metadata.ClusterID = idgen.Next()
-
-	neww, err := wal.Create(destWAL, pbutil.MustMarshal(&metadata))
-	if err != nil {
-		log.Fatal(err)
-	}
-	defer neww.Close()
-	if err := neww.Save(state, ents); err != nil {
-		log.Fatal(err)
-	}
-	if err := neww.SaveSnapshot(walsnap); err != nil {
-		log.Fatal(err)
-	}
-}
diff --git a/etcdctl/command/cluster_health.go b/etcdctl/command/cluster_health.go
deleted file mode 100644
index 0a3e4d6..0000000
--- a/etcdctl/command/cluster_health.go
+++ /dev/null
@@ -1,136 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"encoding/json"
-	"fmt"
-	"io/ioutil"
-	"net/http"
-	"os"
-	"os/signal"
-	"time"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-	"golang.org/x/net/context"
-)
-
-func NewClusterHealthCommand() cli.Command {
-	return cli.Command{
-		Name:      "cluster-health",
-		Usage:     "check the health of the etcd cluster",
-		ArgsUsage: " ",
-		Flags: []cli.Flag{
-			cli.BoolFlag{Name: "forever", Usage: "forever check the health every 10 second until CTRL+C"},
-		},
-		Action: handleClusterHealth,
-	}
-}
-
-func handleClusterHealth(c *cli.Context) {
-	forever := c.Bool("forever")
-	if forever {
-		sigch := make(chan os.Signal, 1)
-		signal.Notify(sigch, os.Interrupt)
-
-		go func() {
-			<-sigch
-			os.Exit(0)
-		}()
-	}
-
-	tr, err := getTransport(c)
-	if err != nil {
-		handleError(ExitServerError, err)
-	}
-
-	hc := http.Client{
-		Transport: tr,
-	}
-
-	cln := mustNewClientNoSync(c)
-	mi := client.NewMembersAPI(cln)
-	ms, err := mi.List(context.TODO())
-	if err != nil {
-		fmt.Println("cluster may be unhealthy: failed to list members")
-		handleError(ExitServerError, err)
-	}
-
-	for {
-		health := false
-		for _, m := range ms {
-			if len(m.ClientURLs) == 0 {
-				fmt.Printf("member %s is unreachable: no available published client urls\n", m.ID)
-				continue
-			}
-
-			checked := false
-			for _, url := range m.ClientURLs {
-				resp, err := hc.Get(url + "/health")
-				if err != nil {
-					fmt.Printf("failed to check the health of member %s on %s: %v\n", m.ID, url, err)
-					continue
-				}
-
-				result := struct{ Health string }{}
-				nresult := struct{ Health bool }{}
-				bytes, err := ioutil.ReadAll(resp.Body)
-				if err != nil {
-					fmt.Printf("failed to check the health of member %s on %s: %v\n", m.ID, url, err)
-					continue
-				}
-				resp.Body.Close()
-
-				err = json.Unmarshal(bytes, &result)
-				if err != nil {
-					err = json.Unmarshal(bytes, &nresult)
-				}
-				if err != nil {
-					fmt.Printf("failed to check the health of member %s on %s: %v\n", m.ID, url, err)
-					continue
-				}
-
-				checked = true
-				if result.Health == "true" || nresult.Health == true {
-					health = true
-					fmt.Printf("member %s is healthy: got healthy result from %s\n", m.ID, url)
-				} else {
-					fmt.Printf("member %s is unhealthy: got unhealthy result from %s\n", m.ID, url)
-				}
-				break
-			}
-			if !checked {
-				fmt.Printf("member %s is unreachable: %v are all unreachable\n", m.ID, m.ClientURLs)
-			}
-		}
-		if health {
-			fmt.Println("cluster is healthy")
-		} else {
-			fmt.Println("cluster is unhealthy")
-		}
-
-		if !forever {
-			if health {
-				os.Exit(ExitSuccess)
-			} else {
-				os.Exit(ExitClusterNotHealthy)
-			}
-		}
-
-		fmt.Printf("\nnext check after 10 second...\n\n")
-		time.Sleep(10 * time.Second)
-	}
-}
diff --git a/etcdctl/command/doc.go b/etcdctl/command/doc.go
deleted file mode 100644
index 7e95e65..0000000
--- a/etcdctl/command/doc.go
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Package command is a set of libraries for etcdctl commands.
-package command
diff --git a/etcdctl/command/error.go b/etcdctl/command/error.go
deleted file mode 100644
index 83a80b2..0000000
--- a/etcdctl/command/error.go
+++ /dev/null
@@ -1,39 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"os"
-
-	"github.com/coreos/etcd/client"
-)
-
-const (
-	ExitSuccess = iota
-	ExitBadArgs
-	ExitBadConnection
-	ExitBadAuth
-	ExitServerError
-	ExitClusterNotHealthy
-)
-
-func handleError(code int, err error) {
-	fmt.Fprintln(os.Stderr, "Error: ", err)
-	if cerr, ok := err.(*client.ClusterError); ok {
-		fmt.Fprintln(os.Stderr, cerr.Detail())
-	}
-	os.Exit(code)
-}
diff --git a/etcdctl/command/exec_watch_command.go b/etcdctl/command/exec_watch_command.go
deleted file mode 100644
index ed6fec7..0000000
--- a/etcdctl/command/exec_watch_command.go
+++ /dev/null
@@ -1,127 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"fmt"
-	"os"
-	"os/exec"
-	"os/signal"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-	"golang.org/x/net/context"
-)
-
-// NewExecWatchCommand returns the CLI command for "exec-watch".
-func NewExecWatchCommand() cli.Command {
-	return cli.Command{
-		Name:      "exec-watch",
-		Usage:     "watch a key for changes and exec an executable",
-		ArgsUsage: "<key> <command> [args...]",
-		Flags: []cli.Flag{
-			cli.IntFlag{Name: "after-index", Value: 0, Usage: "watch after the given index"},
-			cli.BoolFlag{Name: "recursive", Usage: "watch all values for key and child keys"},
-		},
-		Action: func(c *cli.Context) {
-			execWatchCommandFunc(c, mustNewKeyAPI(c))
-		},
-	}
-}
-
-// execWatchCommandFunc executes the "exec-watch" command.
-func execWatchCommandFunc(c *cli.Context, ki client.KeysAPI) {
-	args := c.Args()
-	argslen := len(args)
-
-	if argslen < 2 {
-		handleError(ExitBadArgs, errors.New("key and command to exec required"))
-	}
-
-	var (
-		key     string
-		cmdArgs []string
-	)
-
-	foundSep := false
-	for i := range args {
-		if args[i] == "--" && i != 0 {
-			foundSep = true
-			break
-		}
-	}
-
-	if foundSep {
-		key = args[0]
-		cmdArgs = args[2:]
-	} else {
-		// If no flag is parsed, the order of key and cmdArgs will be switched and
-		// args will not contain `--`.
-		key = args[argslen-1]
-		cmdArgs = args[:argslen-1]
-	}
-
-	index := 0
-	if c.Int("after-index") != 0 {
-		index = c.Int("after-index") + 1
-	}
-
-	recursive := c.Bool("recursive")
-
-	sigch := make(chan os.Signal, 1)
-	signal.Notify(sigch, os.Interrupt)
-
-	go func() {
-		<-sigch
-		os.Exit(0)
-	}()
-
-	w := ki.Watcher(key, &client.WatcherOptions{AfterIndex: uint64(index), Recursive: recursive})
-
-	for {
-		resp, err := w.Next(context.TODO())
-		if err != nil {
-			handleError(ExitServerError, err)
-		}
-		if resp.Node.Dir {
-			fmt.Fprintf(os.Stderr, "Ignored dir %s change", resp.Node.Key)
-			continue
-		}
-
-		cmd := exec.Command(cmdArgs[0], cmdArgs[1:]...)
-		cmd.Env = environResponse(resp, os.Environ())
-
-		cmd.Stdout = os.Stdout
-		cmd.Stderr = os.Stderr
-
-		go func() {
-			err := cmd.Start()
-			if err != nil {
-				fmt.Fprintf(os.Stderr, err.Error())
-				os.Exit(1)
-			}
-			cmd.Wait()
-		}()
-	}
-}
-
-func environResponse(resp *client.Response, env []string) []string {
-	env = append(env, "ETCD_WATCH_ACTION="+resp.Action)
-	env = append(env, "ETCD_WATCH_MODIFIED_INDEX="+fmt.Sprintf("%d", resp.Node.ModifiedIndex))
-	env = append(env, "ETCD_WATCH_KEY="+resp.Node.Key)
-	env = append(env, "ETCD_WATCH_VALUE="+resp.Node.Value)
-	return env
-}
diff --git a/etcdctl/command/format.go b/etcdctl/command/format.go
deleted file mode 100644
index 55661e8..0000000
--- a/etcdctl/command/format.go
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"encoding/json"
-	"fmt"
-	"os"
-
-	"github.com/coreos/etcd/client"
-)
-
-// printResponseKey only supports to print key correctly.
-func printResponseKey(resp *client.Response, format string) {
-	// Format the result.
-	switch format {
-	case "simple":
-		if resp.Action != "delete" {
-			fmt.Println(resp.Node.Value)
-		} else {
-			fmt.Println("PrevNode.Value:", resp.PrevNode.Value)
-		}
-	case "extended":
-		// Extended prints in a rfc2822 style format
-		fmt.Println("Key:", resp.Node.Key)
-		fmt.Println("Created-Index:", resp.Node.CreatedIndex)
-		fmt.Println("Modified-Index:", resp.Node.ModifiedIndex)
-
-		if resp.PrevNode != nil {
-			fmt.Println("PrevNode.Value:", resp.PrevNode.Value)
-		}
-
-		fmt.Println("TTL:", resp.Node.TTL)
-		fmt.Println("Index:", resp.Index)
-		if resp.Action != "delete" {
-			fmt.Println("")
-			fmt.Println(resp.Node.Value)
-		}
-	case "json":
-		b, err := json.Marshal(resp)
-		if err != nil {
-			panic(err)
-		}
-		fmt.Println(string(b))
-	default:
-		fmt.Fprintln(os.Stderr, "Unsupported output format:", format)
-	}
-}
diff --git a/etcdctl/command/get_command.go b/etcdctl/command/get_command.go
deleted file mode 100644
index 6835e86..0000000
--- a/etcdctl/command/get_command.go
+++ /dev/null
@@ -1,65 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"fmt"
-	"os"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-// NewGetCommand returns the CLI command for "get".
-func NewGetCommand() cli.Command {
-	return cli.Command{
-		Name:      "get",
-		Usage:     "retrieve the value of a key",
-		ArgsUsage: "<key>",
-		Flags: []cli.Flag{
-			cli.BoolFlag{Name: "sort", Usage: "returns result in sorted order"},
-			cli.BoolFlag{Name: "quorum", Usage: "require quorum for get request"},
-		},
-		Action: func(c *cli.Context) {
-			getCommandFunc(c, mustNewKeyAPI(c))
-		},
-	}
-}
-
-// getCommandFunc executes the "get" command.
-func getCommandFunc(c *cli.Context, ki client.KeysAPI) {
-	if len(c.Args()) == 0 {
-		handleError(ExitBadArgs, errors.New("key required"))
-	}
-
-	key := c.Args()[0]
-	sorted := c.Bool("sort")
-	quorum := c.Bool("quorum")
-
-	ctx, cancel := contextWithTotalTimeout(c)
-	resp, err := ki.Get(ctx, key, &client.GetOptions{Sort: sorted, Quorum: quorum})
-	cancel()
-	if err != nil {
-		handleError(ExitServerError, err)
-	}
-
-	if resp.Node.Dir {
-		fmt.Fprintln(os.Stderr, fmt.Sprintf("%s: is a directory", resp.Node.Key))
-		os.Exit(1)
-	}
-
-	printResponseKey(resp, c.GlobalString("output"))
-}
diff --git a/etcdctl/command/import_snap_command.go b/etcdctl/command/import_snap_command.go
deleted file mode 100644
index 016d635..0000000
--- a/etcdctl/command/import_snap_command.go
+++ /dev/null
@@ -1,119 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"io/ioutil"
-	"log"
-	"os"
-	"sync"
-	"time"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-	"github.com/coreos/etcd/store"
-	"golang.org/x/net/context"
-)
-
-type set struct {
-	key   string
-	value string
-	ttl   int64
-}
-
-func NewImportSnapCommand() cli.Command {
-	return cli.Command{
-		Name:      "import",
-		Usage:     "import a snapshot to a cluster",
-		ArgsUsage: " ",
-		Flags: []cli.Flag{
-			cli.StringFlag{Name: "snap", Value: "", Usage: "Path to the valid etcd 0.4.x snapshot."},
-			cli.StringSliceFlag{Name: "hidden", Value: new(cli.StringSlice), Usage: "Hidden key spaces to import from snapshot"},
-			cli.IntFlag{Name: "c", Value: 10, Usage: "Number of concurrent clients to import the data"},
-		},
-		Action: handleImportSnap,
-	}
-}
-
-func handleImportSnap(c *cli.Context) {
-	d, err := ioutil.ReadFile(c.String("snap"))
-	if err != nil {
-		if c.String("snap") == "" {
-			fmt.Printf("no snapshot file provided (use --snap)\n")
-		} else {
-			fmt.Printf("cannot read snapshot file %s\n", c.String("snap"))
-		}
-		os.Exit(1)
-	}
-
-	st := store.New()
-	err = st.Recovery(d)
-
-	wg := &sync.WaitGroup{}
-	setc := make(chan set)
-	concurrent := c.Int("c")
-	fmt.Printf("starting to import snapshot %s with %d clients\n", c.String("snap"), concurrent)
-	for i := 0; i < concurrent; i++ {
-		go runSet(mustNewKeyAPI(c), setc, wg)
-	}
-
-	all, err := st.Get("/", true, true)
-	if err != nil {
-		handleError(ExitServerError, err)
-	}
-	n := copyKeys(all.Node, setc)
-
-	hiddens := c.StringSlice("hidden")
-	for _, h := range hiddens {
-		allh, err := st.Get(h, true, true)
-		if err != nil {
-			handleError(ExitServerError, err)
-		}
-		n += copyKeys(allh.Node, setc)
-	}
-	close(setc)
-	wg.Wait()
-	fmt.Printf("finished importing %d keys\n", n)
-}
-
-func copyKeys(n *store.NodeExtern, setc chan set) int {
-	num := 0
-	if !n.Dir {
-		setc <- set{n.Key, *n.Value, n.TTL}
-		return 1
-	}
-	log.Println("entering dir:", n.Key)
-	for _, nn := range n.Nodes {
-		sub := copyKeys(nn, setc)
-		num += sub
-	}
-	return num
-}
-
-func runSet(ki client.KeysAPI, setc chan set, wg *sync.WaitGroup) {
-	for s := range setc {
-		log.Println("copying key:", s.key)
-		if s.ttl != 0 && s.ttl < 300 {
-			log.Printf("extending key %s's ttl to 300 seconds", s.key)
-			s.ttl = 5 * 60
-		}
-		_, err := ki.Set(context.TODO(), s.key, s.value, &client.SetOptions{TTL: time.Duration(s.ttl) * time.Second})
-		if err != nil {
-			log.Fatalf("failed to copy key: %v\n", err)
-		}
-	}
-	wg.Done()
-}
diff --git a/etcdctl/command/ls_command.go b/etcdctl/command/ls_command.go
deleted file mode 100644
index b90db4a..0000000
--- a/etcdctl/command/ls_command.go
+++ /dev/null
@@ -1,84 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-func NewLsCommand() cli.Command {
-	return cli.Command{
-		Name:      "ls",
-		Usage:     "retrieve a directory",
-		ArgsUsage: "[key]",
-		Flags: []cli.Flag{
-			cli.BoolFlag{Name: "sort", Usage: "returns result in sorted order"},
-			cli.BoolFlag{Name: "recursive", Usage: "returns all key names recursively for the given path"},
-			cli.BoolFlag{Name: "p", Usage: "append slash (/) to directories"},
-			cli.BoolFlag{Name: "quorum", Usage: "require quorum for get request"},
-		},
-		Action: func(c *cli.Context) {
-			lsCommandFunc(c, mustNewKeyAPI(c))
-		},
-	}
-}
-
-// lsCommandFunc executes the "ls" command.
-func lsCommandFunc(c *cli.Context, ki client.KeysAPI) {
-	key := "/"
-	if len(c.Args()) != 0 {
-		key = c.Args()[0]
-	}
-
-	sort := c.Bool("sort")
-	recursive := c.Bool("recursive")
-	quorum := c.Bool("quorum")
-
-	ctx, cancel := contextWithTotalTimeout(c)
-	resp, err := ki.Get(ctx, key, &client.GetOptions{Sort: sort, Recursive: recursive, Quorum: quorum})
-	cancel()
-	if err != nil {
-		handleError(ExitServerError, err)
-	}
-
-	printLs(c, resp)
-}
-
-// printLs writes a response out in a manner similar to the `ls` command in unix.
-// Non-empty directories list their contents and files list their name.
-func printLs(c *cli.Context, resp *client.Response) {
-	if !resp.Node.Dir {
-		fmt.Println(resp.Node.Key)
-	}
-	for _, node := range resp.Node.Nodes {
-		rPrint(c, node)
-	}
-}
-
-// rPrint recursively prints out the nodes in the node structure.
-func rPrint(c *cli.Context, n *client.Node) {
-	if n.Dir && c.Bool("p") {
-		fmt.Println(fmt.Sprintf("%v/", n.Key))
-	} else {
-		fmt.Println(n.Key)
-	}
-
-	for _, node := range n.Nodes {
-		rPrint(c, node)
-	}
-}
diff --git a/etcdctl/command/member_commands.go b/etcdctl/command/member_commands.go
deleted file mode 100644
index 5c9ad6d..0000000
--- a/etcdctl/command/member_commands.go
+++ /dev/null
@@ -1,202 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"os"
-	"strings"
-
-	"github.com/codegangsta/cli"
-)
-
-func NewMemberCommand() cli.Command {
-	return cli.Command{
-		Name:  "member",
-		Usage: "member add, remove and list subcommands",
-		Subcommands: []cli.Command{
-			{
-				Name:      "list",
-				Usage:     "enumerate existing cluster members",
-				ArgsUsage: " ",
-				Action:    actionMemberList,
-			},
-			{
-				Name:      "add",
-				Usage:     "add a new member to the etcd cluster",
-				ArgsUsage: "<name> <peerURL>",
-				Action:    actionMemberAdd,
-			},
-			{
-				Name:      "remove",
-				Usage:     "remove an existing member from the etcd cluster",
-				ArgsUsage: "<memberID>",
-				Action:    actionMemberRemove,
-			},
-			{
-				Name:      "update",
-				Usage:     "update an existing member in the etcd cluster",
-				ArgsUsage: "<memberID> <peerURLs>",
-				Action:    actionMemberUpdate,
-			},
-		},
-	}
-}
-
-func actionMemberList(c *cli.Context) {
-	if len(c.Args()) != 0 {
-		fmt.Fprintln(os.Stderr, "No arguments accepted")
-		os.Exit(1)
-	}
-	mAPI := mustNewMembersAPI(c)
-	ctx, cancel := contextWithTotalTimeout(c)
-	defer cancel()
-
-	members, err := mAPI.List(ctx)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-	leader, err := mAPI.Leader(ctx)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, "Failed to get leader: ", err)
-		os.Exit(1)
-	}
-
-	for _, m := range members {
-		isLeader := false
-		if m.ID == leader.ID {
-			isLeader = true
-		}
-		if len(m.Name) == 0 {
-			fmt.Printf("%s[unstarted]: peerURLs=%s\n", m.ID, strings.Join(m.PeerURLs, ","))
-		} else {
-			fmt.Printf("%s: name=%s peerURLs=%s clientURLs=%s isLeader=%v\n", m.ID, m.Name, strings.Join(m.PeerURLs, ","), strings.Join(m.ClientURLs, ","), isLeader)
-		}
-	}
-}
-
-func actionMemberAdd(c *cli.Context) {
-	args := c.Args()
-	if len(args) != 2 {
-		fmt.Fprintln(os.Stderr, "Provide a name and a single member peerURL")
-		os.Exit(1)
-	}
-
-	mAPI := mustNewMembersAPI(c)
-
-	url := args[1]
-	ctx, cancel := contextWithTotalTimeout(c)
-	defer cancel()
-
-	m, err := mAPI.Add(ctx, url)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	newID := m.ID
-	newName := args[0]
-	fmt.Printf("Added member named %s with ID %s to cluster\n", newName, newID)
-
-	members, err := mAPI.List(ctx)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	conf := []string{}
-	for _, memb := range members {
-		for _, u := range memb.PeerURLs {
-			n := memb.Name
-			if memb.ID == newID {
-				n = newName
-			}
-			conf = append(conf, fmt.Sprintf("%s=%s", n, u))
-		}
-	}
-
-	fmt.Print("\n")
-	fmt.Printf("ETCD_NAME=%q\n", newName)
-	fmt.Printf("ETCD_INITIAL_CLUSTER=%q\n", strings.Join(conf, ","))
-	fmt.Printf("ETCD_INITIAL_CLUSTER_STATE=\"existing\"\n")
-}
-
-func actionMemberRemove(c *cli.Context) {
-	args := c.Args()
-	if len(args) != 1 {
-		fmt.Fprintln(os.Stderr, "Provide a single member ID")
-		os.Exit(1)
-	}
-	removalID := args[0]
-
-	mAPI := mustNewMembersAPI(c)
-
-	ctx, cancel := contextWithTotalTimeout(c)
-	defer cancel()
-	// Get the list of members.
-	members, err := mAPI.List(ctx)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, "Error while verifying ID against known members:", err.Error())
-		os.Exit(1)
-	}
-	// Sanity check the input.
-	foundID := false
-	for _, m := range members {
-		if m.ID == removalID {
-			foundID = true
-		}
-		if m.Name == removalID {
-			// Note that, so long as it's not ambiguous, we *could* do the right thing by name here.
-			fmt.Fprintf(os.Stderr, "Found a member named %s; if this is correct, please use its ID, eg:\n\tetcdctl member remove %s\n", m.Name, m.ID)
-			fmt.Fprintf(os.Stderr, "For more details, read the documentation at https://github.com/coreos/etcd/blob/master/Documentation/runtime-configuration.md#remove-a-member\n\n")
-		}
-	}
-	if !foundID {
-		fmt.Fprintf(os.Stderr, "Couldn't find a member in the cluster with an ID of %s.\n", removalID)
-		os.Exit(1)
-	}
-
-	// Actually attempt to remove the member.
-	err = mAPI.Remove(ctx, removalID)
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "Received an error trying to remove member %s: %s", removalID, err.Error())
-		os.Exit(1)
-	}
-
-	fmt.Printf("Removed member %s from cluster\n", removalID)
-}
-
-func actionMemberUpdate(c *cli.Context) {
-	args := c.Args()
-	if len(args) != 2 {
-		fmt.Fprintln(os.Stderr, "Provide an ID and a list of comma separated peerURL (0xabcd http://example.com,http://example1.com)")
-		os.Exit(1)
-	}
-
-	mAPI := mustNewMembersAPI(c)
-
-	mid := args[0]
-	urls := args[1]
-	ctx, cancel := contextWithTotalTimeout(c)
-	err := mAPI.Update(ctx, mid, strings.Split(urls, ","))
-	cancel()
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	fmt.Printf("Updated member with ID %s in cluster\n", mid)
-}
diff --git a/etcdctl/command/mk_command.go b/etcdctl/command/mk_command.go
deleted file mode 100644
index 5e86b07..0000000
--- a/etcdctl/command/mk_command.go
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"os"
-	"time"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-// NewMakeCommand returns the CLI command for "mk".
-func NewMakeCommand() cli.Command {
-	return cli.Command{
-		Name:      "mk",
-		Usage:     "make a new key with a given value",
-		ArgsUsage: "<key> <value>",
-		Flags: []cli.Flag{
-			cli.BoolFlag{Name: "in-order", Usage: "create in-order key under directory <key>"},
-			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
-		},
-		Action: func(c *cli.Context) {
-			mkCommandFunc(c, mustNewKeyAPI(c))
-		},
-	}
-}
-
-// mkCommandFunc executes the "mk" command.
-func mkCommandFunc(c *cli.Context, ki client.KeysAPI) {
-	if len(c.Args()) == 0 {
-		handleError(ExitBadArgs, errors.New("key required"))
-	}
-	key := c.Args()[0]
-	value, err := argOrStdin(c.Args(), os.Stdin, 1)
-	if err != nil {
-		handleError(ExitBadArgs, errors.New("value required"))
-	}
-
-	ttl := c.Int("ttl")
-	inorder := c.Bool("in-order")
-
-	var resp *client.Response
-	ctx, cancel := contextWithTotalTimeout(c)
-	if !inorder {
-		// Since PrevNoExist means that the Node must not exist previously,
-		// this Set method always creates a new key. Therefore, mk command
-		// succeeds only if the key did not previously exist, and the command
-		// prevents one from overwriting values accidentally.
-		resp, err = ki.Set(ctx, key, value, &client.SetOptions{TTL: time.Duration(ttl) * time.Second, PrevExist: client.PrevNoExist})
-	} else {
-		// If in-order flag is specified then create an inorder key under
-		// the directory identified by the key argument.
-		resp, err = ki.CreateInOrder(ctx, key, value, &client.CreateInOrderOptions{TTL: time.Duration(ttl) * time.Second})
-	}
-	cancel()
-	if err != nil {
-		handleError(ExitServerError, err)
-	}
-
-	printResponseKey(resp, c.GlobalString("output"))
-}
diff --git a/etcdctl/command/mkdir_command.go b/etcdctl/command/mkdir_command.go
deleted file mode 100644
index 16e5a29..0000000
--- a/etcdctl/command/mkdir_command.go
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"time"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-// NewMakeDirCommand returns the CLI command for "mkdir".
-func NewMakeDirCommand() cli.Command {
-	return cli.Command{
-		Name:      "mkdir",
-		Usage:     "make a new directory",
-		ArgsUsage: "<key>",
-		Flags: []cli.Flag{
-			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
-		},
-		Action: func(c *cli.Context) {
-			mkdirCommandFunc(c, mustNewKeyAPI(c), client.PrevNoExist)
-		},
-	}
-}
-
-// mkdirCommandFunc executes the "mkdir" command.
-func mkdirCommandFunc(c *cli.Context, ki client.KeysAPI, prevExist client.PrevExistType) {
-	if len(c.Args()) == 0 {
-		handleError(ExitBadArgs, errors.New("key required"))
-	}
-
-	key := c.Args()[0]
-	ttl := c.Int("ttl")
-
-	ctx, cancel := contextWithTotalTimeout(c)
-	_, err := ki.Set(ctx, key, "", &client.SetOptions{TTL: time.Duration(ttl) * time.Second, Dir: true, PrevExist: prevExist})
-	cancel()
-	if err != nil {
-		handleError(ExitServerError, err)
-	}
-}
diff --git a/etcdctl/command/rm_command.go b/etcdctl/command/rm_command.go
deleted file mode 100644
index 2f39cbe..0000000
--- a/etcdctl/command/rm_command.go
+++ /dev/null
@@ -1,63 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-// NewRemoveCommand returns the CLI command for "rm".
-func NewRemoveCommand() cli.Command {
-	return cli.Command{
-		Name:      "rm",
-		Usage:     "remove a key or a directory",
-		ArgsUsage: "<key>",
-		Flags: []cli.Flag{
-			cli.BoolFlag{Name: "dir", Usage: "removes the key if it is an empty directory or a key-value pair"},
-			cli.BoolFlag{Name: "recursive", Usage: "removes the key and all child keys(if it is a directory)"},
-			cli.StringFlag{Name: "with-value", Value: "", Usage: "previous value"},
-			cli.IntFlag{Name: "with-index", Value: 0, Usage: "previous index"},
-		},
-		Action: func(c *cli.Context) {
-			rmCommandFunc(c, mustNewKeyAPI(c))
-		},
-	}
-}
-
-// rmCommandFunc executes the "rm" command.
-func rmCommandFunc(c *cli.Context, ki client.KeysAPI) {
-	if len(c.Args()) == 0 {
-		handleError(ExitBadArgs, errors.New("key required"))
-	}
-	key := c.Args()[0]
-	recursive := c.Bool("recursive")
-	dir := c.Bool("dir")
-	prevValue := c.String("with-value")
-	prevIndex := c.Int("with-index")
-
-	ctx, cancel := contextWithTotalTimeout(c)
-	resp, err := ki.Delete(ctx, key, &client.DeleteOptions{PrevIndex: uint64(prevIndex), PrevValue: prevValue, Dir: dir, Recursive: recursive})
-	cancel()
-	if err != nil {
-		handleError(ExitServerError, err)
-	}
-
-	if !resp.Node.Dir {
-		printResponseKey(resp, c.GlobalString("output"))
-	}
-}
diff --git a/etcdctl/command/rmdir_command.go b/etcdctl/command/rmdir_command.go
deleted file mode 100644
index b7b74b5..0000000
--- a/etcdctl/command/rmdir_command.go
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-// NewRemoveDirCommand returns the CLI command for "rmdir".
-func NewRemoveDirCommand() cli.Command {
-	return cli.Command{
-		Name:      "rmdir",
-		Usage:     "removes the key if it is an empty directory or a key-value pair",
-		ArgsUsage: "<key>",
-		Action: func(c *cli.Context) {
-			rmdirCommandFunc(c, mustNewKeyAPI(c))
-		},
-	}
-}
-
-// rmdirCommandFunc executes the "rmdir" command.
-func rmdirCommandFunc(c *cli.Context, ki client.KeysAPI) {
-	if len(c.Args()) == 0 {
-		handleError(ExitBadArgs, errors.New("key required"))
-	}
-	key := c.Args()[0]
-
-	ctx, cancel := contextWithTotalTimeout(c)
-	resp, err := ki.Delete(ctx, key, &client.DeleteOptions{Dir: true})
-	cancel()
-	if err != nil {
-		handleError(ExitServerError, err)
-	}
-
-	if !resp.Node.Dir {
-		printResponseKey(resp, c.GlobalString("output"))
-	}
-}
diff --git a/etcdctl/command/role_commands.go b/etcdctl/command/role_commands.go
deleted file mode 100644
index 633f1fb..0000000
--- a/etcdctl/command/role_commands.go
+++ /dev/null
@@ -1,248 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"os"
-	"reflect"
-	"strings"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-	"github.com/coreos/etcd/pkg/pathutil"
-)
-
-func NewRoleCommands() cli.Command {
-	return cli.Command{
-		Name:  "role",
-		Usage: "role add, grant and revoke subcommands",
-		Subcommands: []cli.Command{
-			{
-				Name:      "add",
-				Usage:     "add a new role for the etcd cluster",
-				ArgsUsage: "<role> ",
-				Action:    actionRoleAdd,
-			},
-			{
-				Name:      "get",
-				Usage:     "get details for a role",
-				ArgsUsage: "<role>",
-				Action:    actionRoleGet,
-			},
-			{
-				Name:      "list",
-				Usage:     "list all roles",
-				ArgsUsage: " ",
-				Action:    actionRoleList,
-			},
-			{
-				Name:      "remove",
-				Usage:     "remove a role from the etcd cluster",
-				ArgsUsage: "<role>",
-				Action:    actionRoleRemove,
-			},
-			{
-				Name:      "grant",
-				Usage:     "grant path matches to an etcd role",
-				ArgsUsage: "<role>",
-				Flags: []cli.Flag{
-					cli.StringFlag{Name: "path", Value: "", Usage: "Path granted for the role to access"},
-					cli.BoolFlag{Name: "read", Usage: "Grant read-only access"},
-					cli.BoolFlag{Name: "write", Usage: "Grant write-only access"},
-					cli.BoolFlag{Name: "readwrite", Usage: "Grant read-write access"},
-				},
-				Action: actionRoleGrant,
-			},
-			{
-				Name:      "revoke",
-				Usage:     "revoke path matches for an etcd role",
-				ArgsUsage: "<role>",
-				Flags: []cli.Flag{
-					cli.StringFlag{Name: "path", Value: "", Usage: "Path revoked for the role to access"},
-					cli.BoolFlag{Name: "read", Usage: "Revoke read access"},
-					cli.BoolFlag{Name: "write", Usage: "Revoke write access"},
-					cli.BoolFlag{Name: "readwrite", Usage: "Revoke read-write access"},
-				},
-				Action: actionRoleRevoke,
-			},
-		},
-	}
-}
-
-func mustNewAuthRoleAPI(c *cli.Context) client.AuthRoleAPI {
-	hc := mustNewClient(c)
-
-	if c.GlobalBool("debug") {
-		fmt.Fprintf(os.Stderr, "Cluster-Endpoints: %s\n", strings.Join(hc.Endpoints(), ", "))
-	}
-
-	return client.NewAuthRoleAPI(hc)
-}
-
-func actionRoleList(c *cli.Context) {
-	if len(c.Args()) != 0 {
-		fmt.Fprintln(os.Stderr, "No arguments accepted")
-		os.Exit(1)
-	}
-	r := mustNewAuthRoleAPI(c)
-	ctx, cancel := contextWithTotalTimeout(c)
-	roles, err := r.ListRoles(ctx)
-	cancel()
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	for _, role := range roles {
-		fmt.Printf("%s\n", role)
-	}
-}
-
-func actionRoleAdd(c *cli.Context) {
-	api, role := mustRoleAPIAndName(c)
-	ctx, cancel := contextWithTotalTimeout(c)
-	defer cancel()
-	currentRole, err := api.GetRole(ctx, role)
-	if currentRole != nil {
-		fmt.Fprintf(os.Stderr, "Role %s already exists\n", role)
-		os.Exit(1)
-	}
-
-	err = api.AddRole(ctx, role)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	fmt.Printf("Role %s created\n", role)
-}
-
-func actionRoleRemove(c *cli.Context) {
-	api, role := mustRoleAPIAndName(c)
-	ctx, cancel := contextWithTotalTimeout(c)
-	err := api.RemoveRole(ctx, role)
-	cancel()
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	fmt.Printf("Role %s removed\n", role)
-}
-
-func actionRoleGrant(c *cli.Context) {
-	roleGrantRevoke(c, true)
-}
-
-func actionRoleRevoke(c *cli.Context) {
-	roleGrantRevoke(c, false)
-}
-
-func roleGrantRevoke(c *cli.Context, grant bool) {
-	path := c.String("path")
-	if path == "" {
-		fmt.Fprintln(os.Stderr, "No path specified; please use `-path`")
-		os.Exit(1)
-	}
-	if pathutil.CanonicalURLPath(path) != path {
-		fmt.Fprintf(os.Stderr, "Not canonical path; please use `-path=%s`\n", pathutil.CanonicalURLPath(path))
-		os.Exit(1)
-	}
-
-	read := c.Bool("read")
-	write := c.Bool("write")
-	rw := c.Bool("readwrite")
-	permcount := 0
-	for _, v := range []bool{read, write, rw} {
-		if v {
-			permcount++
-		}
-	}
-	if permcount != 1 {
-		fmt.Fprintln(os.Stderr, "Please specify exactly one of -read, -write or -readwrite")
-		os.Exit(1)
-	}
-	var permType client.PermissionType
-	switch {
-	case read:
-		permType = client.ReadPermission
-	case write:
-		permType = client.WritePermission
-	case rw:
-		permType = client.ReadWritePermission
-	}
-
-	api, role := mustRoleAPIAndName(c)
-	ctx, cancel := contextWithTotalTimeout(c)
-	defer cancel()
-	currentRole, err := api.GetRole(ctx, role)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-	var newRole *client.Role
-	if grant {
-		newRole, err = api.GrantRoleKV(ctx, role, []string{path}, permType)
-	} else {
-		newRole, err = api.RevokeRoleKV(ctx, role, []string{path}, permType)
-	}
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-	if reflect.DeepEqual(newRole, currentRole) {
-		if grant {
-			fmt.Printf("Role unchanged; already granted")
-		} else {
-			fmt.Printf("Role unchanged; already revoked")
-		}
-	}
-
-	fmt.Printf("Role %s updated\n", role)
-}
-
-func actionRoleGet(c *cli.Context) {
-	api, rolename := mustRoleAPIAndName(c)
-
-	ctx, cancel := contextWithTotalTimeout(c)
-	role, err := api.GetRole(ctx, rolename)
-	cancel()
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-	fmt.Printf("Role: %s\n", role.Role)
-	fmt.Printf("KV Read:\n")
-	for _, v := range role.Permissions.KV.Read {
-		fmt.Printf("\t%s\n", v)
-	}
-	fmt.Printf("KV Write:\n")
-	for _, v := range role.Permissions.KV.Write {
-		fmt.Printf("\t%s\n", v)
-	}
-}
-
-func mustRoleAPIAndName(c *cli.Context) (client.AuthRoleAPI, string) {
-	args := c.Args()
-	if len(args) != 1 {
-		fmt.Fprintln(os.Stderr, "Please provide a role name")
-		os.Exit(1)
-	}
-
-	name := args[0]
-	api := mustNewAuthRoleAPI(c)
-	return api, name
-}
diff --git a/etcdctl/command/set_command.go b/etcdctl/command/set_command.go
deleted file mode 100644
index f0f71c4..0000000
--- a/etcdctl/command/set_command.go
+++ /dev/null
@@ -1,72 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"os"
-	"time"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-// NewSetCommand returns the CLI command for "set".
-func NewSetCommand() cli.Command {
-	return cli.Command{
-		Name:      "set",
-		Usage:     "set the value of a key",
-		ArgsUsage: "<key> <value>",
-		Description: `Set sets the value of a key.
-
-   When <value> begins with '-', <value> is interpreted as a flag.
-   Insert '--' for workaround:
-
-   $ set -- <key> <value>`,
-		Flags: []cli.Flag{
-			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
-			cli.StringFlag{Name: "swap-with-value", Value: "", Usage: "previous value"},
-			cli.IntFlag{Name: "swap-with-index", Value: 0, Usage: "previous index"},
-		},
-		Action: func(c *cli.Context) {
-			setCommandFunc(c, mustNewKeyAPI(c))
-		},
-	}
-}
-
-// setCommandFunc executes the "set" command.
-func setCommandFunc(c *cli.Context, ki client.KeysAPI) {
-	if len(c.Args()) == 0 {
-		handleError(ExitBadArgs, errors.New("key required"))
-	}
-	key := c.Args()[0]
-	value, err := argOrStdin(c.Args(), os.Stdin, 1)
-	if err != nil {
-		handleError(ExitBadArgs, errors.New("value required"))
-	}
-
-	ttl := c.Int("ttl")
-	prevValue := c.String("swap-with-value")
-	prevIndex := c.Int("swap-with-index")
-
-	ctx, cancel := contextWithTotalTimeout(c)
-	resp, err := ki.Set(ctx, key, value, &client.SetOptions{TTL: time.Duration(ttl) * time.Second, PrevIndex: uint64(prevIndex), PrevValue: prevValue})
-	cancel()
-	if err != nil {
-		handleError(ExitServerError, err)
-	}
-
-	printResponseKey(resp, c.GlobalString("output"))
-}
diff --git a/etcdctl/command/set_dir_command.go b/etcdctl/command/set_dir_command.go
deleted file mode 100644
index 04bd2c4..0000000
--- a/etcdctl/command/set_dir_command.go
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-// NewSetDirCommand returns the CLI command for "setDir".
-func NewSetDirCommand() cli.Command {
-	return cli.Command{
-		Name:      "setdir",
-		Usage:     "create a new directory or update an existing directory TTL",
-		ArgsUsage: "<key>",
-		Flags: []cli.Flag{
-			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
-		},
-		Action: func(c *cli.Context) {
-			mkdirCommandFunc(c, mustNewKeyAPI(c), client.PrevIgnore)
-		},
-	}
-}
diff --git a/etcdctl/command/update_command.go b/etcdctl/command/update_command.go
deleted file mode 100644
index b9a7c33..0000000
--- a/etcdctl/command/update_command.go
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"os"
-	"time"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-// NewUpdateCommand returns the CLI command for "update".
-func NewUpdateCommand() cli.Command {
-	return cli.Command{
-		Name:      "update",
-		Usage:     "update an existing key with a given value",
-		ArgsUsage: "<key> <value>",
-		Flags: []cli.Flag{
-			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
-		},
-		Action: func(c *cli.Context) {
-			updateCommandFunc(c, mustNewKeyAPI(c))
-		},
-	}
-}
-
-// updateCommandFunc executes the "update" command.
-func updateCommandFunc(c *cli.Context, ki client.KeysAPI) {
-	if len(c.Args()) == 0 {
-		handleError(ExitBadArgs, errors.New("key required"))
-	}
-	key := c.Args()[0]
-	value, err := argOrStdin(c.Args(), os.Stdin, 1)
-	if err != nil {
-		handleError(ExitBadArgs, errors.New("value required"))
-	}
-
-	ttl := c.Int("ttl")
-
-	ctx, cancel := contextWithTotalTimeout(c)
-	resp, err := ki.Set(ctx, key, value, &client.SetOptions{TTL: time.Duration(ttl) * time.Second, PrevExist: client.PrevExist})
-	cancel()
-	if err != nil {
-		handleError(ExitServerError, err)
-	}
-
-	printResponseKey(resp, c.GlobalString("output"))
-}
diff --git a/etcdctl/command/update_dir_command.go b/etcdctl/command/update_dir_command.go
deleted file mode 100644
index aff18f0..0000000
--- a/etcdctl/command/update_dir_command.go
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"time"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-// NewUpdateDirCommand returns the CLI command for "updatedir".
-func NewUpdateDirCommand() cli.Command {
-	return cli.Command{
-		Name:      "updatedir",
-		Usage:     "update an existing directory",
-		ArgsUsage: "<key> <value>",
-		Flags: []cli.Flag{
-			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
-		},
-		Action: func(c *cli.Context) {
-			updatedirCommandFunc(c, mustNewKeyAPI(c))
-		},
-	}
-}
-
-// updatedirCommandFunc executes the "updatedir" command.
-func updatedirCommandFunc(c *cli.Context, ki client.KeysAPI) {
-	if len(c.Args()) == 0 {
-		handleError(ExitBadArgs, errors.New("key required"))
-	}
-	key := c.Args()[0]
-	ttl := c.Int("ttl")
-	ctx, cancel := contextWithTotalTimeout(c)
-	_, err := ki.Set(ctx, key, "", &client.SetOptions{TTL: time.Duration(ttl) * time.Second, Dir: true, PrevExist: client.PrevExist})
-	cancel()
-	if err != nil {
-		handleError(ExitServerError, err)
-	}
-}
diff --git a/etcdctl/command/user_commands.go b/etcdctl/command/user_commands.go
deleted file mode 100644
index 2ff6a96..0000000
--- a/etcdctl/command/user_commands.go
+++ /dev/null
@@ -1,245 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"os"
-	"reflect"
-	"sort"
-	"strings"
-
-	"github.com/bgentry/speakeasy"
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-)
-
-func NewUserCommands() cli.Command {
-	return cli.Command{
-		Name:  "user",
-		Usage: "user add, grant and revoke subcommands",
-		Subcommands: []cli.Command{
-			{
-				Name:      "add",
-				Usage:     "add a new user for the etcd cluster",
-				ArgsUsage: "<user>",
-				Action:    actionUserAdd,
-			},
-			{
-				Name:      "get",
-				Usage:     "get details for a user",
-				ArgsUsage: "<user>",
-				Action:    actionUserGet,
-			},
-			{
-				Name:      "list",
-				Usage:     "list all current users",
-				ArgsUsage: "<user>",
-				Action:    actionUserList,
-			},
-			{
-				Name:      "remove",
-				Usage:     "remove a user for the etcd cluster",
-				ArgsUsage: "<user>",
-				Action:    actionUserRemove,
-			},
-			{
-				Name:      "grant",
-				Usage:     "grant roles to an etcd user",
-				ArgsUsage: "<user>",
-				Flags:     []cli.Flag{cli.StringSliceFlag{Name: "roles", Value: new(cli.StringSlice), Usage: "List of roles to grant or revoke"}},
-				Action:    actionUserGrant,
-			},
-			{
-				Name:      "revoke",
-				Usage:     "revoke roles for an etcd user",
-				ArgsUsage: "<user>",
-				Flags:     []cli.Flag{cli.StringSliceFlag{Name: "roles", Value: new(cli.StringSlice), Usage: "List of roles to grant or revoke"}},
-				Action:    actionUserRevoke,
-			},
-			{
-				Name:      "passwd",
-				Usage:     "change password for a user",
-				ArgsUsage: "<user>",
-				Action:    actionUserPasswd,
-			},
-		},
-	}
-}
-
-func mustNewAuthUserAPI(c *cli.Context) client.AuthUserAPI {
-	hc := mustNewClient(c)
-
-	if c.GlobalBool("debug") {
-		fmt.Fprintf(os.Stderr, "Cluster-Endpoints: %s\n", strings.Join(hc.Endpoints(), ", "))
-	}
-
-	return client.NewAuthUserAPI(hc)
-}
-
-func actionUserList(c *cli.Context) {
-	if len(c.Args()) != 0 {
-		fmt.Fprintln(os.Stderr, "No arguments accepted")
-		os.Exit(1)
-	}
-	u := mustNewAuthUserAPI(c)
-	ctx, cancel := contextWithTotalTimeout(c)
-	users, err := u.ListUsers(ctx)
-	cancel()
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	for _, user := range users {
-		fmt.Printf("%s\n", user)
-	}
-}
-
-func actionUserAdd(c *cli.Context) {
-	api, userarg := mustUserAPIAndName(c)
-	ctx, cancel := contextWithTotalTimeout(c)
-	defer cancel()
-	user, _, _ := getUsernamePassword("", userarg+":")
-	currentUser, err := api.GetUser(ctx, user)
-	if currentUser != nil {
-		fmt.Fprintf(os.Stderr, "User %s already exists\n", user)
-		os.Exit(1)
-	}
-
-	_, pass, err := getUsernamePassword("New password: ", userarg)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, "Error reading password:", err)
-		os.Exit(1)
-	}
-	err = api.AddUser(ctx, user, pass)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	fmt.Printf("User %s created\n", user)
-}
-
-func actionUserRemove(c *cli.Context) {
-	api, user := mustUserAPIAndName(c)
-	ctx, cancel := contextWithTotalTimeout(c)
-	err := api.RemoveUser(ctx, user)
-	cancel()
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	fmt.Printf("User %s removed\n", user)
-}
-
-func actionUserPasswd(c *cli.Context) {
-	api, user := mustUserAPIAndName(c)
-	ctx, cancel := contextWithTotalTimeout(c)
-	defer cancel()
-	currentUser, err := api.GetUser(ctx, user)
-	if currentUser == nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-	pass, err := speakeasy.Ask("New password: ")
-	if err != nil {
-		fmt.Fprintln(os.Stderr, "Error reading password:", err)
-		os.Exit(1)
-	}
-
-	_, err = api.ChangePassword(ctx, user, pass)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	fmt.Printf("Password updated\n")
-}
-
-func actionUserGrant(c *cli.Context) {
-	userGrantRevoke(c, true)
-}
-
-func actionUserRevoke(c *cli.Context) {
-	userGrantRevoke(c, false)
-}
-
-func userGrantRevoke(c *cli.Context, grant bool) {
-	roles := c.StringSlice("roles")
-	if len(roles) == 0 {
-		fmt.Fprintln(os.Stderr, "No roles specified; please use `--roles`")
-		os.Exit(1)
-	}
-
-	ctx, cancel := contextWithTotalTimeout(c)
-	defer cancel()
-
-	api, user := mustUserAPIAndName(c)
-	currentUser, err := api.GetUser(ctx, user)
-	if currentUser == nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	var newUser *client.User
-	if grant {
-		newUser, err = api.GrantUser(ctx, user, roles)
-	} else {
-		newUser, err = api.RevokeUser(ctx, user, roles)
-	}
-	sort.Strings(newUser.Roles)
-	sort.Strings(currentUser.Roles)
-	if reflect.DeepEqual(newUser.Roles, currentUser.Roles) {
-		if grant {
-			fmt.Printf("User unchanged; roles already granted")
-		} else {
-			fmt.Printf("User unchanged; roles already revoked")
-		}
-	}
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	fmt.Printf("User %s updated\n", user)
-}
-
-func actionUserGet(c *cli.Context) {
-	api, username := mustUserAPIAndName(c)
-	ctx, cancel := contextWithTotalTimeout(c)
-	user, err := api.GetUser(ctx, username)
-	cancel()
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-	fmt.Printf("User: %s\n", user.User)
-	fmt.Printf("Roles: %s\n", strings.Join(user.Roles, " "))
-
-}
-
-func mustUserAPIAndName(c *cli.Context) (client.AuthUserAPI, string) {
-	args := c.Args()
-	if len(args) != 1 {
-		fmt.Fprintln(os.Stderr, "Please provide a username")
-		os.Exit(1)
-	}
-
-	api := mustNewAuthUserAPI(c)
-	username := args[0]
-	return api, username
-}
diff --git a/etcdctl/command/util.go b/etcdctl/command/util.go
deleted file mode 100644
index 1cca211..0000000
--- a/etcdctl/command/util.go
+++ /dev/null
@@ -1,373 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"fmt"
-	"io"
-	"io/ioutil"
-	"net"
-	"net/http"
-	"net/url"
-	"os"
-	"strings"
-	"syscall"
-	"time"
-
-	"github.com/bgentry/speakeasy"
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-	"github.com/coreos/etcd/pkg/transport"
-	"golang.org/x/net/context"
-)
-
-var (
-	ErrNoAvailSrc = errors.New("no available argument and stdin")
-
-	// the maximum amount of time a dial will wait for a connection to setup.
-	// 30s is long enough for most of the network conditions.
-	defaultDialTimeout = 30 * time.Second
-)
-
-// trimsplit slices s into all substrings separated by sep and returns a
-// slice of the substrings between the separator with all leading and trailing
-// white space removed, as defined by Unicode.
-func trimsplit(s, sep string) []string {
-	raw := strings.Split(s, ",")
-	trimmed := make([]string, 0)
-	for _, r := range raw {
-		trimmed = append(trimmed, strings.TrimSpace(r))
-	}
-	return trimmed
-}
-
-func argOrStdin(args []string, stdin io.Reader, i int) (string, error) {
-	if i < len(args) {
-		return args[i], nil
-	}
-	bytes, err := ioutil.ReadAll(stdin)
-	if string(bytes) == "" || err != nil {
-		return "", ErrNoAvailSrc
-	}
-	return string(bytes), nil
-}
-
-func getPeersFlagValue(c *cli.Context) []string {
-	peerstr := c.GlobalString("endpoints")
-
-	if peerstr == "" {
-		peerstr = os.Getenv("ETCDCTL_ENDPOINTS")
-	}
-
-	if peerstr == "" {
-		peerstr = c.GlobalString("endpoint")
-	}
-
-	if peerstr == "" {
-		peerstr = os.Getenv("ETCDCTL_ENDPOINT")
-	}
-
-	if peerstr == "" {
-		peerstr = c.GlobalString("peers")
-	}
-
-	if peerstr == "" {
-		peerstr = os.Getenv("ETCDCTL_PEERS")
-	}
-
-	// If we still don't have peers, use a default
-	if peerstr == "" {
-		peerstr = "http://127.0.0.1:2379,http://127.0.0.1:4001"
-	}
-
-	return strings.Split(peerstr, ",")
-}
-
-func getDomainDiscoveryFlagValue(c *cli.Context) ([]string, error) {
-	domainstr := c.GlobalString("discovery-srv")
-
-	// Use an environment variable if nothing was supplied on the
-	// command line
-	if domainstr == "" {
-		domainstr = os.Getenv("ETCDCTL_DISCOVERY_SRV")
-	}
-
-	// If we still don't have domain discovery, return nothing
-	if domainstr == "" {
-		return []string{}, nil
-	}
-
-	discoverer := client.NewSRVDiscover()
-	eps, err := discoverer.Discover(domainstr)
-	if err != nil {
-		return nil, err
-	}
-
-	return eps, err
-}
-
-func getEndpoints(c *cli.Context) ([]string, error) {
-	eps, err := getDomainDiscoveryFlagValue(c)
-	if err != nil {
-		return nil, err
-	}
-
-	// If domain discovery returns no endpoints, check peer flag
-	if len(eps) == 0 {
-		eps = getPeersFlagValue(c)
-	}
-
-	for i, ep := range eps {
-		u, err := url.Parse(ep)
-		if err != nil {
-			return nil, err
-		}
-
-		if u.Scheme == "" {
-			u.Scheme = "http"
-		}
-
-		eps[i] = u.String()
-	}
-
-	return eps, nil
-}
-
-func getTransport(c *cli.Context) (*http.Transport, error) {
-	cafile := c.GlobalString("ca-file")
-	certfile := c.GlobalString("cert-file")
-	keyfile := c.GlobalString("key-file")
-
-	// Use an environment variable if nothing was supplied on the
-	// command line
-	if cafile == "" {
-		cafile = os.Getenv("ETCDCTL_CA_FILE")
-	}
-	if certfile == "" {
-		certfile = os.Getenv("ETCDCTL_CERT_FILE")
-	}
-	if keyfile == "" {
-		keyfile = os.Getenv("ETCDCTL_KEY_FILE")
-	}
-
-	tls := transport.TLSInfo{
-		CAFile:   cafile,
-		CertFile: certfile,
-		KeyFile:  keyfile,
-	}
-	return transport.NewTransport(tls, defaultDialTimeout)
-}
-
-func getUsernamePasswordFromFlag(usernameFlag string) (username string, password string, err error) {
-	return getUsernamePassword("Password: ", usernameFlag)
-}
-
-func getUsernamePassword(prompt, usernameFlag string) (username string, password string, err error) {
-	colon := strings.Index(usernameFlag, ":")
-	if colon == -1 {
-		username = usernameFlag
-		// Prompt for the password.
-		password, err = speakeasy.Ask(prompt)
-		if err != nil {
-			return "", "", err
-		}
-	} else {
-		username = usernameFlag[:colon]
-		password = usernameFlag[colon+1:]
-	}
-	return username, password, nil
-}
-
-func mustNewKeyAPI(c *cli.Context) client.KeysAPI {
-	return client.NewKeysAPI(mustNewClient(c))
-}
-
-func mustNewMembersAPI(c *cli.Context) client.MembersAPI {
-	return client.NewMembersAPI(mustNewClient(c))
-}
-
-func mustNewClient(c *cli.Context) client.Client {
-	hc, err := newClient(c)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	debug := c.GlobalBool("debug")
-	if debug {
-		client.EnablecURLDebug()
-	}
-
-	if !c.GlobalBool("no-sync") {
-		if debug {
-			fmt.Fprintf(os.Stderr, "start to sync cluster using endpoints(%s)\n", strings.Join(hc.Endpoints(), ","))
-		}
-		ctx, cancel := context.WithTimeout(context.Background(), client.DefaultRequestTimeout)
-		err := hc.Sync(ctx)
-		cancel()
-		if err != nil {
-			if err == client.ErrNoEndpoints {
-				fmt.Fprintf(os.Stderr, "etcd cluster has no published client endpoints.\n")
-				fmt.Fprintf(os.Stderr, "Try '--no-sync' if you want to access non-published client endpoints(%s).\n", strings.Join(hc.Endpoints(), ","))
-				handleError(ExitServerError, err)
-			}
-
-			if isConnectionError(err) {
-				handleError(ExitBadConnection, err)
-			}
-
-			// fail-back to try sync cluster with peer API. this is for making etcdctl work with etcd 0.4.x.
-			// TODO: remove this when we deprecate the support for etcd 0.4.
-			eps, serr := syncWithPeerAPI(c, ctx, hc.Endpoints())
-			if serr != nil {
-				if isConnectionError(serr) {
-					handleError(ExitBadConnection, serr)
-				} else {
-					handleError(ExitServerError, serr)
-				}
-			}
-			err = hc.SetEndpoints(eps)
-			if err != nil {
-				handleError(ExitServerError, err)
-			}
-		}
-		if debug {
-			fmt.Fprintf(os.Stderr, "got endpoints(%s) after sync\n", strings.Join(hc.Endpoints(), ","))
-		}
-	}
-
-	if debug {
-		fmt.Fprintf(os.Stderr, "Cluster-Endpoints: %s\n", strings.Join(hc.Endpoints(), ", "))
-	}
-
-	return hc
-}
-
-func isConnectionError(err error) bool {
-	switch t := err.(type) {
-	case *client.ClusterError:
-		for _, cerr := range t.Errors {
-			if !isConnectionError(cerr) {
-				return false
-			}
-		}
-		return true
-	case *net.OpError:
-		if t.Op == "dial" || t.Op == "read" {
-			return true
-		}
-		return isConnectionError(t.Err)
-	case net.Error:
-		if t.Timeout() {
-			return true
-		}
-	case syscall.Errno:
-		if t == syscall.ECONNREFUSED {
-			return true
-		}
-	}
-	return false
-}
-
-func mustNewClientNoSync(c *cli.Context) client.Client {
-	hc, err := newClient(c)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err.Error())
-		os.Exit(1)
-	}
-
-	if c.GlobalBool("debug") {
-		fmt.Fprintf(os.Stderr, "Cluster-Endpoints: %s\n", strings.Join(hc.Endpoints(), ", "))
-		client.EnablecURLDebug()
-	}
-
-	return hc
-}
-
-func newClient(c *cli.Context) (client.Client, error) {
-	eps, err := getEndpoints(c)
-	if err != nil {
-		return nil, err
-	}
-
-	tr, err := getTransport(c)
-	if err != nil {
-		return nil, err
-	}
-
-	cfg := client.Config{
-		Transport:               tr,
-		Endpoints:               eps,
-		HeaderTimeoutPerRequest: c.GlobalDuration("timeout"),
-	}
-
-	uFlag := c.GlobalString("username")
-	if uFlag != "" {
-		username, password, err := getUsernamePasswordFromFlag(uFlag)
-		if err != nil {
-			return nil, err
-		}
-		cfg.Username = username
-		cfg.Password = password
-	}
-
-	return client.New(cfg)
-}
-
-func contextWithTotalTimeout(c *cli.Context) (context.Context, context.CancelFunc) {
-	return context.WithTimeout(context.Background(), c.GlobalDuration("total-timeout"))
-}
-
-// syncWithPeerAPI syncs cluster with peer API defined at
-// https://github.com/coreos/etcd/blob/v0.4.9/server/server.go#L311.
-// This exists for backward compatibility with etcd 0.4.x.
-func syncWithPeerAPI(c *cli.Context, ctx context.Context, knownPeers []string) ([]string, error) {
-	tr, err := getTransport(c)
-	if err != nil {
-		return nil, err
-	}
-
-	var (
-		body []byte
-		resp *http.Response
-	)
-	for _, p := range knownPeers {
-		var req *http.Request
-		req, err = http.NewRequest("GET", p+"/v2/peers", nil)
-		if err != nil {
-			continue
-		}
-		resp, err = tr.RoundTrip(req)
-		if err != nil {
-			continue
-		}
-		if resp.StatusCode != http.StatusOK {
-			resp.Body.Close()
-			continue
-		}
-		body, err = ioutil.ReadAll(resp.Body)
-		resp.Body.Close()
-		if err == nil {
-			break
-		}
-	}
-	if err != nil {
-		return nil, err
-	}
-
-	// Parse the peers API format: https://github.com/coreos/etcd/blob/v0.4.9/server/server.go#L311
-	return strings.Split(string(body), ", "), nil
-}
diff --git a/etcdctl/command/util_test.go b/etcdctl/command/util_test.go
deleted file mode 100644
index bf5357e..0000000
--- a/etcdctl/command/util_test.go
+++ /dev/null
@@ -1,70 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"bytes"
-	"testing"
-)
-
-func TestArgOrStdin(t *testing.T) {
-	tests := []struct {
-		args  []string
-		stdin string
-		i     int
-		w     string
-		we    error
-	}{
-		{
-			args: []string{
-				"a",
-			},
-			stdin: "b",
-			i:     0,
-			w:     "a",
-			we:    nil,
-		},
-		{
-			args: []string{
-				"a",
-			},
-			stdin: "b",
-			i:     1,
-			w:     "b",
-			we:    nil,
-		},
-		{
-			args: []string{
-				"a",
-			},
-			stdin: "",
-			i:     1,
-			w:     "",
-			we:    ErrNoAvailSrc,
-		},
-	}
-
-	for i, tt := range tests {
-		var b bytes.Buffer
-		b.Write([]byte(tt.stdin))
-		g, ge := argOrStdin(tt.args, &b, tt.i)
-		if g != tt.w {
-			t.Errorf("#%d: expect %v, not %v", i, tt.w, g)
-		}
-		if ge != tt.we {
-			t.Errorf("#%d: expect %v, not %v", i, tt.we, ge)
-		}
-	}
-}
diff --git a/etcdctl/command/watch_command.go b/etcdctl/command/watch_command.go
deleted file mode 100644
index 2f17f25..0000000
--- a/etcdctl/command/watch_command.go
+++ /dev/null
@@ -1,84 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"fmt"
-	"os"
-	"os/signal"
-
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/client"
-	"golang.org/x/net/context"
-)
-
-// NewWatchCommand returns the CLI command for "watch".
-func NewWatchCommand() cli.Command {
-	return cli.Command{
-		Name:      "watch",
-		Usage:     "watch a key for changes",
-		ArgsUsage: "<key>",
-		Flags: []cli.Flag{
-			cli.BoolFlag{Name: "forever", Usage: "forever watch a key until CTRL+C"},
-			cli.IntFlag{Name: "after-index", Value: 0, Usage: "watch after the given index"},
-			cli.BoolFlag{Name: "recursive", Usage: "returns all values for key and child keys"},
-		},
-		Action: func(c *cli.Context) {
-			watchCommandFunc(c, mustNewKeyAPI(c))
-		},
-	}
-}
-
-// watchCommandFunc executes the "watch" command.
-func watchCommandFunc(c *cli.Context, ki client.KeysAPI) {
-	if len(c.Args()) == 0 {
-		handleError(ExitBadArgs, errors.New("key required"))
-	}
-	key := c.Args()[0]
-	recursive := c.Bool("recursive")
-	forever := c.Bool("forever")
-	index := c.Int("after-index")
-
-	stop := false
-	w := ki.Watcher(key, &client.WatcherOptions{AfterIndex: uint64(index), Recursive: recursive})
-
-	sigch := make(chan os.Signal, 1)
-	signal.Notify(sigch, os.Interrupt)
-
-	go func() {
-		<-sigch
-		os.Exit(0)
-	}()
-
-	for !stop {
-		resp, err := w.Next(context.TODO())
-		if err != nil {
-			handleError(ExitServerError, err)
-		}
-		if resp.Node.Dir {
-			continue
-		}
-		if recursive {
-			fmt.Printf("[%s] %s\n", resp.Action, resp.Node.Key)
-		}
-
-		printResponseKey(resp, c.GlobalString("output"))
-
-		if !forever {
-			stop = true
-		}
-	}
-}
diff --git a/etcdctl/ctlv2/command/auth_commands.go b/etcdctl/ctlv2/command/auth_commands.go
new file mode 100644
index 0000000..bb53c4f
--- /dev/null
+++ b/etcdctl/ctlv2/command/auth_commands.go
@@ -0,0 +1,88 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"os"
+	"strings"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+func NewAuthCommands() cli.Command {
+	return cli.Command{
+		Name:  "auth",
+		Usage: "overall auth controls",
+		Subcommands: []cli.Command{
+			{
+				Name:      "enable",
+				Usage:     "enable auth access controls",
+				ArgsUsage: " ",
+				Action:    actionAuthEnable,
+			},
+			{
+				Name:      "disable",
+				Usage:     "disable auth access controls",
+				ArgsUsage: " ",
+				Action:    actionAuthDisable,
+			},
+		},
+	}
+}
+
+func actionAuthEnable(c *cli.Context) {
+	authEnableDisable(c, true)
+}
+
+func actionAuthDisable(c *cli.Context) {
+	authEnableDisable(c, false)
+}
+
+func mustNewAuthAPI(c *cli.Context) client.AuthAPI {
+	hc := mustNewClient(c)
+
+	if c.GlobalBool("debug") {
+		fmt.Fprintf(os.Stderr, "Cluster-Endpoints: %s\n", strings.Join(hc.Endpoints(), ", "))
+	}
+
+	return client.NewAuthAPI(hc)
+}
+
+func authEnableDisable(c *cli.Context, enable bool) {
+	if len(c.Args()) != 0 {
+		fmt.Fprintln(os.Stderr, "No arguments accepted")
+		os.Exit(1)
+	}
+	s := mustNewAuthAPI(c)
+	ctx, cancel := contextWithTotalTimeout(c)
+	var err error
+	if enable {
+		err = s.Enable(ctx)
+	} else {
+		err = s.Disable(ctx)
+	}
+	cancel()
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+	if enable {
+		fmt.Println("Authentication Enabled")
+	} else {
+		fmt.Println("Authentication Disabled")
+	}
+}
diff --git a/etcdctl/ctlv2/command/backup_command.go b/etcdctl/ctlv2/command/backup_command.go
new file mode 100644
index 0000000..c4ee61d
--- /dev/null
+++ b/etcdctl/ctlv2/command/backup_command.go
@@ -0,0 +1,101 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"log"
+	"os"
+	"path"
+	"time"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/etcdserver/etcdserverpb"
+	"github.com/coreos/etcd/pkg/idutil"
+	"github.com/coreos/etcd/pkg/pbutil"
+	"github.com/coreos/etcd/snap"
+	"github.com/coreos/etcd/wal"
+	"github.com/coreos/etcd/wal/walpb"
+)
+
+func NewBackupCommand() cli.Command {
+	return cli.Command{
+		Name:      "backup",
+		Usage:     "backup an etcd directory",
+		ArgsUsage: " ",
+		Flags: []cli.Flag{
+			cli.StringFlag{Name: "data-dir", Value: "", Usage: "Path to the etcd data dir"},
+			cli.StringFlag{Name: "backup-dir", Value: "", Usage: "Path to the backup dir"},
+		},
+		Action: handleBackup,
+	}
+}
+
+// handleBackup handles a request that intends to do a backup.
+func handleBackup(c *cli.Context) {
+	srcSnap := path.Join(c.String("data-dir"), "member", "snap")
+	destSnap := path.Join(c.String("backup-dir"), "member", "snap")
+	srcWAL := path.Join(c.String("data-dir"), "member", "wal")
+	destWAL := path.Join(c.String("backup-dir"), "member", "wal")
+
+	if err := os.MkdirAll(destSnap, 0700); err != nil {
+		log.Fatalf("failed creating backup snapshot dir %v: %v", destSnap, err)
+	}
+	ss := snap.New(srcSnap)
+	snapshot, err := ss.Load()
+	if err != nil && err != snap.ErrNoSnapshot {
+		log.Fatal(err)
+	}
+	var walsnap walpb.Snapshot
+	if snapshot != nil {
+		walsnap.Index, walsnap.Term = snapshot.Metadata.Index, snapshot.Metadata.Term
+		newss := snap.New(destSnap)
+		if err = newss.SaveSnap(*snapshot); err != nil {
+			log.Fatal(err)
+		}
+	}
+
+	w, err := wal.OpenForRead(srcWAL, walsnap)
+	if err != nil {
+		log.Fatal(err)
+	}
+	defer w.Close()
+	wmetadata, state, ents, err := w.ReadAll()
+	switch err {
+	case nil:
+	case wal.ErrSnapshotNotFound:
+		fmt.Printf("Failed to find the match snapshot record %+v in wal %v.", walsnap, srcWAL)
+		fmt.Printf("etcdctl will add it back. Start auto fixing...")
+	default:
+		log.Fatal(err)
+	}
+	var metadata etcdserverpb.Metadata
+	pbutil.MustUnmarshal(&metadata, wmetadata)
+	idgen := idutil.NewGenerator(0, time.Now())
+	metadata.NodeID = idgen.Next()
+	metadata.ClusterID = idgen.Next()
+
+	neww, err := wal.Create(destWAL, pbutil.MustMarshal(&metadata))
+	if err != nil {
+		log.Fatal(err)
+	}
+	defer neww.Close()
+	if err := neww.Save(state, ents); err != nil {
+		log.Fatal(err)
+	}
+	if err := neww.SaveSnapshot(walsnap); err != nil {
+		log.Fatal(err)
+	}
+}
diff --git a/etcdctl/ctlv2/command/cluster_health.go b/etcdctl/ctlv2/command/cluster_health.go
new file mode 100644
index 0000000..0a3e4d6
--- /dev/null
+++ b/etcdctl/ctlv2/command/cluster_health.go
@@ -0,0 +1,136 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"encoding/json"
+	"fmt"
+	"io/ioutil"
+	"net/http"
+	"os"
+	"os/signal"
+	"time"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+	"golang.org/x/net/context"
+)
+
+func NewClusterHealthCommand() cli.Command {
+	return cli.Command{
+		Name:      "cluster-health",
+		Usage:     "check the health of the etcd cluster",
+		ArgsUsage: " ",
+		Flags: []cli.Flag{
+			cli.BoolFlag{Name: "forever", Usage: "forever check the health every 10 second until CTRL+C"},
+		},
+		Action: handleClusterHealth,
+	}
+}
+
+func handleClusterHealth(c *cli.Context) {
+	forever := c.Bool("forever")
+	if forever {
+		sigch := make(chan os.Signal, 1)
+		signal.Notify(sigch, os.Interrupt)
+
+		go func() {
+			<-sigch
+			os.Exit(0)
+		}()
+	}
+
+	tr, err := getTransport(c)
+	if err != nil {
+		handleError(ExitServerError, err)
+	}
+
+	hc := http.Client{
+		Transport: tr,
+	}
+
+	cln := mustNewClientNoSync(c)
+	mi := client.NewMembersAPI(cln)
+	ms, err := mi.List(context.TODO())
+	if err != nil {
+		fmt.Println("cluster may be unhealthy: failed to list members")
+		handleError(ExitServerError, err)
+	}
+
+	for {
+		health := false
+		for _, m := range ms {
+			if len(m.ClientURLs) == 0 {
+				fmt.Printf("member %s is unreachable: no available published client urls\n", m.ID)
+				continue
+			}
+
+			checked := false
+			for _, url := range m.ClientURLs {
+				resp, err := hc.Get(url + "/health")
+				if err != nil {
+					fmt.Printf("failed to check the health of member %s on %s: %v\n", m.ID, url, err)
+					continue
+				}
+
+				result := struct{ Health string }{}
+				nresult := struct{ Health bool }{}
+				bytes, err := ioutil.ReadAll(resp.Body)
+				if err != nil {
+					fmt.Printf("failed to check the health of member %s on %s: %v\n", m.ID, url, err)
+					continue
+				}
+				resp.Body.Close()
+
+				err = json.Unmarshal(bytes, &result)
+				if err != nil {
+					err = json.Unmarshal(bytes, &nresult)
+				}
+				if err != nil {
+					fmt.Printf("failed to check the health of member %s on %s: %v\n", m.ID, url, err)
+					continue
+				}
+
+				checked = true
+				if result.Health == "true" || nresult.Health == true {
+					health = true
+					fmt.Printf("member %s is healthy: got healthy result from %s\n", m.ID, url)
+				} else {
+					fmt.Printf("member %s is unhealthy: got unhealthy result from %s\n", m.ID, url)
+				}
+				break
+			}
+			if !checked {
+				fmt.Printf("member %s is unreachable: %v are all unreachable\n", m.ID, m.ClientURLs)
+			}
+		}
+		if health {
+			fmt.Println("cluster is healthy")
+		} else {
+			fmt.Println("cluster is unhealthy")
+		}
+
+		if !forever {
+			if health {
+				os.Exit(ExitSuccess)
+			} else {
+				os.Exit(ExitClusterNotHealthy)
+			}
+		}
+
+		fmt.Printf("\nnext check after 10 second...\n\n")
+		time.Sleep(10 * time.Second)
+	}
+}
diff --git a/etcdctl/ctlv2/command/doc.go b/etcdctl/ctlv2/command/doc.go
new file mode 100644
index 0000000..7e95e65
--- /dev/null
+++ b/etcdctl/ctlv2/command/doc.go
@@ -0,0 +1,16 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package command is a set of libraries for etcdctl commands.
+package command
diff --git a/etcdctl/ctlv2/command/error.go b/etcdctl/ctlv2/command/error.go
new file mode 100644
index 0000000..83a80b2
--- /dev/null
+++ b/etcdctl/ctlv2/command/error.go
@@ -0,0 +1,39 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"os"
+
+	"github.com/coreos/etcd/client"
+)
+
+const (
+	ExitSuccess = iota
+	ExitBadArgs
+	ExitBadConnection
+	ExitBadAuth
+	ExitServerError
+	ExitClusterNotHealthy
+)
+
+func handleError(code int, err error) {
+	fmt.Fprintln(os.Stderr, "Error: ", err)
+	if cerr, ok := err.(*client.ClusterError); ok {
+		fmt.Fprintln(os.Stderr, cerr.Detail())
+	}
+	os.Exit(code)
+}
diff --git a/etcdctl/ctlv2/command/exec_watch_command.go b/etcdctl/ctlv2/command/exec_watch_command.go
new file mode 100644
index 0000000..ed6fec7
--- /dev/null
+++ b/etcdctl/ctlv2/command/exec_watch_command.go
@@ -0,0 +1,127 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"fmt"
+	"os"
+	"os/exec"
+	"os/signal"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+	"golang.org/x/net/context"
+)
+
+// NewExecWatchCommand returns the CLI command for "exec-watch".
+func NewExecWatchCommand() cli.Command {
+	return cli.Command{
+		Name:      "exec-watch",
+		Usage:     "watch a key for changes and exec an executable",
+		ArgsUsage: "<key> <command> [args...]",
+		Flags: []cli.Flag{
+			cli.IntFlag{Name: "after-index", Value: 0, Usage: "watch after the given index"},
+			cli.BoolFlag{Name: "recursive", Usage: "watch all values for key and child keys"},
+		},
+		Action: func(c *cli.Context) {
+			execWatchCommandFunc(c, mustNewKeyAPI(c))
+		},
+	}
+}
+
+// execWatchCommandFunc executes the "exec-watch" command.
+func execWatchCommandFunc(c *cli.Context, ki client.KeysAPI) {
+	args := c.Args()
+	argslen := len(args)
+
+	if argslen < 2 {
+		handleError(ExitBadArgs, errors.New("key and command to exec required"))
+	}
+
+	var (
+		key     string
+		cmdArgs []string
+	)
+
+	foundSep := false
+	for i := range args {
+		if args[i] == "--" && i != 0 {
+			foundSep = true
+			break
+		}
+	}
+
+	if foundSep {
+		key = args[0]
+		cmdArgs = args[2:]
+	} else {
+		// If no flag is parsed, the order of key and cmdArgs will be switched and
+		// args will not contain `--`.
+		key = args[argslen-1]
+		cmdArgs = args[:argslen-1]
+	}
+
+	index := 0
+	if c.Int("after-index") != 0 {
+		index = c.Int("after-index") + 1
+	}
+
+	recursive := c.Bool("recursive")
+
+	sigch := make(chan os.Signal, 1)
+	signal.Notify(sigch, os.Interrupt)
+
+	go func() {
+		<-sigch
+		os.Exit(0)
+	}()
+
+	w := ki.Watcher(key, &client.WatcherOptions{AfterIndex: uint64(index), Recursive: recursive})
+
+	for {
+		resp, err := w.Next(context.TODO())
+		if err != nil {
+			handleError(ExitServerError, err)
+		}
+		if resp.Node.Dir {
+			fmt.Fprintf(os.Stderr, "Ignored dir %s change", resp.Node.Key)
+			continue
+		}
+
+		cmd := exec.Command(cmdArgs[0], cmdArgs[1:]...)
+		cmd.Env = environResponse(resp, os.Environ())
+
+		cmd.Stdout = os.Stdout
+		cmd.Stderr = os.Stderr
+
+		go func() {
+			err := cmd.Start()
+			if err != nil {
+				fmt.Fprintf(os.Stderr, err.Error())
+				os.Exit(1)
+			}
+			cmd.Wait()
+		}()
+	}
+}
+
+func environResponse(resp *client.Response, env []string) []string {
+	env = append(env, "ETCD_WATCH_ACTION="+resp.Action)
+	env = append(env, "ETCD_WATCH_MODIFIED_INDEX="+fmt.Sprintf("%d", resp.Node.ModifiedIndex))
+	env = append(env, "ETCD_WATCH_KEY="+resp.Node.Key)
+	env = append(env, "ETCD_WATCH_VALUE="+resp.Node.Value)
+	return env
+}
diff --git a/etcdctl/ctlv2/command/format.go b/etcdctl/ctlv2/command/format.go
new file mode 100644
index 0000000..55661e8
--- /dev/null
+++ b/etcdctl/ctlv2/command/format.go
@@ -0,0 +1,60 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"encoding/json"
+	"fmt"
+	"os"
+
+	"github.com/coreos/etcd/client"
+)
+
+// printResponseKey only supports to print key correctly.
+func printResponseKey(resp *client.Response, format string) {
+	// Format the result.
+	switch format {
+	case "simple":
+		if resp.Action != "delete" {
+			fmt.Println(resp.Node.Value)
+		} else {
+			fmt.Println("PrevNode.Value:", resp.PrevNode.Value)
+		}
+	case "extended":
+		// Extended prints in a rfc2822 style format
+		fmt.Println("Key:", resp.Node.Key)
+		fmt.Println("Created-Index:", resp.Node.CreatedIndex)
+		fmt.Println("Modified-Index:", resp.Node.ModifiedIndex)
+
+		if resp.PrevNode != nil {
+			fmt.Println("PrevNode.Value:", resp.PrevNode.Value)
+		}
+
+		fmt.Println("TTL:", resp.Node.TTL)
+		fmt.Println("Index:", resp.Index)
+		if resp.Action != "delete" {
+			fmt.Println("")
+			fmt.Println(resp.Node.Value)
+		}
+	case "json":
+		b, err := json.Marshal(resp)
+		if err != nil {
+			panic(err)
+		}
+		fmt.Println(string(b))
+	default:
+		fmt.Fprintln(os.Stderr, "Unsupported output format:", format)
+	}
+}
diff --git a/etcdctl/ctlv2/command/get_command.go b/etcdctl/ctlv2/command/get_command.go
new file mode 100644
index 0000000..6835e86
--- /dev/null
+++ b/etcdctl/ctlv2/command/get_command.go
@@ -0,0 +1,65 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"fmt"
+	"os"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+// NewGetCommand returns the CLI command for "get".
+func NewGetCommand() cli.Command {
+	return cli.Command{
+		Name:      "get",
+		Usage:     "retrieve the value of a key",
+		ArgsUsage: "<key>",
+		Flags: []cli.Flag{
+			cli.BoolFlag{Name: "sort", Usage: "returns result in sorted order"},
+			cli.BoolFlag{Name: "quorum", Usage: "require quorum for get request"},
+		},
+		Action: func(c *cli.Context) {
+			getCommandFunc(c, mustNewKeyAPI(c))
+		},
+	}
+}
+
+// getCommandFunc executes the "get" command.
+func getCommandFunc(c *cli.Context, ki client.KeysAPI) {
+	if len(c.Args()) == 0 {
+		handleError(ExitBadArgs, errors.New("key required"))
+	}
+
+	key := c.Args()[0]
+	sorted := c.Bool("sort")
+	quorum := c.Bool("quorum")
+
+	ctx, cancel := contextWithTotalTimeout(c)
+	resp, err := ki.Get(ctx, key, &client.GetOptions{Sort: sorted, Quorum: quorum})
+	cancel()
+	if err != nil {
+		handleError(ExitServerError, err)
+	}
+
+	if resp.Node.Dir {
+		fmt.Fprintln(os.Stderr, fmt.Sprintf("%s: is a directory", resp.Node.Key))
+		os.Exit(1)
+	}
+
+	printResponseKey(resp, c.GlobalString("output"))
+}
diff --git a/etcdctl/ctlv2/command/import_snap_command.go b/etcdctl/ctlv2/command/import_snap_command.go
new file mode 100644
index 0000000..016d635
--- /dev/null
+++ b/etcdctl/ctlv2/command/import_snap_command.go
@@ -0,0 +1,119 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"io/ioutil"
+	"log"
+	"os"
+	"sync"
+	"time"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+	"github.com/coreos/etcd/store"
+	"golang.org/x/net/context"
+)
+
+type set struct {
+	key   string
+	value string
+	ttl   int64
+}
+
+func NewImportSnapCommand() cli.Command {
+	return cli.Command{
+		Name:      "import",
+		Usage:     "import a snapshot to a cluster",
+		ArgsUsage: " ",
+		Flags: []cli.Flag{
+			cli.StringFlag{Name: "snap", Value: "", Usage: "Path to the valid etcd 0.4.x snapshot."},
+			cli.StringSliceFlag{Name: "hidden", Value: new(cli.StringSlice), Usage: "Hidden key spaces to import from snapshot"},
+			cli.IntFlag{Name: "c", Value: 10, Usage: "Number of concurrent clients to import the data"},
+		},
+		Action: handleImportSnap,
+	}
+}
+
+func handleImportSnap(c *cli.Context) {
+	d, err := ioutil.ReadFile(c.String("snap"))
+	if err != nil {
+		if c.String("snap") == "" {
+			fmt.Printf("no snapshot file provided (use --snap)\n")
+		} else {
+			fmt.Printf("cannot read snapshot file %s\n", c.String("snap"))
+		}
+		os.Exit(1)
+	}
+
+	st := store.New()
+	err = st.Recovery(d)
+
+	wg := &sync.WaitGroup{}
+	setc := make(chan set)
+	concurrent := c.Int("c")
+	fmt.Printf("starting to import snapshot %s with %d clients\n", c.String("snap"), concurrent)
+	for i := 0; i < concurrent; i++ {
+		go runSet(mustNewKeyAPI(c), setc, wg)
+	}
+
+	all, err := st.Get("/", true, true)
+	if err != nil {
+		handleError(ExitServerError, err)
+	}
+	n := copyKeys(all.Node, setc)
+
+	hiddens := c.StringSlice("hidden")
+	for _, h := range hiddens {
+		allh, err := st.Get(h, true, true)
+		if err != nil {
+			handleError(ExitServerError, err)
+		}
+		n += copyKeys(allh.Node, setc)
+	}
+	close(setc)
+	wg.Wait()
+	fmt.Printf("finished importing %d keys\n", n)
+}
+
+func copyKeys(n *store.NodeExtern, setc chan set) int {
+	num := 0
+	if !n.Dir {
+		setc <- set{n.Key, *n.Value, n.TTL}
+		return 1
+	}
+	log.Println("entering dir:", n.Key)
+	for _, nn := range n.Nodes {
+		sub := copyKeys(nn, setc)
+		num += sub
+	}
+	return num
+}
+
+func runSet(ki client.KeysAPI, setc chan set, wg *sync.WaitGroup) {
+	for s := range setc {
+		log.Println("copying key:", s.key)
+		if s.ttl != 0 && s.ttl < 300 {
+			log.Printf("extending key %s's ttl to 300 seconds", s.key)
+			s.ttl = 5 * 60
+		}
+		_, err := ki.Set(context.TODO(), s.key, s.value, &client.SetOptions{TTL: time.Duration(s.ttl) * time.Second})
+		if err != nil {
+			log.Fatalf("failed to copy key: %v\n", err)
+		}
+	}
+	wg.Done()
+}
diff --git a/etcdctl/ctlv2/command/ls_command.go b/etcdctl/ctlv2/command/ls_command.go
new file mode 100644
index 0000000..b90db4a
--- /dev/null
+++ b/etcdctl/ctlv2/command/ls_command.go
@@ -0,0 +1,84 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+func NewLsCommand() cli.Command {
+	return cli.Command{
+		Name:      "ls",
+		Usage:     "retrieve a directory",
+		ArgsUsage: "[key]",
+		Flags: []cli.Flag{
+			cli.BoolFlag{Name: "sort", Usage: "returns result in sorted order"},
+			cli.BoolFlag{Name: "recursive", Usage: "returns all key names recursively for the given path"},
+			cli.BoolFlag{Name: "p", Usage: "append slash (/) to directories"},
+			cli.BoolFlag{Name: "quorum", Usage: "require quorum for get request"},
+		},
+		Action: func(c *cli.Context) {
+			lsCommandFunc(c, mustNewKeyAPI(c))
+		},
+	}
+}
+
+// lsCommandFunc executes the "ls" command.
+func lsCommandFunc(c *cli.Context, ki client.KeysAPI) {
+	key := "/"
+	if len(c.Args()) != 0 {
+		key = c.Args()[0]
+	}
+
+	sort := c.Bool("sort")
+	recursive := c.Bool("recursive")
+	quorum := c.Bool("quorum")
+
+	ctx, cancel := contextWithTotalTimeout(c)
+	resp, err := ki.Get(ctx, key, &client.GetOptions{Sort: sort, Recursive: recursive, Quorum: quorum})
+	cancel()
+	if err != nil {
+		handleError(ExitServerError, err)
+	}
+
+	printLs(c, resp)
+}
+
+// printLs writes a response out in a manner similar to the `ls` command in unix.
+// Non-empty directories list their contents and files list their name.
+func printLs(c *cli.Context, resp *client.Response) {
+	if !resp.Node.Dir {
+		fmt.Println(resp.Node.Key)
+	}
+	for _, node := range resp.Node.Nodes {
+		rPrint(c, node)
+	}
+}
+
+// rPrint recursively prints out the nodes in the node structure.
+func rPrint(c *cli.Context, n *client.Node) {
+	if n.Dir && c.Bool("p") {
+		fmt.Println(fmt.Sprintf("%v/", n.Key))
+	} else {
+		fmt.Println(n.Key)
+	}
+
+	for _, node := range n.Nodes {
+		rPrint(c, node)
+	}
+}
diff --git a/etcdctl/ctlv2/command/member_commands.go b/etcdctl/ctlv2/command/member_commands.go
new file mode 100644
index 0000000..5c9ad6d
--- /dev/null
+++ b/etcdctl/ctlv2/command/member_commands.go
@@ -0,0 +1,202 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"os"
+	"strings"
+
+	"github.com/codegangsta/cli"
+)
+
+func NewMemberCommand() cli.Command {
+	return cli.Command{
+		Name:  "member",
+		Usage: "member add, remove and list subcommands",
+		Subcommands: []cli.Command{
+			{
+				Name:      "list",
+				Usage:     "enumerate existing cluster members",
+				ArgsUsage: " ",
+				Action:    actionMemberList,
+			},
+			{
+				Name:      "add",
+				Usage:     "add a new member to the etcd cluster",
+				ArgsUsage: "<name> <peerURL>",
+				Action:    actionMemberAdd,
+			},
+			{
+				Name:      "remove",
+				Usage:     "remove an existing member from the etcd cluster",
+				ArgsUsage: "<memberID>",
+				Action:    actionMemberRemove,
+			},
+			{
+				Name:      "update",
+				Usage:     "update an existing member in the etcd cluster",
+				ArgsUsage: "<memberID> <peerURLs>",
+				Action:    actionMemberUpdate,
+			},
+		},
+	}
+}
+
+func actionMemberList(c *cli.Context) {
+	if len(c.Args()) != 0 {
+		fmt.Fprintln(os.Stderr, "No arguments accepted")
+		os.Exit(1)
+	}
+	mAPI := mustNewMembersAPI(c)
+	ctx, cancel := contextWithTotalTimeout(c)
+	defer cancel()
+
+	members, err := mAPI.List(ctx)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+	leader, err := mAPI.Leader(ctx)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, "Failed to get leader: ", err)
+		os.Exit(1)
+	}
+
+	for _, m := range members {
+		isLeader := false
+		if m.ID == leader.ID {
+			isLeader = true
+		}
+		if len(m.Name) == 0 {
+			fmt.Printf("%s[unstarted]: peerURLs=%s\n", m.ID, strings.Join(m.PeerURLs, ","))
+		} else {
+			fmt.Printf("%s: name=%s peerURLs=%s clientURLs=%s isLeader=%v\n", m.ID, m.Name, strings.Join(m.PeerURLs, ","), strings.Join(m.ClientURLs, ","), isLeader)
+		}
+	}
+}
+
+func actionMemberAdd(c *cli.Context) {
+	args := c.Args()
+	if len(args) != 2 {
+		fmt.Fprintln(os.Stderr, "Provide a name and a single member peerURL")
+		os.Exit(1)
+	}
+
+	mAPI := mustNewMembersAPI(c)
+
+	url := args[1]
+	ctx, cancel := contextWithTotalTimeout(c)
+	defer cancel()
+
+	m, err := mAPI.Add(ctx, url)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	newID := m.ID
+	newName := args[0]
+	fmt.Printf("Added member named %s with ID %s to cluster\n", newName, newID)
+
+	members, err := mAPI.List(ctx)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	conf := []string{}
+	for _, memb := range members {
+		for _, u := range memb.PeerURLs {
+			n := memb.Name
+			if memb.ID == newID {
+				n = newName
+			}
+			conf = append(conf, fmt.Sprintf("%s=%s", n, u))
+		}
+	}
+
+	fmt.Print("\n")
+	fmt.Printf("ETCD_NAME=%q\n", newName)
+	fmt.Printf("ETCD_INITIAL_CLUSTER=%q\n", strings.Join(conf, ","))
+	fmt.Printf("ETCD_INITIAL_CLUSTER_STATE=\"existing\"\n")
+}
+
+func actionMemberRemove(c *cli.Context) {
+	args := c.Args()
+	if len(args) != 1 {
+		fmt.Fprintln(os.Stderr, "Provide a single member ID")
+		os.Exit(1)
+	}
+	removalID := args[0]
+
+	mAPI := mustNewMembersAPI(c)
+
+	ctx, cancel := contextWithTotalTimeout(c)
+	defer cancel()
+	// Get the list of members.
+	members, err := mAPI.List(ctx)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, "Error while verifying ID against known members:", err.Error())
+		os.Exit(1)
+	}
+	// Sanity check the input.
+	foundID := false
+	for _, m := range members {
+		if m.ID == removalID {
+			foundID = true
+		}
+		if m.Name == removalID {
+			// Note that, so long as it's not ambiguous, we *could* do the right thing by name here.
+			fmt.Fprintf(os.Stderr, "Found a member named %s; if this is correct, please use its ID, eg:\n\tetcdctl member remove %s\n", m.Name, m.ID)
+			fmt.Fprintf(os.Stderr, "For more details, read the documentation at https://github.com/coreos/etcd/blob/master/Documentation/runtime-configuration.md#remove-a-member\n\n")
+		}
+	}
+	if !foundID {
+		fmt.Fprintf(os.Stderr, "Couldn't find a member in the cluster with an ID of %s.\n", removalID)
+		os.Exit(1)
+	}
+
+	// Actually attempt to remove the member.
+	err = mAPI.Remove(ctx, removalID)
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "Received an error trying to remove member %s: %s", removalID, err.Error())
+		os.Exit(1)
+	}
+
+	fmt.Printf("Removed member %s from cluster\n", removalID)
+}
+
+func actionMemberUpdate(c *cli.Context) {
+	args := c.Args()
+	if len(args) != 2 {
+		fmt.Fprintln(os.Stderr, "Provide an ID and a list of comma separated peerURL (0xabcd http://example.com,http://example1.com)")
+		os.Exit(1)
+	}
+
+	mAPI := mustNewMembersAPI(c)
+
+	mid := args[0]
+	urls := args[1]
+	ctx, cancel := contextWithTotalTimeout(c)
+	err := mAPI.Update(ctx, mid, strings.Split(urls, ","))
+	cancel()
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	fmt.Printf("Updated member with ID %s in cluster\n", mid)
+}
diff --git a/etcdctl/ctlv2/command/mk_command.go b/etcdctl/ctlv2/command/mk_command.go
new file mode 100644
index 0000000..5e86b07
--- /dev/null
+++ b/etcdctl/ctlv2/command/mk_command.go
@@ -0,0 +1,75 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"os"
+	"time"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+// NewMakeCommand returns the CLI command for "mk".
+func NewMakeCommand() cli.Command {
+	return cli.Command{
+		Name:      "mk",
+		Usage:     "make a new key with a given value",
+		ArgsUsage: "<key> <value>",
+		Flags: []cli.Flag{
+			cli.BoolFlag{Name: "in-order", Usage: "create in-order key under directory <key>"},
+			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
+		},
+		Action: func(c *cli.Context) {
+			mkCommandFunc(c, mustNewKeyAPI(c))
+		},
+	}
+}
+
+// mkCommandFunc executes the "mk" command.
+func mkCommandFunc(c *cli.Context, ki client.KeysAPI) {
+	if len(c.Args()) == 0 {
+		handleError(ExitBadArgs, errors.New("key required"))
+	}
+	key := c.Args()[0]
+	value, err := argOrStdin(c.Args(), os.Stdin, 1)
+	if err != nil {
+		handleError(ExitBadArgs, errors.New("value required"))
+	}
+
+	ttl := c.Int("ttl")
+	inorder := c.Bool("in-order")
+
+	var resp *client.Response
+	ctx, cancel := contextWithTotalTimeout(c)
+	if !inorder {
+		// Since PrevNoExist means that the Node must not exist previously,
+		// this Set method always creates a new key. Therefore, mk command
+		// succeeds only if the key did not previously exist, and the command
+		// prevents one from overwriting values accidentally.
+		resp, err = ki.Set(ctx, key, value, &client.SetOptions{TTL: time.Duration(ttl) * time.Second, PrevExist: client.PrevNoExist})
+	} else {
+		// If in-order flag is specified then create an inorder key under
+		// the directory identified by the key argument.
+		resp, err = ki.CreateInOrder(ctx, key, value, &client.CreateInOrderOptions{TTL: time.Duration(ttl) * time.Second})
+	}
+	cancel()
+	if err != nil {
+		handleError(ExitServerError, err)
+	}
+
+	printResponseKey(resp, c.GlobalString("output"))
+}
diff --git a/etcdctl/ctlv2/command/mkdir_command.go b/etcdctl/ctlv2/command/mkdir_command.go
new file mode 100644
index 0000000..16e5a29
--- /dev/null
+++ b/etcdctl/ctlv2/command/mkdir_command.go
@@ -0,0 +1,55 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"time"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+// NewMakeDirCommand returns the CLI command for "mkdir".
+func NewMakeDirCommand() cli.Command {
+	return cli.Command{
+		Name:      "mkdir",
+		Usage:     "make a new directory",
+		ArgsUsage: "<key>",
+		Flags: []cli.Flag{
+			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
+		},
+		Action: func(c *cli.Context) {
+			mkdirCommandFunc(c, mustNewKeyAPI(c), client.PrevNoExist)
+		},
+	}
+}
+
+// mkdirCommandFunc executes the "mkdir" command.
+func mkdirCommandFunc(c *cli.Context, ki client.KeysAPI, prevExist client.PrevExistType) {
+	if len(c.Args()) == 0 {
+		handleError(ExitBadArgs, errors.New("key required"))
+	}
+
+	key := c.Args()[0]
+	ttl := c.Int("ttl")
+
+	ctx, cancel := contextWithTotalTimeout(c)
+	_, err := ki.Set(ctx, key, "", &client.SetOptions{TTL: time.Duration(ttl) * time.Second, Dir: true, PrevExist: prevExist})
+	cancel()
+	if err != nil {
+		handleError(ExitServerError, err)
+	}
+}
diff --git a/etcdctl/ctlv2/command/rm_command.go b/etcdctl/ctlv2/command/rm_command.go
new file mode 100644
index 0000000..2f39cbe
--- /dev/null
+++ b/etcdctl/ctlv2/command/rm_command.go
@@ -0,0 +1,63 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+// NewRemoveCommand returns the CLI command for "rm".
+func NewRemoveCommand() cli.Command {
+	return cli.Command{
+		Name:      "rm",
+		Usage:     "remove a key or a directory",
+		ArgsUsage: "<key>",
+		Flags: []cli.Flag{
+			cli.BoolFlag{Name: "dir", Usage: "removes the key if it is an empty directory or a key-value pair"},
+			cli.BoolFlag{Name: "recursive", Usage: "removes the key and all child keys(if it is a directory)"},
+			cli.StringFlag{Name: "with-value", Value: "", Usage: "previous value"},
+			cli.IntFlag{Name: "with-index", Value: 0, Usage: "previous index"},
+		},
+		Action: func(c *cli.Context) {
+			rmCommandFunc(c, mustNewKeyAPI(c))
+		},
+	}
+}
+
+// rmCommandFunc executes the "rm" command.
+func rmCommandFunc(c *cli.Context, ki client.KeysAPI) {
+	if len(c.Args()) == 0 {
+		handleError(ExitBadArgs, errors.New("key required"))
+	}
+	key := c.Args()[0]
+	recursive := c.Bool("recursive")
+	dir := c.Bool("dir")
+	prevValue := c.String("with-value")
+	prevIndex := c.Int("with-index")
+
+	ctx, cancel := contextWithTotalTimeout(c)
+	resp, err := ki.Delete(ctx, key, &client.DeleteOptions{PrevIndex: uint64(prevIndex), PrevValue: prevValue, Dir: dir, Recursive: recursive})
+	cancel()
+	if err != nil {
+		handleError(ExitServerError, err)
+	}
+
+	if !resp.Node.Dir {
+		printResponseKey(resp, c.GlobalString("output"))
+	}
+}
diff --git a/etcdctl/ctlv2/command/rmdir_command.go b/etcdctl/ctlv2/command/rmdir_command.go
new file mode 100644
index 0000000..b7b74b5
--- /dev/null
+++ b/etcdctl/ctlv2/command/rmdir_command.go
@@ -0,0 +1,53 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+// NewRemoveDirCommand returns the CLI command for "rmdir".
+func NewRemoveDirCommand() cli.Command {
+	return cli.Command{
+		Name:      "rmdir",
+		Usage:     "removes the key if it is an empty directory or a key-value pair",
+		ArgsUsage: "<key>",
+		Action: func(c *cli.Context) {
+			rmdirCommandFunc(c, mustNewKeyAPI(c))
+		},
+	}
+}
+
+// rmdirCommandFunc executes the "rmdir" command.
+func rmdirCommandFunc(c *cli.Context, ki client.KeysAPI) {
+	if len(c.Args()) == 0 {
+		handleError(ExitBadArgs, errors.New("key required"))
+	}
+	key := c.Args()[0]
+
+	ctx, cancel := contextWithTotalTimeout(c)
+	resp, err := ki.Delete(ctx, key, &client.DeleteOptions{Dir: true})
+	cancel()
+	if err != nil {
+		handleError(ExitServerError, err)
+	}
+
+	if !resp.Node.Dir {
+		printResponseKey(resp, c.GlobalString("output"))
+	}
+}
diff --git a/etcdctl/ctlv2/command/role_commands.go b/etcdctl/ctlv2/command/role_commands.go
new file mode 100644
index 0000000..633f1fb
--- /dev/null
+++ b/etcdctl/ctlv2/command/role_commands.go
@@ -0,0 +1,248 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"os"
+	"reflect"
+	"strings"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+	"github.com/coreos/etcd/pkg/pathutil"
+)
+
+func NewRoleCommands() cli.Command {
+	return cli.Command{
+		Name:  "role",
+		Usage: "role add, grant and revoke subcommands",
+		Subcommands: []cli.Command{
+			{
+				Name:      "add",
+				Usage:     "add a new role for the etcd cluster",
+				ArgsUsage: "<role> ",
+				Action:    actionRoleAdd,
+			},
+			{
+				Name:      "get",
+				Usage:     "get details for a role",
+				ArgsUsage: "<role>",
+				Action:    actionRoleGet,
+			},
+			{
+				Name:      "list",
+				Usage:     "list all roles",
+				ArgsUsage: " ",
+				Action:    actionRoleList,
+			},
+			{
+				Name:      "remove",
+				Usage:     "remove a role from the etcd cluster",
+				ArgsUsage: "<role>",
+				Action:    actionRoleRemove,
+			},
+			{
+				Name:      "grant",
+				Usage:     "grant path matches to an etcd role",
+				ArgsUsage: "<role>",
+				Flags: []cli.Flag{
+					cli.StringFlag{Name: "path", Value: "", Usage: "Path granted for the role to access"},
+					cli.BoolFlag{Name: "read", Usage: "Grant read-only access"},
+					cli.BoolFlag{Name: "write", Usage: "Grant write-only access"},
+					cli.BoolFlag{Name: "readwrite", Usage: "Grant read-write access"},
+				},
+				Action: actionRoleGrant,
+			},
+			{
+				Name:      "revoke",
+				Usage:     "revoke path matches for an etcd role",
+				ArgsUsage: "<role>",
+				Flags: []cli.Flag{
+					cli.StringFlag{Name: "path", Value: "", Usage: "Path revoked for the role to access"},
+					cli.BoolFlag{Name: "read", Usage: "Revoke read access"},
+					cli.BoolFlag{Name: "write", Usage: "Revoke write access"},
+					cli.BoolFlag{Name: "readwrite", Usage: "Revoke read-write access"},
+				},
+				Action: actionRoleRevoke,
+			},
+		},
+	}
+}
+
+func mustNewAuthRoleAPI(c *cli.Context) client.AuthRoleAPI {
+	hc := mustNewClient(c)
+
+	if c.GlobalBool("debug") {
+		fmt.Fprintf(os.Stderr, "Cluster-Endpoints: %s\n", strings.Join(hc.Endpoints(), ", "))
+	}
+
+	return client.NewAuthRoleAPI(hc)
+}
+
+func actionRoleList(c *cli.Context) {
+	if len(c.Args()) != 0 {
+		fmt.Fprintln(os.Stderr, "No arguments accepted")
+		os.Exit(1)
+	}
+	r := mustNewAuthRoleAPI(c)
+	ctx, cancel := contextWithTotalTimeout(c)
+	roles, err := r.ListRoles(ctx)
+	cancel()
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	for _, role := range roles {
+		fmt.Printf("%s\n", role)
+	}
+}
+
+func actionRoleAdd(c *cli.Context) {
+	api, role := mustRoleAPIAndName(c)
+	ctx, cancel := contextWithTotalTimeout(c)
+	defer cancel()
+	currentRole, err := api.GetRole(ctx, role)
+	if currentRole != nil {
+		fmt.Fprintf(os.Stderr, "Role %s already exists\n", role)
+		os.Exit(1)
+	}
+
+	err = api.AddRole(ctx, role)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	fmt.Printf("Role %s created\n", role)
+}
+
+func actionRoleRemove(c *cli.Context) {
+	api, role := mustRoleAPIAndName(c)
+	ctx, cancel := contextWithTotalTimeout(c)
+	err := api.RemoveRole(ctx, role)
+	cancel()
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	fmt.Printf("Role %s removed\n", role)
+}
+
+func actionRoleGrant(c *cli.Context) {
+	roleGrantRevoke(c, true)
+}
+
+func actionRoleRevoke(c *cli.Context) {
+	roleGrantRevoke(c, false)
+}
+
+func roleGrantRevoke(c *cli.Context, grant bool) {
+	path := c.String("path")
+	if path == "" {
+		fmt.Fprintln(os.Stderr, "No path specified; please use `-path`")
+		os.Exit(1)
+	}
+	if pathutil.CanonicalURLPath(path) != path {
+		fmt.Fprintf(os.Stderr, "Not canonical path; please use `-path=%s`\n", pathutil.CanonicalURLPath(path))
+		os.Exit(1)
+	}
+
+	read := c.Bool("read")
+	write := c.Bool("write")
+	rw := c.Bool("readwrite")
+	permcount := 0
+	for _, v := range []bool{read, write, rw} {
+		if v {
+			permcount++
+		}
+	}
+	if permcount != 1 {
+		fmt.Fprintln(os.Stderr, "Please specify exactly one of -read, -write or -readwrite")
+		os.Exit(1)
+	}
+	var permType client.PermissionType
+	switch {
+	case read:
+		permType = client.ReadPermission
+	case write:
+		permType = client.WritePermission
+	case rw:
+		permType = client.ReadWritePermission
+	}
+
+	api, role := mustRoleAPIAndName(c)
+	ctx, cancel := contextWithTotalTimeout(c)
+	defer cancel()
+	currentRole, err := api.GetRole(ctx, role)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+	var newRole *client.Role
+	if grant {
+		newRole, err = api.GrantRoleKV(ctx, role, []string{path}, permType)
+	} else {
+		newRole, err = api.RevokeRoleKV(ctx, role, []string{path}, permType)
+	}
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+	if reflect.DeepEqual(newRole, currentRole) {
+		if grant {
+			fmt.Printf("Role unchanged; already granted")
+		} else {
+			fmt.Printf("Role unchanged; already revoked")
+		}
+	}
+
+	fmt.Printf("Role %s updated\n", role)
+}
+
+func actionRoleGet(c *cli.Context) {
+	api, rolename := mustRoleAPIAndName(c)
+
+	ctx, cancel := contextWithTotalTimeout(c)
+	role, err := api.GetRole(ctx, rolename)
+	cancel()
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+	fmt.Printf("Role: %s\n", role.Role)
+	fmt.Printf("KV Read:\n")
+	for _, v := range role.Permissions.KV.Read {
+		fmt.Printf("\t%s\n", v)
+	}
+	fmt.Printf("KV Write:\n")
+	for _, v := range role.Permissions.KV.Write {
+		fmt.Printf("\t%s\n", v)
+	}
+}
+
+func mustRoleAPIAndName(c *cli.Context) (client.AuthRoleAPI, string) {
+	args := c.Args()
+	if len(args) != 1 {
+		fmt.Fprintln(os.Stderr, "Please provide a role name")
+		os.Exit(1)
+	}
+
+	name := args[0]
+	api := mustNewAuthRoleAPI(c)
+	return api, name
+}
diff --git a/etcdctl/ctlv2/command/set_command.go b/etcdctl/ctlv2/command/set_command.go
new file mode 100644
index 0000000..f0f71c4
--- /dev/null
+++ b/etcdctl/ctlv2/command/set_command.go
@@ -0,0 +1,72 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"os"
+	"time"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+// NewSetCommand returns the CLI command for "set".
+func NewSetCommand() cli.Command {
+	return cli.Command{
+		Name:      "set",
+		Usage:     "set the value of a key",
+		ArgsUsage: "<key> <value>",
+		Description: `Set sets the value of a key.
+
+   When <value> begins with '-', <value> is interpreted as a flag.
+   Insert '--' for workaround:
+
+   $ set -- <key> <value>`,
+		Flags: []cli.Flag{
+			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
+			cli.StringFlag{Name: "swap-with-value", Value: "", Usage: "previous value"},
+			cli.IntFlag{Name: "swap-with-index", Value: 0, Usage: "previous index"},
+		},
+		Action: func(c *cli.Context) {
+			setCommandFunc(c, mustNewKeyAPI(c))
+		},
+	}
+}
+
+// setCommandFunc executes the "set" command.
+func setCommandFunc(c *cli.Context, ki client.KeysAPI) {
+	if len(c.Args()) == 0 {
+		handleError(ExitBadArgs, errors.New("key required"))
+	}
+	key := c.Args()[0]
+	value, err := argOrStdin(c.Args(), os.Stdin, 1)
+	if err != nil {
+		handleError(ExitBadArgs, errors.New("value required"))
+	}
+
+	ttl := c.Int("ttl")
+	prevValue := c.String("swap-with-value")
+	prevIndex := c.Int("swap-with-index")
+
+	ctx, cancel := contextWithTotalTimeout(c)
+	resp, err := ki.Set(ctx, key, value, &client.SetOptions{TTL: time.Duration(ttl) * time.Second, PrevIndex: uint64(prevIndex), PrevValue: prevValue})
+	cancel()
+	if err != nil {
+		handleError(ExitServerError, err)
+	}
+
+	printResponseKey(resp, c.GlobalString("output"))
+}
diff --git a/etcdctl/ctlv2/command/set_dir_command.go b/etcdctl/ctlv2/command/set_dir_command.go
new file mode 100644
index 0000000..04bd2c4
--- /dev/null
+++ b/etcdctl/ctlv2/command/set_dir_command.go
@@ -0,0 +1,35 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+// NewSetDirCommand returns the CLI command for "setDir".
+func NewSetDirCommand() cli.Command {
+	return cli.Command{
+		Name:      "setdir",
+		Usage:     "create a new directory or update an existing directory TTL",
+		ArgsUsage: "<key>",
+		Flags: []cli.Flag{
+			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
+		},
+		Action: func(c *cli.Context) {
+			mkdirCommandFunc(c, mustNewKeyAPI(c), client.PrevIgnore)
+		},
+	}
+}
diff --git a/etcdctl/ctlv2/command/update_command.go b/etcdctl/ctlv2/command/update_command.go
new file mode 100644
index 0000000..b9a7c33
--- /dev/null
+++ b/etcdctl/ctlv2/command/update_command.go
@@ -0,0 +1,62 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"os"
+	"time"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+// NewUpdateCommand returns the CLI command for "update".
+func NewUpdateCommand() cli.Command {
+	return cli.Command{
+		Name:      "update",
+		Usage:     "update an existing key with a given value",
+		ArgsUsage: "<key> <value>",
+		Flags: []cli.Flag{
+			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
+		},
+		Action: func(c *cli.Context) {
+			updateCommandFunc(c, mustNewKeyAPI(c))
+		},
+	}
+}
+
+// updateCommandFunc executes the "update" command.
+func updateCommandFunc(c *cli.Context, ki client.KeysAPI) {
+	if len(c.Args()) == 0 {
+		handleError(ExitBadArgs, errors.New("key required"))
+	}
+	key := c.Args()[0]
+	value, err := argOrStdin(c.Args(), os.Stdin, 1)
+	if err != nil {
+		handleError(ExitBadArgs, errors.New("value required"))
+	}
+
+	ttl := c.Int("ttl")
+
+	ctx, cancel := contextWithTotalTimeout(c)
+	resp, err := ki.Set(ctx, key, value, &client.SetOptions{TTL: time.Duration(ttl) * time.Second, PrevExist: client.PrevExist})
+	cancel()
+	if err != nil {
+		handleError(ExitServerError, err)
+	}
+
+	printResponseKey(resp, c.GlobalString("output"))
+}
diff --git a/etcdctl/ctlv2/command/update_dir_command.go b/etcdctl/ctlv2/command/update_dir_command.go
new file mode 100644
index 0000000..aff18f0
--- /dev/null
+++ b/etcdctl/ctlv2/command/update_dir_command.go
@@ -0,0 +1,53 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"time"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+// NewUpdateDirCommand returns the CLI command for "updatedir".
+func NewUpdateDirCommand() cli.Command {
+	return cli.Command{
+		Name:      "updatedir",
+		Usage:     "update an existing directory",
+		ArgsUsage: "<key> <value>",
+		Flags: []cli.Flag{
+			cli.IntFlag{Name: "ttl", Value: 0, Usage: "key time-to-live"},
+		},
+		Action: func(c *cli.Context) {
+			updatedirCommandFunc(c, mustNewKeyAPI(c))
+		},
+	}
+}
+
+// updatedirCommandFunc executes the "updatedir" command.
+func updatedirCommandFunc(c *cli.Context, ki client.KeysAPI) {
+	if len(c.Args()) == 0 {
+		handleError(ExitBadArgs, errors.New("key required"))
+	}
+	key := c.Args()[0]
+	ttl := c.Int("ttl")
+	ctx, cancel := contextWithTotalTimeout(c)
+	_, err := ki.Set(ctx, key, "", &client.SetOptions{TTL: time.Duration(ttl) * time.Second, Dir: true, PrevExist: client.PrevExist})
+	cancel()
+	if err != nil {
+		handleError(ExitServerError, err)
+	}
+}
diff --git a/etcdctl/ctlv2/command/user_commands.go b/etcdctl/ctlv2/command/user_commands.go
new file mode 100644
index 0000000..2ff6a96
--- /dev/null
+++ b/etcdctl/ctlv2/command/user_commands.go
@@ -0,0 +1,245 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"os"
+	"reflect"
+	"sort"
+	"strings"
+
+	"github.com/bgentry/speakeasy"
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+)
+
+func NewUserCommands() cli.Command {
+	return cli.Command{
+		Name:  "user",
+		Usage: "user add, grant and revoke subcommands",
+		Subcommands: []cli.Command{
+			{
+				Name:      "add",
+				Usage:     "add a new user for the etcd cluster",
+				ArgsUsage: "<user>",
+				Action:    actionUserAdd,
+			},
+			{
+				Name:      "get",
+				Usage:     "get details for a user",
+				ArgsUsage: "<user>",
+				Action:    actionUserGet,
+			},
+			{
+				Name:      "list",
+				Usage:     "list all current users",
+				ArgsUsage: "<user>",
+				Action:    actionUserList,
+			},
+			{
+				Name:      "remove",
+				Usage:     "remove a user for the etcd cluster",
+				ArgsUsage: "<user>",
+				Action:    actionUserRemove,
+			},
+			{
+				Name:      "grant",
+				Usage:     "grant roles to an etcd user",
+				ArgsUsage: "<user>",
+				Flags:     []cli.Flag{cli.StringSliceFlag{Name: "roles", Value: new(cli.StringSlice), Usage: "List of roles to grant or revoke"}},
+				Action:    actionUserGrant,
+			},
+			{
+				Name:      "revoke",
+				Usage:     "revoke roles for an etcd user",
+				ArgsUsage: "<user>",
+				Flags:     []cli.Flag{cli.StringSliceFlag{Name: "roles", Value: new(cli.StringSlice), Usage: "List of roles to grant or revoke"}},
+				Action:    actionUserRevoke,
+			},
+			{
+				Name:      "passwd",
+				Usage:     "change password for a user",
+				ArgsUsage: "<user>",
+				Action:    actionUserPasswd,
+			},
+		},
+	}
+}
+
+func mustNewAuthUserAPI(c *cli.Context) client.AuthUserAPI {
+	hc := mustNewClient(c)
+
+	if c.GlobalBool("debug") {
+		fmt.Fprintf(os.Stderr, "Cluster-Endpoints: %s\n", strings.Join(hc.Endpoints(), ", "))
+	}
+
+	return client.NewAuthUserAPI(hc)
+}
+
+func actionUserList(c *cli.Context) {
+	if len(c.Args()) != 0 {
+		fmt.Fprintln(os.Stderr, "No arguments accepted")
+		os.Exit(1)
+	}
+	u := mustNewAuthUserAPI(c)
+	ctx, cancel := contextWithTotalTimeout(c)
+	users, err := u.ListUsers(ctx)
+	cancel()
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	for _, user := range users {
+		fmt.Printf("%s\n", user)
+	}
+}
+
+func actionUserAdd(c *cli.Context) {
+	api, userarg := mustUserAPIAndName(c)
+	ctx, cancel := contextWithTotalTimeout(c)
+	defer cancel()
+	user, _, _ := getUsernamePassword("", userarg+":")
+	currentUser, err := api.GetUser(ctx, user)
+	if currentUser != nil {
+		fmt.Fprintf(os.Stderr, "User %s already exists\n", user)
+		os.Exit(1)
+	}
+
+	_, pass, err := getUsernamePassword("New password: ", userarg)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, "Error reading password:", err)
+		os.Exit(1)
+	}
+	err = api.AddUser(ctx, user, pass)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	fmt.Printf("User %s created\n", user)
+}
+
+func actionUserRemove(c *cli.Context) {
+	api, user := mustUserAPIAndName(c)
+	ctx, cancel := contextWithTotalTimeout(c)
+	err := api.RemoveUser(ctx, user)
+	cancel()
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	fmt.Printf("User %s removed\n", user)
+}
+
+func actionUserPasswd(c *cli.Context) {
+	api, user := mustUserAPIAndName(c)
+	ctx, cancel := contextWithTotalTimeout(c)
+	defer cancel()
+	currentUser, err := api.GetUser(ctx, user)
+	if currentUser == nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+	pass, err := speakeasy.Ask("New password: ")
+	if err != nil {
+		fmt.Fprintln(os.Stderr, "Error reading password:", err)
+		os.Exit(1)
+	}
+
+	_, err = api.ChangePassword(ctx, user, pass)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	fmt.Printf("Password updated\n")
+}
+
+func actionUserGrant(c *cli.Context) {
+	userGrantRevoke(c, true)
+}
+
+func actionUserRevoke(c *cli.Context) {
+	userGrantRevoke(c, false)
+}
+
+func userGrantRevoke(c *cli.Context, grant bool) {
+	roles := c.StringSlice("roles")
+	if len(roles) == 0 {
+		fmt.Fprintln(os.Stderr, "No roles specified; please use `--roles`")
+		os.Exit(1)
+	}
+
+	ctx, cancel := contextWithTotalTimeout(c)
+	defer cancel()
+
+	api, user := mustUserAPIAndName(c)
+	currentUser, err := api.GetUser(ctx, user)
+	if currentUser == nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	var newUser *client.User
+	if grant {
+		newUser, err = api.GrantUser(ctx, user, roles)
+	} else {
+		newUser, err = api.RevokeUser(ctx, user, roles)
+	}
+	sort.Strings(newUser.Roles)
+	sort.Strings(currentUser.Roles)
+	if reflect.DeepEqual(newUser.Roles, currentUser.Roles) {
+		if grant {
+			fmt.Printf("User unchanged; roles already granted")
+		} else {
+			fmt.Printf("User unchanged; roles already revoked")
+		}
+	}
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	fmt.Printf("User %s updated\n", user)
+}
+
+func actionUserGet(c *cli.Context) {
+	api, username := mustUserAPIAndName(c)
+	ctx, cancel := contextWithTotalTimeout(c)
+	user, err := api.GetUser(ctx, username)
+	cancel()
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+	fmt.Printf("User: %s\n", user.User)
+	fmt.Printf("Roles: %s\n", strings.Join(user.Roles, " "))
+
+}
+
+func mustUserAPIAndName(c *cli.Context) (client.AuthUserAPI, string) {
+	args := c.Args()
+	if len(args) != 1 {
+		fmt.Fprintln(os.Stderr, "Please provide a username")
+		os.Exit(1)
+	}
+
+	api := mustNewAuthUserAPI(c)
+	username := args[0]
+	return api, username
+}
diff --git a/etcdctl/ctlv2/command/util.go b/etcdctl/ctlv2/command/util.go
new file mode 100644
index 0000000..1cca211
--- /dev/null
+++ b/etcdctl/ctlv2/command/util.go
@@ -0,0 +1,373 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"net"
+	"net/http"
+	"net/url"
+	"os"
+	"strings"
+	"syscall"
+	"time"
+
+	"github.com/bgentry/speakeasy"
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+	"github.com/coreos/etcd/pkg/transport"
+	"golang.org/x/net/context"
+)
+
+var (
+	ErrNoAvailSrc = errors.New("no available argument and stdin")
+
+	// the maximum amount of time a dial will wait for a connection to setup.
+	// 30s is long enough for most of the network conditions.
+	defaultDialTimeout = 30 * time.Second
+)
+
+// trimsplit slices s into all substrings separated by sep and returns a
+// slice of the substrings between the separator with all leading and trailing
+// white space removed, as defined by Unicode.
+func trimsplit(s, sep string) []string {
+	raw := strings.Split(s, ",")
+	trimmed := make([]string, 0)
+	for _, r := range raw {
+		trimmed = append(trimmed, strings.TrimSpace(r))
+	}
+	return trimmed
+}
+
+func argOrStdin(args []string, stdin io.Reader, i int) (string, error) {
+	if i < len(args) {
+		return args[i], nil
+	}
+	bytes, err := ioutil.ReadAll(stdin)
+	if string(bytes) == "" || err != nil {
+		return "", ErrNoAvailSrc
+	}
+	return string(bytes), nil
+}
+
+func getPeersFlagValue(c *cli.Context) []string {
+	peerstr := c.GlobalString("endpoints")
+
+	if peerstr == "" {
+		peerstr = os.Getenv("ETCDCTL_ENDPOINTS")
+	}
+
+	if peerstr == "" {
+		peerstr = c.GlobalString("endpoint")
+	}
+
+	if peerstr == "" {
+		peerstr = os.Getenv("ETCDCTL_ENDPOINT")
+	}
+
+	if peerstr == "" {
+		peerstr = c.GlobalString("peers")
+	}
+
+	if peerstr == "" {
+		peerstr = os.Getenv("ETCDCTL_PEERS")
+	}
+
+	// If we still don't have peers, use a default
+	if peerstr == "" {
+		peerstr = "http://127.0.0.1:2379,http://127.0.0.1:4001"
+	}
+
+	return strings.Split(peerstr, ",")
+}
+
+func getDomainDiscoveryFlagValue(c *cli.Context) ([]string, error) {
+	domainstr := c.GlobalString("discovery-srv")
+
+	// Use an environment variable if nothing was supplied on the
+	// command line
+	if domainstr == "" {
+		domainstr = os.Getenv("ETCDCTL_DISCOVERY_SRV")
+	}
+
+	// If we still don't have domain discovery, return nothing
+	if domainstr == "" {
+		return []string{}, nil
+	}
+
+	discoverer := client.NewSRVDiscover()
+	eps, err := discoverer.Discover(domainstr)
+	if err != nil {
+		return nil, err
+	}
+
+	return eps, err
+}
+
+func getEndpoints(c *cli.Context) ([]string, error) {
+	eps, err := getDomainDiscoveryFlagValue(c)
+	if err != nil {
+		return nil, err
+	}
+
+	// If domain discovery returns no endpoints, check peer flag
+	if len(eps) == 0 {
+		eps = getPeersFlagValue(c)
+	}
+
+	for i, ep := range eps {
+		u, err := url.Parse(ep)
+		if err != nil {
+			return nil, err
+		}
+
+		if u.Scheme == "" {
+			u.Scheme = "http"
+		}
+
+		eps[i] = u.String()
+	}
+
+	return eps, nil
+}
+
+func getTransport(c *cli.Context) (*http.Transport, error) {
+	cafile := c.GlobalString("ca-file")
+	certfile := c.GlobalString("cert-file")
+	keyfile := c.GlobalString("key-file")
+
+	// Use an environment variable if nothing was supplied on the
+	// command line
+	if cafile == "" {
+		cafile = os.Getenv("ETCDCTL_CA_FILE")
+	}
+	if certfile == "" {
+		certfile = os.Getenv("ETCDCTL_CERT_FILE")
+	}
+	if keyfile == "" {
+		keyfile = os.Getenv("ETCDCTL_KEY_FILE")
+	}
+
+	tls := transport.TLSInfo{
+		CAFile:   cafile,
+		CertFile: certfile,
+		KeyFile:  keyfile,
+	}
+	return transport.NewTransport(tls, defaultDialTimeout)
+}
+
+func getUsernamePasswordFromFlag(usernameFlag string) (username string, password string, err error) {
+	return getUsernamePassword("Password: ", usernameFlag)
+}
+
+func getUsernamePassword(prompt, usernameFlag string) (username string, password string, err error) {
+	colon := strings.Index(usernameFlag, ":")
+	if colon == -1 {
+		username = usernameFlag
+		// Prompt for the password.
+		password, err = speakeasy.Ask(prompt)
+		if err != nil {
+			return "", "", err
+		}
+	} else {
+		username = usernameFlag[:colon]
+		password = usernameFlag[colon+1:]
+	}
+	return username, password, nil
+}
+
+func mustNewKeyAPI(c *cli.Context) client.KeysAPI {
+	return client.NewKeysAPI(mustNewClient(c))
+}
+
+func mustNewMembersAPI(c *cli.Context) client.MembersAPI {
+	return client.NewMembersAPI(mustNewClient(c))
+}
+
+func mustNewClient(c *cli.Context) client.Client {
+	hc, err := newClient(c)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	debug := c.GlobalBool("debug")
+	if debug {
+		client.EnablecURLDebug()
+	}
+
+	if !c.GlobalBool("no-sync") {
+		if debug {
+			fmt.Fprintf(os.Stderr, "start to sync cluster using endpoints(%s)\n", strings.Join(hc.Endpoints(), ","))
+		}
+		ctx, cancel := context.WithTimeout(context.Background(), client.DefaultRequestTimeout)
+		err := hc.Sync(ctx)
+		cancel()
+		if err != nil {
+			if err == client.ErrNoEndpoints {
+				fmt.Fprintf(os.Stderr, "etcd cluster has no published client endpoints.\n")
+				fmt.Fprintf(os.Stderr, "Try '--no-sync' if you want to access non-published client endpoints(%s).\n", strings.Join(hc.Endpoints(), ","))
+				handleError(ExitServerError, err)
+			}
+
+			if isConnectionError(err) {
+				handleError(ExitBadConnection, err)
+			}
+
+			// fail-back to try sync cluster with peer API. this is for making etcdctl work with etcd 0.4.x.
+			// TODO: remove this when we deprecate the support for etcd 0.4.
+			eps, serr := syncWithPeerAPI(c, ctx, hc.Endpoints())
+			if serr != nil {
+				if isConnectionError(serr) {
+					handleError(ExitBadConnection, serr)
+				} else {
+					handleError(ExitServerError, serr)
+				}
+			}
+			err = hc.SetEndpoints(eps)
+			if err != nil {
+				handleError(ExitServerError, err)
+			}
+		}
+		if debug {
+			fmt.Fprintf(os.Stderr, "got endpoints(%s) after sync\n", strings.Join(hc.Endpoints(), ","))
+		}
+	}
+
+	if debug {
+		fmt.Fprintf(os.Stderr, "Cluster-Endpoints: %s\n", strings.Join(hc.Endpoints(), ", "))
+	}
+
+	return hc
+}
+
+func isConnectionError(err error) bool {
+	switch t := err.(type) {
+	case *client.ClusterError:
+		for _, cerr := range t.Errors {
+			if !isConnectionError(cerr) {
+				return false
+			}
+		}
+		return true
+	case *net.OpError:
+		if t.Op == "dial" || t.Op == "read" {
+			return true
+		}
+		return isConnectionError(t.Err)
+	case net.Error:
+		if t.Timeout() {
+			return true
+		}
+	case syscall.Errno:
+		if t == syscall.ECONNREFUSED {
+			return true
+		}
+	}
+	return false
+}
+
+func mustNewClientNoSync(c *cli.Context) client.Client {
+	hc, err := newClient(c)
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err.Error())
+		os.Exit(1)
+	}
+
+	if c.GlobalBool("debug") {
+		fmt.Fprintf(os.Stderr, "Cluster-Endpoints: %s\n", strings.Join(hc.Endpoints(), ", "))
+		client.EnablecURLDebug()
+	}
+
+	return hc
+}
+
+func newClient(c *cli.Context) (client.Client, error) {
+	eps, err := getEndpoints(c)
+	if err != nil {
+		return nil, err
+	}
+
+	tr, err := getTransport(c)
+	if err != nil {
+		return nil, err
+	}
+
+	cfg := client.Config{
+		Transport:               tr,
+		Endpoints:               eps,
+		HeaderTimeoutPerRequest: c.GlobalDuration("timeout"),
+	}
+
+	uFlag := c.GlobalString("username")
+	if uFlag != "" {
+		username, password, err := getUsernamePasswordFromFlag(uFlag)
+		if err != nil {
+			return nil, err
+		}
+		cfg.Username = username
+		cfg.Password = password
+	}
+
+	return client.New(cfg)
+}
+
+func contextWithTotalTimeout(c *cli.Context) (context.Context, context.CancelFunc) {
+	return context.WithTimeout(context.Background(), c.GlobalDuration("total-timeout"))
+}
+
+// syncWithPeerAPI syncs cluster with peer API defined at
+// https://github.com/coreos/etcd/blob/v0.4.9/server/server.go#L311.
+// This exists for backward compatibility with etcd 0.4.x.
+func syncWithPeerAPI(c *cli.Context, ctx context.Context, knownPeers []string) ([]string, error) {
+	tr, err := getTransport(c)
+	if err != nil {
+		return nil, err
+	}
+
+	var (
+		body []byte
+		resp *http.Response
+	)
+	for _, p := range knownPeers {
+		var req *http.Request
+		req, err = http.NewRequest("GET", p+"/v2/peers", nil)
+		if err != nil {
+			continue
+		}
+		resp, err = tr.RoundTrip(req)
+		if err != nil {
+			continue
+		}
+		if resp.StatusCode != http.StatusOK {
+			resp.Body.Close()
+			continue
+		}
+		body, err = ioutil.ReadAll(resp.Body)
+		resp.Body.Close()
+		if err == nil {
+			break
+		}
+	}
+	if err != nil {
+		return nil, err
+	}
+
+	// Parse the peers API format: https://github.com/coreos/etcd/blob/v0.4.9/server/server.go#L311
+	return strings.Split(string(body), ", "), nil
+}
diff --git a/etcdctl/ctlv2/command/util_test.go b/etcdctl/ctlv2/command/util_test.go
new file mode 100644
index 0000000..bf5357e
--- /dev/null
+++ b/etcdctl/ctlv2/command/util_test.go
@@ -0,0 +1,70 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"bytes"
+	"testing"
+)
+
+func TestArgOrStdin(t *testing.T) {
+	tests := []struct {
+		args  []string
+		stdin string
+		i     int
+		w     string
+		we    error
+	}{
+		{
+			args: []string{
+				"a",
+			},
+			stdin: "b",
+			i:     0,
+			w:     "a",
+			we:    nil,
+		},
+		{
+			args: []string{
+				"a",
+			},
+			stdin: "b",
+			i:     1,
+			w:     "b",
+			we:    nil,
+		},
+		{
+			args: []string{
+				"a",
+			},
+			stdin: "",
+			i:     1,
+			w:     "",
+			we:    ErrNoAvailSrc,
+		},
+	}
+
+	for i, tt := range tests {
+		var b bytes.Buffer
+		b.Write([]byte(tt.stdin))
+		g, ge := argOrStdin(tt.args, &b, tt.i)
+		if g != tt.w {
+			t.Errorf("#%d: expect %v, not %v", i, tt.w, g)
+		}
+		if ge != tt.we {
+			t.Errorf("#%d: expect %v, not %v", i, tt.we, ge)
+		}
+	}
+}
diff --git a/etcdctl/ctlv2/command/watch_command.go b/etcdctl/ctlv2/command/watch_command.go
new file mode 100644
index 0000000..2f17f25
--- /dev/null
+++ b/etcdctl/ctlv2/command/watch_command.go
@@ -0,0 +1,84 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"fmt"
+	"os"
+	"os/signal"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/client"
+	"golang.org/x/net/context"
+)
+
+// NewWatchCommand returns the CLI command for "watch".
+func NewWatchCommand() cli.Command {
+	return cli.Command{
+		Name:      "watch",
+		Usage:     "watch a key for changes",
+		ArgsUsage: "<key>",
+		Flags: []cli.Flag{
+			cli.BoolFlag{Name: "forever", Usage: "forever watch a key until CTRL+C"},
+			cli.IntFlag{Name: "after-index", Value: 0, Usage: "watch after the given index"},
+			cli.BoolFlag{Name: "recursive", Usage: "returns all values for key and child keys"},
+		},
+		Action: func(c *cli.Context) {
+			watchCommandFunc(c, mustNewKeyAPI(c))
+		},
+	}
+}
+
+// watchCommandFunc executes the "watch" command.
+func watchCommandFunc(c *cli.Context, ki client.KeysAPI) {
+	if len(c.Args()) == 0 {
+		handleError(ExitBadArgs, errors.New("key required"))
+	}
+	key := c.Args()[0]
+	recursive := c.Bool("recursive")
+	forever := c.Bool("forever")
+	index := c.Int("after-index")
+
+	stop := false
+	w := ki.Watcher(key, &client.WatcherOptions{AfterIndex: uint64(index), Recursive: recursive})
+
+	sigch := make(chan os.Signal, 1)
+	signal.Notify(sigch, os.Interrupt)
+
+	go func() {
+		<-sigch
+		os.Exit(0)
+	}()
+
+	for !stop {
+		resp, err := w.Next(context.TODO())
+		if err != nil {
+			handleError(ExitServerError, err)
+		}
+		if resp.Node.Dir {
+			continue
+		}
+		if recursive {
+			fmt.Printf("[%s] %s\n", resp.Action, resp.Node.Key)
+		}
+
+		printResponseKey(resp, c.GlobalString("output"))
+
+		if !forever {
+			stop = true
+		}
+	}
+}
diff --git a/etcdctl/ctlv2/ctl.go b/etcdctl/ctlv2/ctl.go
new file mode 100644
index 0000000..f68de6a
--- /dev/null
+++ b/etcdctl/ctlv2/ctl.go
@@ -0,0 +1,70 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package ctlv2 contains the main entry point for the etcdctl for v2 API.
+package ctlv2
+
+import (
+	"os"
+	"time"
+
+	"github.com/codegangsta/cli"
+	"github.com/coreos/etcd/etcdctl/ctlv2/command"
+	"github.com/coreos/etcd/version"
+)
+
+func Start() {
+	app := cli.NewApp()
+	app.Name = "etcdctl"
+	app.Version = version.Version
+	app.Usage = "A simple command line client for etcd."
+	app.Flags = []cli.Flag{
+		cli.BoolFlag{Name: "debug", Usage: "output cURL commands which can be used to reproduce the request"},
+		cli.BoolFlag{Name: "no-sync", Usage: "don't synchronize cluster information before sending request"},
+		cli.StringFlag{Name: "output, o", Value: "simple", Usage: "output response in the given format (`simple`, `extended` or `json`)"},
+		cli.StringFlag{Name: "discovery-srv, D", Usage: "domain name to query for SRV records describing cluster endpoints"},
+		cli.StringFlag{Name: "peers, C", Value: "", Usage: "DEPRECATED - \"--endpoints\" should be used instead"},
+		cli.StringFlag{Name: "endpoint", Value: "", Usage: "DEPRECATED - \"--endpoints\" should be used instead"},
+		cli.StringFlag{Name: "endpoints", Value: "", Usage: "a comma-delimited list of machine addresses in the cluster (default: \"http://127.0.0.1:2379,http://127.0.0.1:4001\")"},
+		cli.StringFlag{Name: "cert-file", Value: "", Usage: "identify HTTPS client using this SSL certificate file"},
+		cli.StringFlag{Name: "key-file", Value: "", Usage: "identify HTTPS client using this SSL key file"},
+		cli.StringFlag{Name: "ca-file", Value: "", Usage: "verify certificates of HTTPS-enabled servers using this CA bundle"},
+		cli.StringFlag{Name: "username, u", Value: "", Usage: "provide username[:password] and prompt if password is not supplied."},
+		cli.DurationFlag{Name: "timeout", Value: time.Second, Usage: "connection timeout per request"},
+		cli.DurationFlag{Name: "total-timeout", Value: 5 * time.Second, Usage: "timeout for the command execution (except watch)"},
+	}
+	app.Commands = []cli.Command{
+		command.NewBackupCommand(),
+		command.NewClusterHealthCommand(),
+		command.NewMakeCommand(),
+		command.NewMakeDirCommand(),
+		command.NewRemoveCommand(),
+		command.NewRemoveDirCommand(),
+		command.NewGetCommand(),
+		command.NewLsCommand(),
+		command.NewSetCommand(),
+		command.NewSetDirCommand(),
+		command.NewUpdateCommand(),
+		command.NewUpdateDirCommand(),
+		command.NewWatchCommand(),
+		command.NewExecWatchCommand(),
+		command.NewMemberCommand(),
+		command.NewImportSnapCommand(),
+		command.NewUserCommands(),
+		command.NewRoleCommands(),
+		command.NewAuthCommands(),
+	}
+
+	app.Run(os.Args)
+}
diff --git a/etcdctl/ctlv3/command/auth_command.go b/etcdctl/ctlv3/command/auth_command.go
new file mode 100644
index 0000000..cf7d21f
--- /dev/null
+++ b/etcdctl/ctlv3/command/auth_command.go
@@ -0,0 +1,55 @@
+// Copyright 2016 Nippon Telegraph and Telephone Corporation.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+
+	"github.com/spf13/cobra"
+)
+
+// NewAuthCommand returns the cobra command for "auth".
+func NewAuthCommand() *cobra.Command {
+	ac := &cobra.Command{
+		Use:   "auth <enable or disable>",
+		Short: "Enable or disable authentication.",
+	}
+
+	ac.AddCommand(NewAuthEnableCommand())
+
+	return ac
+}
+
+func NewAuthEnableCommand() *cobra.Command {
+	return &cobra.Command{
+		Use:   "enable",
+		Short: "enable authentication",
+		Run:   authEnableCommandFunc,
+	}
+}
+
+// authEnableCommandFunc executes the "auth enable" command.
+func authEnableCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 0 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("auth enable command does not accept argument."))
+	}
+
+	ctx, cancel := commandCtx(cmd)
+	_, err := mustClientFromCmd(cmd).Auth.AuthEnable(ctx)
+	cancel()
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+}
diff --git a/etcdctl/ctlv3/command/compaction_command.go b/etcdctl/ctlv3/command/compaction_command.go
new file mode 100644
index 0000000..366e3e2
--- /dev/null
+++ b/etcdctl/ctlv3/command/compaction_command.go
@@ -0,0 +1,53 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"strconv"
+
+	"github.com/spf13/cobra"
+)
+
+// NewCompactionCommand returns the cobra command for "compaction".
+func NewCompactionCommand() *cobra.Command {
+	return &cobra.Command{
+		Use:   "compaction <revision>",
+		Short: "Compaction compacts the event history in etcd.",
+		Run:   compactionCommandFunc,
+	}
+}
+
+// compactionCommandFunc executes the "compaction" command.
+func compactionCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 1 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("compaction command needs 1 argument."))
+	}
+
+	rev, err := strconv.ParseInt(args[0], 10, 64)
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+
+	c := mustClientFromCmd(cmd)
+	ctx, cancel := commandCtx(cmd)
+	cerr := c.Compact(ctx, rev)
+	cancel()
+	if cerr != nil {
+		ExitWithError(ExitError, cerr)
+		return
+	}
+	fmt.Println("compacted revision", rev)
+}
diff --git a/etcdctl/ctlv3/command/defrag_command.go b/etcdctl/ctlv3/command/defrag_command.go
new file mode 100644
index 0000000..3a8e40d
--- /dev/null
+++ b/etcdctl/ctlv3/command/defrag_command.go
@@ -0,0 +1,45 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"os"
+
+	"github.com/spf13/cobra"
+)
+
+// NewDefragCommand returns the cobra command for "Defrag".
+func NewDefragCommand() *cobra.Command {
+	return &cobra.Command{
+		Use:   "defrag",
+		Short: "defrag defragments the storage of the etcd members with given endpoints.",
+		Run:   defragCommandFunc,
+	}
+}
+
+func defragCommandFunc(cmd *cobra.Command, args []string) {
+	c := mustClientFromCmd(cmd)
+	for _, ep := range c.Endpoints() {
+		ctx, cancel := commandCtx(cmd)
+		_, err := c.Defragment(ctx, ep)
+		cancel()
+		if err != nil {
+			fmt.Fprintf(os.Stderr, "Failed to defragment etcd member[%s] (%v)\n", ep, err)
+		} else {
+			fmt.Printf("Finished defragmenting etcd member[%s]\n", ep)
+		}
+	}
+}
diff --git a/etcdctl/ctlv3/command/del_command.go b/etcdctl/ctlv3/command/del_command.go
new file mode 100644
index 0000000..6076667
--- /dev/null
+++ b/etcdctl/ctlv3/command/del_command.go
@@ -0,0 +1,55 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/spf13/cobra"
+)
+
+// NewDelCommand returns the cobra command for "del".
+func NewDelCommand() *cobra.Command {
+	return &cobra.Command{
+		Use:   "del [options] <key> [range_end]",
+		Short: "Removes the specified key or range of keys [key, range_end).",
+		Run:   delCommandFunc,
+	}
+}
+
+// delCommandFunc executes the "del" command.
+func delCommandFunc(cmd *cobra.Command, args []string) {
+	key, opts := getDelOp(cmd, args)
+	ctx, cancel := commandCtx(cmd)
+	resp, err := mustClientFromCmd(cmd).Delete(ctx, key, opts...)
+	cancel()
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+	display.Del(*resp)
+}
+
+func getDelOp(cmd *cobra.Command, args []string) (string, []clientv3.OpOption) {
+	if len(args) == 0 || len(args) > 2 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("del command needs one argument as key and an optional argument as range_end."))
+	}
+	opts := []clientv3.OpOption{}
+	key := args[0]
+	if len(args) > 1 {
+		opts = append(opts, clientv3.WithRange(args[1]))
+	}
+	return key, opts
+}
diff --git a/etcdctl/ctlv3/command/doc.go b/etcdctl/ctlv3/command/doc.go
new file mode 100644
index 0000000..b9420fe
--- /dev/null
+++ b/etcdctl/ctlv3/command/doc.go
@@ -0,0 +1,16 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package command is a set of libraries for etcd v3 commands.
+package command
diff --git a/etcdctl/ctlv3/command/elect_command.go b/etcdctl/ctlv3/command/elect_command.go
new file mode 100644
index 0000000..e3e3cd4
--- /dev/null
+++ b/etcdctl/ctlv3/command/elect_command.go
@@ -0,0 +1,132 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"os"
+	"os/signal"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/coreos/etcd/clientv3/concurrency"
+	"github.com/spf13/cobra"
+	"golang.org/x/net/context"
+)
+
+var (
+	electListen bool
+)
+
+// NewElectCommand returns the cobra command for "elect".
+func NewElectCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "elect <election-name> [proposal]",
+		Short: "elect observes and participates in leader election",
+		Run:   electCommandFunc,
+	}
+	cmd.Flags().BoolVarP(&electListen, "listen", "l", false, "observation mode")
+	return cmd
+}
+
+func electCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 1 && len(args) != 2 {
+		ExitWithError(ExitBadArgs, errors.New("elect takes one election name argument and an optional proposal argument."))
+	}
+	c := mustClientFromCmd(cmd)
+
+	var err error
+	if len(args) == 1 {
+		if !electListen {
+			ExitWithError(ExitBadArgs, errors.New("no proposal argument but -l not set"))
+		}
+		err = observe(c, args[0])
+	} else {
+		if electListen {
+			ExitWithError(ExitBadArgs, errors.New("proposal given but -l is set"))
+		}
+		err = campaign(c, args[0], args[1])
+	}
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+}
+
+func observe(c *clientv3.Client, election string) error {
+	e := concurrency.NewElection(c, election)
+	ctx, cancel := context.WithCancel(context.TODO())
+
+	donec := make(chan struct{})
+	sigc := make(chan os.Signal, 1)
+	signal.Notify(sigc, os.Interrupt, os.Kill)
+	go func() {
+		<-sigc
+		cancel()
+	}()
+
+	go func() {
+		for resp := range e.Observe(ctx) {
+			display.Get(resp)
+		}
+		close(donec)
+	}()
+
+	<-donec
+
+	select {
+	case <-ctx.Done():
+	default:
+		return errors.New("elect: observer lost")
+	}
+
+	return nil
+}
+
+func campaign(c *clientv3.Client, election string, prop string) error {
+	e := concurrency.NewElection(c, election)
+	ctx, cancel := context.WithCancel(context.TODO())
+
+	donec := make(chan struct{})
+	sigc := make(chan os.Signal, 1)
+	signal.Notify(sigc, os.Interrupt, os.Kill)
+	go func() {
+		<-sigc
+		cancel()
+		close(donec)
+	}()
+
+	s, serr := concurrency.NewSession(c)
+	if serr != nil {
+		return serr
+	}
+
+	if err := e.Campaign(ctx, prop); err != nil {
+		return err
+	}
+
+	// print key since elected
+	resp, err := c.Get(ctx, e.Key())
+	if err != nil {
+		return err
+	}
+	display.Get(*resp)
+
+	select {
+	case <-donec:
+	case <-s.Done():
+		return errors.New("elect: session expired")
+	}
+
+	return e.Resign()
+}
diff --git a/etcdctl/ctlv3/command/ep_health_command.go b/etcdctl/ctlv3/command/ep_health_command.go
new file mode 100644
index 0000000..64a57be
--- /dev/null
+++ b/etcdctl/ctlv3/command/ep_health_command.go
@@ -0,0 +1,83 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"sync"
+	"time"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/coreos/etcd/pkg/flags"
+	"github.com/spf13/cobra"
+)
+
+// NewEpHealthCommand returns the cobra command for "endpoint-health".
+func NewEpHealthCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "endpoint-health",
+		Short: "endpoint-health checks the healthiness of endpoints specified in `--endpoints` flag",
+		Run:   epHealthCommandFunc,
+	}
+	return cmd
+}
+
+// epHealthCommandFunc executes the "endpoint-health" command.
+func epHealthCommandFunc(cmd *cobra.Command, args []string) {
+	flags.SetPflagsFromEnv("ETCDCTL", cmd.InheritedFlags())
+	endpoints, err := cmd.Flags().GetStringSlice("endpoints")
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+
+	sec := secureCfgFromCmd(cmd)
+	dt := dialTimeoutFromCmd(cmd)
+	cfgs := []*clientv3.Config{}
+	for _, ep := range endpoints {
+		cfg, err := newClientCfg([]string{ep}, dt, sec)
+		if err != nil {
+			ExitWithError(ExitBadArgs, err)
+		}
+		cfgs = append(cfgs, cfg)
+	}
+
+	var wg sync.WaitGroup
+
+	for _, cfg := range cfgs {
+		wg.Add(1)
+		go func(cfg *clientv3.Config) {
+			defer wg.Done()
+			ep := cfg.Endpoints[0]
+			cli, err := clientv3.New(*cfg)
+			if err != nil {
+				fmt.Printf("%s is unhealthy: failed to connect: %v\n", ep, err)
+				return
+			}
+			st := time.Now()
+			// get a random key. As long as we can get the response without an error, the
+			// endpoint is health.
+			ctx, cancel := commandCtx(cmd)
+			_, err = cli.Get(ctx, "health")
+			cancel()
+			if err != nil {
+				fmt.Printf("%s is unhealthy: failed to commit proposal: %v\n", ep, err)
+			} else {
+				fmt.Printf("%s is healthy: successfully committed proposal: took = %v\n", ep, time.Since(st))
+			}
+		}(cfg)
+	}
+
+	wg.Wait()
+}
diff --git a/etcdctl/ctlv3/command/error.go b/etcdctl/ctlv3/command/error.go
new file mode 100644
index 0000000..2643329
--- /dev/null
+++ b/etcdctl/ctlv3/command/error.go
@@ -0,0 +1,42 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"os"
+
+	"github.com/coreos/etcd/client"
+)
+
+const (
+	// http://tldp.org/LDP/abs/html/exitcodes.html
+	ExitSuccess = iota
+	ExitError
+	ExitBadConnection
+	ExitInvalidInput // for txn, watch command
+	ExitBadFeature   // provided a valid flag with an unsupported value
+	ExitInterrupted
+	ExitIO
+	ExitBadArgs = 128
+)
+
+func ExitWithError(code int, err error) {
+	fmt.Fprintln(os.Stderr, "Error: ", err)
+	if cerr, ok := err.(*client.ClusterError); ok {
+		fmt.Fprintln(os.Stderr, cerr.Detail())
+	}
+	os.Exit(code)
+}
diff --git a/etcdctl/ctlv3/command/get_command.go b/etcdctl/ctlv3/command/get_command.go
new file mode 100644
index 0000000..42405cb
--- /dev/null
+++ b/etcdctl/ctlv3/command/get_command.go
@@ -0,0 +1,135 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/spf13/cobra"
+)
+
+var (
+	getConsistency string
+	getLimit       int64
+	getSortOrder   string
+	getSortTarget  string
+	getPrefix      bool
+	getFromKey     bool
+)
+
+// NewGetCommand returns the cobra command for "get".
+func NewGetCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "get [options] <key> [range_end]",
+		Short: "Get gets the key or a range of keys.",
+		Run:   getCommandFunc,
+	}
+
+	cmd.Flags().StringVar(&getConsistency, "consistency", "l", "Linearizable(l) or Serializable(s)")
+	cmd.Flags().StringVar(&getSortOrder, "order", "", "order of results; ASCEND or DESCEND")
+	cmd.Flags().StringVar(&getSortTarget, "sort-by", "", "sort target; CREATE, KEY, MODIFY, VALUE, or VERSION")
+	cmd.Flags().Int64Var(&getLimit, "limit", 0, "maximum number of results")
+	cmd.Flags().BoolVar(&getPrefix, "prefix", false, "get keys with matching prefix")
+	cmd.Flags().BoolVar(&getFromKey, "from-key", false, "get keys that are greater than or equal to the given key")
+	return cmd
+}
+
+// getCommandFunc executes the "get" command.
+func getCommandFunc(cmd *cobra.Command, args []string) {
+	key, opts := getGetOp(cmd, args)
+	ctx, cancel := commandCtx(cmd)
+	resp, err := mustClientFromCmd(cmd).Get(ctx, key, opts...)
+	cancel()
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+
+	display.Get(*resp)
+}
+
+func getGetOp(cmd *cobra.Command, args []string) (string, []clientv3.OpOption) {
+	if len(args) == 0 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("range command needs arguments."))
+	}
+
+	if getPrefix && getFromKey {
+		ExitWithError(ExitBadArgs, fmt.Errorf("`--prefix` and `--from-key` cannot be set at the same time, choose one."))
+	}
+
+	opts := []clientv3.OpOption{}
+	switch getConsistency {
+	case "s":
+		opts = append(opts, clientv3.WithSerializable())
+	case "l":
+	default:
+		ExitWithError(ExitBadFeature, fmt.Errorf("unknown consistency flag %q", getConsistency))
+	}
+
+	key := args[0]
+	if len(args) > 1 {
+		if getPrefix || getFromKey {
+			ExitWithError(ExitBadArgs, fmt.Errorf("too many arguments, only accept one arguement when `--prefix` or `--from-key` is set."))
+		}
+		opts = append(opts, clientv3.WithRange(args[1]))
+	}
+
+	opts = append(opts, clientv3.WithLimit(getLimit))
+
+	sortByOrder := clientv3.SortNone
+	sortOrder := strings.ToUpper(getSortOrder)
+	switch {
+	case sortOrder == "ASCEND":
+		sortByOrder = clientv3.SortAscend
+	case sortOrder == "DESCEND":
+		sortByOrder = clientv3.SortDescend
+	case sortOrder == "":
+		// nothing
+	default:
+		ExitWithError(ExitBadFeature, fmt.Errorf("bad sort order %v", getSortOrder))
+	}
+
+	sortByTarget := clientv3.SortByKey
+	sortTarget := strings.ToUpper(getSortTarget)
+	switch {
+	case sortTarget == "CREATE":
+		sortByTarget = clientv3.SortByCreateRevision
+	case sortTarget == "KEY":
+		sortByTarget = clientv3.SortByKey
+	case sortTarget == "MODIFY":
+		sortByTarget = clientv3.SortByModRevision
+	case sortTarget == "VALUE":
+		sortByTarget = clientv3.SortByValue
+	case sortTarget == "VERSION":
+		sortByTarget = clientv3.SortByVersion
+	case sortTarget == "":
+		// nothing
+	default:
+		ExitWithError(ExitBadFeature, fmt.Errorf("bad sort target %v", getSortTarget))
+	}
+
+	opts = append(opts, clientv3.WithSort(sortByTarget, sortByOrder))
+
+	if getPrefix {
+		opts = append(opts, clientv3.WithPrefix())
+	}
+
+	if getFromKey {
+		opts = append(opts, clientv3.WithFromKey())
+	}
+
+	return key, opts
+}
diff --git a/etcdctl/ctlv3/command/global.go b/etcdctl/ctlv3/command/global.go
new file mode 100644
index 0000000..13a4531
--- /dev/null
+++ b/etcdctl/ctlv3/command/global.go
@@ -0,0 +1,199 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"crypto/tls"
+	"errors"
+	"io"
+	"io/ioutil"
+	"time"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/coreos/etcd/pkg/flags"
+	"github.com/coreos/etcd/pkg/transport"
+	"github.com/spf13/cobra"
+)
+
+// GlobalFlags are flags that defined globally
+// and are inherited to all sub-commands.
+type GlobalFlags struct {
+	Insecure           bool
+	InsecureSkipVerify bool
+	Endpoints          []string
+	DialTimeout        time.Duration
+	CommandTimeOut     time.Duration
+
+	TLS transport.TLSInfo
+
+	OutputFormat string
+	IsHex        bool
+}
+
+type secureCfg struct {
+	cert   string
+	key    string
+	cacert string
+
+	insecureTransport  bool
+	insecureSkipVerify bool
+}
+
+var display printer = &simplePrinter{}
+
+func mustClientFromCmd(cmd *cobra.Command) *clientv3.Client {
+	flags.SetPflagsFromEnv("ETCDCTL", cmd.InheritedFlags())
+
+	endpoints, err := cmd.Flags().GetStringSlice("endpoints")
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+	dialTimeout := dialTimeoutFromCmd(cmd)
+	sec := secureCfgFromCmd(cmd)
+
+	return mustClient(endpoints, dialTimeout, sec)
+}
+
+func mustClient(endpoints []string, dialTimeout time.Duration, scfg *secureCfg) *clientv3.Client {
+	cfg, err := newClientCfg(endpoints, dialTimeout, scfg)
+	if err != nil {
+		ExitWithError(ExitBadArgs, err)
+	}
+
+	client, err := clientv3.New(*cfg)
+	if err != nil {
+		ExitWithError(ExitBadConnection, err)
+	}
+
+	return client
+}
+
+func newClientCfg(endpoints []string, dialTimeout time.Duration, scfg *secureCfg) (*clientv3.Config, error) {
+	// set tls if any one tls option set
+	var cfgtls *transport.TLSInfo
+	tlsinfo := transport.TLSInfo{}
+	if scfg.cert != "" {
+		tlsinfo.CertFile = scfg.cert
+		cfgtls = &tlsinfo
+	}
+
+	if scfg.key != "" {
+		tlsinfo.KeyFile = scfg.key
+		cfgtls = &tlsinfo
+	}
+
+	if scfg.cacert != "" {
+		tlsinfo.CAFile = scfg.cacert
+		cfgtls = &tlsinfo
+	}
+
+	cfg := &clientv3.Config{
+		Endpoints:   endpoints,
+		DialTimeout: dialTimeout,
+	}
+	if cfgtls != nil {
+		clientTLS, err := cfgtls.ClientConfig()
+		if err != nil {
+			return nil, err
+		}
+		cfg.TLS = clientTLS
+	}
+	// if key/cert is not given but user wants secure connection, we
+	// should still setup an empty tls configuration for gRPC to setup
+	// secure connection.
+	if cfg.TLS == nil && !scfg.insecureTransport {
+		cfg.TLS = &tls.Config{}
+	}
+
+	// If the user wants to skip TLS verification then we should set
+	// the InsecureSkipVerify flag in tls configuration.
+	if scfg.insecureSkipVerify && cfg.TLS != nil {
+		cfg.TLS.InsecureSkipVerify = true
+	}
+	return cfg, nil
+}
+
+func argOrStdin(args []string, stdin io.Reader, i int) (string, error) {
+	if i < len(args) {
+		return args[i], nil
+	}
+	bytes, err := ioutil.ReadAll(stdin)
+	if string(bytes) == "" || err != nil {
+		return "", errors.New("no available argument and stdin")
+	}
+	return string(bytes), nil
+}
+
+func dialTimeoutFromCmd(cmd *cobra.Command) time.Duration {
+	dialTimeout, err := cmd.Flags().GetDuration("dial-timeout")
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+	return dialTimeout
+}
+
+func secureCfgFromCmd(cmd *cobra.Command) *secureCfg {
+	cert, key, cacert := keyAndCertFromCmd(cmd)
+	insecureTr := insecureTransportFromCmd(cmd)
+	skipVerify := insecureSkipVerifyFromCmd(cmd)
+
+	return &secureCfg{
+		cert:   cert,
+		key:    key,
+		cacert: cacert,
+
+		insecureTransport:  insecureTr,
+		insecureSkipVerify: skipVerify,
+	}
+}
+
+func insecureTransportFromCmd(cmd *cobra.Command) bool {
+	insecureTr, err := cmd.Flags().GetBool("insecure-transport")
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+	return insecureTr
+}
+
+func insecureSkipVerifyFromCmd(cmd *cobra.Command) bool {
+	skipVerify, err := cmd.Flags().GetBool("insecure-skip-tls-verify")
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+	return skipVerify
+}
+
+func keyAndCertFromCmd(cmd *cobra.Command) (cert, key, cacert string) {
+	var err error
+	if cert, err = cmd.Flags().GetString("cert"); err != nil {
+		ExitWithError(ExitBadArgs, err)
+	} else if cert == "" && cmd.Flags().Changed("cert") {
+		ExitWithError(ExitBadArgs, errors.New("empty string is passed to --cert option"))
+	}
+
+	if key, err = cmd.Flags().GetString("key"); err != nil {
+		ExitWithError(ExitBadArgs, err)
+	} else if key == "" && cmd.Flags().Changed("key") {
+		ExitWithError(ExitBadArgs, errors.New("empty string is passed to --key option"))
+	}
+
+	if cacert, err = cmd.Flags().GetString("cacert"); err != nil {
+		ExitWithError(ExitBadArgs, err)
+	} else if cacert == "" && cmd.Flags().Changed("cacert") {
+		ExitWithError(ExitBadArgs, errors.New("empty string is passed to --cacert option"))
+	}
+
+	return cert, key, cacert
+}
diff --git a/etcdctl/ctlv3/command/lease_command.go b/etcdctl/ctlv3/command/lease_command.go
new file mode 100644
index 0000000..ede7b33
--- /dev/null
+++ b/etcdctl/ctlv3/command/lease_command.go
@@ -0,0 +1,139 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"os"
+	"strconv"
+
+	v3 "github.com/coreos/etcd/clientv3"
+	"github.com/spf13/cobra"
+	"golang.org/x/net/context"
+)
+
+// NewLeaseCommand returns the cobra command for "lease".
+func NewLeaseCommand() *cobra.Command {
+	lc := &cobra.Command{
+		Use:   "lease",
+		Short: "lease is used to manage leases.",
+	}
+
+	lc.AddCommand(NewLeaseCreateCommand())
+	lc.AddCommand(NewLeaseRevokeCommand())
+	lc.AddCommand(NewLeaseKeepAliveCommand())
+
+	return lc
+}
+
+// NewLeaseCreateCommand returns the cobra command for "lease create".
+func NewLeaseCreateCommand() *cobra.Command {
+	lc := &cobra.Command{
+		Use:   "create",
+		Short: "create is used to create leases.",
+
+		Run: leaseCreateCommandFunc,
+	}
+
+	return lc
+}
+
+// leaseCreateCommandFunc executes the "lease create" command.
+func leaseCreateCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 1 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("lease create command needs TTL argument."))
+	}
+
+	ttl, err := strconv.ParseInt(args[0], 10, 64)
+	if err != nil {
+		ExitWithError(ExitBadArgs, fmt.Errorf("bad TTL (%v)", err))
+	}
+
+	ctx, cancel := commandCtx(cmd)
+	resp, err := mustClientFromCmd(cmd).Create(ctx, ttl)
+	cancel()
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "failed to create lease (%v)\n", err)
+		return
+	}
+	fmt.Printf("lease %016x created with TTL(%ds)\n", resp.ID, resp.TTL)
+}
+
+// NewLeaseRevokeCommand returns the cobra command for "lease revoke".
+func NewLeaseRevokeCommand() *cobra.Command {
+	lc := &cobra.Command{
+		Use:   "revoke",
+		Short: "revoke is used to revoke leases.",
+
+		Run: leaseRevokeCommandFunc,
+	}
+
+	return lc
+}
+
+// leaseRevokeCommandFunc executes the "lease create" command.
+func leaseRevokeCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 1 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("lease revoke command needs 1 argument"))
+	}
+
+	id, err := strconv.ParseInt(args[0], 16, 64)
+	if err != nil {
+		ExitWithError(ExitBadArgs, fmt.Errorf("bad lease ID arg (%v), expecting ID in Hex", err))
+	}
+
+	ctx, cancel := commandCtx(cmd)
+	_, err = mustClientFromCmd(cmd).Revoke(ctx, v3.LeaseID(id))
+	cancel()
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "failed to revoke lease (%v)\n", err)
+		return
+	}
+	fmt.Printf("lease %016x revoked\n", id)
+}
+
+// NewLeaseKeepAliveCommand returns the cobra command for "lease keep-alive".
+func NewLeaseKeepAliveCommand() *cobra.Command {
+	lc := &cobra.Command{
+		Use:   "keep-alive",
+		Short: "keep-alive is used to keep leases alive.",
+
+		Run: leaseKeepAliveCommandFunc,
+	}
+
+	return lc
+}
+
+// leaseKeepAliveCommandFunc executes the "lease keep-alive" command.
+func leaseKeepAliveCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 1 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("lease keep-alive command needs lease ID as argument"))
+	}
+
+	id, err := strconv.ParseInt(args[0], 16, 64)
+	if err != nil {
+		ExitWithError(ExitBadArgs, fmt.Errorf("bad lease ID arg (%v), expecting ID in Hex", err))
+	}
+
+	respc, kerr := mustClientFromCmd(cmd).KeepAlive(context.TODO(), v3.LeaseID(id))
+	if kerr != nil {
+		ExitWithError(ExitBadConnection, kerr)
+	}
+
+	for resp := range respc {
+		fmt.Printf("lease %016x keepalived with TTL(%d)\n", resp.ID, resp.TTL)
+	}
+	fmt.Printf("lease %016x expired or revoked.\n", id)
+}
diff --git a/etcdctl/ctlv3/command/lock_command.go b/etcdctl/ctlv3/command/lock_command.go
new file mode 100644
index 0000000..57db4fa
--- /dev/null
+++ b/etcdctl/ctlv3/command/lock_command.go
@@ -0,0 +1,88 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"os"
+	"os/signal"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/coreos/etcd/clientv3/concurrency"
+	"github.com/spf13/cobra"
+	"golang.org/x/net/context"
+)
+
+// NewLockCommand returns the cobra command for "lock".
+func NewLockCommand() *cobra.Command {
+	c := &cobra.Command{
+		Use:   "lock <lockname>",
+		Short: "lock acquires a named lock",
+		Run:   lockCommandFunc,
+	}
+	return c
+}
+
+func lockCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 1 {
+		ExitWithError(ExitBadArgs, errors.New("lock takes one lock name arguement."))
+	}
+	c := mustClientFromCmd(cmd)
+	if err := lockUntilSignal(c, args[0]); err != nil {
+		ExitWithError(ExitError, err)
+	}
+}
+
+func lockUntilSignal(c *clientv3.Client, lockname string) error {
+	m := concurrency.NewMutex(c, lockname)
+	ctx, cancel := context.WithCancel(context.TODO())
+
+	// unlock in case of ordinary shutdown
+	donec := make(chan struct{})
+	sigc := make(chan os.Signal, 1)
+	signal.Notify(sigc, os.Interrupt, os.Kill)
+	go func() {
+		<-sigc
+		cancel()
+		close(donec)
+	}()
+
+	s, serr := concurrency.NewSession(c)
+	if serr != nil {
+		return serr
+	}
+
+	if err := m.Lock(ctx); err != nil {
+		return err
+	}
+
+	k, kerr := c.Get(ctx, m.Key())
+	if kerr != nil {
+		return kerr
+	}
+	if len(k.Kvs) == 0 {
+		return errors.New("lock lost on init")
+	}
+
+	display.Get(*k)
+
+	select {
+	case <-donec:
+		return m.Unlock()
+	case <-s.Done():
+	}
+
+	return errors.New("session expired")
+}
diff --git a/etcdctl/ctlv3/command/make_mirror_command.go b/etcdctl/ctlv3/command/make_mirror_command.go
new file mode 100644
index 0000000..571ca3f
--- /dev/null
+++ b/etcdctl/ctlv3/command/make_mirror_command.go
@@ -0,0 +1,148 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"errors"
+	"fmt"
+	"sync/atomic"
+	"time"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/coreos/etcd/clientv3/mirror"
+	"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
+	"github.com/coreos/etcd/storage/storagepb"
+	"github.com/spf13/cobra"
+	"golang.org/x/net/context"
+)
+
+var (
+	mminsecureTr bool
+	mmcert       string
+	mmkey        string
+	mmcacert     string
+	mmprefix     string
+)
+
+// NewMakeMirrorCommand returns the cobra command for "makeMirror".
+func NewMakeMirrorCommand() *cobra.Command {
+	c := &cobra.Command{
+		Use:   "make-mirror [options] <destination>",
+		Short: "make-mirror makes a mirror at the destination etcd cluster",
+		Run:   makeMirrorCommandFunc,
+	}
+
+	c.Flags().StringVar(&mmprefix, "prefix", "", "the key-value prefix to mirror")
+	// TODO: add dest-prefix to mirror a prefix to a different prefix in the destionation cluster?
+	c.Flags().StringVar(&mmcert, "dest-cert", "", "identify secure client using this TLS certificate file for the destination cluster")
+	c.Flags().StringVar(&mmkey, "dest-key", "", "identify secure client using this TLS key file")
+	c.Flags().StringVar(&mmcacert, "dest-cacert", "", "verify certificates of TLS enabled secure servers using this CA bundle")
+	// TODO: secure by default when etcd enables secure gRPC by default.
+	c.Flags().BoolVar(&mminsecureTr, "dest-insecure-transport", true, "disable transport security for client connections")
+
+	return c
+}
+
+func makeMirrorCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 1 {
+		ExitWithError(ExitBadArgs, errors.New("make-mirror takes one destination arguement."))
+	}
+
+	dialTimeout := dialTimeoutFromCmd(cmd)
+	sec := &secureCfg{
+		cert:              mmcert,
+		key:               mmkey,
+		cacert:            mmcacert,
+		insecureTransport: mminsecureTr,
+	}
+
+	dc := mustClient([]string{args[0]}, dialTimeout, sec)
+	c := mustClientFromCmd(cmd)
+
+	err := makeMirror(context.TODO(), c, dc)
+	ExitWithError(ExitError, err)
+}
+
+func makeMirror(ctx context.Context, c *clientv3.Client, dc *clientv3.Client) error {
+	total := int64(0)
+
+	go func() {
+		for {
+			time.Sleep(30 * time.Second)
+			fmt.Println(atomic.LoadInt64(&total))
+		}
+	}()
+
+	// TODO: remove the prefix of the destination cluster?
+	s := mirror.NewSyncer(c, mmprefix, 0)
+
+	rc, errc := s.SyncBase(ctx)
+
+	for r := range rc {
+		for _, kv := range r.Kvs {
+			_, err := dc.Put(ctx, string(kv.Key), string(kv.Value))
+			if err != nil {
+				return err
+			}
+			atomic.AddInt64(&total, 1)
+		}
+	}
+
+	err := <-errc
+	if err != nil {
+		return err
+	}
+
+	wc := s.SyncUpdates(ctx)
+
+	for wr := range wc {
+		if wr.CompactRevision != 0 {
+			return rpctypes.ErrCompacted
+		}
+
+		var rev int64
+		ops := []clientv3.Op{}
+
+		for _, ev := range wr.Events {
+			nrev := ev.Kv.ModRevision
+			if rev != 0 && nrev > rev {
+				_, err := dc.Txn(ctx).Then(ops...).Commit()
+				if err != nil {
+					return err
+				}
+				ops = []clientv3.Op{}
+			}
+			switch ev.Type {
+			case storagepb.PUT:
+				ops = append(ops, clientv3.OpPut(string(ev.Kv.Key), string(ev.Kv.Value)))
+				atomic.AddInt64(&total, 1)
+			case storagepb.DELETE, storagepb.EXPIRE:
+				ops = append(ops, clientv3.OpDelete(string(ev.Kv.Key)))
+				atomic.AddInt64(&total, 1)
+			default:
+				panic("unexpected event type")
+			}
+		}
+
+		if len(ops) != 0 {
+			_, err := dc.Txn(ctx).Then(ops...).Commit()
+			if err != nil {
+				return err
+			}
+		}
+	}
+
+	return nil
+}
diff --git a/etcdctl/ctlv3/command/member_command.go b/etcdctl/ctlv3/command/member_command.go
new file mode 100644
index 0000000..8a2b977
--- /dev/null
+++ b/etcdctl/ctlv3/command/member_command.go
@@ -0,0 +1,176 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"strconv"
+	"strings"
+
+	"github.com/spf13/cobra"
+)
+
+var (
+	memberID       uint64
+	memberPeerURLs string
+)
+
+// NewMemberCommand returns the cobra command for "member".
+func NewMemberCommand() *cobra.Command {
+	mc := &cobra.Command{
+		Use:   "member",
+		Short: "member is used to manage membership in an etcd cluster.",
+	}
+
+	mc.AddCommand(NewMemberAddCommand())
+	mc.AddCommand(NewMemberRemoveCommand())
+	mc.AddCommand(NewMemberUpdateCommand())
+	mc.AddCommand(NewMemberListCommand())
+
+	return mc
+}
+
+// NewMemberAddCommand returns the cobra command for "member add".
+func NewMemberAddCommand() *cobra.Command {
+	cc := &cobra.Command{
+		Use:   "add",
+		Short: "add is used to add a member into the cluster",
+
+		Run: memberAddCommandFunc,
+	}
+
+	cc.Flags().StringVar(&memberPeerURLs, "peerURLs", "", "comma separated peer URLs for the new member.")
+
+	return cc
+}
+
+// NewMemberRemoveCommand returns the cobra command for "member remove".
+func NewMemberRemoveCommand() *cobra.Command {
+	cc := &cobra.Command{
+		Use:   "remove",
+		Short: "remove is used to remove a member from the cluster",
+
+		Run: memberRemoveCommandFunc,
+	}
+
+	return cc
+}
+
+// NewMemberUpdateCommand returns the cobra command for "member update".
+func NewMemberUpdateCommand() *cobra.Command {
+	cc := &cobra.Command{
+		Use:   "update",
+		Short: "update is used to update a member in the cluster",
+
+		Run: memberUpdateCommandFunc,
+	}
+
+	cc.Flags().StringVar(&memberPeerURLs, "peerURLs", "", "comma separated peer URLs for the updated member.")
+
+	return cc
+}
+
+// NewMemberListCommand returns the cobra command for "member list".
+func NewMemberListCommand() *cobra.Command {
+	cc := &cobra.Command{
+		Use:   "list",
+		Short: "list is used to list all members in the cluster",
+
+		Run: memberListCommandFunc,
+	}
+
+	return cc
+}
+
+// memberAddCommandFunc executes the "member add" command.
+func memberAddCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 1 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("member name not provided."))
+	}
+
+	if len(memberPeerURLs) == 0 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("member peer urls not provided."))
+	}
+
+	urls := strings.Split(memberPeerURLs, ",")
+	ctx, cancel := commandCtx(cmd)
+	resp, err := mustClientFromCmd(cmd).MemberAdd(ctx, urls)
+	cancel()
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+
+	fmt.Printf("Member %16x added to cluster %16x\n", resp.Member.ID, resp.Header.ClusterId)
+}
+
+// memberRemoveCommandFunc executes the "member remove" command.
+func memberRemoveCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 1 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("member ID is not provided"))
+	}
+
+	id, err := strconv.ParseUint(args[0], 16, 64)
+	if err != nil {
+		ExitWithError(ExitBadArgs, fmt.Errorf("bad member ID arg (%v), expecting ID in Hex", err))
+	}
+
+	ctx, cancel := commandCtx(cmd)
+	resp, err := mustClientFromCmd(cmd).MemberRemove(ctx, id)
+	cancel()
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+
+	fmt.Printf("Member %16x removed from cluster %16x\n", id, resp.Header.ClusterId)
+}
+
+// memberUpdateCommandFunc executes the "member update" command.
+func memberUpdateCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 1 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("member ID is not provided"))
+	}
+
+	id, err := strconv.ParseUint(args[0], 16, 64)
+	if err != nil {
+		ExitWithError(ExitBadArgs, fmt.Errorf("bad member ID arg (%v), expecting ID in Hex", err))
+	}
+
+	if len(memberPeerURLs) == 0 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("member peer urls not provided."))
+	}
+
+	urls := strings.Split(memberPeerURLs, ",")
+
+	ctx, cancel := commandCtx(cmd)
+	resp, err := mustClientFromCmd(cmd).MemberUpdate(ctx, id, urls)
+	cancel()
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+
+	fmt.Printf("Member %16x updated in cluster %16x\n", id, resp.Header.ClusterId)
+}
+
+// memberListCommandFunc executes the "member list" command.
+func memberListCommandFunc(cmd *cobra.Command, args []string) {
+	ctx, cancel := commandCtx(cmd)
+	resp, err := mustClientFromCmd(cmd).MemberList(ctx)
+	cancel()
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+
+	display.MemberList(*resp)
+}
diff --git a/etcdctl/ctlv3/command/printer.go b/etcdctl/ctlv3/command/printer.go
new file mode 100644
index 0000000..df0abc3
--- /dev/null
+++ b/etcdctl/ctlv3/command/printer.go
@@ -0,0 +1,183 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"encoding/json"
+	"errors"
+	"fmt"
+	"os"
+	"strings"
+
+	v3 "github.com/coreos/etcd/clientv3"
+	pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
+	spb "github.com/coreos/etcd/storage/storagepb"
+	"github.com/olekukonko/tablewriter"
+)
+
+type printer interface {
+	Del(v3.DeleteResponse)
+	Get(v3.GetResponse)
+	Put(v3.PutResponse)
+	Txn(v3.TxnResponse)
+	Watch(v3.WatchResponse)
+
+	MemberList(v3.MemberListResponse)
+}
+
+func NewPrinter(printerType string, isHex bool) printer {
+	switch printerType {
+	case "simple":
+		return &simplePrinter{isHex: isHex}
+	case "json":
+		return &jsonPrinter{}
+	case "protobuf":
+		return &pbPrinter{}
+	}
+	return nil
+}
+
+type simplePrinter struct {
+	isHex bool
+}
+
+func (s *simplePrinter) Del(v3.DeleteResponse) {
+	// TODO: add number of key removed into the response of delete.
+	// TODO: print out the number of removed keys.
+	fmt.Println(0)
+}
+
+func (s *simplePrinter) Get(resp v3.GetResponse) {
+	for _, kv := range resp.Kvs {
+		printKV(s.isHex, kv)
+	}
+}
+
+func (s *simplePrinter) Put(r v3.PutResponse) { fmt.Println("OK") }
+
+func (s *simplePrinter) Txn(resp v3.TxnResponse) {
+	if resp.Succeeded {
+		fmt.Println("SUCCESS")
+	} else {
+		fmt.Println("FAILURE")
+	}
+
+	for _, r := range resp.Responses {
+		fmt.Println("")
+		switch v := r.Response.(type) {
+		case *pb.ResponseUnion_ResponseDeleteRange:
+			s.Del((v3.DeleteResponse)(*v.ResponseDeleteRange))
+		case *pb.ResponseUnion_ResponsePut:
+			s.Put((v3.PutResponse)(*v.ResponsePut))
+		case *pb.ResponseUnion_ResponseRange:
+			s.Get(((v3.GetResponse)(*v.ResponseRange)))
+		default:
+			fmt.Printf("unexpected response %+v\n", r)
+		}
+	}
+}
+
+func (s *simplePrinter) Watch(resp v3.WatchResponse) {
+	for _, e := range resp.Events {
+		fmt.Println(e.Type)
+		printKV(s.isHex, e.Kv)
+	}
+}
+
+func (s *simplePrinter) MemberList(resp v3.MemberListResponse) {
+	table := tablewriter.NewWriter(os.Stdout)
+	table.SetHeader([]string{"ID", "Status", "Name", "Peer Addrs", "Client Addrs", "Is Leader"})
+
+	for _, m := range resp.Members {
+		status := "started"
+		if len(m.Name) == 0 {
+			status = "unstarted"
+		}
+
+		table.Append([]string{
+			fmt.Sprintf("%x", m.ID),
+			status,
+			m.Name,
+			strings.Join(m.PeerURLs, ","),
+			strings.Join(m.ClientURLs, ","),
+			fmt.Sprint(m.IsLeader),
+		})
+	}
+
+	table.Render()
+}
+
+type jsonPrinter struct{}
+
+func (p *jsonPrinter) Del(r v3.DeleteResponse) { printJSON(r) }
+func (p *jsonPrinter) Get(r v3.GetResponse) {
+	for _, kv := range r.Kvs {
+		printJSON(kv)
+	}
+}
+func (p *jsonPrinter) Put(r v3.PutResponse)               { printJSON(r) }
+func (p *jsonPrinter) Txn(r v3.TxnResponse)               { printJSON(r) }
+func (p *jsonPrinter) Watch(r v3.WatchResponse)           { printJSON(r) }
+func (p *jsonPrinter) MemberList(r v3.MemberListResponse) { printJSON(r) }
+
+func printJSON(v interface{}) {
+	b, err := json.Marshal(v)
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "%v\n", err)
+		return
+	}
+	fmt.Println(string(b))
+}
+
+type pbPrinter struct{}
+
+type pbMarshal interface {
+	Marshal() ([]byte, error)
+}
+
+func (p *pbPrinter) Del(r v3.DeleteResponse) {
+	printPB((*pb.DeleteRangeResponse)(&r))
+}
+
+func (p *pbPrinter) Get(r v3.GetResponse) {
+	printPB((*pb.RangeResponse)(&r))
+}
+
+func (p *pbPrinter) Put(r v3.PutResponse) {
+	printPB((*pb.PutResponse)(&r))
+}
+
+func (p *pbPrinter) Txn(r v3.TxnResponse) {
+	printPB((*pb.TxnResponse)(&r))
+}
+
+func (p *pbPrinter) Watch(r v3.WatchResponse) {
+	for _, ev := range r.Events {
+		printPB((*spb.Event)(ev))
+	}
+}
+
+func (pb *pbPrinter) MemberList(r v3.MemberListResponse) {
+	ExitWithError(ExitBadFeature, errors.New("only support simple or json as output format"))
+}
+
+func printPB(m pbMarshal) {
+	b, err := m.Marshal()
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "%v\n", err)
+		return
+	}
+	fmt.Printf(string(b))
+}
diff --git a/etcdctl/ctlv3/command/put_command.go b/etcdctl/ctlv3/command/put_command.go
new file mode 100644
index 0000000..d596b70
--- /dev/null
+++ b/etcdctl/ctlv3/command/put_command.go
@@ -0,0 +1,90 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"os"
+	"strconv"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/spf13/cobra"
+)
+
+var (
+	leaseStr string
+)
+
+// NewPutCommand returns the cobra command for "put".
+func NewPutCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "put [options] <key> <value> (<value> can also be given from stdin)",
+		Short: "Put puts the given key into the store.",
+		Long: `
+Put puts the given key into the store.
+
+When <value> begins with '-', <value> is interpreted as a flag.
+Insert '--' for workaround:
+
+$ put <key> -- <value>
+$ put -- <key> <value>
+
+If <value> isn't given as command line arguement, this command tries to read the value from standard input.
+For example,
+$ cat file | put <key>
+will store the content of the file to <key>.
+`,
+		Run: putCommandFunc,
+	}
+	cmd.Flags().StringVar(&leaseStr, "lease", "0", "lease ID (in hexadecimal) to attach to the key")
+	return cmd
+}
+
+// putCommandFunc executes the "put" command.
+func putCommandFunc(cmd *cobra.Command, args []string) {
+	key, value, opts := getPutOp(cmd, args)
+
+	ctx, cancel := commandCtx(cmd)
+	resp, err := mustClientFromCmd(cmd).Put(ctx, key, value, opts...)
+	cancel()
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+	display.Put(*resp)
+}
+
+func getPutOp(cmd *cobra.Command, args []string) (string, string, []clientv3.OpOption) {
+	if len(args) == 0 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("put command needs 1 argument and input from stdin or 2 arguments."))
+	}
+
+	key := args[0]
+	value, err := argOrStdin(args, os.Stdin, 1)
+	if err != nil {
+		ExitWithError(ExitBadArgs, fmt.Errorf("put command needs 1 argument and input from stdin or 2 arguments."))
+	}
+
+	id, err := strconv.ParseInt(leaseStr, 16, 64)
+	if err != nil {
+		ExitWithError(ExitBadArgs, fmt.Errorf("bad lease ID (%v), expecting ID in Hex", err))
+	}
+
+	opts := []clientv3.OpOption{}
+	if id != 0 {
+		opts = append(opts, clientv3.WithLease(clientv3.LeaseID(id)))
+	}
+
+	return key, value, opts
+}
diff --git a/etcdctl/ctlv3/command/snapshot_command.go b/etcdctl/ctlv3/command/snapshot_command.go
new file mode 100644
index 0000000..b6edd5f
--- /dev/null
+++ b/etcdctl/ctlv3/command/snapshot_command.go
@@ -0,0 +1,127 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"io"
+	"os"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/coreos/etcd/clientv3/mirror"
+	"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
+	"github.com/spf13/cobra"
+	"golang.org/x/net/context"
+)
+
+// NewSnapshotCommand returns the cobra command for "snapshot".
+func NewSnapshotCommand() *cobra.Command {
+	return &cobra.Command{
+		Use:   "snapshot [filename]",
+		Short: "Snapshot streams a point-in-time snapshot of the store",
+		Run:   snapshotCommandFunc,
+	}
+}
+
+// snapshotCommandFunc watches for the length of the entire store and records
+// to a file.
+func snapshotCommandFunc(cmd *cobra.Command, args []string) {
+	switch {
+	case len(args) == 0:
+		snapshotToStdout(mustClientFromCmd(cmd))
+	case len(args) == 1:
+		snapshotToFile(mustClientFromCmd(cmd), args[0])
+	default:
+		err := fmt.Errorf("snapshot takes at most one argument")
+		ExitWithError(ExitBadArgs, err)
+	}
+}
+
+// snapshotToStdout streams a snapshot over stdout
+func snapshotToStdout(c *clientv3.Client) {
+	// must explicitly fetch first revision since no retry on stdout
+	wr := <-c.Watch(context.TODO(), "", clientv3.WithPrefix(), clientv3.WithRev(1))
+	if wr.Err() == nil {
+		wr.CompactRevision = 1
+	}
+	if rev := snapshot(os.Stdout, c, wr.CompactRevision+1); rev != 0 {
+		err := fmt.Errorf("snapshot interrupted by compaction %v", rev)
+		ExitWithError(ExitInterrupted, err)
+	}
+	os.Stdout.Sync()
+}
+
+// snapshotToFile atomically writes a snapshot to a file
+func snapshotToFile(c *clientv3.Client, path string) {
+	partpath := path + ".part"
+	f, err := os.Create(partpath)
+	defer f.Close()
+	if err != nil {
+		exiterr := fmt.Errorf("could not open %s (%v)", partpath, err)
+		ExitWithError(ExitBadArgs, exiterr)
+	}
+	rev := int64(1)
+	for rev != 0 {
+		f.Seek(0, 0)
+		f.Truncate(0)
+		rev = snapshot(f, c, rev)
+	}
+	f.Sync()
+	if err := os.Rename(partpath, path); err != nil {
+		exiterr := fmt.Errorf("could not rename %s to %s (%v)", partpath, path, err)
+		ExitWithError(ExitIO, exiterr)
+	}
+}
+
+// snapshot reads all of a watcher; returns compaction revision if incomplete
+// TODO: stabilize snapshot format
+func snapshot(w io.Writer, c *clientv3.Client, rev int64) int64 {
+	s := mirror.NewSyncer(c, "", rev)
+
+	rc, errc := s.SyncBase(context.TODO())
+
+	for r := range rc {
+		for _, kv := range r.Kvs {
+			fmt.Fprintln(w, kv)
+		}
+	}
+
+	err := <-errc
+	if err != nil {
+		if err == rpctypes.ErrCompacted {
+			// will get correct compact revision on retry
+			return rev + 1
+		}
+		// failed for some unknown reason, retry on same revision
+		return rev
+	}
+
+	wc := s.SyncUpdates(context.TODO())
+
+	for wr := range wc {
+		if wr.Err() != nil {
+			return wr.CompactRevision
+		}
+		for _, ev := range wr.Events {
+			fmt.Fprintln(w, ev)
+		}
+		rev := wr.Events[len(wr.Events)-1].Kv.ModRevision
+		if rev >= wr.Header.Revision {
+			break
+		}
+	}
+
+	return 0
+}
diff --git a/etcdctl/ctlv3/command/txn_command.go b/etcdctl/ctlv3/command/txn_command.go
new file mode 100644
index 0000000..c972ed8
--- /dev/null
+++ b/etcdctl/ctlv3/command/txn_command.go
@@ -0,0 +1,203 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"bufio"
+	"fmt"
+	"os"
+	"strconv"
+	"strings"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/spf13/cobra"
+	"golang.org/x/net/context"
+)
+
+var (
+	txnInteractive bool
+)
+
+// NewTxnCommand returns the cobra command for "txn".
+func NewTxnCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "txn [options]",
+		Short: "Txn processes all the requests in one transaction.",
+		Run:   txnCommandFunc,
+	}
+	cmd.Flags().BoolVarP(&txnInteractive, "interactive", "i", false, "input transaction in interactive mode")
+	return cmd
+}
+
+// txnCommandFunc executes the "txn" command.
+func txnCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 0 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("txn command does not accept argument."))
+	}
+
+	reader := bufio.NewReader(os.Stdin)
+
+	txn := mustClientFromCmd(cmd).Txn(context.Background())
+	promptInteractive("compares:")
+	txn.If(readCompares(reader)...)
+	promptInteractive("success requests (get, put, delete):")
+	txn.Then(readOps(reader)...)
+	promptInteractive("failure requests (get, put, delete):")
+	txn.Else(readOps(reader)...)
+
+	resp, err := txn.Commit()
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+
+	display.Txn(*resp)
+}
+
+func promptInteractive(s string) {
+	if txnInteractive {
+		fmt.Println(s)
+	}
+}
+
+func readCompares(r *bufio.Reader) (cmps []clientv3.Cmp) {
+	for {
+		line, err := r.ReadString('\n')
+		if err != nil {
+			ExitWithError(ExitInvalidInput, err)
+		}
+		if len(line) == 1 {
+			break
+		}
+
+		// remove trialling \n
+		line = line[:len(line)-1]
+		cmp, err := parseCompare(line)
+		if err != nil {
+			ExitWithError(ExitInvalidInput, err)
+		}
+		cmps = append(cmps, *cmp)
+	}
+
+	return cmps
+}
+
+func readOps(r *bufio.Reader) (ops []clientv3.Op) {
+	for {
+		line, err := r.ReadString('\n')
+		if err != nil {
+			ExitWithError(ExitInvalidInput, err)
+		}
+		if len(line) == 1 {
+			break
+		}
+
+		// remove trialling \n
+		line = line[:len(line)-1]
+		op, err := parseRequestUnion(line)
+		if err != nil {
+			ExitWithError(ExitInvalidInput, err)
+		}
+		ops = append(ops, *op)
+	}
+
+	return ops
+}
+
+func parseRequestUnion(line string) (*clientv3.Op, error) {
+	args := argify(line)
+	if len(args) < 2 {
+		return nil, fmt.Errorf("invalid txn compare request: %s", line)
+	}
+
+	opc := make(chan clientv3.Op, 1)
+
+	put := NewPutCommand()
+	put.Run = func(cmd *cobra.Command, args []string) {
+		key, value, opts := getPutOp(cmd, args)
+		opc <- clientv3.OpPut(key, value, opts...)
+	}
+	get := NewGetCommand()
+	get.Run = func(cmd *cobra.Command, args []string) {
+		key, opts := getGetOp(cmd, args)
+		opc <- clientv3.OpGet(key, opts...)
+	}
+	del := NewDelCommand()
+	del.Run = func(cmd *cobra.Command, args []string) {
+		key, opts := getDelOp(cmd, args)
+		opc <- clientv3.OpDelete(key, opts...)
+	}
+	cmds := &cobra.Command{SilenceErrors: true}
+	cmds.AddCommand(put, get, del)
+
+	cmds.SetArgs(args)
+	if err := cmds.Execute(); err != nil {
+		return nil, fmt.Errorf("invalid txn request: %s", line)
+	}
+
+	op := <-opc
+	return &op, nil
+}
+
+func parseCompare(line string) (*clientv3.Cmp, error) {
+	var (
+		key string
+		op  string
+		val string
+	)
+
+	lparenSplit := strings.SplitN(line, "(", 2)
+	if len(lparenSplit) != 2 {
+		return nil, fmt.Errorf("malformed comparison: %s", line)
+	}
+
+	target := lparenSplit[0]
+	n, serr := fmt.Sscanf(lparenSplit[1], "%q) %s %q", &key, &op, &val)
+	if n != 3 {
+		return nil, fmt.Errorf("malformed comparison: %s; got %s(%q) %s %q", line, target, key, op, val)
+	}
+	if serr != nil {
+		return nil, fmt.Errorf("malformed comparison: %s (%v)", line, serr)
+	}
+
+	var (
+		v   int64
+		err error
+		cmp clientv3.Cmp
+	)
+	switch target {
+	case "ver", "version":
+		if v, err = strconv.ParseInt(val, 10, 64); err == nil {
+			cmp = clientv3.Compare(clientv3.Version(key), op, v)
+		}
+	case "c", "create":
+		if v, err = strconv.ParseInt(val, 10, 64); err == nil {
+			cmp = clientv3.Compare(clientv3.CreateRevision(key), op, v)
+		}
+	case "m", "mod":
+		if v, err = strconv.ParseInt(val, 10, 64); err == nil {
+			cmp = clientv3.Compare(clientv3.ModRevision(key), op, v)
+		}
+	case "val", "value":
+		cmp = clientv3.Compare(clientv3.Value(key), op, val)
+	default:
+		return nil, fmt.Errorf("malformed comparison: %s (unknown target %s)", line, target)
+	}
+
+	if err != nil {
+		return nil, fmt.Errorf("invalid txn compare request: %s", line)
+	}
+
+	return &cmp, nil
+}
diff --git a/etcdctl/ctlv3/command/user_command.go b/etcdctl/ctlv3/command/user_command.go
new file mode 100644
index 0000000..77fb797
--- /dev/null
+++ b/etcdctl/ctlv3/command/user_command.go
@@ -0,0 +1,91 @@
+// Copyright 2016 Nippon Telegraph and Telephone Corporation.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/bgentry/speakeasy"
+	"github.com/spf13/cobra"
+	"golang.org/x/net/context"
+)
+
+// NewUserCommand returns the cobra command for "user".
+func NewUserCommand() *cobra.Command {
+	ac := &cobra.Command{
+		Use:   "user <subcommand>",
+		Short: "user related command",
+	}
+
+	ac.AddCommand(NewUserAddCommand())
+
+	return ac
+}
+
+var (
+	passwordInteractive bool
+)
+
+func NewUserAddCommand() *cobra.Command {
+	cmd := cobra.Command{
+		Use:   "add <user name>",
+		Short: "add a new user",
+		Run:   userAddCommandFunc,
+	}
+
+	cmd.Flags().BoolVar(&passwordInteractive, "interactive", true, "read password from stdin instead of interactive terminal")
+
+	return &cmd
+}
+
+// userAddCommandFunc executes the "user add" command.
+func userAddCommandFunc(cmd *cobra.Command, args []string) {
+	if len(args) != 1 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("user add command requires user name as its argument."))
+	}
+
+	var password string
+
+	if !passwordInteractive {
+		fmt.Scanf("%s", &password)
+	} else {
+		prompt1 := fmt.Sprintf("Password of %s: ", args[0])
+		password1, err1 := speakeasy.Ask(prompt1)
+		if err1 != nil {
+			ExitWithError(ExitBadArgs, fmt.Errorf("failed to ask password: %s.", err1))
+		}
+
+		if len(password1) == 0 {
+			ExitWithError(ExitBadArgs, fmt.Errorf("empty password"))
+		}
+
+		prompt2 := fmt.Sprintf("Type password of %s again for confirmation: ", args[0])
+		password2, err2 := speakeasy.Ask(prompt2)
+		if err2 != nil {
+			ExitWithError(ExitBadArgs, fmt.Errorf("failed to ask password: %s.", err2))
+		}
+
+		if strings.Compare(password1, password2) != 0 {
+			ExitWithError(ExitBadArgs, fmt.Errorf("given passwords are different."))
+		}
+		password = password1
+	}
+
+	_, err := mustClientFromCmd(cmd).Auth.UserAdd(context.TODO(), args[0], password)
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+}
diff --git a/etcdctl/ctlv3/command/util.go b/etcdctl/ctlv3/command/util.go
new file mode 100644
index 0000000..1d4e0ae
--- /dev/null
+++ b/etcdctl/ctlv3/command/util.go
@@ -0,0 +1,59 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"encoding/hex"
+	"fmt"
+	"regexp"
+
+	pb "github.com/coreos/etcd/storage/storagepb"
+	"github.com/spf13/cobra"
+	"golang.org/x/net/context"
+)
+
+func printKV(isHex bool, kv *pb.KeyValue) {
+	k, v := string(kv.Key), string(kv.Value)
+	if isHex {
+		k = addHexPrefix(hex.EncodeToString(kv.Key))
+		v = addHexPrefix(hex.EncodeToString(kv.Value))
+	}
+	fmt.Println(k)
+	fmt.Println(v)
+}
+
+func addHexPrefix(s string) string {
+	ns := make([]byte, len(s)*2)
+	for i := 0; i < len(s); i += 2 {
+		ns[i*2] = '\\'
+		ns[i*2+1] = 'x'
+		ns[i*2+2] = s[i]
+		ns[i*2+3] = s[i+1]
+	}
+	return string(ns)
+}
+
+func argify(s string) []string {
+	r := regexp.MustCompile("'.+'|\".+\"|\\S+")
+	return r.FindAllString(s, -1)
+}
+
+func commandCtx(cmd *cobra.Command) (context.Context, context.CancelFunc) {
+	timeOut, err := cmd.Flags().GetDuration("command-timeout")
+	if err != nil {
+		ExitWithError(ExitError, err)
+	}
+	return context.WithTimeout(context.Background(), timeOut)
+}
diff --git a/etcdctl/ctlv3/command/version_command.go b/etcdctl/ctlv3/command/version_command.go
new file mode 100644
index 0000000..3a8e8e4
--- /dev/null
+++ b/etcdctl/ctlv3/command/version_command.go
@@ -0,0 +1,35 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"fmt"
+
+	"github.com/coreos/etcd/version"
+	"github.com/spf13/cobra"
+)
+
+// NewVersionCommand prints out the version of etcd.
+func NewVersionCommand() *cobra.Command {
+	return &cobra.Command{
+		Use:   "version",
+		Short: "Print the version of etcdctl.",
+		Run:   versionCommandFunc,
+	}
+}
+
+func versionCommandFunc(cmd *cobra.Command, args []string) {
+	fmt.Println(version.Version)
+}
diff --git a/etcdctl/ctlv3/command/watch_command.go b/etcdctl/ctlv3/command/watch_command.go
new file mode 100644
index 0000000..80ea88d
--- /dev/null
+++ b/etcdctl/ctlv3/command/watch_command.go
@@ -0,0 +1,126 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package command
+
+import (
+	"bufio"
+	"fmt"
+	"os"
+	"strings"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/spf13/cobra"
+	"golang.org/x/net/context"
+)
+
+var (
+	watchRev         int64
+	watchPrefix      bool
+	watchInteractive bool
+)
+
+// NewWatchCommand returns the cobra command for "watch".
+func NewWatchCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "watch [key or prefix]",
+		Short: "Watch watches events stream on keys or prefixes.",
+		Run:   watchCommandFunc,
+	}
+
+	cmd.Flags().BoolVarP(&watchInteractive, "interactive", "i", false, "interactive mode")
+	cmd.Flags().BoolVar(&watchPrefix, "prefix", false, "watch on a prefix if prefix is set")
+	cmd.Flags().Int64Var(&watchRev, "rev", 0, "revision to start watching")
+
+	return cmd
+}
+
+// watchCommandFunc executes the "watch" command.
+func watchCommandFunc(cmd *cobra.Command, args []string) {
+	if watchInteractive {
+		watchInteractiveFunc(cmd, args)
+		return
+	}
+
+	if len(args) != 1 {
+		ExitWithError(ExitBadArgs, fmt.Errorf("watch in non-interactive mode requires an argument as key or prefix"))
+	}
+
+	opts := []clientv3.OpOption{clientv3.WithRev(watchRev)}
+	if watchPrefix {
+		opts = append(opts, clientv3.WithPrefix())
+	}
+	c := mustClientFromCmd(cmd)
+	wc := c.Watch(context.TODO(), args[0], opts...)
+	printWatchCh(wc)
+	err := c.Close()
+	if err == nil {
+		ExitWithError(ExitInterrupted, fmt.Errorf("watch is canceled by the server"))
+	}
+	ExitWithError(ExitBadConnection, err)
+}
+
+func watchInteractiveFunc(cmd *cobra.Command, args []string) {
+	c := mustClientFromCmd(cmd)
+
+	reader := bufio.NewReader(os.Stdin)
+
+	for {
+		l, err := reader.ReadString('\n')
+		if err != nil {
+			ExitWithError(ExitInvalidInput, fmt.Errorf("Error reading watch request line: %v", err))
+		}
+		l = strings.TrimSuffix(l, "\n")
+
+		args := argify(l)
+		if len(args) < 2 {
+			fmt.Fprintf(os.Stderr, "Invalid command %s (command type or key is not provided)\n", l)
+			continue
+		}
+
+		if args[0] != "watch" {
+			fmt.Fprintf(os.Stderr, "Invalid command %s (only support watch)\n", l)
+			continue
+		}
+
+		flagset := NewWatchCommand().Flags()
+		err = flagset.Parse(args[1:])
+		if err != nil {
+			fmt.Fprintf(os.Stderr, "Invalid command %s (%v)\n", l, err)
+			continue
+		}
+		moreargs := flagset.Args()
+		if len(moreargs) != 1 {
+			fmt.Fprintf(os.Stderr, "Invalid command %s (Too many arguments)\n", l)
+			continue
+		}
+		var key string
+		_, err = fmt.Sscanf(moreargs[0], "%q", &key)
+		if err != nil {
+			key = moreargs[0]
+		}
+		opts := []clientv3.OpOption{clientv3.WithRev(watchRev)}
+		if watchPrefix {
+			opts = append(opts, clientv3.WithPrefix())
+		}
+		ch := c.Watch(context.TODO(), key, opts...)
+		go printWatchCh(ch)
+	}
+}
+
+func printWatchCh(ch clientv3.WatchChan) {
+	for resp := range ch {
+		display.Watch(resp)
+	}
+}
diff --git a/etcdctl/ctlv3/ctl.go b/etcdctl/ctlv3/ctl.go
new file mode 100644
index 0000000..428241f
--- /dev/null
+++ b/etcdctl/ctlv3/ctl.go
@@ -0,0 +1,97 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package ctlv3 contains the main entry point for the etcdctl for v3 API.
+package ctlv3
+
+import (
+	"text/tabwriter"
+	"time"
+
+	"github.com/coreos/etcd/etcdctl/ctlv3/command"
+	"github.com/spf13/cobra"
+)
+
+const (
+	cliName        = "etcdctl"
+	cliDescription = "A simple command line client for etcd3."
+
+	defaultDialTimeout    = 2 * time.Second
+	defaultCommandTimeOut = 5 * time.Second
+)
+
+var (
+	tabOut      *tabwriter.Writer
+	globalFlags = command.GlobalFlags{}
+)
+
+var (
+	rootCmd = &cobra.Command{
+		Use:        cliName,
+		Short:      cliDescription,
+		SuggestFor: []string{"etcdctl"},
+	}
+)
+
+func init() {
+	rootCmd.PersistentFlags().StringSliceVar(&globalFlags.Endpoints, "endpoints", []string{"127.0.0.1:2379", "127.0.0.1:22379", "127.0.0.1:32379"}, "gRPC endpoints")
+
+	rootCmd.PersistentFlags().StringVarP(&globalFlags.OutputFormat, "write-out", "w", "simple", "set the output format (simple, json, protobuf)")
+	rootCmd.PersistentFlags().BoolVar(&globalFlags.IsHex, "hex", false, "print byte strings as hex encoded strings")
+
+	rootCmd.PersistentFlags().DurationVar(&globalFlags.DialTimeout, "dial-timeout", defaultDialTimeout, "dial timeout for client connections")
+	rootCmd.PersistentFlags().DurationVar(&globalFlags.CommandTimeOut, "command-timeout", defaultCommandTimeOut, "timeout for short running command (excluding dial timeout)")
+
+	// TODO: secure by default when etcd enables secure gRPC by default.
+	rootCmd.PersistentFlags().BoolVar(&globalFlags.Insecure, "insecure-transport", true, "disable transport security for client connections")
+	rootCmd.PersistentFlags().BoolVar(&globalFlags.InsecureSkipVerify, "insecure-skip-tls-verify", false, "skip server certificate verification")
+	rootCmd.PersistentFlags().StringVar(&globalFlags.TLS.CertFile, "cert", "", "identify secure client using this TLS certificate file")
+	rootCmd.PersistentFlags().StringVar(&globalFlags.TLS.KeyFile, "key", "", "identify secure client using this TLS key file")
+	rootCmd.PersistentFlags().StringVar(&globalFlags.TLS.CAFile, "cacert", "", "verify certificates of TLS-enabled secure servers using this CA bundle")
+
+	rootCmd.AddCommand(
+		command.NewGetCommand(),
+		command.NewPutCommand(),
+		command.NewDelCommand(),
+		command.NewTxnCommand(),
+		command.NewCompactionCommand(),
+		command.NewDefragCommand(),
+		command.NewWatchCommand(),
+		command.NewVersionCommand(),
+		command.NewLeaseCommand(),
+		command.NewMemberCommand(),
+		command.NewEpHealthCommand(),
+		command.NewSnapshotCommand(),
+		command.NewMakeMirrorCommand(),
+		command.NewLockCommand(),
+		command.NewAuthCommand(),
+		command.NewElectCommand(),
+		command.NewUserCommand(),
+	)
+}
+
+func init() {
+	cobra.EnablePrefixMatching = true
+}
+
+func Start() {
+	rootCmd.SetUsageFunc(usageFunc)
+
+	// Make help just show the usage
+	rootCmd.SetHelpTemplate(`{{.UsageString}}`)
+
+	if err := rootCmd.Execute(); err != nil {
+		command.ExitWithError(command.ExitError, err)
+	}
+}
diff --git a/etcdctl/ctlv3/help.go b/etcdctl/ctlv3/help.go
new file mode 100644
index 0000000..e7633df
--- /dev/null
+++ b/etcdctl/ctlv3/help.go
@@ -0,0 +1,166 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// copied from https://github.com/coreos/rkt/blob/master/rkt/help.go
+
+package ctlv3
+
+import (
+	"bytes"
+	"fmt"
+	"io"
+	"os"
+	"strings"
+	"text/tabwriter"
+	"text/template"
+
+	"github.com/coreos/etcd/version"
+	"github.com/spf13/cobra"
+	"github.com/spf13/pflag"
+)
+
+var (
+	commandUsageTemplate *template.Template
+	templFuncs           = template.FuncMap{
+		"descToLines": func(s string) []string {
+			// trim leading/trailing whitespace and split into slice of lines
+			return strings.Split(strings.Trim(s, "\n\t "), "\n")
+		},
+		"cmdName": func(cmd *cobra.Command, startCmd *cobra.Command) string {
+			parts := []string{cmd.Name()}
+			for cmd.HasParent() && cmd.Parent().Name() != startCmd.Name() {
+				cmd = cmd.Parent()
+				parts = append([]string{cmd.Name()}, parts...)
+			}
+			return strings.Join(parts, " ")
+		},
+	}
+)
+
+func init() {
+	commandUsage := `
+{{ $cmd := .Cmd }}\
+{{ $cmdname := cmdName .Cmd .Cmd.Root }}\
+NAME:
+{{ if not .Cmd.HasParent }}\
+{{printf "\t%s - %s" .Cmd.Name .Cmd.Short}}
+{{else}}\
+{{printf "\t%s - %s" $cmdname .Cmd.Short}}
+{{end}}\
+
+USAGE:
+{{printf "\t%s" .Cmd.UseLine}}
+{{ if not .Cmd.HasParent }}\
+
+VERSION:
+{{printf "\t%s" .Version}}
+{{end}}\
+{{if .Cmd.HasSubCommands}}\
+
+COMMANDS:
+{{range .SubCommands}}\
+{{ $cmdname := cmdName . $cmd }}\
+{{ if .Runnable }}\
+{{printf "\t%s\t%s" $cmdname .Short}}
+{{end}}\
+{{end}}\
+{{end}}\
+{{ if .Cmd.Long }}\
+
+DESCRIPTION:
+{{range $line := descToLines .Cmd.Long}}{{printf "\t%s" $line}}
+{{end}}\
+{{end}}\
+{{if .Cmd.HasLocalFlags}}\
+
+OPTIONS:
+{{.LocalFlags}}\
+{{end}}\
+{{if .Cmd.HasInheritedFlags}}\
+
+GLOBAL OPTIONS:
+{{.GlobalFlags}}\
+{{end}}
+`[1:]
+
+	commandUsageTemplate = template.Must(template.New("command_usage").Funcs(templFuncs).Parse(strings.Replace(commandUsage, "\\\n", "", -1)))
+}
+
+func etcdFlagUsages(flagSet *pflag.FlagSet) string {
+	x := new(bytes.Buffer)
+
+	flagSet.VisitAll(func(flag *pflag.Flag) {
+		if len(flag.Deprecated) > 0 {
+			return
+		}
+		format := ""
+		if len(flag.Shorthand) > 0 {
+			format = "  -%s, --%s"
+		} else {
+			format = "   %s   --%s"
+		}
+		if len(flag.NoOptDefVal) > 0 {
+			format = format + "["
+		}
+		if flag.Value.Type() == "string" {
+			// put quotes on the value
+			format = format + "=%q"
+		} else {
+			format = format + "=%s"
+		}
+		if len(flag.NoOptDefVal) > 0 {
+			format = format + "]"
+		}
+		format = format + "\t%s\n"
+		shorthand := flag.Shorthand
+		fmt.Fprintf(x, format, shorthand, flag.Name, flag.DefValue, flag.Usage)
+	})
+
+	return x.String()
+}
+
+func getSubCommands(cmd *cobra.Command) []*cobra.Command {
+	var subCommands []*cobra.Command
+	for _, subCmd := range cmd.Commands() {
+		subCommands = append(subCommands, subCmd)
+		subCommands = append(subCommands, getSubCommands(subCmd)...)
+	}
+	return subCommands
+}
+
+func usageFunc(cmd *cobra.Command) error {
+	subCommands := getSubCommands(cmd)
+	tabOut := getTabOutWithWriter(os.Stdout)
+	commandUsageTemplate.Execute(tabOut, struct {
+		Cmd         *cobra.Command
+		LocalFlags  string
+		GlobalFlags string
+		SubCommands []*cobra.Command
+		Version     string
+	}{
+		cmd,
+		etcdFlagUsages(cmd.LocalFlags()),
+		etcdFlagUsages(cmd.InheritedFlags()),
+		subCommands,
+		version.Version,
+	})
+	tabOut.Flush()
+	return nil
+}
+
+func getTabOutWithWriter(writer io.Writer) *tabwriter.Writer {
+	aTabOut := new(tabwriter.Writer)
+	aTabOut.Init(writer, 0, 8, 1, '\t', 0)
+	return aTabOut
+}
diff --git a/etcdctl/doc/mirror_maker.md b/etcdctl/doc/mirror_maker.md
new file mode 100644
index 0000000..6b14a25
--- /dev/null
+++ b/etcdctl/doc/mirror_maker.md
@@ -0,0 +1,29 @@
+## Mirror Maker
+
+Mirror maker mirrors a prefix in the key-value space of an etcd cluster into another prefix in another cluster. Mirroring is designed for copying configuration to various clusters distributed around the world. Mirroring usually has very low latency once it completes synchronizing with the initial state. Mirror maker utilizes the etcd watcher facility to immediately inform the mirror of any key modifications. Based on our experiments, the network latency between the mirror maker and the two clusters accounts for most of the latency. If the network is healthy, copying configuration held in etcd to the mirror should take under one second even for a world-wide deployment.
+
+If the mirror maker fails to connect to one of the clusters, the mirroring will pause. Mirroring can  be resumed automatically once connectivity is reestablished.
+
+The mirroring mechanism is unidirectional. Data under the destination cluster’s mirroring prefix should be treated as read only. The mirror maker only mirrors key-value pairs; metadata, such as version number or modification revision, is discarded. However, mirror maker still attempts to preserve update ordering during normal operation, but there is no ordering guarantee during initial sync nor during failure recovery following network interruption. As a rule of thumb, the ordering of the updates on the mirror should not be considered reliable.
+
+```
++-------------+
+|             |
+|  source     |      +-----------+
+|  cluster    +----> |  mirror   |
+|             |      |  maker    |
++-------------+      +---+-------+
+                         |
+                         v
+               +-------------+
+               |             |
+               |    mirror  |
+               |    cluster  |
+               |             |
+               +-------------+
+
+```
+
+Mirror-maker is a built-in feature of [etcdctl][etcdctl].
+
+[etcdctl]: ../README.md
diff --git a/etcdctl/main.go b/etcdctl/main.go
index 4b504b5..cf353e3 100644
--- a/etcdctl/main.go
+++ b/etcdctl/main.go
@@ -1,4 +1,4 @@
-// Copyright 2015 CoreOS, Inc.
+// Copyright 2016 CoreOS, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -16,55 +16,31 @@
 package main
 
 import (
+	"fmt"
 	"os"
-	"time"
 
-	"github.com/codegangsta/cli"
-	"github.com/coreos/etcd/etcdctl/command"
-	"github.com/coreos/etcd/version"
+	"github.com/coreos/etcd/etcdctl/ctlv2"
+	"github.com/coreos/etcd/etcdctl/ctlv3"
+)
+
+const (
+	apiEnv = "ETCDCTL_API"
 )
 
 func main() {
-	app := cli.NewApp()
-	app.Name = "etcdctl"
-	app.Version = version.Version
-	app.Usage = "A simple command line client for etcd."
-	app.Flags = []cli.Flag{
-		cli.BoolFlag{Name: "debug", Usage: "output cURL commands which can be used to reproduce the request"},
-		cli.BoolFlag{Name: "no-sync", Usage: "don't synchronize cluster information before sending request"},
-		cli.StringFlag{Name: "output, o", Value: "simple", Usage: "output response in the given format (`simple`, `extended` or `json`)"},
-		cli.StringFlag{Name: "discovery-srv, D", Usage: "domain name to query for SRV records describing cluster endpoints"},
-		cli.StringFlag{Name: "peers, C", Value: "", Usage: "DEPRECATED - \"--endpoints\" should be used instead"},
-		cli.StringFlag{Name: "endpoint", Value: "", Usage: "DEPRECATED - \"--endpoints\" should be used instead"},
-		cli.StringFlag{Name: "endpoints", Value: "", Usage: "a comma-delimited list of machine addresses in the cluster (default: \"http://127.0.0.1:2379,http://127.0.0.1:4001\")"},
-		cli.StringFlag{Name: "cert-file", Value: "", Usage: "identify HTTPS client using this SSL certificate file"},
-		cli.StringFlag{Name: "key-file", Value: "", Usage: "identify HTTPS client using this SSL key file"},
-		cli.StringFlag{Name: "ca-file", Value: "", Usage: "verify certificates of HTTPS-enabled servers using this CA bundle"},
-		cli.StringFlag{Name: "username, u", Value: "", Usage: "provide username[:password] and prompt if password is not supplied."},
-		cli.DurationFlag{Name: "timeout", Value: time.Second, Usage: "connection timeout per request"},
-		cli.DurationFlag{Name: "total-timeout", Value: 5 * time.Second, Usage: "timeout for the command execution (except watch)"},
+	apiv := os.Getenv(apiEnv)
+	// unset apiEnv to avoid side-effect for future env and flag parsing.
+	os.Unsetenv(apiv)
+	if len(apiv) == 0 || apiv == "2" {
+		ctlv2.Start()
+		return
 	}
-	app.Commands = []cli.Command{
-		command.NewBackupCommand(),
-		command.NewClusterHealthCommand(),
-		command.NewMakeCommand(),
-		command.NewMakeDirCommand(),
-		command.NewRemoveCommand(),
-		command.NewRemoveDirCommand(),
-		command.NewGetCommand(),
-		command.NewLsCommand(),
-		command.NewSetCommand(),
-		command.NewSetDirCommand(),
-		command.NewUpdateCommand(),
-		command.NewUpdateDirCommand(),
-		command.NewWatchCommand(),
-		command.NewExecWatchCommand(),
-		command.NewMemberCommand(),
-		command.NewImportSnapCommand(),
-		command.NewUserCommands(),
-		command.NewRoleCommands(),
-		command.NewAuthCommands(),
+
+	if apiv == "3" {
+		ctlv3.Start()
+		return
 	}
 
-	app.Run(os.Args)
+	fmt.Fprintln(os.Stderr, "unsupported API version", apiv)
+	os.Exit(1)
 }
diff --git a/etcdctlv3/.gitignore b/etcdctlv3/.gitignore
deleted file mode 100644
index c32e492..0000000
--- a/etcdctlv3/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-etcdctlv3
diff --git a/etcdctlv3/README.md b/etcdctlv3/README.md
deleted file mode 100644
index 00c32f2..0000000
--- a/etcdctlv3/README.md
+++ /dev/null
@@ -1,389 +0,0 @@
-etcdctl
-========
-
-## Commands
-
-### PUT [options] \<key\> \<value\>
-
-PUT assigns the specified value with the specified key. If key already holds a value, it is overwritten.
-
-#### Options
-
-- lease -- lease ID (in hexadecimal) to attach to the key.
-
-#### Return value
-
-##### Simple reply
-
-- OK if PUT executed correctly. Exit code is zero.
-
-- Error string if PUT failed. Exit code is non-zero.
-
-##### JSON reply
-
-The JSON encoding of the PUT [RPC response][etcdrpc].
-
-##### Protobuf reply
-
-The protobuf encoding of the PUT [RPC response][etcdrpc].
-
-#### Examples
-
-``` bash
-./etcdctl PUT foo bar --lease=0x1234abcd
-OK
-./etcdctl range foo
-bar
-```
-
-#### Notes
-
-If \<value\> isn't given as command line argument, this command tries to read the value from standard input.
-
-When \<value\> begins with '-', \<value\> is interpreted as a flag.
-Insert '--' for workaround:
-
-``` bash
-./etcdctl put <key> -- <value>
-./etcdctl put -- <key> <value>
-```
-
-### GET [options] \<key\> [range_end]
-
-GET gets the key or a range of keys [key, range_end) if `range-end` is given.
-
-#### Options
-
-- hex -- print out key and value as hex encode string
-
-- limit -- maximum number of results
-
-- order -- order of results; ASCEND or DESCEND
-
-- sort-by -- sort target; CREATE, KEY, MODIFY, VALUE, or VERSION
-
-TODO: add consistency, from, prefix
-
-#### Return value
-
-##### Simple reply
-
-- \<key\>\n\<value\>\n\<next_key\>\n\<next_value\>...
-
-- Error string if GET failed. Exit code is non-zero.
-
-##### JSON reply
-
-The JSON encoding of the [RPC message][etcdrpc] for a key-value pair for each fetched key-value.
-
-##### Protobuf reply
-
-The protobuf encoding of the [RPC message][etcdrpc] for a key-value pair for each fetched key-value.
-
-#### Examples
-
-``` bash
-./etcdctl get foo
-foo
-bar
-```
-
-#### Notes
-
-If any key or value contains non-printable characters or control characters, the output in text format (e.g. simple reply) might be ambiguous.
-Adding `--hex` to print key or value as hex encode string in text format can resolve this issue.
-
-### DEL [options] \<key\> [range_end]
-
-Removes the specified key or range of keys [key, range_end) if `range-end` is given.
-
-#### Options
-
-TODO: --prefix, --from
-
-#### Return value
-
-##### Simple reply
-
-- The number of keys that were removed in decimal if DEL executed correctly. Exit code is zero.
-
-- Error string if DEL failed. Exit code is non-zero.
-
-##### JSON reply
-
-The JSON encoding of the DeleteRange [RPC response][etcdrpc].
-
-##### Protobuf reply
-
-The protobuf encoding of the DeleteRange [RPC response][etcdrpc].
-
-#### Examples
-
-``` bash
-./etcdctl put foo bar
-OK
-./etcdctl del foo
-1
-./etcdctl range foo
-```
-
-### TXN [options]
-
-TXN reads multiple etcd requests from standard input and applies them as a single atomic transaction.
-A transaction consists of list of conditions, a list of requests to apply if all the conditions are true, and a list of requests to apply if any condition is false.
-
-#### Options
-
-- hex -- print out keys and values as hex encoded string
-
-- interactive -- input transaction with interactive prompting
-
-#### Input Format
-```ebnf
-<Txn> ::= <CMP>* "\n" <THEN> "\n" <ELSE> "\n"
-<CMP> ::= (<CMPCREATE>|<CMPMOD>|<CMPVAL>|<CMPVER>) "\n"
-<CMPOP> ::= "<" | "=" | ">"
-<CMPCREATE> := ("c"|"create")"("<KEY>")" <REVISION>
-<CMPMOD> ::= ("m"|"mod")"("<KEY>")" <CMPOP> <REVISION>
-<CMPVAL> ::= ("val"|"value")"("<KEY>")" <CMPOP> <VALUE>
-<CMPVER> ::= ("ver"|"version")"("<KEY>")" <CMPOP> <VERSION>
-<THEN> ::= <OP>*
-<ELSE> ::= <OP>*
-<OP> ::= ((see put, get, del etcdctl command syntax)) "\n"
-<KEY> ::= (%q formatted string)
-<VALUE> ::= (%q formatted string)
-<REVISION> ::= "\""[0-9]+"\""
-<VERSION> ::= "\""[0-9]+"\""
-```
-
-#### Return value
-
-##### Simple reply
-
-- SUCCESS if etcd processed the transaction success list, FAILURE if etcd processed the transaction failure list.
-
-- Simple reply for each command executed request list, each separated by a blank line.
-
-- Additional error string if TXN failed. Exit code is non-zero.
-
-##### JSON reply
-
-The JSON encoding of the Txn [RPC response][etcdrpc].
-
-##### Protobuf reply
-
-The protobuf encoding of the Txn [RPC response][etcdrpc].
-
-#### Examples
-
-txn in interactive mode:
-``` bash
-./etcdctl txn -i
-mod("key1") > "0"
-
-put key1 "overwrote-key1"
-
-put key1 "created-key1"
-put key2 "some extra key"
-
-FAILURE
-
-OK
-
-OK
-```
-
-txn in non-interactive mode:
-```
-./etcdctl txn <<<'mod("key1") > "0"
-
-put key1 "overwrote-key1"
-
-put key1 "created-key1"
-put key2 "some extra key"
-
-'
-FAILURE
-
-OK
-
-OK
-````
-
-### WATCH [options] [key or prefix]
-
-Watch watches events stream on keys or prefixes. The watch command runs until it encounters an error or is terminated by the user.
-
-#### Options
-
-- hex -- print out key and value as hex encode string
-
-- interactive -- begins an interactive watch session
-
-- prefix -- watch on a prefix if prefix is set.
-
-- rev -- the revision to start watching. Specifying a revision is useful for observing past events.
-
-#### Input Format
-
-Input is only accepted for interactive mode.
-
-```
-watch [options] <key or prefix>\n
-```
-
-#### Return value
-
-##### Simple reply
-
-- \<event\>\n\<key\>\n\<value\>\n\<event\>\n\<next_key\>\n\<next_value\>\n...
-
-- Additional error string if WATCH failed. Exit code is non-zero.
-
-##### JSON reply
-
-The JSON encoding of the [RPC message][storagerpc] for each received Event.
-
-##### Protobuf reply
-
-The protobuf encoding of the [RPC message][storagerpc] for each received Event.
-
-#### Examples
-
-##### Non-interactive
-
-``` bash
-./etcdctl watch foo
-PUT
-foo
-bar
-```
-
-##### Interactive
-
-``` bash
-./etcdctl watch -i
-watch foo
-watch foo
-PUT
-foo
-bar
-PUT
-foo
-bar
-```
-
-## Utility Commands
-
-### LOCK \<lockname\>
-
-LOCK acquires a distributed named mutex with a given name. Once the lock is acquired, it will be held until etcdctlv3 is terminated.
-
-#### Return value
-
-- Once the lock is acquired, the result for the GET on the unique lock holder key is displayed.
-
-- LOCK returns a zero exit code only if it is terminated by a signal and can release the lock.
-
-#### Example
-```bash
-./etcdctl lock mylock
-mylock/1234534535445
-
-
-```
-
-### Notes
-
-The lease length of a lock defaults to 60 seconds. If LOCK is abnormally terminated, lock progress may be delayed
-by up to 60 seconds.
-
-
-### ELECT [options] \<election-name\> [proposal]
-
-ELECT participates on a named election. A node announces its candidacy in the election by providing
-a proposal value. If a node wishes to observe the election, ELECT listens for new leaders values.
-Whenever a leader is elected, its proposal is given as output.
-
-#### Options
-
-- listen -- observe the election
-
-#### Return value
-
-- If a candidate, ELECT displays the GET on the leader key once the node is elected election.
-
-- If observing, ELECT streams the result for a GET on the leader key for the current election and all future elections.
-
-- ELECT returns a zero exit code only if it is terminated by a signal and can revoke its candidacy or leadership, if any.
-
-#### Example
-```bash
-./etcdctl elect myelection foo
-myelection/1456952310051373265
-foo
-
-```
-
-### Notes
-
-The lease length of a leader defaults to 60 seconds. If a candidate is abnormally terminated, election
-progress may be delayed by up to 60 seconds.
-
-
-### MAKE-MIRROR [options] \<destination\>
-
-[make-mirror][mirror] mirrors a key prefix in an etcd cluster to a destination etcd cluster.
-
-#### Options
-
-- dest-cacert -- TLS certificate authority file for destination cluster
-
-- dest-cert -- TLS certificate file for destination cluster
-
-- dest-key -- TLS key file for destination cluster
-
-- prefix -- The key-value prefix to mirror
-
-#### Return value
-
-Simple reply
-
-- The approximate total number of keys transferred to the destination cluster, updated every 30 seconds.
-
-- Error string if mirroring failed. Exit code is non-zero.
-
-#### Examples
-
-```
-./etcdctl make-mirror mirror.example.com:2379
-10
-18
-```
-
-[mirror]: ./doc/mirror_maker.md
-
-
-## Notes
-
-- JSON encoding for keys and values uses base64 since they are byte strings.
-
-
-[etcdrpc]: ../etcdserver/etcdserverpb/rpc.proto
-[storagerpc]: ../storage/storagepb/kv.proto
-
-## Compatibility Support
-
-etcdctl is still in its early stage. We try out best to ensure fully compatible releases, however we might break compatibility to fix bugs or improve commands. If we intend to release a version of etcdctl with backward incompatibilities, we will provide notice prior to release and have instructions on how to upgrade.
-
-### Input Compatibility
-
-Input includes the command name, its flags, and its arguments. We ensure backward compatibility of the input of normal commands in non-interactive mode.
-
-### Output Compatibility
-
-Output includes output from etcdctl and its exit code. etcdctl provides `simple` output format by default.
-We ensure compatibility for the `simple` output format of normal commands in non-interactive mode. Currently, we do not ensure
-backward compatibility for `JSON` format and the format in non-interactive mode. Currently, we do not ensure backward compatibility of utility commands.
-
-### TODO: compatibility with etcd server
diff --git a/etcdctlv3/command/auth_command.go b/etcdctlv3/command/auth_command.go
deleted file mode 100644
index cf7d21f..0000000
--- a/etcdctlv3/command/auth_command.go
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright 2016 Nippon Telegraph and Telephone Corporation.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-
-	"github.com/spf13/cobra"
-)
-
-// NewAuthCommand returns the cobra command for "auth".
-func NewAuthCommand() *cobra.Command {
-	ac := &cobra.Command{
-		Use:   "auth <enable or disable>",
-		Short: "Enable or disable authentication.",
-	}
-
-	ac.AddCommand(NewAuthEnableCommand())
-
-	return ac
-}
-
-func NewAuthEnableCommand() *cobra.Command {
-	return &cobra.Command{
-		Use:   "enable",
-		Short: "enable authentication",
-		Run:   authEnableCommandFunc,
-	}
-}
-
-// authEnableCommandFunc executes the "auth enable" command.
-func authEnableCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 0 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("auth enable command does not accept argument."))
-	}
-
-	ctx, cancel := commandCtx(cmd)
-	_, err := mustClientFromCmd(cmd).Auth.AuthEnable(ctx)
-	cancel()
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-}
diff --git a/etcdctlv3/command/compaction_command.go b/etcdctlv3/command/compaction_command.go
deleted file mode 100644
index 366e3e2..0000000
--- a/etcdctlv3/command/compaction_command.go
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"strconv"
-
-	"github.com/spf13/cobra"
-)
-
-// NewCompactionCommand returns the cobra command for "compaction".
-func NewCompactionCommand() *cobra.Command {
-	return &cobra.Command{
-		Use:   "compaction <revision>",
-		Short: "Compaction compacts the event history in etcd.",
-		Run:   compactionCommandFunc,
-	}
-}
-
-// compactionCommandFunc executes the "compaction" command.
-func compactionCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 1 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("compaction command needs 1 argument."))
-	}
-
-	rev, err := strconv.ParseInt(args[0], 10, 64)
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-
-	c := mustClientFromCmd(cmd)
-	ctx, cancel := commandCtx(cmd)
-	cerr := c.Compact(ctx, rev)
-	cancel()
-	if cerr != nil {
-		ExitWithError(ExitError, cerr)
-		return
-	}
-	fmt.Println("compacted revision", rev)
-}
diff --git a/etcdctlv3/command/defrag_command.go b/etcdctlv3/command/defrag_command.go
deleted file mode 100644
index 3a8e40d..0000000
--- a/etcdctlv3/command/defrag_command.go
+++ /dev/null
@@ -1,45 +0,0 @@
-// Copyright 2016 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"os"
-
-	"github.com/spf13/cobra"
-)
-
-// NewDefragCommand returns the cobra command for "Defrag".
-func NewDefragCommand() *cobra.Command {
-	return &cobra.Command{
-		Use:   "defrag",
-		Short: "defrag defragments the storage of the etcd members with given endpoints.",
-		Run:   defragCommandFunc,
-	}
-}
-
-func defragCommandFunc(cmd *cobra.Command, args []string) {
-	c := mustClientFromCmd(cmd)
-	for _, ep := range c.Endpoints() {
-		ctx, cancel := commandCtx(cmd)
-		_, err := c.Defragment(ctx, ep)
-		cancel()
-		if err != nil {
-			fmt.Fprintf(os.Stderr, "Failed to defragment etcd member[%s] (%v)\n", ep, err)
-		} else {
-			fmt.Printf("Finished defragmenting etcd member[%s]\n", ep)
-		}
-	}
-}
diff --git a/etcdctlv3/command/del_command.go b/etcdctlv3/command/del_command.go
deleted file mode 100644
index 6076667..0000000
--- a/etcdctlv3/command/del_command.go
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/spf13/cobra"
-)
-
-// NewDelCommand returns the cobra command for "del".
-func NewDelCommand() *cobra.Command {
-	return &cobra.Command{
-		Use:   "del [options] <key> [range_end]",
-		Short: "Removes the specified key or range of keys [key, range_end).",
-		Run:   delCommandFunc,
-	}
-}
-
-// delCommandFunc executes the "del" command.
-func delCommandFunc(cmd *cobra.Command, args []string) {
-	key, opts := getDelOp(cmd, args)
-	ctx, cancel := commandCtx(cmd)
-	resp, err := mustClientFromCmd(cmd).Delete(ctx, key, opts...)
-	cancel()
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-	display.Del(*resp)
-}
-
-func getDelOp(cmd *cobra.Command, args []string) (string, []clientv3.OpOption) {
-	if len(args) == 0 || len(args) > 2 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("del command needs one argument as key and an optional argument as range_end."))
-	}
-	opts := []clientv3.OpOption{}
-	key := args[0]
-	if len(args) > 1 {
-		opts = append(opts, clientv3.WithRange(args[1]))
-	}
-	return key, opts
-}
diff --git a/etcdctlv3/command/doc.go b/etcdctlv3/command/doc.go
deleted file mode 100644
index b9420fe..0000000
--- a/etcdctlv3/command/doc.go
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Package command is a set of libraries for etcd v3 commands.
-package command
diff --git a/etcdctlv3/command/elect_command.go b/etcdctlv3/command/elect_command.go
deleted file mode 100644
index e3e3cd4..0000000
--- a/etcdctlv3/command/elect_command.go
+++ /dev/null
@@ -1,132 +0,0 @@
-// Copyright 2016 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"os"
-	"os/signal"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/coreos/etcd/clientv3/concurrency"
-	"github.com/spf13/cobra"
-	"golang.org/x/net/context"
-)
-
-var (
-	electListen bool
-)
-
-// NewElectCommand returns the cobra command for "elect".
-func NewElectCommand() *cobra.Command {
-	cmd := &cobra.Command{
-		Use:   "elect <election-name> [proposal]",
-		Short: "elect observes and participates in leader election",
-		Run:   electCommandFunc,
-	}
-	cmd.Flags().BoolVarP(&electListen, "listen", "l", false, "observation mode")
-	return cmd
-}
-
-func electCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 1 && len(args) != 2 {
-		ExitWithError(ExitBadArgs, errors.New("elect takes one election name argument and an optional proposal argument."))
-	}
-	c := mustClientFromCmd(cmd)
-
-	var err error
-	if len(args) == 1 {
-		if !electListen {
-			ExitWithError(ExitBadArgs, errors.New("no proposal argument but -l not set"))
-		}
-		err = observe(c, args[0])
-	} else {
-		if electListen {
-			ExitWithError(ExitBadArgs, errors.New("proposal given but -l is set"))
-		}
-		err = campaign(c, args[0], args[1])
-	}
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-}
-
-func observe(c *clientv3.Client, election string) error {
-	e := concurrency.NewElection(c, election)
-	ctx, cancel := context.WithCancel(context.TODO())
-
-	donec := make(chan struct{})
-	sigc := make(chan os.Signal, 1)
-	signal.Notify(sigc, os.Interrupt, os.Kill)
-	go func() {
-		<-sigc
-		cancel()
-	}()
-
-	go func() {
-		for resp := range e.Observe(ctx) {
-			display.Get(resp)
-		}
-		close(donec)
-	}()
-
-	<-donec
-
-	select {
-	case <-ctx.Done():
-	default:
-		return errors.New("elect: observer lost")
-	}
-
-	return nil
-}
-
-func campaign(c *clientv3.Client, election string, prop string) error {
-	e := concurrency.NewElection(c, election)
-	ctx, cancel := context.WithCancel(context.TODO())
-
-	donec := make(chan struct{})
-	sigc := make(chan os.Signal, 1)
-	signal.Notify(sigc, os.Interrupt, os.Kill)
-	go func() {
-		<-sigc
-		cancel()
-		close(donec)
-	}()
-
-	s, serr := concurrency.NewSession(c)
-	if serr != nil {
-		return serr
-	}
-
-	if err := e.Campaign(ctx, prop); err != nil {
-		return err
-	}
-
-	// print key since elected
-	resp, err := c.Get(ctx, e.Key())
-	if err != nil {
-		return err
-	}
-	display.Get(*resp)
-
-	select {
-	case <-donec:
-	case <-s.Done():
-		return errors.New("elect: session expired")
-	}
-
-	return e.Resign()
-}
diff --git a/etcdctlv3/command/ep_health_command.go b/etcdctlv3/command/ep_health_command.go
deleted file mode 100644
index 64a57be..0000000
--- a/etcdctlv3/command/ep_health_command.go
+++ /dev/null
@@ -1,83 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"sync"
-	"time"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/coreos/etcd/pkg/flags"
-	"github.com/spf13/cobra"
-)
-
-// NewEpHealthCommand returns the cobra command for "endpoint-health".
-func NewEpHealthCommand() *cobra.Command {
-	cmd := &cobra.Command{
-		Use:   "endpoint-health",
-		Short: "endpoint-health checks the healthiness of endpoints specified in `--endpoints` flag",
-		Run:   epHealthCommandFunc,
-	}
-	return cmd
-}
-
-// epHealthCommandFunc executes the "endpoint-health" command.
-func epHealthCommandFunc(cmd *cobra.Command, args []string) {
-	flags.SetPflagsFromEnv("ETCDCTL", cmd.InheritedFlags())
-	endpoints, err := cmd.Flags().GetStringSlice("endpoints")
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-
-	sec := secureCfgFromCmd(cmd)
-	dt := dialTimeoutFromCmd(cmd)
-	cfgs := []*clientv3.Config{}
-	for _, ep := range endpoints {
-		cfg, err := newClientCfg([]string{ep}, dt, sec)
-		if err != nil {
-			ExitWithError(ExitBadArgs, err)
-		}
-		cfgs = append(cfgs, cfg)
-	}
-
-	var wg sync.WaitGroup
-
-	for _, cfg := range cfgs {
-		wg.Add(1)
-		go func(cfg *clientv3.Config) {
-			defer wg.Done()
-			ep := cfg.Endpoints[0]
-			cli, err := clientv3.New(*cfg)
-			if err != nil {
-				fmt.Printf("%s is unhealthy: failed to connect: %v\n", ep, err)
-				return
-			}
-			st := time.Now()
-			// get a random key. As long as we can get the response without an error, the
-			// endpoint is health.
-			ctx, cancel := commandCtx(cmd)
-			_, err = cli.Get(ctx, "health")
-			cancel()
-			if err != nil {
-				fmt.Printf("%s is unhealthy: failed to commit proposal: %v\n", ep, err)
-			} else {
-				fmt.Printf("%s is healthy: successfully committed proposal: took = %v\n", ep, time.Since(st))
-			}
-		}(cfg)
-	}
-
-	wg.Wait()
-}
diff --git a/etcdctlv3/command/error.go b/etcdctlv3/command/error.go
deleted file mode 100644
index 2643329..0000000
--- a/etcdctlv3/command/error.go
+++ /dev/null
@@ -1,42 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"os"
-
-	"github.com/coreos/etcd/client"
-)
-
-const (
-	// http://tldp.org/LDP/abs/html/exitcodes.html
-	ExitSuccess = iota
-	ExitError
-	ExitBadConnection
-	ExitInvalidInput // for txn, watch command
-	ExitBadFeature   // provided a valid flag with an unsupported value
-	ExitInterrupted
-	ExitIO
-	ExitBadArgs = 128
-)
-
-func ExitWithError(code int, err error) {
-	fmt.Fprintln(os.Stderr, "Error: ", err)
-	if cerr, ok := err.(*client.ClusterError); ok {
-		fmt.Fprintln(os.Stderr, cerr.Detail())
-	}
-	os.Exit(code)
-}
diff --git a/etcdctlv3/command/get_command.go b/etcdctlv3/command/get_command.go
deleted file mode 100644
index 42405cb..0000000
--- a/etcdctlv3/command/get_command.go
+++ /dev/null
@@ -1,135 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"strings"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/spf13/cobra"
-)
-
-var (
-	getConsistency string
-	getLimit       int64
-	getSortOrder   string
-	getSortTarget  string
-	getPrefix      bool
-	getFromKey     bool
-)
-
-// NewGetCommand returns the cobra command for "get".
-func NewGetCommand() *cobra.Command {
-	cmd := &cobra.Command{
-		Use:   "get [options] <key> [range_end]",
-		Short: "Get gets the key or a range of keys.",
-		Run:   getCommandFunc,
-	}
-
-	cmd.Flags().StringVar(&getConsistency, "consistency", "l", "Linearizable(l) or Serializable(s)")
-	cmd.Flags().StringVar(&getSortOrder, "order", "", "order of results; ASCEND or DESCEND")
-	cmd.Flags().StringVar(&getSortTarget, "sort-by", "", "sort target; CREATE, KEY, MODIFY, VALUE, or VERSION")
-	cmd.Flags().Int64Var(&getLimit, "limit", 0, "maximum number of results")
-	cmd.Flags().BoolVar(&getPrefix, "prefix", false, "get keys with matching prefix")
-	cmd.Flags().BoolVar(&getFromKey, "from-key", false, "get keys that are greater than or equal to the given key")
-	return cmd
-}
-
-// getCommandFunc executes the "get" command.
-func getCommandFunc(cmd *cobra.Command, args []string) {
-	key, opts := getGetOp(cmd, args)
-	ctx, cancel := commandCtx(cmd)
-	resp, err := mustClientFromCmd(cmd).Get(ctx, key, opts...)
-	cancel()
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-
-	display.Get(*resp)
-}
-
-func getGetOp(cmd *cobra.Command, args []string) (string, []clientv3.OpOption) {
-	if len(args) == 0 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("range command needs arguments."))
-	}
-
-	if getPrefix && getFromKey {
-		ExitWithError(ExitBadArgs, fmt.Errorf("`--prefix` and `--from-key` cannot be set at the same time, choose one."))
-	}
-
-	opts := []clientv3.OpOption{}
-	switch getConsistency {
-	case "s":
-		opts = append(opts, clientv3.WithSerializable())
-	case "l":
-	default:
-		ExitWithError(ExitBadFeature, fmt.Errorf("unknown consistency flag %q", getConsistency))
-	}
-
-	key := args[0]
-	if len(args) > 1 {
-		if getPrefix || getFromKey {
-			ExitWithError(ExitBadArgs, fmt.Errorf("too many arguments, only accept one arguement when `--prefix` or `--from-key` is set."))
-		}
-		opts = append(opts, clientv3.WithRange(args[1]))
-	}
-
-	opts = append(opts, clientv3.WithLimit(getLimit))
-
-	sortByOrder := clientv3.SortNone
-	sortOrder := strings.ToUpper(getSortOrder)
-	switch {
-	case sortOrder == "ASCEND":
-		sortByOrder = clientv3.SortAscend
-	case sortOrder == "DESCEND":
-		sortByOrder = clientv3.SortDescend
-	case sortOrder == "":
-		// nothing
-	default:
-		ExitWithError(ExitBadFeature, fmt.Errorf("bad sort order %v", getSortOrder))
-	}
-
-	sortByTarget := clientv3.SortByKey
-	sortTarget := strings.ToUpper(getSortTarget)
-	switch {
-	case sortTarget == "CREATE":
-		sortByTarget = clientv3.SortByCreateRevision
-	case sortTarget == "KEY":
-		sortByTarget = clientv3.SortByKey
-	case sortTarget == "MODIFY":
-		sortByTarget = clientv3.SortByModRevision
-	case sortTarget == "VALUE":
-		sortByTarget = clientv3.SortByValue
-	case sortTarget == "VERSION":
-		sortByTarget = clientv3.SortByVersion
-	case sortTarget == "":
-		// nothing
-	default:
-		ExitWithError(ExitBadFeature, fmt.Errorf("bad sort target %v", getSortTarget))
-	}
-
-	opts = append(opts, clientv3.WithSort(sortByTarget, sortByOrder))
-
-	if getPrefix {
-		opts = append(opts, clientv3.WithPrefix())
-	}
-
-	if getFromKey {
-		opts = append(opts, clientv3.WithFromKey())
-	}
-
-	return key, opts
-}
diff --git a/etcdctlv3/command/global.go b/etcdctlv3/command/global.go
deleted file mode 100644
index 13a4531..0000000
--- a/etcdctlv3/command/global.go
+++ /dev/null
@@ -1,199 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"crypto/tls"
-	"errors"
-	"io"
-	"io/ioutil"
-	"time"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/coreos/etcd/pkg/flags"
-	"github.com/coreos/etcd/pkg/transport"
-	"github.com/spf13/cobra"
-)
-
-// GlobalFlags are flags that defined globally
-// and are inherited to all sub-commands.
-type GlobalFlags struct {
-	Insecure           bool
-	InsecureSkipVerify bool
-	Endpoints          []string
-	DialTimeout        time.Duration
-	CommandTimeOut     time.Duration
-
-	TLS transport.TLSInfo
-
-	OutputFormat string
-	IsHex        bool
-}
-
-type secureCfg struct {
-	cert   string
-	key    string
-	cacert string
-
-	insecureTransport  bool
-	insecureSkipVerify bool
-}
-
-var display printer = &simplePrinter{}
-
-func mustClientFromCmd(cmd *cobra.Command) *clientv3.Client {
-	flags.SetPflagsFromEnv("ETCDCTL", cmd.InheritedFlags())
-
-	endpoints, err := cmd.Flags().GetStringSlice("endpoints")
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-	dialTimeout := dialTimeoutFromCmd(cmd)
-	sec := secureCfgFromCmd(cmd)
-
-	return mustClient(endpoints, dialTimeout, sec)
-}
-
-func mustClient(endpoints []string, dialTimeout time.Duration, scfg *secureCfg) *clientv3.Client {
-	cfg, err := newClientCfg(endpoints, dialTimeout, scfg)
-	if err != nil {
-		ExitWithError(ExitBadArgs, err)
-	}
-
-	client, err := clientv3.New(*cfg)
-	if err != nil {
-		ExitWithError(ExitBadConnection, err)
-	}
-
-	return client
-}
-
-func newClientCfg(endpoints []string, dialTimeout time.Duration, scfg *secureCfg) (*clientv3.Config, error) {
-	// set tls if any one tls option set
-	var cfgtls *transport.TLSInfo
-	tlsinfo := transport.TLSInfo{}
-	if scfg.cert != "" {
-		tlsinfo.CertFile = scfg.cert
-		cfgtls = &tlsinfo
-	}
-
-	if scfg.key != "" {
-		tlsinfo.KeyFile = scfg.key
-		cfgtls = &tlsinfo
-	}
-
-	if scfg.cacert != "" {
-		tlsinfo.CAFile = scfg.cacert
-		cfgtls = &tlsinfo
-	}
-
-	cfg := &clientv3.Config{
-		Endpoints:   endpoints,
-		DialTimeout: dialTimeout,
-	}
-	if cfgtls != nil {
-		clientTLS, err := cfgtls.ClientConfig()
-		if err != nil {
-			return nil, err
-		}
-		cfg.TLS = clientTLS
-	}
-	// if key/cert is not given but user wants secure connection, we
-	// should still setup an empty tls configuration for gRPC to setup
-	// secure connection.
-	if cfg.TLS == nil && !scfg.insecureTransport {
-		cfg.TLS = &tls.Config{}
-	}
-
-	// If the user wants to skip TLS verification then we should set
-	// the InsecureSkipVerify flag in tls configuration.
-	if scfg.insecureSkipVerify && cfg.TLS != nil {
-		cfg.TLS.InsecureSkipVerify = true
-	}
-	return cfg, nil
-}
-
-func argOrStdin(args []string, stdin io.Reader, i int) (string, error) {
-	if i < len(args) {
-		return args[i], nil
-	}
-	bytes, err := ioutil.ReadAll(stdin)
-	if string(bytes) == "" || err != nil {
-		return "", errors.New("no available argument and stdin")
-	}
-	return string(bytes), nil
-}
-
-func dialTimeoutFromCmd(cmd *cobra.Command) time.Duration {
-	dialTimeout, err := cmd.Flags().GetDuration("dial-timeout")
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-	return dialTimeout
-}
-
-func secureCfgFromCmd(cmd *cobra.Command) *secureCfg {
-	cert, key, cacert := keyAndCertFromCmd(cmd)
-	insecureTr := insecureTransportFromCmd(cmd)
-	skipVerify := insecureSkipVerifyFromCmd(cmd)
-
-	return &secureCfg{
-		cert:   cert,
-		key:    key,
-		cacert: cacert,
-
-		insecureTransport:  insecureTr,
-		insecureSkipVerify: skipVerify,
-	}
-}
-
-func insecureTransportFromCmd(cmd *cobra.Command) bool {
-	insecureTr, err := cmd.Flags().GetBool("insecure-transport")
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-	return insecureTr
-}
-
-func insecureSkipVerifyFromCmd(cmd *cobra.Command) bool {
-	skipVerify, err := cmd.Flags().GetBool("insecure-skip-tls-verify")
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-	return skipVerify
-}
-
-func keyAndCertFromCmd(cmd *cobra.Command) (cert, key, cacert string) {
-	var err error
-	if cert, err = cmd.Flags().GetString("cert"); err != nil {
-		ExitWithError(ExitBadArgs, err)
-	} else if cert == "" && cmd.Flags().Changed("cert") {
-		ExitWithError(ExitBadArgs, errors.New("empty string is passed to --cert option"))
-	}
-
-	if key, err = cmd.Flags().GetString("key"); err != nil {
-		ExitWithError(ExitBadArgs, err)
-	} else if key == "" && cmd.Flags().Changed("key") {
-		ExitWithError(ExitBadArgs, errors.New("empty string is passed to --key option"))
-	}
-
-	if cacert, err = cmd.Flags().GetString("cacert"); err != nil {
-		ExitWithError(ExitBadArgs, err)
-	} else if cacert == "" && cmd.Flags().Changed("cacert") {
-		ExitWithError(ExitBadArgs, errors.New("empty string is passed to --cacert option"))
-	}
-
-	return cert, key, cacert
-}
diff --git a/etcdctlv3/command/lease_command.go b/etcdctlv3/command/lease_command.go
deleted file mode 100644
index ede7b33..0000000
--- a/etcdctlv3/command/lease_command.go
+++ /dev/null
@@ -1,139 +0,0 @@
-// Copyright 2016 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"os"
-	"strconv"
-
-	v3 "github.com/coreos/etcd/clientv3"
-	"github.com/spf13/cobra"
-	"golang.org/x/net/context"
-)
-
-// NewLeaseCommand returns the cobra command for "lease".
-func NewLeaseCommand() *cobra.Command {
-	lc := &cobra.Command{
-		Use:   "lease",
-		Short: "lease is used to manage leases.",
-	}
-
-	lc.AddCommand(NewLeaseCreateCommand())
-	lc.AddCommand(NewLeaseRevokeCommand())
-	lc.AddCommand(NewLeaseKeepAliveCommand())
-
-	return lc
-}
-
-// NewLeaseCreateCommand returns the cobra command for "lease create".
-func NewLeaseCreateCommand() *cobra.Command {
-	lc := &cobra.Command{
-		Use:   "create",
-		Short: "create is used to create leases.",
-
-		Run: leaseCreateCommandFunc,
-	}
-
-	return lc
-}
-
-// leaseCreateCommandFunc executes the "lease create" command.
-func leaseCreateCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 1 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("lease create command needs TTL argument."))
-	}
-
-	ttl, err := strconv.ParseInt(args[0], 10, 64)
-	if err != nil {
-		ExitWithError(ExitBadArgs, fmt.Errorf("bad TTL (%v)", err))
-	}
-
-	ctx, cancel := commandCtx(cmd)
-	resp, err := mustClientFromCmd(cmd).Create(ctx, ttl)
-	cancel()
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "failed to create lease (%v)\n", err)
-		return
-	}
-	fmt.Printf("lease %016x created with TTL(%ds)\n", resp.ID, resp.TTL)
-}
-
-// NewLeaseRevokeCommand returns the cobra command for "lease revoke".
-func NewLeaseRevokeCommand() *cobra.Command {
-	lc := &cobra.Command{
-		Use:   "revoke",
-		Short: "revoke is used to revoke leases.",
-
-		Run: leaseRevokeCommandFunc,
-	}
-
-	return lc
-}
-
-// leaseRevokeCommandFunc executes the "lease create" command.
-func leaseRevokeCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 1 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("lease revoke command needs 1 argument"))
-	}
-
-	id, err := strconv.ParseInt(args[0], 16, 64)
-	if err != nil {
-		ExitWithError(ExitBadArgs, fmt.Errorf("bad lease ID arg (%v), expecting ID in Hex", err))
-	}
-
-	ctx, cancel := commandCtx(cmd)
-	_, err = mustClientFromCmd(cmd).Revoke(ctx, v3.LeaseID(id))
-	cancel()
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "failed to revoke lease (%v)\n", err)
-		return
-	}
-	fmt.Printf("lease %016x revoked\n", id)
-}
-
-// NewLeaseKeepAliveCommand returns the cobra command for "lease keep-alive".
-func NewLeaseKeepAliveCommand() *cobra.Command {
-	lc := &cobra.Command{
-		Use:   "keep-alive",
-		Short: "keep-alive is used to keep leases alive.",
-
-		Run: leaseKeepAliveCommandFunc,
-	}
-
-	return lc
-}
-
-// leaseKeepAliveCommandFunc executes the "lease keep-alive" command.
-func leaseKeepAliveCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 1 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("lease keep-alive command needs lease ID as argument"))
-	}
-
-	id, err := strconv.ParseInt(args[0], 16, 64)
-	if err != nil {
-		ExitWithError(ExitBadArgs, fmt.Errorf("bad lease ID arg (%v), expecting ID in Hex", err))
-	}
-
-	respc, kerr := mustClientFromCmd(cmd).KeepAlive(context.TODO(), v3.LeaseID(id))
-	if kerr != nil {
-		ExitWithError(ExitBadConnection, kerr)
-	}
-
-	for resp := range respc {
-		fmt.Printf("lease %016x keepalived with TTL(%d)\n", resp.ID, resp.TTL)
-	}
-	fmt.Printf("lease %016x expired or revoked.\n", id)
-}
diff --git a/etcdctlv3/command/lock_command.go b/etcdctlv3/command/lock_command.go
deleted file mode 100644
index 57db4fa..0000000
--- a/etcdctlv3/command/lock_command.go
+++ /dev/null
@@ -1,88 +0,0 @@
-// Copyright 2016 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"os"
-	"os/signal"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/coreos/etcd/clientv3/concurrency"
-	"github.com/spf13/cobra"
-	"golang.org/x/net/context"
-)
-
-// NewLockCommand returns the cobra command for "lock".
-func NewLockCommand() *cobra.Command {
-	c := &cobra.Command{
-		Use:   "lock <lockname>",
-		Short: "lock acquires a named lock",
-		Run:   lockCommandFunc,
-	}
-	return c
-}
-
-func lockCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 1 {
-		ExitWithError(ExitBadArgs, errors.New("lock takes one lock name arguement."))
-	}
-	c := mustClientFromCmd(cmd)
-	if err := lockUntilSignal(c, args[0]); err != nil {
-		ExitWithError(ExitError, err)
-	}
-}
-
-func lockUntilSignal(c *clientv3.Client, lockname string) error {
-	m := concurrency.NewMutex(c, lockname)
-	ctx, cancel := context.WithCancel(context.TODO())
-
-	// unlock in case of ordinary shutdown
-	donec := make(chan struct{})
-	sigc := make(chan os.Signal, 1)
-	signal.Notify(sigc, os.Interrupt, os.Kill)
-	go func() {
-		<-sigc
-		cancel()
-		close(donec)
-	}()
-
-	s, serr := concurrency.NewSession(c)
-	if serr != nil {
-		return serr
-	}
-
-	if err := m.Lock(ctx); err != nil {
-		return err
-	}
-
-	k, kerr := c.Get(ctx, m.Key())
-	if kerr != nil {
-		return kerr
-	}
-	if len(k.Kvs) == 0 {
-		return errors.New("lock lost on init")
-	}
-
-	display.Get(*k)
-
-	select {
-	case <-donec:
-		return m.Unlock()
-	case <-s.Done():
-	}
-
-	return errors.New("session expired")
-}
diff --git a/etcdctlv3/command/make_mirror_command.go b/etcdctlv3/command/make_mirror_command.go
deleted file mode 100644
index 571ca3f..0000000
--- a/etcdctlv3/command/make_mirror_command.go
+++ /dev/null
@@ -1,148 +0,0 @@
-// Copyright 2016 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"errors"
-	"fmt"
-	"sync/atomic"
-	"time"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/coreos/etcd/clientv3/mirror"
-	"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
-	"github.com/coreos/etcd/storage/storagepb"
-	"github.com/spf13/cobra"
-	"golang.org/x/net/context"
-)
-
-var (
-	mminsecureTr bool
-	mmcert       string
-	mmkey        string
-	mmcacert     string
-	mmprefix     string
-)
-
-// NewMakeMirrorCommand returns the cobra command for "makeMirror".
-func NewMakeMirrorCommand() *cobra.Command {
-	c := &cobra.Command{
-		Use:   "make-mirror [options] <destination>",
-		Short: "make-mirror makes a mirror at the destination etcd cluster",
-		Run:   makeMirrorCommandFunc,
-	}
-
-	c.Flags().StringVar(&mmprefix, "prefix", "", "the key-value prefix to mirror")
-	// TODO: add dest-prefix to mirror a prefix to a different prefix in the destionation cluster?
-	c.Flags().StringVar(&mmcert, "dest-cert", "", "identify secure client using this TLS certificate file for the destination cluster")
-	c.Flags().StringVar(&mmkey, "dest-key", "", "identify secure client using this TLS key file")
-	c.Flags().StringVar(&mmcacert, "dest-cacert", "", "verify certificates of TLS enabled secure servers using this CA bundle")
-	// TODO: secure by default when etcd enables secure gRPC by default.
-	c.Flags().BoolVar(&mminsecureTr, "dest-insecure-transport", true, "disable transport security for client connections")
-
-	return c
-}
-
-func makeMirrorCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 1 {
-		ExitWithError(ExitBadArgs, errors.New("make-mirror takes one destination arguement."))
-	}
-
-	dialTimeout := dialTimeoutFromCmd(cmd)
-	sec := &secureCfg{
-		cert:              mmcert,
-		key:               mmkey,
-		cacert:            mmcacert,
-		insecureTransport: mminsecureTr,
-	}
-
-	dc := mustClient([]string{args[0]}, dialTimeout, sec)
-	c := mustClientFromCmd(cmd)
-
-	err := makeMirror(context.TODO(), c, dc)
-	ExitWithError(ExitError, err)
-}
-
-func makeMirror(ctx context.Context, c *clientv3.Client, dc *clientv3.Client) error {
-	total := int64(0)
-
-	go func() {
-		for {
-			time.Sleep(30 * time.Second)
-			fmt.Println(atomic.LoadInt64(&total))
-		}
-	}()
-
-	// TODO: remove the prefix of the destination cluster?
-	s := mirror.NewSyncer(c, mmprefix, 0)
-
-	rc, errc := s.SyncBase(ctx)
-
-	for r := range rc {
-		for _, kv := range r.Kvs {
-			_, err := dc.Put(ctx, string(kv.Key), string(kv.Value))
-			if err != nil {
-				return err
-			}
-			atomic.AddInt64(&total, 1)
-		}
-	}
-
-	err := <-errc
-	if err != nil {
-		return err
-	}
-
-	wc := s.SyncUpdates(ctx)
-
-	for wr := range wc {
-		if wr.CompactRevision != 0 {
-			return rpctypes.ErrCompacted
-		}
-
-		var rev int64
-		ops := []clientv3.Op{}
-
-		for _, ev := range wr.Events {
-			nrev := ev.Kv.ModRevision
-			if rev != 0 && nrev > rev {
-				_, err := dc.Txn(ctx).Then(ops...).Commit()
-				if err != nil {
-					return err
-				}
-				ops = []clientv3.Op{}
-			}
-			switch ev.Type {
-			case storagepb.PUT:
-				ops = append(ops, clientv3.OpPut(string(ev.Kv.Key), string(ev.Kv.Value)))
-				atomic.AddInt64(&total, 1)
-			case storagepb.DELETE, storagepb.EXPIRE:
-				ops = append(ops, clientv3.OpDelete(string(ev.Kv.Key)))
-				atomic.AddInt64(&total, 1)
-			default:
-				panic("unexpected event type")
-			}
-		}
-
-		if len(ops) != 0 {
-			_, err := dc.Txn(ctx).Then(ops...).Commit()
-			if err != nil {
-				return err
-			}
-		}
-	}
-
-	return nil
-}
diff --git a/etcdctlv3/command/member_command.go b/etcdctlv3/command/member_command.go
deleted file mode 100644
index 8a2b977..0000000
--- a/etcdctlv3/command/member_command.go
+++ /dev/null
@@ -1,176 +0,0 @@
-// Copyright 2016 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"strconv"
-	"strings"
-
-	"github.com/spf13/cobra"
-)
-
-var (
-	memberID       uint64
-	memberPeerURLs string
-)
-
-// NewMemberCommand returns the cobra command for "member".
-func NewMemberCommand() *cobra.Command {
-	mc := &cobra.Command{
-		Use:   "member",
-		Short: "member is used to manage membership in an etcd cluster.",
-	}
-
-	mc.AddCommand(NewMemberAddCommand())
-	mc.AddCommand(NewMemberRemoveCommand())
-	mc.AddCommand(NewMemberUpdateCommand())
-	mc.AddCommand(NewMemberListCommand())
-
-	return mc
-}
-
-// NewMemberAddCommand returns the cobra command for "member add".
-func NewMemberAddCommand() *cobra.Command {
-	cc := &cobra.Command{
-		Use:   "add",
-		Short: "add is used to add a member into the cluster",
-
-		Run: memberAddCommandFunc,
-	}
-
-	cc.Flags().StringVar(&memberPeerURLs, "peerURLs", "", "comma separated peer URLs for the new member.")
-
-	return cc
-}
-
-// NewMemberRemoveCommand returns the cobra command for "member remove".
-func NewMemberRemoveCommand() *cobra.Command {
-	cc := &cobra.Command{
-		Use:   "remove",
-		Short: "remove is used to remove a member from the cluster",
-
-		Run: memberRemoveCommandFunc,
-	}
-
-	return cc
-}
-
-// NewMemberUpdateCommand returns the cobra command for "member update".
-func NewMemberUpdateCommand() *cobra.Command {
-	cc := &cobra.Command{
-		Use:   "update",
-		Short: "update is used to update a member in the cluster",
-
-		Run: memberUpdateCommandFunc,
-	}
-
-	cc.Flags().StringVar(&memberPeerURLs, "peerURLs", "", "comma separated peer URLs for the updated member.")
-
-	return cc
-}
-
-// NewMemberListCommand returns the cobra command for "member list".
-func NewMemberListCommand() *cobra.Command {
-	cc := &cobra.Command{
-		Use:   "list",
-		Short: "list is used to list all members in the cluster",
-
-		Run: memberListCommandFunc,
-	}
-
-	return cc
-}
-
-// memberAddCommandFunc executes the "member add" command.
-func memberAddCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 1 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("member name not provided."))
-	}
-
-	if len(memberPeerURLs) == 0 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("member peer urls not provided."))
-	}
-
-	urls := strings.Split(memberPeerURLs, ",")
-	ctx, cancel := commandCtx(cmd)
-	resp, err := mustClientFromCmd(cmd).MemberAdd(ctx, urls)
-	cancel()
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-
-	fmt.Printf("Member %16x added to cluster %16x\n", resp.Member.ID, resp.Header.ClusterId)
-}
-
-// memberRemoveCommandFunc executes the "member remove" command.
-func memberRemoveCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 1 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("member ID is not provided"))
-	}
-
-	id, err := strconv.ParseUint(args[0], 16, 64)
-	if err != nil {
-		ExitWithError(ExitBadArgs, fmt.Errorf("bad member ID arg (%v), expecting ID in Hex", err))
-	}
-
-	ctx, cancel := commandCtx(cmd)
-	resp, err := mustClientFromCmd(cmd).MemberRemove(ctx, id)
-	cancel()
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-
-	fmt.Printf("Member %16x removed from cluster %16x\n", id, resp.Header.ClusterId)
-}
-
-// memberUpdateCommandFunc executes the "member update" command.
-func memberUpdateCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 1 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("member ID is not provided"))
-	}
-
-	id, err := strconv.ParseUint(args[0], 16, 64)
-	if err != nil {
-		ExitWithError(ExitBadArgs, fmt.Errorf("bad member ID arg (%v), expecting ID in Hex", err))
-	}
-
-	if len(memberPeerURLs) == 0 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("member peer urls not provided."))
-	}
-
-	urls := strings.Split(memberPeerURLs, ",")
-
-	ctx, cancel := commandCtx(cmd)
-	resp, err := mustClientFromCmd(cmd).MemberUpdate(ctx, id, urls)
-	cancel()
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-
-	fmt.Printf("Member %16x updated in cluster %16x\n", id, resp.Header.ClusterId)
-}
-
-// memberListCommandFunc executes the "member list" command.
-func memberListCommandFunc(cmd *cobra.Command, args []string) {
-	ctx, cancel := commandCtx(cmd)
-	resp, err := mustClientFromCmd(cmd).MemberList(ctx)
-	cancel()
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-
-	display.MemberList(*resp)
-}
diff --git a/etcdctlv3/command/printer.go b/etcdctlv3/command/printer.go
deleted file mode 100644
index df0abc3..0000000
--- a/etcdctlv3/command/printer.go
+++ /dev/null
@@ -1,183 +0,0 @@
-// Copyright 2016 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"encoding/json"
-	"errors"
-	"fmt"
-	"os"
-	"strings"
-
-	v3 "github.com/coreos/etcd/clientv3"
-	pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
-	spb "github.com/coreos/etcd/storage/storagepb"
-	"github.com/olekukonko/tablewriter"
-)
-
-type printer interface {
-	Del(v3.DeleteResponse)
-	Get(v3.GetResponse)
-	Put(v3.PutResponse)
-	Txn(v3.TxnResponse)
-	Watch(v3.WatchResponse)
-
-	MemberList(v3.MemberListResponse)
-}
-
-func NewPrinter(printerType string, isHex bool) printer {
-	switch printerType {
-	case "simple":
-		return &simplePrinter{isHex: isHex}
-	case "json":
-		return &jsonPrinter{}
-	case "protobuf":
-		return &pbPrinter{}
-	}
-	return nil
-}
-
-type simplePrinter struct {
-	isHex bool
-}
-
-func (s *simplePrinter) Del(v3.DeleteResponse) {
-	// TODO: add number of key removed into the response of delete.
-	// TODO: print out the number of removed keys.
-	fmt.Println(0)
-}
-
-func (s *simplePrinter) Get(resp v3.GetResponse) {
-	for _, kv := range resp.Kvs {
-		printKV(s.isHex, kv)
-	}
-}
-
-func (s *simplePrinter) Put(r v3.PutResponse) { fmt.Println("OK") }
-
-func (s *simplePrinter) Txn(resp v3.TxnResponse) {
-	if resp.Succeeded {
-		fmt.Println("SUCCESS")
-	} else {
-		fmt.Println("FAILURE")
-	}
-
-	for _, r := range resp.Responses {
-		fmt.Println("")
-		switch v := r.Response.(type) {
-		case *pb.ResponseUnion_ResponseDeleteRange:
-			s.Del((v3.DeleteResponse)(*v.ResponseDeleteRange))
-		case *pb.ResponseUnion_ResponsePut:
-			s.Put((v3.PutResponse)(*v.ResponsePut))
-		case *pb.ResponseUnion_ResponseRange:
-			s.Get(((v3.GetResponse)(*v.ResponseRange)))
-		default:
-			fmt.Printf("unexpected response %+v\n", r)
-		}
-	}
-}
-
-func (s *simplePrinter) Watch(resp v3.WatchResponse) {
-	for _, e := range resp.Events {
-		fmt.Println(e.Type)
-		printKV(s.isHex, e.Kv)
-	}
-}
-
-func (s *simplePrinter) MemberList(resp v3.MemberListResponse) {
-	table := tablewriter.NewWriter(os.Stdout)
-	table.SetHeader([]string{"ID", "Status", "Name", "Peer Addrs", "Client Addrs", "Is Leader"})
-
-	for _, m := range resp.Members {
-		status := "started"
-		if len(m.Name) == 0 {
-			status = "unstarted"
-		}
-
-		table.Append([]string{
-			fmt.Sprintf("%x", m.ID),
-			status,
-			m.Name,
-			strings.Join(m.PeerURLs, ","),
-			strings.Join(m.ClientURLs, ","),
-			fmt.Sprint(m.IsLeader),
-		})
-	}
-
-	table.Render()
-}
-
-type jsonPrinter struct{}
-
-func (p *jsonPrinter) Del(r v3.DeleteResponse) { printJSON(r) }
-func (p *jsonPrinter) Get(r v3.GetResponse) {
-	for _, kv := range r.Kvs {
-		printJSON(kv)
-	}
-}
-func (p *jsonPrinter) Put(r v3.PutResponse)               { printJSON(r) }
-func (p *jsonPrinter) Txn(r v3.TxnResponse)               { printJSON(r) }
-func (p *jsonPrinter) Watch(r v3.WatchResponse)           { printJSON(r) }
-func (p *jsonPrinter) MemberList(r v3.MemberListResponse) { printJSON(r) }
-
-func printJSON(v interface{}) {
-	b, err := json.Marshal(v)
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "%v\n", err)
-		return
-	}
-	fmt.Println(string(b))
-}
-
-type pbPrinter struct{}
-
-type pbMarshal interface {
-	Marshal() ([]byte, error)
-}
-
-func (p *pbPrinter) Del(r v3.DeleteResponse) {
-	printPB((*pb.DeleteRangeResponse)(&r))
-}
-
-func (p *pbPrinter) Get(r v3.GetResponse) {
-	printPB((*pb.RangeResponse)(&r))
-}
-
-func (p *pbPrinter) Put(r v3.PutResponse) {
-	printPB((*pb.PutResponse)(&r))
-}
-
-func (p *pbPrinter) Txn(r v3.TxnResponse) {
-	printPB((*pb.TxnResponse)(&r))
-}
-
-func (p *pbPrinter) Watch(r v3.WatchResponse) {
-	for _, ev := range r.Events {
-		printPB((*spb.Event)(ev))
-	}
-}
-
-func (pb *pbPrinter) MemberList(r v3.MemberListResponse) {
-	ExitWithError(ExitBadFeature, errors.New("only support simple or json as output format"))
-}
-
-func printPB(m pbMarshal) {
-	b, err := m.Marshal()
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "%v\n", err)
-		return
-	}
-	fmt.Printf(string(b))
-}
diff --git a/etcdctlv3/command/put_command.go b/etcdctlv3/command/put_command.go
deleted file mode 100644
index d596b70..0000000
--- a/etcdctlv3/command/put_command.go
+++ /dev/null
@@ -1,90 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"os"
-	"strconv"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/spf13/cobra"
-)
-
-var (
-	leaseStr string
-)
-
-// NewPutCommand returns the cobra command for "put".
-func NewPutCommand() *cobra.Command {
-	cmd := &cobra.Command{
-		Use:   "put [options] <key> <value> (<value> can also be given from stdin)",
-		Short: "Put puts the given key into the store.",
-		Long: `
-Put puts the given key into the store.
-
-When <value> begins with '-', <value> is interpreted as a flag.
-Insert '--' for workaround:
-
-$ put <key> -- <value>
-$ put -- <key> <value>
-
-If <value> isn't given as command line arguement, this command tries to read the value from standard input.
-For example,
-$ cat file | put <key>
-will store the content of the file to <key>.
-`,
-		Run: putCommandFunc,
-	}
-	cmd.Flags().StringVar(&leaseStr, "lease", "0", "lease ID (in hexadecimal) to attach to the key")
-	return cmd
-}
-
-// putCommandFunc executes the "put" command.
-func putCommandFunc(cmd *cobra.Command, args []string) {
-	key, value, opts := getPutOp(cmd, args)
-
-	ctx, cancel := commandCtx(cmd)
-	resp, err := mustClientFromCmd(cmd).Put(ctx, key, value, opts...)
-	cancel()
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-	display.Put(*resp)
-}
-
-func getPutOp(cmd *cobra.Command, args []string) (string, string, []clientv3.OpOption) {
-	if len(args) == 0 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("put command needs 1 argument and input from stdin or 2 arguments."))
-	}
-
-	key := args[0]
-	value, err := argOrStdin(args, os.Stdin, 1)
-	if err != nil {
-		ExitWithError(ExitBadArgs, fmt.Errorf("put command needs 1 argument and input from stdin or 2 arguments."))
-	}
-
-	id, err := strconv.ParseInt(leaseStr, 16, 64)
-	if err != nil {
-		ExitWithError(ExitBadArgs, fmt.Errorf("bad lease ID (%v), expecting ID in Hex", err))
-	}
-
-	opts := []clientv3.OpOption{}
-	if id != 0 {
-		opts = append(opts, clientv3.WithLease(clientv3.LeaseID(id)))
-	}
-
-	return key, value, opts
-}
diff --git a/etcdctlv3/command/snapshot_command.go b/etcdctlv3/command/snapshot_command.go
deleted file mode 100644
index b6edd5f..0000000
--- a/etcdctlv3/command/snapshot_command.go
+++ /dev/null
@@ -1,127 +0,0 @@
-// Copyright 2016 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"io"
-	"os"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/coreos/etcd/clientv3/mirror"
-	"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
-	"github.com/spf13/cobra"
-	"golang.org/x/net/context"
-)
-
-// NewSnapshotCommand returns the cobra command for "snapshot".
-func NewSnapshotCommand() *cobra.Command {
-	return &cobra.Command{
-		Use:   "snapshot [filename]",
-		Short: "Snapshot streams a point-in-time snapshot of the store",
-		Run:   snapshotCommandFunc,
-	}
-}
-
-// snapshotCommandFunc watches for the length of the entire store and records
-// to a file.
-func snapshotCommandFunc(cmd *cobra.Command, args []string) {
-	switch {
-	case len(args) == 0:
-		snapshotToStdout(mustClientFromCmd(cmd))
-	case len(args) == 1:
-		snapshotToFile(mustClientFromCmd(cmd), args[0])
-	default:
-		err := fmt.Errorf("snapshot takes at most one argument")
-		ExitWithError(ExitBadArgs, err)
-	}
-}
-
-// snapshotToStdout streams a snapshot over stdout
-func snapshotToStdout(c *clientv3.Client) {
-	// must explicitly fetch first revision since no retry on stdout
-	wr := <-c.Watch(context.TODO(), "", clientv3.WithPrefix(), clientv3.WithRev(1))
-	if wr.Err() == nil {
-		wr.CompactRevision = 1
-	}
-	if rev := snapshot(os.Stdout, c, wr.CompactRevision+1); rev != 0 {
-		err := fmt.Errorf("snapshot interrupted by compaction %v", rev)
-		ExitWithError(ExitInterrupted, err)
-	}
-	os.Stdout.Sync()
-}
-
-// snapshotToFile atomically writes a snapshot to a file
-func snapshotToFile(c *clientv3.Client, path string) {
-	partpath := path + ".part"
-	f, err := os.Create(partpath)
-	defer f.Close()
-	if err != nil {
-		exiterr := fmt.Errorf("could not open %s (%v)", partpath, err)
-		ExitWithError(ExitBadArgs, exiterr)
-	}
-	rev := int64(1)
-	for rev != 0 {
-		f.Seek(0, 0)
-		f.Truncate(0)
-		rev = snapshot(f, c, rev)
-	}
-	f.Sync()
-	if err := os.Rename(partpath, path); err != nil {
-		exiterr := fmt.Errorf("could not rename %s to %s (%v)", partpath, path, err)
-		ExitWithError(ExitIO, exiterr)
-	}
-}
-
-// snapshot reads all of a watcher; returns compaction revision if incomplete
-// TODO: stabilize snapshot format
-func snapshot(w io.Writer, c *clientv3.Client, rev int64) int64 {
-	s := mirror.NewSyncer(c, "", rev)
-
-	rc, errc := s.SyncBase(context.TODO())
-
-	for r := range rc {
-		for _, kv := range r.Kvs {
-			fmt.Fprintln(w, kv)
-		}
-	}
-
-	err := <-errc
-	if err != nil {
-		if err == rpctypes.ErrCompacted {
-			// will get correct compact revision on retry
-			return rev + 1
-		}
-		// failed for some unknown reason, retry on same revision
-		return rev
-	}
-
-	wc := s.SyncUpdates(context.TODO())
-
-	for wr := range wc {
-		if wr.Err() != nil {
-			return wr.CompactRevision
-		}
-		for _, ev := range wr.Events {
-			fmt.Fprintln(w, ev)
-		}
-		rev := wr.Events[len(wr.Events)-1].Kv.ModRevision
-		if rev >= wr.Header.Revision {
-			break
-		}
-	}
-
-	return 0
-}
diff --git a/etcdctlv3/command/txn_command.go b/etcdctlv3/command/txn_command.go
deleted file mode 100644
index c972ed8..0000000
--- a/etcdctlv3/command/txn_command.go
+++ /dev/null
@@ -1,203 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"bufio"
-	"fmt"
-	"os"
-	"strconv"
-	"strings"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/spf13/cobra"
-	"golang.org/x/net/context"
-)
-
-var (
-	txnInteractive bool
-)
-
-// NewTxnCommand returns the cobra command for "txn".
-func NewTxnCommand() *cobra.Command {
-	cmd := &cobra.Command{
-		Use:   "txn [options]",
-		Short: "Txn processes all the requests in one transaction.",
-		Run:   txnCommandFunc,
-	}
-	cmd.Flags().BoolVarP(&txnInteractive, "interactive", "i", false, "input transaction in interactive mode")
-	return cmd
-}
-
-// txnCommandFunc executes the "txn" command.
-func txnCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 0 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("txn command does not accept argument."))
-	}
-
-	reader := bufio.NewReader(os.Stdin)
-
-	txn := mustClientFromCmd(cmd).Txn(context.Background())
-	promptInteractive("compares:")
-	txn.If(readCompares(reader)...)
-	promptInteractive("success requests (get, put, delete):")
-	txn.Then(readOps(reader)...)
-	promptInteractive("failure requests (get, put, delete):")
-	txn.Else(readOps(reader)...)
-
-	resp, err := txn.Commit()
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-
-	display.Txn(*resp)
-}
-
-func promptInteractive(s string) {
-	if txnInteractive {
-		fmt.Println(s)
-	}
-}
-
-func readCompares(r *bufio.Reader) (cmps []clientv3.Cmp) {
-	for {
-		line, err := r.ReadString('\n')
-		if err != nil {
-			ExitWithError(ExitInvalidInput, err)
-		}
-		if len(line) == 1 {
-			break
-		}
-
-		// remove trialling \n
-		line = line[:len(line)-1]
-		cmp, err := parseCompare(line)
-		if err != nil {
-			ExitWithError(ExitInvalidInput, err)
-		}
-		cmps = append(cmps, *cmp)
-	}
-
-	return cmps
-}
-
-func readOps(r *bufio.Reader) (ops []clientv3.Op) {
-	for {
-		line, err := r.ReadString('\n')
-		if err != nil {
-			ExitWithError(ExitInvalidInput, err)
-		}
-		if len(line) == 1 {
-			break
-		}
-
-		// remove trialling \n
-		line = line[:len(line)-1]
-		op, err := parseRequestUnion(line)
-		if err != nil {
-			ExitWithError(ExitInvalidInput, err)
-		}
-		ops = append(ops, *op)
-	}
-
-	return ops
-}
-
-func parseRequestUnion(line string) (*clientv3.Op, error) {
-	args := argify(line)
-	if len(args) < 2 {
-		return nil, fmt.Errorf("invalid txn compare request: %s", line)
-	}
-
-	opc := make(chan clientv3.Op, 1)
-
-	put := NewPutCommand()
-	put.Run = func(cmd *cobra.Command, args []string) {
-		key, value, opts := getPutOp(cmd, args)
-		opc <- clientv3.OpPut(key, value, opts...)
-	}
-	get := NewGetCommand()
-	get.Run = func(cmd *cobra.Command, args []string) {
-		key, opts := getGetOp(cmd, args)
-		opc <- clientv3.OpGet(key, opts...)
-	}
-	del := NewDelCommand()
-	del.Run = func(cmd *cobra.Command, args []string) {
-		key, opts := getDelOp(cmd, args)
-		opc <- clientv3.OpDelete(key, opts...)
-	}
-	cmds := &cobra.Command{SilenceErrors: true}
-	cmds.AddCommand(put, get, del)
-
-	cmds.SetArgs(args)
-	if err := cmds.Execute(); err != nil {
-		return nil, fmt.Errorf("invalid txn request: %s", line)
-	}
-
-	op := <-opc
-	return &op, nil
-}
-
-func parseCompare(line string) (*clientv3.Cmp, error) {
-	var (
-		key string
-		op  string
-		val string
-	)
-
-	lparenSplit := strings.SplitN(line, "(", 2)
-	if len(lparenSplit) != 2 {
-		return nil, fmt.Errorf("malformed comparison: %s", line)
-	}
-
-	target := lparenSplit[0]
-	n, serr := fmt.Sscanf(lparenSplit[1], "%q) %s %q", &key, &op, &val)
-	if n != 3 {
-		return nil, fmt.Errorf("malformed comparison: %s; got %s(%q) %s %q", line, target, key, op, val)
-	}
-	if serr != nil {
-		return nil, fmt.Errorf("malformed comparison: %s (%v)", line, serr)
-	}
-
-	var (
-		v   int64
-		err error
-		cmp clientv3.Cmp
-	)
-	switch target {
-	case "ver", "version":
-		if v, err = strconv.ParseInt(val, 10, 64); err == nil {
-			cmp = clientv3.Compare(clientv3.Version(key), op, v)
-		}
-	case "c", "create":
-		if v, err = strconv.ParseInt(val, 10, 64); err == nil {
-			cmp = clientv3.Compare(clientv3.CreateRevision(key), op, v)
-		}
-	case "m", "mod":
-		if v, err = strconv.ParseInt(val, 10, 64); err == nil {
-			cmp = clientv3.Compare(clientv3.ModRevision(key), op, v)
-		}
-	case "val", "value":
-		cmp = clientv3.Compare(clientv3.Value(key), op, val)
-	default:
-		return nil, fmt.Errorf("malformed comparison: %s (unknown target %s)", line, target)
-	}
-
-	if err != nil {
-		return nil, fmt.Errorf("invalid txn compare request: %s", line)
-	}
-
-	return &cmp, nil
-}
diff --git a/etcdctlv3/command/user_command.go b/etcdctlv3/command/user_command.go
deleted file mode 100644
index 77fb797..0000000
--- a/etcdctlv3/command/user_command.go
+++ /dev/null
@@ -1,91 +0,0 @@
-// Copyright 2016 Nippon Telegraph and Telephone Corporation.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-	"strings"
-
-	"github.com/bgentry/speakeasy"
-	"github.com/spf13/cobra"
-	"golang.org/x/net/context"
-)
-
-// NewUserCommand returns the cobra command for "user".
-func NewUserCommand() *cobra.Command {
-	ac := &cobra.Command{
-		Use:   "user <subcommand>",
-		Short: "user related command",
-	}
-
-	ac.AddCommand(NewUserAddCommand())
-
-	return ac
-}
-
-var (
-	passwordInteractive bool
-)
-
-func NewUserAddCommand() *cobra.Command {
-	cmd := cobra.Command{
-		Use:   "add <user name>",
-		Short: "add a new user",
-		Run:   userAddCommandFunc,
-	}
-
-	cmd.Flags().BoolVar(&passwordInteractive, "interactive", true, "read password from stdin instead of interactive terminal")
-
-	return &cmd
-}
-
-// userAddCommandFunc executes the "user add" command.
-func userAddCommandFunc(cmd *cobra.Command, args []string) {
-	if len(args) != 1 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("user add command requires user name as its argument."))
-	}
-
-	var password string
-
-	if !passwordInteractive {
-		fmt.Scanf("%s", &password)
-	} else {
-		prompt1 := fmt.Sprintf("Password of %s: ", args[0])
-		password1, err1 := speakeasy.Ask(prompt1)
-		if err1 != nil {
-			ExitWithError(ExitBadArgs, fmt.Errorf("failed to ask password: %s.", err1))
-		}
-
-		if len(password1) == 0 {
-			ExitWithError(ExitBadArgs, fmt.Errorf("empty password"))
-		}
-
-		prompt2 := fmt.Sprintf("Type password of %s again for confirmation: ", args[0])
-		password2, err2 := speakeasy.Ask(prompt2)
-		if err2 != nil {
-			ExitWithError(ExitBadArgs, fmt.Errorf("failed to ask password: %s.", err2))
-		}
-
-		if strings.Compare(password1, password2) != 0 {
-			ExitWithError(ExitBadArgs, fmt.Errorf("given passwords are different."))
-		}
-		password = password1
-	}
-
-	_, err := mustClientFromCmd(cmd).Auth.UserAdd(context.TODO(), args[0], password)
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-}
diff --git a/etcdctlv3/command/util.go b/etcdctlv3/command/util.go
deleted file mode 100644
index 1d4e0ae..0000000
--- a/etcdctlv3/command/util.go
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"encoding/hex"
-	"fmt"
-	"regexp"
-
-	pb "github.com/coreos/etcd/storage/storagepb"
-	"github.com/spf13/cobra"
-	"golang.org/x/net/context"
-)
-
-func printKV(isHex bool, kv *pb.KeyValue) {
-	k, v := string(kv.Key), string(kv.Value)
-	if isHex {
-		k = addHexPrefix(hex.EncodeToString(kv.Key))
-		v = addHexPrefix(hex.EncodeToString(kv.Value))
-	}
-	fmt.Println(k)
-	fmt.Println(v)
-}
-
-func addHexPrefix(s string) string {
-	ns := make([]byte, len(s)*2)
-	for i := 0; i < len(s); i += 2 {
-		ns[i*2] = '\\'
-		ns[i*2+1] = 'x'
-		ns[i*2+2] = s[i]
-		ns[i*2+3] = s[i+1]
-	}
-	return string(ns)
-}
-
-func argify(s string) []string {
-	r := regexp.MustCompile("'.+'|\".+\"|\\S+")
-	return r.FindAllString(s, -1)
-}
-
-func commandCtx(cmd *cobra.Command) (context.Context, context.CancelFunc) {
-	timeOut, err := cmd.Flags().GetDuration("command-timeout")
-	if err != nil {
-		ExitWithError(ExitError, err)
-	}
-	return context.WithTimeout(context.Background(), timeOut)
-}
diff --git a/etcdctlv3/command/version_command.go b/etcdctlv3/command/version_command.go
deleted file mode 100644
index b3637f8..0000000
--- a/etcdctlv3/command/version_command.go
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"fmt"
-
-	"github.com/coreos/etcd/version"
-	"github.com/spf13/cobra"
-)
-
-// NewVersionCommand prints out the version of etcd.
-func NewVersionCommand() *cobra.Command {
-	return &cobra.Command{
-		Use:   "version",
-		Short: "Print the version of etcdctlv3.",
-		Run:   versionCommandFunc,
-	}
-}
-
-func versionCommandFunc(cmd *cobra.Command, args []string) {
-	fmt.Println(version.Version)
-}
diff --git a/etcdctlv3/command/watch_command.go b/etcdctlv3/command/watch_command.go
deleted file mode 100644
index 80ea88d..0000000
--- a/etcdctlv3/command/watch_command.go
+++ /dev/null
@@ -1,126 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package command
-
-import (
-	"bufio"
-	"fmt"
-	"os"
-	"strings"
-
-	"github.com/coreos/etcd/clientv3"
-	"github.com/spf13/cobra"
-	"golang.org/x/net/context"
-)
-
-var (
-	watchRev         int64
-	watchPrefix      bool
-	watchInteractive bool
-)
-
-// NewWatchCommand returns the cobra command for "watch".
-func NewWatchCommand() *cobra.Command {
-	cmd := &cobra.Command{
-		Use:   "watch [key or prefix]",
-		Short: "Watch watches events stream on keys or prefixes.",
-		Run:   watchCommandFunc,
-	}
-
-	cmd.Flags().BoolVarP(&watchInteractive, "interactive", "i", false, "interactive mode")
-	cmd.Flags().BoolVar(&watchPrefix, "prefix", false, "watch on a prefix if prefix is set")
-	cmd.Flags().Int64Var(&watchRev, "rev", 0, "revision to start watching")
-
-	return cmd
-}
-
-// watchCommandFunc executes the "watch" command.
-func watchCommandFunc(cmd *cobra.Command, args []string) {
-	if watchInteractive {
-		watchInteractiveFunc(cmd, args)
-		return
-	}
-
-	if len(args) != 1 {
-		ExitWithError(ExitBadArgs, fmt.Errorf("watch in non-interactive mode requires an argument as key or prefix"))
-	}
-
-	opts := []clientv3.OpOption{clientv3.WithRev(watchRev)}
-	if watchPrefix {
-		opts = append(opts, clientv3.WithPrefix())
-	}
-	c := mustClientFromCmd(cmd)
-	wc := c.Watch(context.TODO(), args[0], opts...)
-	printWatchCh(wc)
-	err := c.Close()
-	if err == nil {
-		ExitWithError(ExitInterrupted, fmt.Errorf("watch is canceled by the server"))
-	}
-	ExitWithError(ExitBadConnection, err)
-}
-
-func watchInteractiveFunc(cmd *cobra.Command, args []string) {
-	c := mustClientFromCmd(cmd)
-
-	reader := bufio.NewReader(os.Stdin)
-
-	for {
-		l, err := reader.ReadString('\n')
-		if err != nil {
-			ExitWithError(ExitInvalidInput, fmt.Errorf("Error reading watch request line: %v", err))
-		}
-		l = strings.TrimSuffix(l, "\n")
-
-		args := argify(l)
-		if len(args) < 2 {
-			fmt.Fprintf(os.Stderr, "Invalid command %s (command type or key is not provided)\n", l)
-			continue
-		}
-
-		if args[0] != "watch" {
-			fmt.Fprintf(os.Stderr, "Invalid command %s (only support watch)\n", l)
-			continue
-		}
-
-		flagset := NewWatchCommand().Flags()
-		err = flagset.Parse(args[1:])
-		if err != nil {
-			fmt.Fprintf(os.Stderr, "Invalid command %s (%v)\n", l, err)
-			continue
-		}
-		moreargs := flagset.Args()
-		if len(moreargs) != 1 {
-			fmt.Fprintf(os.Stderr, "Invalid command %s (Too many arguments)\n", l)
-			continue
-		}
-		var key string
-		_, err = fmt.Sscanf(moreargs[0], "%q", &key)
-		if err != nil {
-			key = moreargs[0]
-		}
-		opts := []clientv3.OpOption{clientv3.WithRev(watchRev)}
-		if watchPrefix {
-			opts = append(opts, clientv3.WithPrefix())
-		}
-		ch := c.Watch(context.TODO(), key, opts...)
-		go printWatchCh(ch)
-	}
-}
-
-func printWatchCh(ch clientv3.WatchChan) {
-	for resp := range ch {
-		display.Watch(resp)
-	}
-}
diff --git a/etcdctlv3/doc/mirror_maker.md b/etcdctlv3/doc/mirror_maker.md
deleted file mode 100644
index 6b14a25..0000000
--- a/etcdctlv3/doc/mirror_maker.md
+++ /dev/null
@@ -1,29 +0,0 @@
-## Mirror Maker
-
-Mirror maker mirrors a prefix in the key-value space of an etcd cluster into another prefix in another cluster. Mirroring is designed for copying configuration to various clusters distributed around the world. Mirroring usually has very low latency once it completes synchronizing with the initial state. Mirror maker utilizes the etcd watcher facility to immediately inform the mirror of any key modifications. Based on our experiments, the network latency between the mirror maker and the two clusters accounts for most of the latency. If the network is healthy, copying configuration held in etcd to the mirror should take under one second even for a world-wide deployment.
-
-If the mirror maker fails to connect to one of the clusters, the mirroring will pause. Mirroring can  be resumed automatically once connectivity is reestablished.
-
-The mirroring mechanism is unidirectional. Data under the destination cluster’s mirroring prefix should be treated as read only. The mirror maker only mirrors key-value pairs; metadata, such as version number or modification revision, is discarded. However, mirror maker still attempts to preserve update ordering during normal operation, but there is no ordering guarantee during initial sync nor during failure recovery following network interruption. As a rule of thumb, the ordering of the updates on the mirror should not be considered reliable.
-
-```
-+-------------+
-|             |
-|  source     |      +-----------+
-|  cluster    +----> |  mirror   |
-|             |      |  maker    |
-+-------------+      +---+-------+
-                         |
-                         v
-               +-------------+
-               |             |
-               |    mirror  |
-               |    cluster  |
-               |             |
-               +-------------+
-
-```
-
-Mirror-maker is a built-in feature of [etcdctl][etcdctl].
-
-[etcdctl]: ../README.md
diff --git a/etcdctlv3/help.go b/etcdctlv3/help.go
deleted file mode 100644
index 6796f63..0000000
--- a/etcdctlv3/help.go
+++ /dev/null
@@ -1,166 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// copied from https://github.com/coreos/rkt/blob/master/rkt/help.go
-
-package main
-
-import (
-	"bytes"
-	"fmt"
-	"io"
-	"os"
-	"strings"
-	"text/tabwriter"
-	"text/template"
-
-	"github.com/coreos/etcd/version"
-	"github.com/spf13/cobra"
-	"github.com/spf13/pflag"
-)
-
-var (
-	commandUsageTemplate *template.Template
-	templFuncs           = template.FuncMap{
-		"descToLines": func(s string) []string {
-			// trim leading/trailing whitespace and split into slice of lines
-			return strings.Split(strings.Trim(s, "\n\t "), "\n")
-		},
-		"cmdName": func(cmd *cobra.Command, startCmd *cobra.Command) string {
-			parts := []string{cmd.Name()}
-			for cmd.HasParent() && cmd.Parent().Name() != startCmd.Name() {
-				cmd = cmd.Parent()
-				parts = append([]string{cmd.Name()}, parts...)
-			}
-			return strings.Join(parts, " ")
-		},
-	}
-)
-
-func init() {
-	commandUsage := `
-{{ $cmd := .Cmd }}\
-{{ $cmdname := cmdName .Cmd .Cmd.Root }}\
-NAME:
-{{ if not .Cmd.HasParent }}\
-{{printf "\t%s - %s" .Cmd.Name .Cmd.Short}}
-{{else}}\
-{{printf "\t%s - %s" $cmdname .Cmd.Short}}
-{{end}}\
-
-USAGE:
-{{printf "\t%s" .Cmd.UseLine}}
-{{ if not .Cmd.HasParent }}\
-
-VERSION:
-{{printf "\t%s" .Version}}
-{{end}}\
-{{if .Cmd.HasSubCommands}}\
-
-COMMANDS:
-{{range .SubCommands}}\
-{{ $cmdname := cmdName . $cmd }}\
-{{ if .Runnable }}\
-{{printf "\t%s\t%s" $cmdname .Short}}
-{{end}}\
-{{end}}\
-{{end}}\
-{{ if .Cmd.Long }}\
-
-DESCRIPTION:
-{{range $line := descToLines .Cmd.Long}}{{printf "\t%s" $line}}
-{{end}}\
-{{end}}\
-{{if .Cmd.HasLocalFlags}}\
-
-OPTIONS:
-{{.LocalFlags}}\
-{{end}}\
-{{if .Cmd.HasInheritedFlags}}\
-
-GLOBAL OPTIONS:
-{{.GlobalFlags}}\
-{{end}}
-`[1:]
-
-	commandUsageTemplate = template.Must(template.New("command_usage").Funcs(templFuncs).Parse(strings.Replace(commandUsage, "\\\n", "", -1)))
-}
-
-func etcdFlagUsages(flagSet *pflag.FlagSet) string {
-	x := new(bytes.Buffer)
-
-	flagSet.VisitAll(func(flag *pflag.Flag) {
-		if len(flag.Deprecated) > 0 {
-			return
-		}
-		format := ""
-		if len(flag.Shorthand) > 0 {
-			format = "  -%s, --%s"
-		} else {
-			format = "   %s   --%s"
-		}
-		if len(flag.NoOptDefVal) > 0 {
-			format = format + "["
-		}
-		if flag.Value.Type() == "string" {
-			// put quotes on the value
-			format = format + "=%q"
-		} else {
-			format = format + "=%s"
-		}
-		if len(flag.NoOptDefVal) > 0 {
-			format = format + "]"
-		}
-		format = format + "\t%s\n"
-		shorthand := flag.Shorthand
-		fmt.Fprintf(x, format, shorthand, flag.Name, flag.DefValue, flag.Usage)
-	})
-
-	return x.String()
-}
-
-func getSubCommands(cmd *cobra.Command) []*cobra.Command {
-	var subCommands []*cobra.Command
-	for _, subCmd := range cmd.Commands() {
-		subCommands = append(subCommands, subCmd)
-		subCommands = append(subCommands, getSubCommands(subCmd)...)
-	}
-	return subCommands
-}
-
-func usageFunc(cmd *cobra.Command) error {
-	subCommands := getSubCommands(cmd)
-	tabOut := getTabOutWithWriter(os.Stdout)
-	commandUsageTemplate.Execute(tabOut, struct {
-		Cmd         *cobra.Command
-		LocalFlags  string
-		GlobalFlags string
-		SubCommands []*cobra.Command
-		Version     string
-	}{
-		cmd,
-		etcdFlagUsages(cmd.LocalFlags()),
-		etcdFlagUsages(cmd.InheritedFlags()),
-		subCommands,
-		version.Version,
-	})
-	tabOut.Flush()
-	return nil
-}
-
-func getTabOutWithWriter(writer io.Writer) *tabwriter.Writer {
-	aTabOut := new(tabwriter.Writer)
-	aTabOut.Init(writer, 0, 8, 1, '\t', 0)
-	return aTabOut
-}
diff --git a/etcdctlv3/main.go b/etcdctlv3/main.go
deleted file mode 100644
index be3c270..0000000
--- a/etcdctlv3/main.go
+++ /dev/null
@@ -1,97 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// etcdctlv3 is a command line application that utilizes v3 API.
-package main
-
-import (
-	"text/tabwriter"
-	"time"
-
-	"github.com/coreos/etcd/etcdctlv3/command"
-	"github.com/spf13/cobra"
-)
-
-const (
-	cliName        = "etcdctlv3"
-	cliDescription = "A simple command line client for etcd3."
-
-	defaultDialTimeout    = 2 * time.Second
-	defaultCommandTimeOut = 5 * time.Second
-)
-
-var (
-	tabOut      *tabwriter.Writer
-	globalFlags = command.GlobalFlags{}
-)
-
-var (
-	rootCmd = &cobra.Command{
-		Use:        cliName,
-		Short:      cliDescription,
-		SuggestFor: []string{"etcctlv3", "etcdcltv3", "etlctlv3"},
-	}
-)
-
-func init() {
-	rootCmd.PersistentFlags().StringSliceVar(&globalFlags.Endpoints, "endpoints", []string{"127.0.0.1:2379", "127.0.0.1:22379", "127.0.0.1:32379"}, "gRPC endpoints")
-
-	rootCmd.PersistentFlags().StringVarP(&globalFlags.OutputFormat, "write-out", "w", "simple", "set the output format (simple, json, protobuf)")
-	rootCmd.PersistentFlags().BoolVar(&globalFlags.IsHex, "hex", false, "print byte strings as hex encoded strings")
-
-	rootCmd.PersistentFlags().DurationVar(&globalFlags.DialTimeout, "dial-timeout", defaultDialTimeout, "dial timeout for client connections")
-	rootCmd.PersistentFlags().DurationVar(&globalFlags.CommandTimeOut, "command-timeout", defaultCommandTimeOut, "timeout for short running command (excluding dial timeout)")
-
-	// TODO: secure by default when etcd enables secure gRPC by default.
-	rootCmd.PersistentFlags().BoolVar(&globalFlags.Insecure, "insecure-transport", true, "disable transport security for client connections")
-	rootCmd.PersistentFlags().BoolVar(&globalFlags.InsecureSkipVerify, "insecure-skip-tls-verify", false, "skip server certificate verification")
-	rootCmd.PersistentFlags().StringVar(&globalFlags.TLS.CertFile, "cert", "", "identify secure client using this TLS certificate file")
-	rootCmd.PersistentFlags().StringVar(&globalFlags.TLS.KeyFile, "key", "", "identify secure client using this TLS key file")
-	rootCmd.PersistentFlags().StringVar(&globalFlags.TLS.CAFile, "cacert", "", "verify certificates of TLS-enabled secure servers using this CA bundle")
-
-	rootCmd.AddCommand(
-		command.NewGetCommand(),
-		command.NewPutCommand(),
-		command.NewDelCommand(),
-		command.NewTxnCommand(),
-		command.NewCompactionCommand(),
-		command.NewDefragCommand(),
-		command.NewWatchCommand(),
-		command.NewVersionCommand(),
-		command.NewLeaseCommand(),
-		command.NewMemberCommand(),
-		command.NewEpHealthCommand(),
-		command.NewSnapshotCommand(),
-		command.NewMakeMirrorCommand(),
-		command.NewLockCommand(),
-		command.NewAuthCommand(),
-		command.NewElectCommand(),
-		command.NewUserCommand(),
-	)
-}
-
-func init() {
-	cobra.EnablePrefixMatching = true
-}
-
-func main() {
-	rootCmd.SetUsageFunc(usageFunc)
-
-	// Make help just show the usage
-	rootCmd.SetHelpTemplate(`{{.UsageString}}`)
-
-	if err := rootCmd.Execute(); err != nil {
-		command.ExitWithError(command.ExitError, err)
-	}
-}
diff --git a/test b/test
index 99d3d92..8882667 100755
--- a/test
+++ b/test
@@ -17,7 +17,7 @@ GO_BUILD_FLAGS=-a
 source ./build
 
 # Hack: gofmt ./ will recursively check the .git directory. So use *.go for gofmt.
-TESTABLE_AND_FORMATTABLE="client clientv3 discovery error etcdctl/command etcdmain etcdserver etcdserver/auth etcdserver/etcdhttp etcdserver/etcdhttp/httptypes pkg/fileutil pkg/flags pkg/idutil pkg/ioutil pkg/netutil pkg/osutil pkg/pbutil pkg/types pkg/transport pkg/wait proxy raft snap storage storage/backend store version wal"
+TESTABLE_AND_FORMATTABLE="client clientv3 discovery error etcdctl/ctlv2 etcdctl/ctlv3 etcdmain etcdserver etcdserver/auth etcdserver/etcdhttp etcdserver/etcdhttp/httptypes pkg/fileutil pkg/flags pkg/idutil pkg/ioutil pkg/netutil pkg/osutil pkg/pbutil pkg/types pkg/transport pkg/wait proxy raft snap storage storage/backend store version wal"
 # TODO: add it to race testing when the issue is resolved
 # https://github.com/golang/go/issues/9946
 NO_RACE_TESTABLE="rafthttp"
