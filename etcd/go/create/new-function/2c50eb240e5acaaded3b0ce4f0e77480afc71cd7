commit 2c50eb240e5acaaded3b0ce4f0e77480afc71cd7
Author: Xiang Li <xiangli.cs@gmail.com>
Date:   Mon Apr 4 16:31:35 2016 -0700

    *: mv etcdhttp into api pkg

diff --git a/etcdmain/etcd.go b/etcdmain/etcd.go
index 71a265c..db77a1f 100644
--- a/etcdmain/etcd.go
+++ b/etcdmain/etcd.go
@@ -34,7 +34,7 @@ import (
 
 	"github.com/coreos/etcd/discovery"
 	"github.com/coreos/etcd/etcdserver"
-	"github.com/coreos/etcd/etcdserver/etcdhttp"
+	"github.com/coreos/etcd/etcdserver/api/v2http"
 	"github.com/coreos/etcd/pkg/cors"
 	"github.com/coreos/etcd/pkg/fileutil"
 	pkgioutil "github.com/coreos/etcd/pkg/ioutil"
@@ -363,10 +363,10 @@ func startEtcd(cfg *config) (<-chan struct{}, error) {
 		plog.Infof("cors = %s", cfg.corsInfo)
 	}
 	ch := http.Handler(&cors.CORSHandler{
-		Handler: etcdhttp.NewClientHandler(s, srvcfg.ReqTimeout()),
+		Handler: v2http.NewClientHandler(s, srvcfg.ReqTimeout()),
 		Info:    cfg.corsInfo,
 	})
-	ph := etcdhttp.NewPeerHandler(s)
+	ph := v2http.NewPeerHandler(s)
 
 	// Start the peer server in a goroutine
 	for _, l := range plns {
diff --git a/etcdserver/api/v2http/capability.go b/etcdserver/api/v2http/capability.go
new file mode 100644
index 0000000..73361ef
--- /dev/null
+++ b/etcdserver/api/v2http/capability.go
@@ -0,0 +1,100 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2http
+
+import (
+	"fmt"
+	"net/http"
+	"sync"
+	"time"
+
+	"github.com/coreos/etcd/etcdserver"
+	"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
+	"github.com/coreos/go-semver/semver"
+)
+
+type capability string
+
+const (
+	authCapability capability = "auth"
+)
+
+var (
+	// capabilityMaps is a static map of version to capability map.
+	// the base capabilities is the set of capability 2.0 supports.
+	capabilityMaps = map[string]map[capability]bool{
+		"2.1.0": {authCapability: true},
+		"2.2.0": {authCapability: true},
+		"2.3.0": {authCapability: true},
+	}
+
+	enableMapMu sync.Mutex
+	// enabledMap points to a map in capabilityMaps
+	enabledMap map[capability]bool
+)
+
+// capabilityLoop checks the cluster version every 500ms and updates
+// the enabledMap when the cluster version increased.
+// capabilityLoop MUST be ran in a goroutine before checking capability
+// or using capabilityHandler.
+func capabilityLoop(s *etcdserver.EtcdServer) {
+	stopped := s.StopNotify()
+
+	var pv *semver.Version
+	for {
+		if v := s.ClusterVersion(); v != pv {
+			if pv == nil {
+				pv = v
+			} else if v != nil && pv.LessThan(*v) {
+				pv = v
+			}
+			enableMapMu.Lock()
+			enabledMap = capabilityMaps[pv.String()]
+			enableMapMu.Unlock()
+		}
+
+		select {
+		case <-stopped:
+			return
+		case <-time.After(500 * time.Millisecond):
+		}
+	}
+}
+
+func isCapabilityEnabled(c capability) bool {
+	enableMapMu.Lock()
+	defer enableMapMu.Unlock()
+	if enabledMap == nil {
+		return false
+	}
+	return enabledMap[c]
+}
+
+func capabilityHandler(c capability, fn func(http.ResponseWriter, *http.Request)) http.HandlerFunc {
+	return func(w http.ResponseWriter, r *http.Request) {
+		if !isCapabilityEnabled(c) {
+			notCapable(w, r, c)
+			return
+		}
+		fn(w, r)
+	}
+}
+
+func notCapable(w http.ResponseWriter, r *http.Request, c capability) {
+	herr := httptypes.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf("Not capable of accessing %s feature during rolling upgrades.", c))
+	if err := herr.WriteTo(w); err != nil {
+		plog.Debugf("error writing HTTPError (%v) to %s", err, r.RemoteAddr)
+	}
+}
diff --git a/etcdserver/api/v2http/client.go b/etcdserver/api/v2http/client.go
new file mode 100644
index 0000000..ecda539
--- /dev/null
+++ b/etcdserver/api/v2http/client.go
@@ -0,0 +1,828 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2http
+
+import (
+	"encoding/json"
+	"errors"
+	"expvar"
+	"fmt"
+	"io/ioutil"
+	"net/http"
+	"net/http/pprof"
+	"net/url"
+	"path"
+	"strconv"
+	"strings"
+	"time"
+
+	etcdErr "github.com/coreos/etcd/error"
+	"github.com/coreos/etcd/etcdserver"
+	"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
+	"github.com/coreos/etcd/etcdserver/auth"
+	"github.com/coreos/etcd/etcdserver/etcdserverpb"
+	"github.com/coreos/etcd/etcdserver/stats"
+	"github.com/coreos/etcd/pkg/types"
+	"github.com/coreos/etcd/raft"
+	"github.com/coreos/etcd/store"
+	"github.com/coreos/etcd/version"
+	"github.com/coreos/pkg/capnslog"
+	"github.com/jonboulle/clockwork"
+	"github.com/prometheus/client_golang/prometheus"
+	"golang.org/x/net/context"
+)
+
+const (
+	authPrefix               = "/v2/auth"
+	keysPrefix               = "/v2/keys"
+	deprecatedMachinesPrefix = "/v2/machines"
+	membersPrefix            = "/v2/members"
+	statsPrefix              = "/v2/stats"
+	varsPath                 = "/debug/vars"
+	metricsPath              = "/metrics"
+	healthPath               = "/health"
+	versionPath              = "/version"
+	configPath               = "/config"
+	pprofPrefix              = "/debug/pprof"
+)
+
+// NewClientHandler generates a muxed http.Handler with the given parameters to serve etcd client requests.
+func NewClientHandler(server *etcdserver.EtcdServer, timeout time.Duration) http.Handler {
+	go capabilityLoop(server)
+
+	sec := auth.NewStore(server, timeout)
+
+	kh := &keysHandler{
+		sec:     sec,
+		server:  server,
+		cluster: server.Cluster(),
+		timer:   server,
+		timeout: timeout,
+	}
+
+	sh := &statsHandler{
+		stats: server,
+	}
+
+	mh := &membersHandler{
+		sec:     sec,
+		server:  server,
+		cluster: server.Cluster(),
+		timeout: timeout,
+		clock:   clockwork.NewRealClock(),
+	}
+
+	dmh := &deprecatedMachinesHandler{
+		cluster: server.Cluster(),
+	}
+
+	sech := &authHandler{
+		sec:     sec,
+		cluster: server.Cluster(),
+	}
+
+	mux := http.NewServeMux()
+	mux.HandleFunc("/", http.NotFound)
+	mux.Handle(healthPath, healthHandler(server))
+	mux.HandleFunc(versionPath, versionHandler(server.Cluster(), serveVersion))
+	mux.Handle(keysPrefix, kh)
+	mux.Handle(keysPrefix+"/", kh)
+	mux.HandleFunc(statsPrefix+"/store", sh.serveStore)
+	mux.HandleFunc(statsPrefix+"/self", sh.serveSelf)
+	mux.HandleFunc(statsPrefix+"/leader", sh.serveLeader)
+	mux.HandleFunc(varsPath, serveVars)
+	mux.HandleFunc(configPath+"/local/log", logHandleFunc)
+	mux.Handle(metricsPath, prometheus.Handler())
+	mux.Handle(membersPrefix, mh)
+	mux.Handle(membersPrefix+"/", mh)
+	mux.Handle(deprecatedMachinesPrefix, dmh)
+	handleAuth(mux, sech)
+
+	if server.IsPprofEnabled() {
+		plog.Infof("pprof is enabled under %s", pprofPrefix)
+
+		mux.HandleFunc(pprofPrefix, pprof.Index)
+		mux.HandleFunc(pprofPrefix+"/profile", pprof.Profile)
+		mux.HandleFunc(pprofPrefix+"/symbol", pprof.Symbol)
+		mux.HandleFunc(pprofPrefix+"/cmdline", pprof.Cmdline)
+		// TODO: currently, we don't create an entry for pprof.Trace,
+		// because go 1.4 doesn't provide it. After support of go 1.4 is dropped,
+		// we should add the entry.
+
+		mux.Handle(pprofPrefix+"/heap", pprof.Handler("heap"))
+		mux.Handle(pprofPrefix+"/goroutine", pprof.Handler("goroutine"))
+		mux.Handle(pprofPrefix+"/threadcreate", pprof.Handler("threadcreate"))
+		mux.Handle(pprofPrefix+"/block", pprof.Handler("block"))
+	}
+
+	return requestLogger(mux)
+}
+
+type keysHandler struct {
+	sec     auth.Store
+	server  etcdserver.Server
+	cluster etcdserver.Cluster
+	timer   etcdserver.RaftTimer
+	timeout time.Duration
+}
+
+func (h *keysHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "HEAD", "GET", "PUT", "POST", "DELETE") {
+		return
+	}
+
+	w.Header().Set("X-Etcd-Cluster-ID", h.cluster.ID().String())
+
+	ctx, cancel := context.WithTimeout(context.Background(), h.timeout)
+	defer cancel()
+	clock := clockwork.NewRealClock()
+	startTime := clock.Now()
+	rr, err := parseKeyRequest(r, clock)
+	if err != nil {
+		writeKeyError(w, err)
+		return
+	}
+	// The path must be valid at this point (we've parsed the request successfully).
+	if !hasKeyPrefixAccess(h.sec, r, r.URL.Path[len(keysPrefix):], rr.Recursive) {
+		writeKeyNoAuth(w)
+		return
+	}
+	if !rr.Wait {
+		reportRequestReceived(rr)
+	}
+	resp, err := h.server.Do(ctx, rr)
+	if err != nil {
+		err = trimErrorPrefix(err, etcdserver.StoreKeysPrefix)
+		writeKeyError(w, err)
+		reportRequestFailed(rr, err)
+		return
+	}
+	switch {
+	case resp.Event != nil:
+		if err := writeKeyEvent(w, resp.Event, h.timer); err != nil {
+			// Should never be reached
+			plog.Errorf("error writing event (%v)", err)
+		}
+		reportRequestCompleted(rr, resp, startTime)
+	case resp.Watcher != nil:
+		ctx, cancel := context.WithTimeout(context.Background(), defaultWatchTimeout)
+		defer cancel()
+		handleKeyWatch(ctx, w, resp.Watcher, rr.Stream, h.timer)
+	default:
+		writeKeyError(w, errors.New("received response with no Event/Watcher!"))
+	}
+}
+
+type deprecatedMachinesHandler struct {
+	cluster etcdserver.Cluster
+}
+
+func (h *deprecatedMachinesHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "GET", "HEAD") {
+		return
+	}
+	endpoints := h.cluster.ClientURLs()
+	w.Write([]byte(strings.Join(endpoints, ", ")))
+}
+
+type membersHandler struct {
+	sec     auth.Store
+	server  etcdserver.Server
+	cluster etcdserver.Cluster
+	timeout time.Duration
+	clock   clockwork.Clock
+}
+
+func (h *membersHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "GET", "POST", "DELETE", "PUT") {
+		return
+	}
+	if !hasWriteRootAccess(h.sec, r) {
+		writeNoAuth(w, r)
+		return
+	}
+	w.Header().Set("X-Etcd-Cluster-ID", h.cluster.ID().String())
+
+	ctx, cancel := context.WithTimeout(context.Background(), h.timeout)
+	defer cancel()
+
+	switch r.Method {
+	case "GET":
+		switch trimPrefix(r.URL.Path, membersPrefix) {
+		case "":
+			mc := newMemberCollection(h.cluster.Members())
+			w.Header().Set("Content-Type", "application/json")
+			if err := json.NewEncoder(w).Encode(mc); err != nil {
+				plog.Warningf("failed to encode members response (%v)", err)
+			}
+		case "leader":
+			id := h.server.Leader()
+			if id == 0 {
+				writeError(w, r, httptypes.NewHTTPError(http.StatusServiceUnavailable, "During election"))
+				return
+			}
+			m := newMember(h.cluster.Member(id))
+			w.Header().Set("Content-Type", "application/json")
+			if err := json.NewEncoder(w).Encode(m); err != nil {
+				plog.Warningf("failed to encode members response (%v)", err)
+			}
+		default:
+			writeError(w, r, httptypes.NewHTTPError(http.StatusNotFound, "Not found"))
+		}
+	case "POST":
+		req := httptypes.MemberCreateRequest{}
+		if ok := unmarshalRequest(r, &req, w); !ok {
+			return
+		}
+		now := h.clock.Now()
+		m := etcdserver.NewMember("", req.PeerURLs, "", &now)
+		err := h.server.AddMember(ctx, *m)
+		switch {
+		case err == etcdserver.ErrIDExists || err == etcdserver.ErrPeerURLexists:
+			writeError(w, r, httptypes.NewHTTPError(http.StatusConflict, err.Error()))
+			return
+		case err != nil:
+			plog.Errorf("error adding member %s (%v)", m.ID, err)
+			writeError(w, r, err)
+			return
+		}
+		res := newMember(m)
+		w.Header().Set("Content-Type", "application/json")
+		w.WriteHeader(http.StatusCreated)
+		if err := json.NewEncoder(w).Encode(res); err != nil {
+			plog.Warningf("failed to encode members response (%v)", err)
+		}
+	case "DELETE":
+		id, ok := getID(r.URL.Path, w)
+		if !ok {
+			return
+		}
+		err := h.server.RemoveMember(ctx, uint64(id))
+		switch {
+		case err == etcdserver.ErrIDRemoved:
+			writeError(w, r, httptypes.NewHTTPError(http.StatusGone, fmt.Sprintf("Member permanently removed: %s", id)))
+		case err == etcdserver.ErrIDNotFound:
+			writeError(w, r, httptypes.NewHTTPError(http.StatusNotFound, fmt.Sprintf("No such member: %s", id)))
+		case err != nil:
+			plog.Errorf("error removing member %s (%v)", id, err)
+			writeError(w, r, err)
+		default:
+			w.WriteHeader(http.StatusNoContent)
+		}
+	case "PUT":
+		id, ok := getID(r.URL.Path, w)
+		if !ok {
+			return
+		}
+		req := httptypes.MemberUpdateRequest{}
+		if ok := unmarshalRequest(r, &req, w); !ok {
+			return
+		}
+		m := etcdserver.Member{
+			ID:             id,
+			RaftAttributes: etcdserver.RaftAttributes{PeerURLs: req.PeerURLs.StringSlice()},
+		}
+		err := h.server.UpdateMember(ctx, m)
+		switch {
+		case err == etcdserver.ErrPeerURLexists:
+			writeError(w, r, httptypes.NewHTTPError(http.StatusConflict, err.Error()))
+		case err == etcdserver.ErrIDNotFound:
+			writeError(w, r, httptypes.NewHTTPError(http.StatusNotFound, fmt.Sprintf("No such member: %s", id)))
+		case err != nil:
+			plog.Errorf("error updating member %s (%v)", m.ID, err)
+			writeError(w, r, err)
+		default:
+			w.WriteHeader(http.StatusNoContent)
+		}
+	}
+}
+
+type statsHandler struct {
+	stats stats.Stats
+}
+
+func (h *statsHandler) serveStore(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "GET") {
+		return
+	}
+	w.Header().Set("Content-Type", "application/json")
+	w.Write(h.stats.StoreStats())
+}
+
+func (h *statsHandler) serveSelf(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "GET") {
+		return
+	}
+	w.Header().Set("Content-Type", "application/json")
+	w.Write(h.stats.SelfStats())
+}
+
+func (h *statsHandler) serveLeader(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "GET") {
+		return
+	}
+	stats := h.stats.LeaderStats()
+	if stats == nil {
+		writeError(w, r, httptypes.NewHTTPError(http.StatusForbidden, "not current leader"))
+		return
+	}
+	w.Header().Set("Content-Type", "application/json")
+	w.Write(stats)
+}
+
+func serveVars(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "GET") {
+		return
+	}
+
+	w.Header().Set("Content-Type", "application/json; charset=utf-8")
+	fmt.Fprintf(w, "{\n")
+	first := true
+	expvar.Do(func(kv expvar.KeyValue) {
+		if !first {
+			fmt.Fprintf(w, ",\n")
+		}
+		first = false
+		fmt.Fprintf(w, "%q: %s", kv.Key, kv.Value)
+	})
+	fmt.Fprintf(w, "\n}\n")
+}
+
+// TODO: change etcdserver to raft interface when we have it.
+//       add test for healthHandler when we have the interface ready.
+func healthHandler(server *etcdserver.EtcdServer) http.HandlerFunc {
+	return func(w http.ResponseWriter, r *http.Request) {
+		if !allowMethod(w, r.Method, "GET") {
+			return
+		}
+
+		if uint64(server.Leader()) == raft.None {
+			http.Error(w, `{"health": "false"}`, http.StatusServiceUnavailable)
+			return
+		}
+
+		// wait for raft's progress
+		index := server.Index()
+		for i := 0; i < 3; i++ {
+			time.Sleep(250 * time.Millisecond)
+			if server.Index() > index {
+				w.WriteHeader(http.StatusOK)
+				w.Write([]byte(`{"health": "true"}`))
+				return
+			}
+		}
+
+		http.Error(w, `{"health": "false"}`, http.StatusServiceUnavailable)
+		return
+	}
+}
+
+func versionHandler(c etcdserver.Cluster, fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
+	return func(w http.ResponseWriter, r *http.Request) {
+		v := c.Version()
+		if v != nil {
+			fn(w, r, v.String())
+		} else {
+			fn(w, r, "not_decided")
+		}
+	}
+}
+
+func serveVersion(w http.ResponseWriter, r *http.Request, clusterV string) {
+	if !allowMethod(w, r.Method, "GET") {
+		return
+	}
+	vs := version.Versions{
+		Server:  version.Version,
+		Cluster: clusterV,
+	}
+
+	w.Header().Set("Content-Type", "application/json")
+	b, err := json.Marshal(&vs)
+	if err != nil {
+		plog.Panicf("cannot marshal versions to json (%v)", err)
+	}
+	w.Write(b)
+}
+
+func logHandleFunc(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "PUT") {
+		return
+	}
+
+	in := struct{ Level string }{}
+
+	d := json.NewDecoder(r.Body)
+	if err := d.Decode(&in); err != nil {
+		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid json body"))
+		return
+	}
+
+	logl, err := capnslog.ParseLevel(strings.ToUpper(in.Level))
+	if err != nil {
+		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid log level "+in.Level))
+		return
+	}
+
+	plog.Noticef("globalLogLevel set to %q", logl.String())
+	capnslog.SetGlobalLogLevel(logl)
+	w.WriteHeader(http.StatusNoContent)
+}
+
+// parseKeyRequest converts a received http.Request on keysPrefix to
+// a server Request, performing validation of supplied fields as appropriate.
+// If any validation fails, an empty Request and non-nil error is returned.
+func parseKeyRequest(r *http.Request, clock clockwork.Clock) (etcdserverpb.Request, error) {
+	emptyReq := etcdserverpb.Request{}
+
+	err := r.ParseForm()
+	if err != nil {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodeInvalidForm,
+			err.Error(),
+		)
+	}
+
+	if !strings.HasPrefix(r.URL.Path, keysPrefix) {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodeInvalidForm,
+			"incorrect key prefix",
+		)
+	}
+	p := path.Join(etcdserver.StoreKeysPrefix, r.URL.Path[len(keysPrefix):])
+
+	var pIdx, wIdx uint64
+	if pIdx, err = getUint64(r.Form, "prevIndex"); err != nil {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodeIndexNaN,
+			`invalid value for "prevIndex"`,
+		)
+	}
+	if wIdx, err = getUint64(r.Form, "waitIndex"); err != nil {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodeIndexNaN,
+			`invalid value for "waitIndex"`,
+		)
+	}
+
+	var rec, sort, wait, dir, quorum, stream bool
+	if rec, err = getBool(r.Form, "recursive"); err != nil {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodeInvalidField,
+			`invalid value for "recursive"`,
+		)
+	}
+	if sort, err = getBool(r.Form, "sorted"); err != nil {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodeInvalidField,
+			`invalid value for "sorted"`,
+		)
+	}
+	if wait, err = getBool(r.Form, "wait"); err != nil {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodeInvalidField,
+			`invalid value for "wait"`,
+		)
+	}
+	// TODO(jonboulle): define what parameters dir is/isn't compatible with?
+	if dir, err = getBool(r.Form, "dir"); err != nil {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodeInvalidField,
+			`invalid value for "dir"`,
+		)
+	}
+	if quorum, err = getBool(r.Form, "quorum"); err != nil {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodeInvalidField,
+			`invalid value for "quorum"`,
+		)
+	}
+	if stream, err = getBool(r.Form, "stream"); err != nil {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodeInvalidField,
+			`invalid value for "stream"`,
+		)
+	}
+
+	if wait && r.Method != "GET" {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodeInvalidField,
+			`"wait" can only be used with GET requests`,
+		)
+	}
+
+	pV := r.FormValue("prevValue")
+	if _, ok := r.Form["prevValue"]; ok && pV == "" {
+		return emptyReq, etcdErr.NewRequestError(
+			etcdErr.EcodePrevValueRequired,
+			`"prevValue" cannot be empty`,
+		)
+	}
+
+	// TTL is nullable, so leave it null if not specified
+	// or an empty string
+	var ttl *uint64
+	if len(r.FormValue("ttl")) > 0 {
+		i, err := getUint64(r.Form, "ttl")
+		if err != nil {
+			return emptyReq, etcdErr.NewRequestError(
+				etcdErr.EcodeTTLNaN,
+				`invalid value for "ttl"`,
+			)
+		}
+		ttl = &i
+	}
+
+	// prevExist is nullable, so leave it null if not specified
+	var pe *bool
+	if _, ok := r.Form["prevExist"]; ok {
+		bv, err := getBool(r.Form, "prevExist")
+		if err != nil {
+			return emptyReq, etcdErr.NewRequestError(
+				etcdErr.EcodeInvalidField,
+				"invalid value for prevExist",
+			)
+		}
+		pe = &bv
+	}
+
+	// refresh is nullable, so leave it null if not specified
+	var refresh *bool
+	if _, ok := r.Form["refresh"]; ok {
+		bv, err := getBool(r.Form, "refresh")
+		if err != nil {
+			return emptyReq, etcdErr.NewRequestError(
+				etcdErr.EcodeInvalidField,
+				"invalid value for refresh",
+			)
+		}
+		refresh = &bv
+		if refresh != nil && *refresh {
+			val := r.FormValue("value")
+			if _, ok := r.Form["value"]; ok && val != "" {
+				return emptyReq, etcdErr.NewRequestError(
+					etcdErr.EcodeRefreshValue,
+					`A value was provided on a refresh`,
+				)
+			}
+			if ttl == nil {
+				return emptyReq, etcdErr.NewRequestError(
+					etcdErr.EcodeRefreshTTLRequired,
+					`No TTL value set`,
+				)
+			}
+		}
+	}
+
+	rr := etcdserverpb.Request{
+		Method:    r.Method,
+		Path:      p,
+		Val:       r.FormValue("value"),
+		Dir:       dir,
+		PrevValue: pV,
+		PrevIndex: pIdx,
+		PrevExist: pe,
+		Wait:      wait,
+		Since:     wIdx,
+		Recursive: rec,
+		Sorted:    sort,
+		Quorum:    quorum,
+		Stream:    stream,
+	}
+
+	if pe != nil {
+		rr.PrevExist = pe
+	}
+
+	if refresh != nil {
+		rr.Refresh = refresh
+	}
+
+	// Null TTL is equivalent to unset Expiration
+	if ttl != nil {
+		expr := time.Duration(*ttl) * time.Second
+		rr.Expiration = clock.Now().Add(expr).UnixNano()
+	}
+
+	return rr, nil
+}
+
+// writeKeyEvent trims the prefix of key path in a single Event under
+// StoreKeysPrefix, serializes it and writes the resulting JSON to the given
+// ResponseWriter, along with the appropriate headers.
+func writeKeyEvent(w http.ResponseWriter, ev *store.Event, rt etcdserver.RaftTimer) error {
+	if ev == nil {
+		return errors.New("cannot write empty Event!")
+	}
+	w.Header().Set("Content-Type", "application/json")
+	w.Header().Set("X-Etcd-Index", fmt.Sprint(ev.EtcdIndex))
+	w.Header().Set("X-Raft-Index", fmt.Sprint(rt.Index()))
+	w.Header().Set("X-Raft-Term", fmt.Sprint(rt.Term()))
+
+	if ev.IsCreated() {
+		w.WriteHeader(http.StatusCreated)
+	}
+
+	ev = trimEventPrefix(ev, etcdserver.StoreKeysPrefix)
+	return json.NewEncoder(w).Encode(ev)
+}
+
+func writeKeyNoAuth(w http.ResponseWriter) {
+	e := etcdErr.NewError(etcdErr.EcodeUnauthorized, "Insufficient credentials", 0)
+	e.WriteTo(w)
+}
+
+// writeKeyError logs and writes the given Error to the ResponseWriter.
+// If Error is not an etcdErr, the error will be converted to an etcd error.
+func writeKeyError(w http.ResponseWriter, err error) {
+	if err == nil {
+		return
+	}
+	switch e := err.(type) {
+	case *etcdErr.Error:
+		e.WriteTo(w)
+	default:
+		switch err {
+		case etcdserver.ErrTimeoutDueToLeaderFail, etcdserver.ErrTimeoutDueToConnectionLost:
+			mlog.MergeError(err)
+		default:
+			mlog.MergeErrorf("got unexpected response error (%v)", err)
+		}
+		ee := etcdErr.NewError(etcdErr.EcodeRaftInternal, err.Error(), 0)
+		ee.WriteTo(w)
+	}
+}
+
+func handleKeyWatch(ctx context.Context, w http.ResponseWriter, wa store.Watcher, stream bool, rt etcdserver.RaftTimer) {
+	defer wa.Remove()
+	ech := wa.EventChan()
+	var nch <-chan bool
+	if x, ok := w.(http.CloseNotifier); ok {
+		nch = x.CloseNotify()
+	}
+
+	w.Header().Set("Content-Type", "application/json")
+	w.Header().Set("X-Etcd-Index", fmt.Sprint(wa.StartIndex()))
+	w.Header().Set("X-Raft-Index", fmt.Sprint(rt.Index()))
+	w.Header().Set("X-Raft-Term", fmt.Sprint(rt.Term()))
+	w.WriteHeader(http.StatusOK)
+
+	// Ensure headers are flushed early, in case of long polling
+	w.(http.Flusher).Flush()
+
+	for {
+		select {
+		case <-nch:
+			// Client closed connection. Nothing to do.
+			return
+		case <-ctx.Done():
+			// Timed out. net/http will close the connection for us, so nothing to do.
+			return
+		case ev, ok := <-ech:
+			if !ok {
+				// If the channel is closed this may be an indication of
+				// that notifications are much more than we are able to
+				// send to the client in time. Then we simply end streaming.
+				return
+			}
+			ev = trimEventPrefix(ev, etcdserver.StoreKeysPrefix)
+			if err := json.NewEncoder(w).Encode(ev); err != nil {
+				// Should never be reached
+				plog.Warningf("error writing event (%v)", err)
+				return
+			}
+			if !stream {
+				return
+			}
+			w.(http.Flusher).Flush()
+		}
+	}
+}
+
+func trimEventPrefix(ev *store.Event, prefix string) *store.Event {
+	if ev == nil {
+		return nil
+	}
+	// Since the *Event may reference one in the store history
+	// history, we must copy it before modifying
+	e := ev.Clone()
+	e.Node = trimNodeExternPrefix(e.Node, prefix)
+	e.PrevNode = trimNodeExternPrefix(e.PrevNode, prefix)
+	return e
+}
+
+func trimNodeExternPrefix(n *store.NodeExtern, prefix string) *store.NodeExtern {
+	if n == nil {
+		return nil
+	}
+	n.Key = strings.TrimPrefix(n.Key, prefix)
+	for _, nn := range n.Nodes {
+		nn = trimNodeExternPrefix(nn, prefix)
+	}
+	return n
+}
+
+func trimErrorPrefix(err error, prefix string) error {
+	if e, ok := err.(*etcdErr.Error); ok {
+		e.Cause = strings.TrimPrefix(e.Cause, prefix)
+	}
+	return err
+}
+
+func unmarshalRequest(r *http.Request, req json.Unmarshaler, w http.ResponseWriter) bool {
+	ctype := r.Header.Get("Content-Type")
+	if ctype != "application/json" {
+		writeError(w, r, httptypes.NewHTTPError(http.StatusUnsupportedMediaType, fmt.Sprintf("Bad Content-Type %s, accept application/json", ctype)))
+		return false
+	}
+	b, err := ioutil.ReadAll(r.Body)
+	if err != nil {
+		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, err.Error()))
+		return false
+	}
+	if err := req.UnmarshalJSON(b); err != nil {
+		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, err.Error()))
+		return false
+	}
+	return true
+}
+
+func getID(p string, w http.ResponseWriter) (types.ID, bool) {
+	idStr := trimPrefix(p, membersPrefix)
+	if idStr == "" {
+		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
+		return 0, false
+	}
+	id, err := types.IDFromString(idStr)
+	if err != nil {
+		writeError(w, nil, httptypes.NewHTTPError(http.StatusNotFound, fmt.Sprintf("No such member: %s", idStr)))
+		return 0, false
+	}
+	return id, true
+}
+
+// getUint64 extracts a uint64 by the given key from a Form. If the key does
+// not exist in the form, 0 is returned. If the key exists but the value is
+// badly formed, an error is returned. If multiple values are present only the
+// first is considered.
+func getUint64(form url.Values, key string) (i uint64, err error) {
+	if vals, ok := form[key]; ok {
+		i, err = strconv.ParseUint(vals[0], 10, 64)
+	}
+	return
+}
+
+// getBool extracts a bool by the given key from a Form. If the key does not
+// exist in the form, false is returned. If the key exists but the value is
+// badly formed, an error is returned. If multiple values are present only the
+// first is considered.
+func getBool(form url.Values, key string) (b bool, err error) {
+	if vals, ok := form[key]; ok {
+		b, err = strconv.ParseBool(vals[0])
+	}
+	return
+}
+
+// trimPrefix removes a given prefix and any slash following the prefix
+// e.g.: trimPrefix("foo", "foo") == trimPrefix("foo/", "foo") == ""
+func trimPrefix(p, prefix string) (s string) {
+	s = strings.TrimPrefix(p, prefix)
+	s = strings.TrimPrefix(s, "/")
+	return
+}
+
+func newMemberCollection(ms []*etcdserver.Member) *httptypes.MemberCollection {
+	c := httptypes.MemberCollection(make([]httptypes.Member, len(ms)))
+
+	for i, m := range ms {
+		c[i] = newMember(m)
+	}
+
+	return &c
+}
+
+func newMember(m *etcdserver.Member) httptypes.Member {
+	tm := httptypes.Member{
+		ID:         m.ID.String(),
+		Name:       m.Name,
+		PeerURLs:   make([]string, len(m.PeerURLs)),
+		ClientURLs: make([]string, len(m.ClientURLs)),
+	}
+
+	copy(tm.PeerURLs, m.PeerURLs)
+	copy(tm.ClientURLs, m.ClientURLs)
+
+	return tm
+}
diff --git a/etcdserver/api/v2http/client_auth.go b/etcdserver/api/v2http/client_auth.go
new file mode 100644
index 0000000..21e557c
--- /dev/null
+++ b/etcdserver/api/v2http/client_auth.go
@@ -0,0 +1,507 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2http
+
+import (
+	"encoding/json"
+	"net/http"
+	"path"
+	"strings"
+
+	"github.com/coreos/etcd/etcdserver"
+	"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
+	"github.com/coreos/etcd/etcdserver/auth"
+)
+
+type authHandler struct {
+	sec     auth.Store
+	cluster etcdserver.Cluster
+}
+
+func hasWriteRootAccess(sec auth.Store, r *http.Request) bool {
+	if r.Method == "GET" || r.Method == "HEAD" {
+		return true
+	}
+	return hasRootAccess(sec, r)
+}
+
+func hasRootAccess(sec auth.Store, r *http.Request) bool {
+	if sec == nil {
+		// No store means no auth available, eg, tests.
+		return true
+	}
+	if !sec.AuthEnabled() {
+		return true
+	}
+	username, password, ok := r.BasicAuth()
+	if !ok {
+		return false
+	}
+	rootUser, err := sec.GetUser(username)
+	if err != nil {
+		return false
+	}
+
+	ok = sec.CheckPassword(rootUser, password)
+	if !ok {
+		plog.Warningf("auth: wrong password for user %s", username)
+		return false
+	}
+	for _, role := range rootUser.Roles {
+		if role == auth.RootRoleName {
+			return true
+		}
+	}
+	plog.Warningf("auth: user %s does not have the %s role for resource %s.", username, auth.RootRoleName, r.URL.Path)
+	return false
+}
+
+func hasKeyPrefixAccess(sec auth.Store, r *http.Request, key string, recursive bool) bool {
+	if sec == nil {
+		// No store means no auth available, eg, tests.
+		return true
+	}
+	if !sec.AuthEnabled() {
+		return true
+	}
+	if r.Header.Get("Authorization") == "" {
+		plog.Warningf("auth: no authorization provided, checking guest access")
+		return hasGuestAccess(sec, r, key)
+	}
+	username, password, ok := r.BasicAuth()
+	if !ok {
+		plog.Warningf("auth: malformed basic auth encoding")
+		return false
+	}
+	user, err := sec.GetUser(username)
+	if err != nil {
+		plog.Warningf("auth: no such user: %s.", username)
+		return false
+	}
+	authAsUser := sec.CheckPassword(user, password)
+	if !authAsUser {
+		plog.Warningf("auth: incorrect password for user: %s.", username)
+		return false
+	}
+	writeAccess := r.Method != "GET" && r.Method != "HEAD"
+	for _, roleName := range user.Roles {
+		role, err := sec.GetRole(roleName)
+		if err != nil {
+			continue
+		}
+		if recursive {
+			if role.HasRecursiveAccess(key, writeAccess) {
+				return true
+			}
+		} else if role.HasKeyAccess(key, writeAccess) {
+			return true
+		}
+	}
+	plog.Warningf("auth: invalid access for user %s on key %s.", username, key)
+	return false
+}
+
+func hasGuestAccess(sec auth.Store, r *http.Request, key string) bool {
+	writeAccess := r.Method != "GET" && r.Method != "HEAD"
+	role, err := sec.GetRole(auth.GuestRoleName)
+	if err != nil {
+		return false
+	}
+	if role.HasKeyAccess(key, writeAccess) {
+		return true
+	}
+	plog.Warningf("auth: invalid access for unauthenticated user on resource %s.", key)
+	return false
+}
+
+func writeNoAuth(w http.ResponseWriter, r *http.Request) {
+	herr := httptypes.NewHTTPError(http.StatusUnauthorized, "Insufficient credentials")
+	if err := herr.WriteTo(w); err != nil {
+		plog.Debugf("error writing HTTPError (%v) to %s", err, r.RemoteAddr)
+	}
+}
+
+func handleAuth(mux *http.ServeMux, sh *authHandler) {
+	mux.HandleFunc(authPrefix+"/roles", capabilityHandler(authCapability, sh.baseRoles))
+	mux.HandleFunc(authPrefix+"/roles/", capabilityHandler(authCapability, sh.handleRoles))
+	mux.HandleFunc(authPrefix+"/users", capabilityHandler(authCapability, sh.baseUsers))
+	mux.HandleFunc(authPrefix+"/users/", capabilityHandler(authCapability, sh.handleUsers))
+	mux.HandleFunc(authPrefix+"/enable", capabilityHandler(authCapability, sh.enableDisable))
+}
+
+func (sh *authHandler) baseRoles(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "GET") {
+		return
+	}
+	if !hasRootAccess(sh.sec, r) {
+		writeNoAuth(w, r)
+		return
+	}
+
+	w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
+	w.Header().Set("Content-Type", "application/json")
+
+	roles, err := sh.sec.AllRoles()
+	if err != nil {
+		writeError(w, r, err)
+		return
+	}
+	if roles == nil {
+		roles = make([]string, 0)
+	}
+
+	err = r.ParseForm()
+	if err != nil {
+		writeError(w, r, err)
+		return
+	}
+
+	var rolesCollections struct {
+		Roles []auth.Role `json:"roles"`
+	}
+	for _, roleName := range roles {
+		var role auth.Role
+		role, err = sh.sec.GetRole(roleName)
+		if err != nil {
+			writeError(w, r, err)
+			return
+		}
+		rolesCollections.Roles = append(rolesCollections.Roles, role)
+	}
+	err = json.NewEncoder(w).Encode(rolesCollections)
+
+	if err != nil {
+		plog.Warningf("baseRoles error encoding on %s", r.URL)
+		writeError(w, r, err)
+		return
+	}
+}
+
+func (sh *authHandler) handleRoles(w http.ResponseWriter, r *http.Request) {
+	subpath := path.Clean(r.URL.Path[len(authPrefix):])
+	// Split "/roles/rolename/command".
+	// First item is an empty string, second is "roles"
+	pieces := strings.Split(subpath, "/")
+	if len(pieces) == 2 {
+		sh.baseRoles(w, r)
+		return
+	}
+	if len(pieces) != 3 {
+		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid path"))
+		return
+	}
+	sh.forRole(w, r, pieces[2])
+}
+
+func (sh *authHandler) forRole(w http.ResponseWriter, r *http.Request, role string) {
+	if !allowMethod(w, r.Method, "GET", "PUT", "DELETE") {
+		return
+	}
+	if !hasRootAccess(sh.sec, r) {
+		writeNoAuth(w, r)
+		return
+	}
+	w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
+	w.Header().Set("Content-Type", "application/json")
+
+	switch r.Method {
+	case "GET":
+		data, err := sh.sec.GetRole(role)
+		if err != nil {
+			writeError(w, r, err)
+			return
+		}
+		err = json.NewEncoder(w).Encode(data)
+		if err != nil {
+			plog.Warningf("forRole error encoding on %s", r.URL)
+			return
+		}
+		return
+	case "PUT":
+		var in auth.Role
+		err := json.NewDecoder(r.Body).Decode(&in)
+		if err != nil {
+			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid JSON in request body."))
+			return
+		}
+		if in.Role != role {
+			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Role JSON name does not match the name in the URL"))
+			return
+		}
+
+		var out auth.Role
+
+		// create
+		if in.Grant.IsEmpty() && in.Revoke.IsEmpty() {
+			err = sh.sec.CreateRole(in)
+			if err != nil {
+				writeError(w, r, err)
+				return
+			}
+			w.WriteHeader(http.StatusCreated)
+			out = in
+		} else {
+			if !in.Permissions.IsEmpty() {
+				writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Role JSON contains both permissions and grant/revoke"))
+				return
+			}
+			out, err = sh.sec.UpdateRole(in)
+			if err != nil {
+				writeError(w, r, err)
+				return
+			}
+			w.WriteHeader(http.StatusOK)
+		}
+
+		err = json.NewEncoder(w).Encode(out)
+		if err != nil {
+			plog.Warningf("forRole error encoding on %s", r.URL)
+			return
+		}
+		return
+	case "DELETE":
+		err := sh.sec.DeleteRole(role)
+		if err != nil {
+			writeError(w, r, err)
+			return
+		}
+	}
+}
+
+type userWithRoles struct {
+	User  string      `json:"user"`
+	Roles []auth.Role `json:"roles,omitempty"`
+}
+
+func (sh *authHandler) baseUsers(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "GET") {
+		return
+	}
+	if !hasRootAccess(sh.sec, r) {
+		writeNoAuth(w, r)
+		return
+	}
+	w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
+	w.Header().Set("Content-Type", "application/json")
+
+	users, err := sh.sec.AllUsers()
+	if err != nil {
+		writeError(w, r, err)
+		return
+	}
+	if users == nil {
+		users = make([]string, 0)
+	}
+
+	err = r.ParseForm()
+	if err != nil {
+		writeError(w, r, err)
+		return
+	}
+
+	var usersCollections struct {
+		Users []userWithRoles `json:"users"`
+	}
+	for _, userName := range users {
+		var user auth.User
+		user, err = sh.sec.GetUser(userName)
+		if err != nil {
+			writeError(w, r, err)
+			return
+		}
+
+		uwr := userWithRoles{User: user.User}
+		for _, roleName := range user.Roles {
+			var role auth.Role
+			role, err = sh.sec.GetRole(roleName)
+			if err != nil {
+				writeError(w, r, err)
+				return
+			}
+			uwr.Roles = append(uwr.Roles, role)
+		}
+
+		usersCollections.Users = append(usersCollections.Users, uwr)
+	}
+	err = json.NewEncoder(w).Encode(usersCollections)
+
+	if err != nil {
+		plog.Warningf("baseUsers error encoding on %s", r.URL)
+		writeError(w, r, err)
+		return
+	}
+}
+
+func (sh *authHandler) handleUsers(w http.ResponseWriter, r *http.Request) {
+	subpath := path.Clean(r.URL.Path[len(authPrefix):])
+	// Split "/users/username".
+	// First item is an empty string, second is "users"
+	pieces := strings.Split(subpath, "/")
+	if len(pieces) == 2 {
+		sh.baseUsers(w, r)
+		return
+	}
+	if len(pieces) != 3 {
+		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid path"))
+		return
+	}
+	sh.forUser(w, r, pieces[2])
+}
+
+func (sh *authHandler) forUser(w http.ResponseWriter, r *http.Request, user string) {
+	if !allowMethod(w, r.Method, "GET", "PUT", "DELETE") {
+		return
+	}
+	if !hasRootAccess(sh.sec, r) {
+		writeNoAuth(w, r)
+		return
+	}
+	w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
+	w.Header().Set("Content-Type", "application/json")
+
+	switch r.Method {
+	case "GET":
+		u, err := sh.sec.GetUser(user)
+		if err != nil {
+			writeError(w, r, err)
+			return
+		}
+
+		err = r.ParseForm()
+		if err != nil {
+			writeError(w, r, err)
+			return
+		}
+
+		uwr := userWithRoles{User: u.User}
+		for _, roleName := range u.Roles {
+			var role auth.Role
+			role, err = sh.sec.GetRole(roleName)
+			if err != nil {
+				writeError(w, r, err)
+				return
+			}
+			uwr.Roles = append(uwr.Roles, role)
+		}
+		err = json.NewEncoder(w).Encode(uwr)
+
+		if err != nil {
+			plog.Warningf("forUser error encoding on %s", r.URL)
+			return
+		}
+		return
+	case "PUT":
+		var u auth.User
+		err := json.NewDecoder(r.Body).Decode(&u)
+		if err != nil {
+			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid JSON in request body."))
+			return
+		}
+		if u.User != user {
+			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "User JSON name does not match the name in the URL"))
+			return
+		}
+
+		var (
+			out     auth.User
+			created bool
+		)
+
+		if len(u.Grant) == 0 && len(u.Revoke) == 0 {
+			// create or update
+			if len(u.Roles) != 0 {
+				out, err = sh.sec.CreateUser(u)
+			} else {
+				// if user passes in both password and roles, we are unsure about his/her
+				// intention.
+				out, created, err = sh.sec.CreateOrUpdateUser(u)
+			}
+
+			if err != nil {
+				writeError(w, r, err)
+				return
+			}
+		} else {
+			// update case
+			if len(u.Roles) != 0 {
+				writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "User JSON contains both roles and grant/revoke"))
+				return
+			}
+			out, err = sh.sec.UpdateUser(u)
+			if err != nil {
+				writeError(w, r, err)
+				return
+			}
+		}
+
+		if created {
+			w.WriteHeader(http.StatusCreated)
+		} else {
+			w.WriteHeader(http.StatusOK)
+		}
+
+		out.Password = ""
+
+		err = json.NewEncoder(w).Encode(out)
+		if err != nil {
+			plog.Warningf("forUser error encoding on %s", r.URL)
+			return
+		}
+		return
+	case "DELETE":
+		err := sh.sec.DeleteUser(user)
+		if err != nil {
+			writeError(w, r, err)
+			return
+		}
+	}
+}
+
+type enabled struct {
+	Enabled bool `json:"enabled"`
+}
+
+func (sh *authHandler) enableDisable(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "GET", "PUT", "DELETE") {
+		return
+	}
+	if !hasWriteRootAccess(sh.sec, r) {
+		writeNoAuth(w, r)
+		return
+	}
+	w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
+	w.Header().Set("Content-Type", "application/json")
+	isEnabled := sh.sec.AuthEnabled()
+	switch r.Method {
+	case "GET":
+		jsonDict := enabled{isEnabled}
+		err := json.NewEncoder(w).Encode(jsonDict)
+		if err != nil {
+			plog.Warningf("error encoding auth state on %s", r.URL)
+		}
+	case "PUT":
+		err := sh.sec.EnableAuth()
+		if err != nil {
+			writeError(w, r, err)
+			return
+		}
+	case "DELETE":
+		err := sh.sec.DisableAuth()
+		if err != nil {
+			writeError(w, r, err)
+			return
+		}
+	}
+}
diff --git a/etcdserver/api/v2http/client_auth_test.go b/etcdserver/api/v2http/client_auth_test.go
new file mode 100644
index 0000000..ec88c5d
--- /dev/null
+++ b/etcdserver/api/v2http/client_auth_test.go
@@ -0,0 +1,633 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2http
+
+import (
+	"errors"
+	"net/http"
+	"net/http/httptest"
+	"path"
+	"strings"
+	"testing"
+
+	"github.com/coreos/etcd/etcdserver/auth"
+)
+
+const goodPassword = "good"
+
+func mustJSONRequest(t *testing.T, method string, p string, body string) *http.Request {
+	req, err := http.NewRequest(method, path.Join(authPrefix, p), strings.NewReader(body))
+	if err != nil {
+		t.Fatalf("Error making JSON request: %s %s %s\n", method, p, body)
+	}
+	req.Header.Set("Content-Type", "application/json")
+	return req
+}
+
+type mockAuthStore struct {
+	users   map[string]*auth.User
+	roles   map[string]*auth.Role
+	err     error
+	enabled bool
+}
+
+func (s *mockAuthStore) AllUsers() ([]string, error) { return []string{"alice", "bob", "root"}, s.err }
+func (s *mockAuthStore) GetUser(name string) (auth.User, error) {
+	u, ok := s.users[name]
+	if !ok {
+		return auth.User{}, s.err
+	}
+	return *u, s.err
+}
+func (s *mockAuthStore) CreateOrUpdateUser(user auth.User) (out auth.User, created bool, err error) {
+	if s.users == nil {
+		u, err := s.CreateUser(user)
+		return u, true, err
+	}
+	u, err := s.UpdateUser(user)
+	return u, false, err
+}
+func (s *mockAuthStore) CreateUser(user auth.User) (auth.User, error) { return user, s.err }
+func (s *mockAuthStore) DeleteUser(name string) error                 { return s.err }
+func (s *mockAuthStore) UpdateUser(user auth.User) (auth.User, error) {
+	return *s.users[user.User], s.err
+}
+func (s *mockAuthStore) AllRoles() ([]string, error) {
+	return []string{"awesome", "guest", "root"}, s.err
+}
+func (s *mockAuthStore) GetRole(name string) (auth.Role, error) { return *s.roles[name], s.err }
+func (s *mockAuthStore) CreateRole(role auth.Role) error        { return s.err }
+func (s *mockAuthStore) DeleteRole(name string) error           { return s.err }
+func (s *mockAuthStore) UpdateRole(role auth.Role) (auth.Role, error) {
+	return *s.roles[role.Role], s.err
+}
+func (s *mockAuthStore) AuthEnabled() bool  { return s.enabled }
+func (s *mockAuthStore) EnableAuth() error  { return s.err }
+func (s *mockAuthStore) DisableAuth() error { return s.err }
+
+func (s *mockAuthStore) CheckPassword(user auth.User, password string) bool {
+	return user.Password == password
+}
+
+func (s *mockAuthStore) HashPassword(password string) (string, error) {
+	return password, nil
+}
+
+func TestAuthFlow(t *testing.T) {
+	enableMapMu.Lock()
+	enabledMap = make(map[capability]bool)
+	enabledMap[authCapability] = true
+	enableMapMu.Unlock()
+	var testCases = []struct {
+		req   *http.Request
+		store mockAuthStore
+
+		wcode int
+		wbody string
+	}{
+		{
+			req:   mustJSONRequest(t, "PUT", "users/alice", `{{{{{{{`),
+			store: mockAuthStore{},
+			wcode: http.StatusBadRequest,
+			wbody: `{"message":"Invalid JSON in request body."}`,
+		},
+		{
+			req:   mustJSONRequest(t, "PUT", "users/alice", `{"user": "alice", "password": "goodpassword"}`),
+			store: mockAuthStore{enabled: true},
+			wcode: http.StatusUnauthorized,
+			wbody: `{"message":"Insufficient credentials"}`,
+		},
+		// Users
+		{
+			req: mustJSONRequest(t, "GET", "users", ""),
+			store: mockAuthStore{
+				users: map[string]*auth.User{
+					"alice": {
+						User:     "alice",
+						Roles:    []string{"alicerole", "guest"},
+						Password: "wheeee",
+					},
+					"bob": {
+						User:     "bob",
+						Roles:    []string{"guest"},
+						Password: "wheeee",
+					},
+					"root": {
+						User:     "root",
+						Roles:    []string{"root"},
+						Password: "wheeee",
+					},
+				},
+				roles: map[string]*auth.Role{
+					"alicerole": {
+						Role: "alicerole",
+					},
+					"guest": {
+						Role: "guest",
+					},
+					"root": {
+						Role: "root",
+					},
+				},
+			},
+			wcode: http.StatusOK,
+			wbody: `{"users":[` +
+				`{"user":"alice","roles":[` +
+				`{"role":"alicerole","permissions":{"kv":{"read":null,"write":null}}},` +
+				`{"role":"guest","permissions":{"kv":{"read":null,"write":null}}}` +
+				`]},` +
+				`{"user":"bob","roles":[{"role":"guest","permissions":{"kv":{"read":null,"write":null}}}]},` +
+				`{"user":"root","roles":[{"role":"root","permissions":{"kv":{"read":null,"write":null}}}]}]}`,
+		},
+		{
+			req: mustJSONRequest(t, "GET", "users/alice", ""),
+			store: mockAuthStore{
+				users: map[string]*auth.User{
+					"alice": {
+						User:     "alice",
+						Roles:    []string{"alicerole"},
+						Password: "wheeee",
+					},
+				},
+				roles: map[string]*auth.Role{
+					"alicerole": {
+						Role: "alicerole",
+					},
+				},
+			},
+			wcode: http.StatusOK,
+			wbody: `{"user":"alice","roles":[{"role":"alicerole","permissions":{"kv":{"read":null,"write":null}}}]}`,
+		},
+		{
+			req:   mustJSONRequest(t, "PUT", "users/alice", `{"user": "alice", "password": "goodpassword"}`),
+			store: mockAuthStore{},
+			wcode: http.StatusCreated,
+			wbody: `{"user":"alice","roles":null}`,
+		},
+		{
+			req:   mustJSONRequest(t, "DELETE", "users/alice", ``),
+			store: mockAuthStore{},
+			wcode: http.StatusOK,
+			wbody: ``,
+		},
+		{
+			req: mustJSONRequest(t, "PUT", "users/alice", `{"user": "alice", "password": "goodpassword"}`),
+			store: mockAuthStore{
+				users: map[string]*auth.User{
+					"alice": {
+						User:     "alice",
+						Roles:    []string{"alicerole", "guest"},
+						Password: "wheeee",
+					},
+				},
+			},
+			wcode: http.StatusOK,
+			wbody: `{"user":"alice","roles":["alicerole","guest"]}`,
+		},
+		{
+			req: mustJSONRequest(t, "PUT", "users/alice", `{"user": "alice", "grant": ["alicerole"]}`),
+			store: mockAuthStore{
+				users: map[string]*auth.User{
+					"alice": {
+						User:     "alice",
+						Roles:    []string{"alicerole", "guest"},
+						Password: "wheeee",
+					},
+				},
+			},
+			wcode: http.StatusOK,
+			wbody: `{"user":"alice","roles":["alicerole","guest"]}`,
+		},
+		{
+			req: mustJSONRequest(t, "GET", "users/alice", ``),
+			store: mockAuthStore{
+				users: map[string]*auth.User{},
+				err:   auth.Error{Status: http.StatusNotFound, Errmsg: "auth: User alice doesn't exist."},
+			},
+			wcode: http.StatusNotFound,
+			wbody: `{"message":"auth: User alice doesn't exist."}`,
+		},
+		{
+			req: mustJSONRequest(t, "GET", "roles/manager", ""),
+			store: mockAuthStore{
+				roles: map[string]*auth.Role{
+					"manager": {
+						Role: "manager",
+					},
+				},
+			},
+			wcode: http.StatusOK,
+			wbody: `{"role":"manager","permissions":{"kv":{"read":null,"write":null}}}`,
+		},
+		{
+			req:   mustJSONRequest(t, "DELETE", "roles/manager", ``),
+			store: mockAuthStore{},
+			wcode: http.StatusOK,
+			wbody: ``,
+		},
+		{
+			req:   mustJSONRequest(t, "PUT", "roles/manager", `{"role":"manager","permissions":{"kv":{"read":[],"write":[]}}}`),
+			store: mockAuthStore{},
+			wcode: http.StatusCreated,
+			wbody: `{"role":"manager","permissions":{"kv":{"read":[],"write":[]}}}`,
+		},
+		{
+			req: mustJSONRequest(t, "PUT", "roles/manager", `{"role":"manager","revoke":{"kv":{"read":["foo"],"write":[]}}}`),
+			store: mockAuthStore{
+				roles: map[string]*auth.Role{
+					"manager": {
+						Role: "manager",
+					},
+				},
+			},
+			wcode: http.StatusOK,
+			wbody: `{"role":"manager","permissions":{"kv":{"read":null,"write":null}}}`,
+		},
+		{
+			req: mustJSONRequest(t, "GET", "roles", ""),
+			store: mockAuthStore{
+				roles: map[string]*auth.Role{
+					"awesome": {
+						Role: "awesome",
+					},
+					"guest": {
+						Role: "guest",
+					},
+					"root": {
+						Role: "root",
+					},
+				},
+			},
+			wcode: http.StatusOK,
+			wbody: `{"roles":[{"role":"awesome","permissions":{"kv":{"read":null,"write":null}}},` +
+				`{"role":"guest","permissions":{"kv":{"read":null,"write":null}}},` +
+				`{"role":"root","permissions":{"kv":{"read":null,"write":null}}}]}`,
+		},
+		{
+			req: mustJSONRequest(t, "GET", "enable", ""),
+			store: mockAuthStore{
+				enabled: true,
+			},
+			wcode: http.StatusOK,
+			wbody: `{"enabled":true}`,
+		},
+		{
+			req: mustJSONRequest(t, "PUT", "enable", ""),
+			store: mockAuthStore{
+				enabled: false,
+			},
+			wcode: http.StatusOK,
+			wbody: ``,
+		},
+		{
+			req: (func() *http.Request {
+				req := mustJSONRequest(t, "DELETE", "enable", "")
+				req.SetBasicAuth("root", "good")
+				return req
+			})(),
+			store: mockAuthStore{
+				enabled: true,
+				users: map[string]*auth.User{
+					"root": {
+						User:     "root",
+						Password: goodPassword,
+						Roles:    []string{"root"},
+					},
+				},
+				roles: map[string]*auth.Role{
+					"root": {
+						Role: "root",
+					},
+				},
+			},
+			wcode: http.StatusOK,
+			wbody: ``,
+		},
+		{
+			req: (func() *http.Request {
+				req := mustJSONRequest(t, "DELETE", "enable", "")
+				req.SetBasicAuth("root", "bad")
+				return req
+			})(),
+			store: mockAuthStore{
+				enabled: true,
+				users: map[string]*auth.User{
+					"root": {
+						User:     "root",
+						Password: goodPassword,
+						Roles:    []string{"root"},
+					},
+				},
+				roles: map[string]*auth.Role{
+					"root": {
+						Role: "guest",
+					},
+				},
+			},
+			wcode: http.StatusUnauthorized,
+			wbody: `{"message":"Insufficient credentials"}`,
+		},
+	}
+
+	for i, tt := range testCases {
+		mux := http.NewServeMux()
+		h := &authHandler{
+			sec:     &tt.store,
+			cluster: &fakeCluster{id: 1},
+		}
+		handleAuth(mux, h)
+		rw := httptest.NewRecorder()
+		mux.ServeHTTP(rw, tt.req)
+		if rw.Code != tt.wcode {
+			t.Errorf("#%d: got code=%d, want %d", i, rw.Code, tt.wcode)
+		}
+		g := rw.Body.String()
+		g = strings.TrimSpace(g)
+		if g != tt.wbody {
+			t.Errorf("#%d: got body=%s, want %s", i, g, tt.wbody)
+		}
+	}
+}
+
+func mustAuthRequest(method, username, password string) *http.Request {
+	req, err := http.NewRequest(method, "path", strings.NewReader(""))
+	if err != nil {
+		panic("Cannot make auth request: " + err.Error())
+	}
+	req.SetBasicAuth(username, password)
+	return req
+}
+
+func TestPrefixAccess(t *testing.T) {
+	var table = []struct {
+		key                string
+		req                *http.Request
+		store              *mockAuthStore
+		hasRoot            bool
+		hasKeyPrefixAccess bool
+		hasRecursiveAccess bool
+	}{
+		{
+			key: "/foo",
+			req: mustAuthRequest("GET", "root", "good"),
+			store: &mockAuthStore{
+				users: map[string]*auth.User{
+					"root": {
+						User:     "root",
+						Password: goodPassword,
+						Roles:    []string{"root"},
+					},
+				},
+				roles: map[string]*auth.Role{
+					"root": {
+						Role: "root",
+					},
+				},
+				enabled: true,
+			},
+			hasRoot:            true,
+			hasKeyPrefixAccess: true,
+			hasRecursiveAccess: true,
+		},
+		{
+			key: "/foo",
+			req: mustAuthRequest("GET", "user", "good"),
+			store: &mockAuthStore{
+				users: map[string]*auth.User{
+					"user": {
+						User:     "user",
+						Password: goodPassword,
+						Roles:    []string{"foorole"},
+					},
+				},
+				roles: map[string]*auth.Role{
+					"foorole": {
+						Role: "foorole",
+						Permissions: auth.Permissions{
+							KV: auth.RWPermission{
+								Read:  []string{"/foo"},
+								Write: []string{"/foo"},
+							},
+						},
+					},
+				},
+				enabled: true,
+			},
+			hasRoot:            false,
+			hasKeyPrefixAccess: true,
+			hasRecursiveAccess: false,
+		},
+		{
+			key: "/foo",
+			req: mustAuthRequest("GET", "user", "good"),
+			store: &mockAuthStore{
+				users: map[string]*auth.User{
+					"user": {
+						User:     "user",
+						Password: goodPassword,
+						Roles:    []string{"foorole"},
+					},
+				},
+				roles: map[string]*auth.Role{
+					"foorole": {
+						Role: "foorole",
+						Permissions: auth.Permissions{
+							KV: auth.RWPermission{
+								Read:  []string{"/foo*"},
+								Write: []string{"/foo*"},
+							},
+						},
+					},
+				},
+				enabled: true,
+			},
+			hasRoot:            false,
+			hasKeyPrefixAccess: true,
+			hasRecursiveAccess: true,
+		},
+		{
+			key: "/foo",
+			req: mustAuthRequest("GET", "user", "bad"),
+			store: &mockAuthStore{
+				users: map[string]*auth.User{
+					"user": {
+						User:     "user",
+						Password: goodPassword,
+						Roles:    []string{"foorole"},
+					},
+				},
+				roles: map[string]*auth.Role{
+					"foorole": {
+						Role: "foorole",
+						Permissions: auth.Permissions{
+							KV: auth.RWPermission{
+								Read:  []string{"/foo*"},
+								Write: []string{"/foo*"},
+							},
+						},
+					},
+				},
+				enabled: true,
+			},
+			hasRoot:            false,
+			hasKeyPrefixAccess: false,
+			hasRecursiveAccess: false,
+		},
+		{
+			key: "/foo",
+			req: mustAuthRequest("GET", "user", "good"),
+			store: &mockAuthStore{
+				users:   map[string]*auth.User{},
+				err:     errors.New("Not the user"),
+				enabled: true,
+			},
+			hasRoot:            false,
+			hasKeyPrefixAccess: false,
+			hasRecursiveAccess: false,
+		},
+		{
+			key: "/foo",
+			req: mustJSONRequest(t, "GET", "somepath", ""),
+			store: &mockAuthStore{
+				users: map[string]*auth.User{
+					"user": {
+						User:     "user",
+						Password: goodPassword,
+						Roles:    []string{"foorole"},
+					},
+				},
+				roles: map[string]*auth.Role{
+					"guest": {
+						Role: "guest",
+						Permissions: auth.Permissions{
+							KV: auth.RWPermission{
+								Read:  []string{"/foo*"},
+								Write: []string{"/foo*"},
+							},
+						},
+					},
+				},
+				enabled: true,
+			},
+			hasRoot:            false,
+			hasKeyPrefixAccess: true,
+			hasRecursiveAccess: true,
+		},
+		{
+			key: "/bar",
+			req: mustJSONRequest(t, "GET", "somepath", ""),
+			store: &mockAuthStore{
+				users: map[string]*auth.User{
+					"user": {
+						User:     "user",
+						Password: goodPassword,
+						Roles:    []string{"foorole"},
+					},
+				},
+				roles: map[string]*auth.Role{
+					"guest": {
+						Role: "guest",
+						Permissions: auth.Permissions{
+							KV: auth.RWPermission{
+								Read:  []string{"/foo*"},
+								Write: []string{"/foo*"},
+							},
+						},
+					},
+				},
+				enabled: true,
+			},
+			hasRoot:            false,
+			hasKeyPrefixAccess: false,
+			hasRecursiveAccess: false,
+		},
+		// check access for multiple roles
+		{
+			key: "/foo",
+			req: mustAuthRequest("GET", "user", "good"),
+			store: &mockAuthStore{
+				users: map[string]*auth.User{
+					"user": {
+						User:     "user",
+						Password: goodPassword,
+						Roles:    []string{"role1", "role2"},
+					},
+				},
+				roles: map[string]*auth.Role{
+					"role1": {
+						Role: "role1",
+					},
+					"role2": {
+						Role: "role2",
+						Permissions: auth.Permissions{
+							KV: auth.RWPermission{
+								Read:  []string{"/foo"},
+								Write: []string{"/foo"},
+							},
+						},
+					},
+				},
+				enabled: true,
+			},
+			hasRoot:            false,
+			hasKeyPrefixAccess: true,
+			hasRecursiveAccess: false,
+		},
+		{
+			key: "/foo",
+			req: (func() *http.Request {
+				req := mustJSONRequest(t, "GET", "somepath", "")
+				req.Header.Set("Authorization", "malformedencoding")
+				return req
+			})(),
+			store: &mockAuthStore{
+				enabled: true,
+				users: map[string]*auth.User{
+					"root": {
+						User:     "root",
+						Password: goodPassword,
+						Roles:    []string{"root"},
+					},
+				},
+				roles: map[string]*auth.Role{
+					"guest": {
+						Role: "guest",
+						Permissions: auth.Permissions{
+							KV: auth.RWPermission{
+								Read:  []string{"/foo*"},
+								Write: []string{"/foo*"},
+							},
+						},
+					},
+				},
+			},
+			hasRoot:            false,
+			hasKeyPrefixAccess: false,
+			hasRecursiveAccess: false,
+		},
+	}
+
+	for i, tt := range table {
+		if tt.hasRoot != hasRootAccess(tt.store, tt.req) {
+			t.Errorf("#%d: hasRoot doesn't match (expected %v)", i, tt.hasRoot)
+		}
+		if tt.hasKeyPrefixAccess != hasKeyPrefixAccess(tt.store, tt.req, tt.key, false) {
+			t.Errorf("#%d: hasKeyPrefixAccess doesn't match (expected %v)", i, tt.hasRoot)
+		}
+		if tt.hasRecursiveAccess != hasKeyPrefixAccess(tt.store, tt.req, tt.key, true) {
+			t.Errorf("#%d: hasRecursiveAccess doesn't match (expected %v)", i, tt.hasRoot)
+		}
+	}
+}
diff --git a/etcdserver/api/v2http/client_test.go b/etcdserver/api/v2http/client_test.go
new file mode 100644
index 0000000..bc5b933
--- /dev/null
+++ b/etcdserver/api/v2http/client_test.go
@@ -0,0 +1,2015 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2http
+
+import (
+	"bytes"
+	"encoding/json"
+	"errors"
+	"io/ioutil"
+	"net/http"
+	"net/http/httptest"
+	"net/url"
+	"path"
+	"reflect"
+	"strings"
+	"testing"
+	"time"
+
+	etcdErr "github.com/coreos/etcd/error"
+	"github.com/coreos/etcd/etcdserver"
+	"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
+	"github.com/coreos/etcd/etcdserver/etcdserverpb"
+	"github.com/coreos/etcd/pkg/testutil"
+	"github.com/coreos/etcd/pkg/types"
+	"github.com/coreos/etcd/raft/raftpb"
+	"github.com/coreos/etcd/store"
+	"github.com/coreos/etcd/version"
+	"github.com/coreos/go-semver/semver"
+	"github.com/jonboulle/clockwork"
+	"golang.org/x/net/context"
+)
+
+func mustMarshalEvent(t *testing.T, ev *store.Event) string {
+	b := new(bytes.Buffer)
+	if err := json.NewEncoder(b).Encode(ev); err != nil {
+		t.Fatalf("error marshalling event %#v: %v", ev, err)
+	}
+	return b.String()
+}
+
+// mustNewForm takes a set of Values and constructs a PUT *http.Request,
+// with a URL constructed from appending the given path to the standard keysPrefix
+func mustNewForm(t *testing.T, p string, vals url.Values) *http.Request {
+	u := testutil.MustNewURL(t, path.Join(keysPrefix, p))
+	req, err := http.NewRequest("PUT", u.String(), strings.NewReader(vals.Encode()))
+	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
+	if err != nil {
+		t.Fatalf("error creating new request: %v", err)
+	}
+	return req
+}
+
+// mustNewPostForm takes a set of Values and constructs a POST *http.Request,
+// with a URL constructed from appending the given path to the standard keysPrefix
+func mustNewPostForm(t *testing.T, p string, vals url.Values) *http.Request {
+	u := testutil.MustNewURL(t, path.Join(keysPrefix, p))
+	req, err := http.NewRequest("POST", u.String(), strings.NewReader(vals.Encode()))
+	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
+	if err != nil {
+		t.Fatalf("error creating new request: %v", err)
+	}
+	return req
+}
+
+// mustNewRequest takes a path, appends it to the standard keysPrefix, and constructs
+// a GET *http.Request referencing the resulting URL
+func mustNewRequest(t *testing.T, p string) *http.Request {
+	return mustNewMethodRequest(t, "GET", p)
+}
+
+func mustNewMethodRequest(t *testing.T, m, p string) *http.Request {
+	return &http.Request{
+		Method: m,
+		URL:    testutil.MustNewURL(t, path.Join(keysPrefix, p)),
+	}
+}
+
+type serverRecorder struct {
+	actions []action
+}
+
+func (s *serverRecorder) Start()           {}
+func (s *serverRecorder) Stop()            {}
+func (s *serverRecorder) Leader() types.ID { return types.ID(1) }
+func (s *serverRecorder) ID() types.ID     { return types.ID(1) }
+func (s *serverRecorder) Do(_ context.Context, r etcdserverpb.Request) (etcdserver.Response, error) {
+	s.actions = append(s.actions, action{name: "Do", params: []interface{}{r}})
+	return etcdserver.Response{}, nil
+}
+func (s *serverRecorder) Process(_ context.Context, m raftpb.Message) error {
+	s.actions = append(s.actions, action{name: "Process", params: []interface{}{m}})
+	return nil
+}
+func (s *serverRecorder) AddMember(_ context.Context, m etcdserver.Member) error {
+	s.actions = append(s.actions, action{name: "AddMember", params: []interface{}{m}})
+	return nil
+}
+func (s *serverRecorder) RemoveMember(_ context.Context, id uint64) error {
+	s.actions = append(s.actions, action{name: "RemoveMember", params: []interface{}{id}})
+	return nil
+}
+
+func (s *serverRecorder) UpdateMember(_ context.Context, m etcdserver.Member) error {
+	s.actions = append(s.actions, action{name: "UpdateMember", params: []interface{}{m}})
+	return nil
+}
+
+func (s *serverRecorder) ClusterVersion() *semver.Version { return nil }
+
+type action struct {
+	name   string
+	params []interface{}
+}
+
+// flushingRecorder provides a channel to allow users to block until the Recorder is Flushed()
+type flushingRecorder struct {
+	*httptest.ResponseRecorder
+	ch chan struct{}
+}
+
+func (fr *flushingRecorder) Flush() {
+	fr.ResponseRecorder.Flush()
+	fr.ch <- struct{}{}
+}
+
+// resServer implements the etcd.Server interface for testing.
+// It returns the given response from any Do calls, and nil error
+type resServer struct {
+	res etcdserver.Response
+}
+
+func (rs *resServer) Start()           {}
+func (rs *resServer) Stop()            {}
+func (rs *resServer) ID() types.ID     { return types.ID(1) }
+func (rs *resServer) Leader() types.ID { return types.ID(1) }
+func (rs *resServer) Do(_ context.Context, _ etcdserverpb.Request) (etcdserver.Response, error) {
+	return rs.res, nil
+}
+func (rs *resServer) Process(_ context.Context, _ raftpb.Message) error         { return nil }
+func (rs *resServer) AddMember(_ context.Context, _ etcdserver.Member) error    { return nil }
+func (rs *resServer) RemoveMember(_ context.Context, _ uint64) error            { return nil }
+func (rs *resServer) UpdateMember(_ context.Context, _ etcdserver.Member) error { return nil }
+func (rs *resServer) ClusterVersion() *semver.Version                           { return nil }
+
+func boolp(b bool) *bool { return &b }
+
+type dummyRaftTimer struct{}
+
+func (drt dummyRaftTimer) Index() uint64 { return uint64(100) }
+func (drt dummyRaftTimer) Term() uint64  { return uint64(5) }
+
+type dummyWatcher struct {
+	echan chan *store.Event
+	sidx  uint64
+}
+
+func (w *dummyWatcher) EventChan() chan *store.Event {
+	return w.echan
+}
+func (w *dummyWatcher) StartIndex() uint64 { return w.sidx }
+func (w *dummyWatcher) Remove()            {}
+
+func TestBadRefreshRequest(t *testing.T) {
+	tests := []struct {
+		in    *http.Request
+		wcode int
+	}{
+		{
+			mustNewRequest(t, "foo?refresh=true&value=test"),
+			etcdErr.EcodeRefreshValue,
+		},
+		{
+			mustNewRequest(t, "foo?refresh=true&value=10"),
+			etcdErr.EcodeRefreshValue,
+		},
+		{
+			mustNewRequest(t, "foo?refresh=true"),
+			etcdErr.EcodeRefreshTTLRequired,
+		},
+		{
+			mustNewRequest(t, "foo?refresh=true&ttl="),
+			etcdErr.EcodeRefreshTTLRequired,
+		},
+	}
+	for i, tt := range tests {
+		got, err := parseKeyRequest(tt.in, clockwork.NewFakeClock())
+		if err == nil {
+			t.Errorf("#%d: unexpected nil error!", i)
+			continue
+		}
+		ee, ok := err.(*etcdErr.Error)
+		if !ok {
+			t.Errorf("#%d: err is not etcd.Error!", i)
+			continue
+		}
+		if ee.ErrorCode != tt.wcode {
+			t.Errorf("#%d: code=%d, want %v", i, ee.ErrorCode, tt.wcode)
+			t.Logf("cause: %#v", ee.Cause)
+		}
+		if !reflect.DeepEqual(got, etcdserverpb.Request{}) {
+			t.Errorf("#%d: unexpected non-empty Request: %#v", i, got)
+		}
+	}
+}
+
+func TestBadParseRequest(t *testing.T) {
+	tests := []struct {
+		in    *http.Request
+		wcode int
+	}{
+		{
+			// parseForm failure
+			&http.Request{
+				Body:   nil,
+				Method: "PUT",
+			},
+			etcdErr.EcodeInvalidForm,
+		},
+		{
+			// bad key prefix
+			&http.Request{
+				URL: testutil.MustNewURL(t, "/badprefix/"),
+			},
+			etcdErr.EcodeInvalidForm,
+		},
+		// bad values for prevIndex, waitIndex, ttl
+		{
+			mustNewForm(t, "foo", url.Values{"prevIndex": []string{"garbage"}}),
+			etcdErr.EcodeIndexNaN,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"prevIndex": []string{"1.5"}}),
+			etcdErr.EcodeIndexNaN,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"prevIndex": []string{"-1"}}),
+			etcdErr.EcodeIndexNaN,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"waitIndex": []string{"garbage"}}),
+			etcdErr.EcodeIndexNaN,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"waitIndex": []string{"??"}}),
+			etcdErr.EcodeIndexNaN,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"ttl": []string{"-1"}}),
+			etcdErr.EcodeTTLNaN,
+		},
+		// bad values for recursive, sorted, wait, prevExist, dir, stream
+		{
+			mustNewForm(t, "foo", url.Values{"recursive": []string{"hahaha"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"recursive": []string{"1234"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"recursive": []string{"?"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"sorted": []string{"?"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"sorted": []string{"x"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"wait": []string{"?!"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"wait": []string{"yes"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"prevExist": []string{"yes"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"prevExist": []string{"#2"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"dir": []string{"no"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"dir": []string{"file"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"quorum": []string{"no"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"quorum": []string{"file"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"stream": []string{"zzz"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"stream": []string{"something"}}),
+			etcdErr.EcodeInvalidField,
+		},
+		// prevValue cannot be empty
+		{
+			mustNewForm(t, "foo", url.Values{"prevValue": []string{""}}),
+			etcdErr.EcodePrevValueRequired,
+		},
+		// wait is only valid with GET requests
+		{
+			mustNewMethodRequest(t, "HEAD", "foo?wait=true"),
+			etcdErr.EcodeInvalidField,
+		},
+		// query values are considered
+		{
+			mustNewRequest(t, "foo?prevExist=wrong"),
+			etcdErr.EcodeInvalidField,
+		},
+		{
+			mustNewRequest(t, "foo?ttl=wrong"),
+			etcdErr.EcodeTTLNaN,
+		},
+		// but body takes precedence if both are specified
+		{
+			mustNewForm(
+				t,
+				"foo?ttl=12",
+				url.Values{"ttl": []string{"garbage"}},
+			),
+			etcdErr.EcodeTTLNaN,
+		},
+		{
+			mustNewForm(
+				t,
+				"foo?prevExist=false",
+				url.Values{"prevExist": []string{"yes"}},
+			),
+			etcdErr.EcodeInvalidField,
+		},
+	}
+	for i, tt := range tests {
+		got, err := parseKeyRequest(tt.in, clockwork.NewFakeClock())
+		if err == nil {
+			t.Errorf("#%d: unexpected nil error!", i)
+			continue
+		}
+		ee, ok := err.(*etcdErr.Error)
+		if !ok {
+			t.Errorf("#%d: err is not etcd.Error!", i)
+			continue
+		}
+		if ee.ErrorCode != tt.wcode {
+			t.Errorf("#%d: code=%d, want %v", i, ee.ErrorCode, tt.wcode)
+			t.Logf("cause: %#v", ee.Cause)
+		}
+		if !reflect.DeepEqual(got, etcdserverpb.Request{}) {
+			t.Errorf("#%d: unexpected non-empty Request: %#v", i, got)
+		}
+	}
+}
+
+func TestGoodParseRequest(t *testing.T) {
+	fc := clockwork.NewFakeClock()
+	fc.Advance(1111)
+	tests := []struct {
+		in *http.Request
+		w  etcdserverpb.Request
+	}{
+		{
+			// good prefix, all other values default
+			mustNewRequest(t, "foo"),
+			etcdserverpb.Request{
+				Method: "GET",
+				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		{
+			// value specified
+			mustNewForm(
+				t,
+				"foo",
+				url.Values{"value": []string{"some_value"}},
+			),
+			etcdserverpb.Request{
+				Method: "PUT",
+				Val:    "some_value",
+				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		{
+			// prevIndex specified
+			mustNewForm(
+				t,
+				"foo",
+				url.Values{"prevIndex": []string{"98765"}},
+			),
+			etcdserverpb.Request{
+				Method:    "PUT",
+				PrevIndex: 98765,
+				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		{
+			// recursive specified
+			mustNewForm(
+				t,
+				"foo",
+				url.Values{"recursive": []string{"true"}},
+			),
+			etcdserverpb.Request{
+				Method:    "PUT",
+				Recursive: true,
+				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		{
+			// sorted specified
+			mustNewForm(
+				t,
+				"foo",
+				url.Values{"sorted": []string{"true"}},
+			),
+			etcdserverpb.Request{
+				Method: "PUT",
+				Sorted: true,
+				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		{
+			// quorum specified
+			mustNewForm(
+				t,
+				"foo",
+				url.Values{"quorum": []string{"true"}},
+			),
+			etcdserverpb.Request{
+				Method: "PUT",
+				Quorum: true,
+				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		{
+			// wait specified
+			mustNewRequest(t, "foo?wait=true"),
+			etcdserverpb.Request{
+				Method: "GET",
+				Wait:   true,
+				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		{
+			// empty TTL specified
+			mustNewRequest(t, "foo?ttl="),
+			etcdserverpb.Request{
+				Method:     "GET",
+				Path:       path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+				Expiration: 0,
+			},
+		},
+		{
+			// non-empty TTL specified
+			mustNewRequest(t, "foo?ttl=5678"),
+			etcdserverpb.Request{
+				Method:     "GET",
+				Path:       path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+				Expiration: fc.Now().Add(5678 * time.Second).UnixNano(),
+			},
+		},
+		{
+			// zero TTL specified
+			mustNewRequest(t, "foo?ttl=0"),
+			etcdserverpb.Request{
+				Method:     "GET",
+				Path:       path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+				Expiration: fc.Now().UnixNano(),
+			},
+		},
+		{
+			// dir specified
+			mustNewRequest(t, "foo?dir=true"),
+			etcdserverpb.Request{
+				Method: "GET",
+				Dir:    true,
+				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		{
+			// dir specified negatively
+			mustNewRequest(t, "foo?dir=false"),
+			etcdserverpb.Request{
+				Method: "GET",
+				Dir:    false,
+				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		{
+			// prevExist should be non-null if specified
+			mustNewForm(
+				t,
+				"foo",
+				url.Values{"prevExist": []string{"true"}},
+			),
+			etcdserverpb.Request{
+				Method:    "PUT",
+				PrevExist: boolp(true),
+				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		{
+			// prevExist should be non-null if specified
+			mustNewForm(
+				t,
+				"foo",
+				url.Values{"prevExist": []string{"false"}},
+			),
+			etcdserverpb.Request{
+				Method:    "PUT",
+				PrevExist: boolp(false),
+				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		// mix various fields
+		{
+			mustNewForm(
+				t,
+				"foo",
+				url.Values{
+					"value":     []string{"some value"},
+					"prevExist": []string{"true"},
+					"prevValue": []string{"previous value"},
+				},
+			),
+			etcdserverpb.Request{
+				Method:    "PUT",
+				PrevExist: boolp(true),
+				PrevValue: "previous value",
+				Val:       "some value",
+				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		// query parameters should be used if given
+		{
+			mustNewForm(
+				t,
+				"foo?prevValue=woof",
+				url.Values{},
+			),
+			etcdserverpb.Request{
+				Method:    "PUT",
+				PrevValue: "woof",
+				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+		// but form values should take precedence over query parameters
+		{
+			mustNewForm(
+				t,
+				"foo?prevValue=woof",
+				url.Values{
+					"prevValue": []string{"miaow"},
+				},
+			),
+			etcdserverpb.Request{
+				Method:    "PUT",
+				PrevValue: "miaow",
+				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
+			},
+		},
+	}
+
+	for i, tt := range tests {
+		got, err := parseKeyRequest(tt.in, fc)
+		if err != nil {
+			t.Errorf("#%d: err = %v, want %v", i, err, nil)
+		}
+		if !reflect.DeepEqual(got, tt.w) {
+			t.Errorf("#%d: request=%#v, want %#v", i, got, tt.w)
+		}
+	}
+}
+
+func TestServeMembers(t *testing.T) {
+	memb1 := etcdserver.Member{ID: 12, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8080"}}}
+	memb2 := etcdserver.Member{ID: 13, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8081"}}}
+	cluster := &fakeCluster{
+		id:      1,
+		members: map[uint64]*etcdserver.Member{1: &memb1, 2: &memb2},
+	}
+	h := &membersHandler{
+		server:  &serverRecorder{},
+		clock:   clockwork.NewFakeClock(),
+		cluster: cluster,
+	}
+
+	wmc := string(`{"members":[{"id":"c","name":"","peerURLs":[],"clientURLs":["http://localhost:8080"]},{"id":"d","name":"","peerURLs":[],"clientURLs":["http://localhost:8081"]}]}`)
+
+	tests := []struct {
+		path  string
+		wcode int
+		wct   string
+		wbody string
+	}{
+		{membersPrefix, http.StatusOK, "application/json", wmc + "\n"},
+		{membersPrefix + "/", http.StatusOK, "application/json", wmc + "\n"},
+		{path.Join(membersPrefix, "100"), http.StatusNotFound, "application/json", `{"message":"Not found"}`},
+		{path.Join(membersPrefix, "foobar"), http.StatusNotFound, "application/json", `{"message":"Not found"}`},
+	}
+
+	for i, tt := range tests {
+		req, err := http.NewRequest("GET", testutil.MustNewURL(t, tt.path).String(), nil)
+		if err != nil {
+			t.Fatal(err)
+		}
+		rw := httptest.NewRecorder()
+		h.ServeHTTP(rw, req)
+
+		if rw.Code != tt.wcode {
+			t.Errorf("#%d: code=%d, want %d", i, rw.Code, tt.wcode)
+		}
+		if gct := rw.Header().Get("Content-Type"); gct != tt.wct {
+			t.Errorf("#%d: content-type = %s, want %s", i, gct, tt.wct)
+		}
+		gcid := rw.Header().Get("X-Etcd-Cluster-ID")
+		wcid := cluster.ID().String()
+		if gcid != wcid {
+			t.Errorf("#%d: cid = %s, want %s", i, gcid, wcid)
+		}
+		if rw.Body.String() != tt.wbody {
+			t.Errorf("#%d: body = %q, want %q", i, rw.Body.String(), tt.wbody)
+		}
+	}
+}
+
+// TODO: consolidate **ALL** fake server implementations and add no leader test case.
+func TestServeLeader(t *testing.T) {
+	memb1 := etcdserver.Member{ID: 1, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8080"}}}
+	memb2 := etcdserver.Member{ID: 2, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8081"}}}
+	cluster := &fakeCluster{
+		id:      1,
+		members: map[uint64]*etcdserver.Member{1: &memb1, 2: &memb2},
+	}
+	h := &membersHandler{
+		server:  &serverRecorder{},
+		clock:   clockwork.NewFakeClock(),
+		cluster: cluster,
+	}
+
+	wmc := string(`{"id":"1","name":"","peerURLs":[],"clientURLs":["http://localhost:8080"]}`)
+
+	tests := []struct {
+		path  string
+		wcode int
+		wct   string
+		wbody string
+	}{
+		{membersPrefix + "leader", http.StatusOK, "application/json", wmc + "\n"},
+		// TODO: add no leader case
+	}
+
+	for i, tt := range tests {
+		req, err := http.NewRequest("GET", testutil.MustNewURL(t, tt.path).String(), nil)
+		if err != nil {
+			t.Fatal(err)
+		}
+		rw := httptest.NewRecorder()
+		h.ServeHTTP(rw, req)
+
+		if rw.Code != tt.wcode {
+			t.Errorf("#%d: code=%d, want %d", i, rw.Code, tt.wcode)
+		}
+		if gct := rw.Header().Get("Content-Type"); gct != tt.wct {
+			t.Errorf("#%d: content-type = %s, want %s", i, gct, tt.wct)
+		}
+		gcid := rw.Header().Get("X-Etcd-Cluster-ID")
+		wcid := cluster.ID().String()
+		if gcid != wcid {
+			t.Errorf("#%d: cid = %s, want %s", i, gcid, wcid)
+		}
+		if rw.Body.String() != tt.wbody {
+			t.Errorf("#%d: body = %q, want %q", i, rw.Body.String(), tt.wbody)
+		}
+	}
+}
+
+func TestServeMembersCreate(t *testing.T) {
+	u := testutil.MustNewURL(t, membersPrefix)
+	b := []byte(`{"peerURLs":["http://127.0.0.1:1"]}`)
+	req, err := http.NewRequest("POST", u.String(), bytes.NewReader(b))
+	if err != nil {
+		t.Fatal(err)
+	}
+	req.Header.Set("Content-Type", "application/json")
+	s := &serverRecorder{}
+	h := &membersHandler{
+		server:  s,
+		clock:   clockwork.NewFakeClock(),
+		cluster: &fakeCluster{id: 1},
+	}
+	rw := httptest.NewRecorder()
+
+	h.ServeHTTP(rw, req)
+
+	wcode := http.StatusCreated
+	if rw.Code != wcode {
+		t.Errorf("code=%d, want %d", rw.Code, wcode)
+	}
+
+	wct := "application/json"
+	if gct := rw.Header().Get("Content-Type"); gct != wct {
+		t.Errorf("content-type = %s, want %s", gct, wct)
+	}
+	gcid := rw.Header().Get("X-Etcd-Cluster-ID")
+	wcid := h.cluster.ID().String()
+	if gcid != wcid {
+		t.Errorf("cid = %s, want %s", gcid, wcid)
+	}
+
+	wb := `{"id":"2a86a83729b330d5","name":"","peerURLs":["http://127.0.0.1:1"],"clientURLs":[]}` + "\n"
+	g := rw.Body.String()
+	if g != wb {
+		t.Errorf("got body=%q, want %q", g, wb)
+	}
+
+	wm := etcdserver.Member{
+		ID: 3064321551348478165,
+		RaftAttributes: etcdserver.RaftAttributes{
+			PeerURLs: []string{"http://127.0.0.1:1"},
+		},
+	}
+
+	wactions := []action{{name: "AddMember", params: []interface{}{wm}}}
+	if !reflect.DeepEqual(s.actions, wactions) {
+		t.Errorf("actions = %+v, want %+v", s.actions, wactions)
+	}
+}
+
+func TestServeMembersDelete(t *testing.T) {
+	req := &http.Request{
+		Method: "DELETE",
+		URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "BEEF")),
+	}
+	s := &serverRecorder{}
+	h := &membersHandler{
+		server:  s,
+		cluster: &fakeCluster{id: 1},
+	}
+	rw := httptest.NewRecorder()
+
+	h.ServeHTTP(rw, req)
+
+	wcode := http.StatusNoContent
+	if rw.Code != wcode {
+		t.Errorf("code=%d, want %d", rw.Code, wcode)
+	}
+	gcid := rw.Header().Get("X-Etcd-Cluster-ID")
+	wcid := h.cluster.ID().String()
+	if gcid != wcid {
+		t.Errorf("cid = %s, want %s", gcid, wcid)
+	}
+	g := rw.Body.String()
+	if g != "" {
+		t.Errorf("got body=%q, want %q", g, "")
+	}
+	wactions := []action{{name: "RemoveMember", params: []interface{}{uint64(0xBEEF)}}}
+	if !reflect.DeepEqual(s.actions, wactions) {
+		t.Errorf("actions = %+v, want %+v", s.actions, wactions)
+	}
+}
+
+func TestServeMembersUpdate(t *testing.T) {
+	u := testutil.MustNewURL(t, path.Join(membersPrefix, "1"))
+	b := []byte(`{"peerURLs":["http://127.0.0.1:1"]}`)
+	req, err := http.NewRequest("PUT", u.String(), bytes.NewReader(b))
+	if err != nil {
+		t.Fatal(err)
+	}
+	req.Header.Set("Content-Type", "application/json")
+	s := &serverRecorder{}
+	h := &membersHandler{
+		server:  s,
+		clock:   clockwork.NewFakeClock(),
+		cluster: &fakeCluster{id: 1},
+	}
+	rw := httptest.NewRecorder()
+
+	h.ServeHTTP(rw, req)
+
+	wcode := http.StatusNoContent
+	if rw.Code != wcode {
+		t.Errorf("code=%d, want %d", rw.Code, wcode)
+	}
+
+	gcid := rw.Header().Get("X-Etcd-Cluster-ID")
+	wcid := h.cluster.ID().String()
+	if gcid != wcid {
+		t.Errorf("cid = %s, want %s", gcid, wcid)
+	}
+
+	wm := etcdserver.Member{
+		ID: 1,
+		RaftAttributes: etcdserver.RaftAttributes{
+			PeerURLs: []string{"http://127.0.0.1:1"},
+		},
+	}
+
+	wactions := []action{{name: "UpdateMember", params: []interface{}{wm}}}
+	if !reflect.DeepEqual(s.actions, wactions) {
+		t.Errorf("actions = %+v, want %+v", s.actions, wactions)
+	}
+}
+
+func TestServeMembersFail(t *testing.T) {
+	tests := []struct {
+		req    *http.Request
+		server etcdserver.Server
+
+		wcode int
+	}{
+		{
+			// bad method
+			&http.Request{
+				Method: "CONNECT",
+			},
+			&resServer{},
+
+			http.StatusMethodNotAllowed,
+		},
+		{
+			// bad method
+			&http.Request{
+				Method: "TRACE",
+			},
+			&resServer{},
+
+			http.StatusMethodNotAllowed,
+		},
+		{
+			// parse body error
+			&http.Request{
+				URL:    testutil.MustNewURL(t, membersPrefix),
+				Method: "POST",
+				Body:   ioutil.NopCloser(strings.NewReader("bad json")),
+				Header: map[string][]string{"Content-Type": {"application/json"}},
+			},
+			&resServer{},
+
+			http.StatusBadRequest,
+		},
+		{
+			// bad content type
+			&http.Request{
+				URL:    testutil.MustNewURL(t, membersPrefix),
+				Method: "POST",
+				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
+				Header: map[string][]string{"Content-Type": {"application/bad"}},
+			},
+			&errServer{},
+
+			http.StatusUnsupportedMediaType,
+		},
+		{
+			// bad url
+			&http.Request{
+				URL:    testutil.MustNewURL(t, membersPrefix),
+				Method: "POST",
+				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://a"]}`)),
+				Header: map[string][]string{"Content-Type": {"application/json"}},
+			},
+			&errServer{},
+
+			http.StatusBadRequest,
+		},
+		{
+			// etcdserver.AddMember error
+			&http.Request{
+				URL:    testutil.MustNewURL(t, membersPrefix),
+				Method: "POST",
+				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
+				Header: map[string][]string{"Content-Type": {"application/json"}},
+			},
+			&errServer{
+				errors.New("Error while adding a member"),
+			},
+
+			http.StatusInternalServerError,
+		},
+		{
+			// etcdserver.AddMember error
+			&http.Request{
+				URL:    testutil.MustNewURL(t, membersPrefix),
+				Method: "POST",
+				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
+				Header: map[string][]string{"Content-Type": {"application/json"}},
+			},
+			&errServer{
+				etcdserver.ErrIDExists,
+			},
+
+			http.StatusConflict,
+		},
+		{
+			// etcdserver.AddMember error
+			&http.Request{
+				URL:    testutil.MustNewURL(t, membersPrefix),
+				Method: "POST",
+				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
+				Header: map[string][]string{"Content-Type": {"application/json"}},
+			},
+			&errServer{
+				etcdserver.ErrPeerURLexists,
+			},
+
+			http.StatusConflict,
+		},
+		{
+			// etcdserver.RemoveMember error with arbitrary server error
+			&http.Request{
+				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "1")),
+				Method: "DELETE",
+			},
+			&errServer{
+				errors.New("Error while removing member"),
+			},
+
+			http.StatusInternalServerError,
+		},
+		{
+			// etcdserver.RemoveMember error with previously removed ID
+			&http.Request{
+				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
+				Method: "DELETE",
+			},
+			&errServer{
+				etcdserver.ErrIDRemoved,
+			},
+
+			http.StatusGone,
+		},
+		{
+			// etcdserver.RemoveMember error with nonexistent ID
+			&http.Request{
+				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
+				Method: "DELETE",
+			},
+			&errServer{
+				etcdserver.ErrIDNotFound,
+			},
+
+			http.StatusNotFound,
+		},
+		{
+			// etcdserver.RemoveMember error with badly formed ID
+			&http.Request{
+				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "bad_id")),
+				Method: "DELETE",
+			},
+			nil,
+
+			http.StatusNotFound,
+		},
+		{
+			// etcdserver.RemoveMember with no ID
+			&http.Request{
+				URL:    testutil.MustNewURL(t, membersPrefix),
+				Method: "DELETE",
+			},
+			nil,
+
+			http.StatusMethodNotAllowed,
+		},
+		{
+			// parse body error
+			&http.Request{
+				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
+				Method: "PUT",
+				Body:   ioutil.NopCloser(strings.NewReader("bad json")),
+				Header: map[string][]string{"Content-Type": {"application/json"}},
+			},
+			&resServer{},
+
+			http.StatusBadRequest,
+		},
+		{
+			// bad content type
+			&http.Request{
+				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
+				Method: "PUT",
+				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
+				Header: map[string][]string{"Content-Type": {"application/bad"}},
+			},
+			&errServer{},
+
+			http.StatusUnsupportedMediaType,
+		},
+		{
+			// bad url
+			&http.Request{
+				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
+				Method: "PUT",
+				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://a"]}`)),
+				Header: map[string][]string{"Content-Type": {"application/json"}},
+			},
+			&errServer{},
+
+			http.StatusBadRequest,
+		},
+		{
+			// etcdserver.UpdateMember error
+			&http.Request{
+				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
+				Method: "PUT",
+				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
+				Header: map[string][]string{"Content-Type": {"application/json"}},
+			},
+			&errServer{
+				errors.New("blah"),
+			},
+
+			http.StatusInternalServerError,
+		},
+		{
+			// etcdserver.UpdateMember error
+			&http.Request{
+				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
+				Method: "PUT",
+				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
+				Header: map[string][]string{"Content-Type": {"application/json"}},
+			},
+			&errServer{
+				etcdserver.ErrPeerURLexists,
+			},
+
+			http.StatusConflict,
+		},
+		{
+			// etcdserver.UpdateMember error
+			&http.Request{
+				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
+				Method: "PUT",
+				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
+				Header: map[string][]string{"Content-Type": {"application/json"}},
+			},
+			&errServer{
+				etcdserver.ErrIDNotFound,
+			},
+
+			http.StatusNotFound,
+		},
+		{
+			// etcdserver.UpdateMember error with badly formed ID
+			&http.Request{
+				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "bad_id")),
+				Method: "PUT",
+			},
+			nil,
+
+			http.StatusNotFound,
+		},
+		{
+			// etcdserver.UpdateMember with no ID
+			&http.Request{
+				URL:    testutil.MustNewURL(t, membersPrefix),
+				Method: "PUT",
+			},
+			nil,
+
+			http.StatusMethodNotAllowed,
+		},
+	}
+	for i, tt := range tests {
+		h := &membersHandler{
+			server:  tt.server,
+			cluster: &fakeCluster{id: 1},
+			clock:   clockwork.NewFakeClock(),
+		}
+		rw := httptest.NewRecorder()
+		h.ServeHTTP(rw, tt.req)
+		if rw.Code != tt.wcode {
+			t.Errorf("#%d: code=%d, want %d", i, rw.Code, tt.wcode)
+		}
+		if rw.Code != http.StatusMethodNotAllowed {
+			gcid := rw.Header().Get("X-Etcd-Cluster-ID")
+			wcid := h.cluster.ID().String()
+			if gcid != wcid {
+				t.Errorf("#%d: cid = %s, want %s", i, gcid, wcid)
+			}
+		}
+	}
+}
+
+func TestWriteEvent(t *testing.T) {
+	// nil event should not panic
+	rec := httptest.NewRecorder()
+	writeKeyEvent(rec, nil, dummyRaftTimer{})
+	h := rec.Header()
+	if len(h) > 0 {
+		t.Fatalf("unexpected non-empty headers: %#v", h)
+	}
+	b := rec.Body.String()
+	if len(b) > 0 {
+		t.Fatalf("unexpected non-empty body: %q", b)
+	}
+
+	tests := []struct {
+		ev  *store.Event
+		idx string
+		// TODO(jonboulle): check body as well as just status code
+		code int
+		err  error
+	}{
+		// standard case, standard 200 response
+		{
+			&store.Event{
+				Action:   store.Get,
+				Node:     &store.NodeExtern{},
+				PrevNode: &store.NodeExtern{},
+			},
+			"0",
+			http.StatusOK,
+			nil,
+		},
+		// check new nodes return StatusCreated
+		{
+			&store.Event{
+				Action:   store.Create,
+				Node:     &store.NodeExtern{},
+				PrevNode: &store.NodeExtern{},
+			},
+			"0",
+			http.StatusCreated,
+			nil,
+		},
+	}
+
+	for i, tt := range tests {
+		rw := httptest.NewRecorder()
+		writeKeyEvent(rw, tt.ev, dummyRaftTimer{})
+		if gct := rw.Header().Get("Content-Type"); gct != "application/json" {
+			t.Errorf("case %d: bad Content-Type: got %q, want application/json", i, gct)
+		}
+		if gri := rw.Header().Get("X-Raft-Index"); gri != "100" {
+			t.Errorf("case %d: bad X-Raft-Index header: got %s, want %s", i, gri, "100")
+		}
+		if grt := rw.Header().Get("X-Raft-Term"); grt != "5" {
+			t.Errorf("case %d: bad X-Raft-Term header: got %s, want %s", i, grt, "5")
+		}
+		if gei := rw.Header().Get("X-Etcd-Index"); gei != tt.idx {
+			t.Errorf("case %d: bad X-Etcd-Index header: got %s, want %s", i, gei, tt.idx)
+		}
+		if rw.Code != tt.code {
+			t.Errorf("case %d: bad response code: got %d, want %v", i, rw.Code, tt.code)
+		}
+
+	}
+}
+
+func TestV2DeprecatedMachinesEndpoint(t *testing.T) {
+	tests := []struct {
+		method string
+		wcode  int
+	}{
+		{"GET", http.StatusOK},
+		{"HEAD", http.StatusOK},
+		{"POST", http.StatusMethodNotAllowed},
+	}
+
+	m := &deprecatedMachinesHandler{cluster: &fakeCluster{}}
+	s := httptest.NewServer(m)
+	defer s.Close()
+
+	for _, tt := range tests {
+		req, err := http.NewRequest(tt.method, s.URL+deprecatedMachinesPrefix, nil)
+		if err != nil {
+			t.Fatal(err)
+		}
+		resp, err := http.DefaultClient.Do(req)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		if resp.StatusCode != tt.wcode {
+			t.Errorf("StatusCode = %d, expected %d", resp.StatusCode, tt.wcode)
+		}
+	}
+}
+
+func TestServeMachines(t *testing.T) {
+	cluster := &fakeCluster{
+		clientURLs: []string{"http://localhost:8080", "http://localhost:8081", "http://localhost:8082"},
+	}
+	writer := httptest.NewRecorder()
+	req, err := http.NewRequest("GET", "", nil)
+	if err != nil {
+		t.Fatal(err)
+	}
+	h := &deprecatedMachinesHandler{cluster: cluster}
+	h.ServeHTTP(writer, req)
+	w := "http://localhost:8080, http://localhost:8081, http://localhost:8082"
+	if g := writer.Body.String(); g != w {
+		t.Errorf("body = %s, want %s", g, w)
+	}
+	if writer.Code != http.StatusOK {
+		t.Errorf("code = %d, want %d", writer.Code, http.StatusOK)
+	}
+}
+
+func TestGetID(t *testing.T) {
+	tests := []struct {
+		path string
+
+		wok   bool
+		wid   types.ID
+		wcode int
+	}{
+		{
+			"123",
+			true, 0x123, http.StatusOK,
+		},
+		{
+			"bad_id",
+			false, 0, http.StatusNotFound,
+		},
+		{
+			"",
+			false, 0, http.StatusMethodNotAllowed,
+		},
+	}
+
+	for i, tt := range tests {
+		w := httptest.NewRecorder()
+		id, ok := getID(tt.path, w)
+		if id != tt.wid {
+			t.Errorf("#%d: id = %d, want %d", i, id, tt.wid)
+		}
+		if ok != tt.wok {
+			t.Errorf("#%d: ok = %t, want %t", i, ok, tt.wok)
+		}
+		if w.Code != tt.wcode {
+			t.Errorf("#%d code = %d, want %d", i, w.Code, tt.wcode)
+		}
+	}
+}
+
+type dummyStats struct {
+	data []byte
+}
+
+func (ds *dummyStats) SelfStats() []byte                 { return ds.data }
+func (ds *dummyStats) LeaderStats() []byte               { return ds.data }
+func (ds *dummyStats) StoreStats() []byte                { return ds.data }
+func (ds *dummyStats) UpdateRecvApp(_ types.ID, _ int64) {}
+
+func TestServeSelfStats(t *testing.T) {
+	wb := []byte("some statistics")
+	w := string(wb)
+	sh := &statsHandler{
+		stats: &dummyStats{data: wb},
+	}
+	rw := httptest.NewRecorder()
+	sh.serveSelf(rw, &http.Request{Method: "GET"})
+	if rw.Code != http.StatusOK {
+		t.Errorf("code = %d, want %d", rw.Code, http.StatusOK)
+	}
+	wct := "application/json"
+	if gct := rw.Header().Get("Content-Type"); gct != wct {
+		t.Errorf("Content-Type = %q, want %q", gct, wct)
+	}
+	if g := rw.Body.String(); g != w {
+		t.Errorf("body = %s, want %s", g, w)
+	}
+}
+
+func TestSelfServeStatsBad(t *testing.T) {
+	for _, m := range []string{"PUT", "POST", "DELETE"} {
+		sh := &statsHandler{}
+		rw := httptest.NewRecorder()
+		sh.serveSelf(
+			rw,
+			&http.Request{
+				Method: m,
+			},
+		)
+		if rw.Code != http.StatusMethodNotAllowed {
+			t.Errorf("method %s: code=%d, want %d", m, rw.Code, http.StatusMethodNotAllowed)
+		}
+	}
+}
+
+func TestLeaderServeStatsBad(t *testing.T) {
+	for _, m := range []string{"PUT", "POST", "DELETE"} {
+		sh := &statsHandler{}
+		rw := httptest.NewRecorder()
+		sh.serveLeader(
+			rw,
+			&http.Request{
+				Method: m,
+			},
+		)
+		if rw.Code != http.StatusMethodNotAllowed {
+			t.Errorf("method %s: code=%d, want %d", m, rw.Code, http.StatusMethodNotAllowed)
+		}
+	}
+}
+
+func TestServeLeaderStats(t *testing.T) {
+	wb := []byte("some statistics")
+	w := string(wb)
+	sh := &statsHandler{
+		stats: &dummyStats{data: wb},
+	}
+	rw := httptest.NewRecorder()
+	sh.serveLeader(rw, &http.Request{Method: "GET"})
+	if rw.Code != http.StatusOK {
+		t.Errorf("code = %d, want %d", rw.Code, http.StatusOK)
+	}
+	wct := "application/json"
+	if gct := rw.Header().Get("Content-Type"); gct != wct {
+		t.Errorf("Content-Type = %q, want %q", gct, wct)
+	}
+	if g := rw.Body.String(); g != w {
+		t.Errorf("body = %s, want %s", g, w)
+	}
+}
+
+func TestServeStoreStats(t *testing.T) {
+	wb := []byte("some statistics")
+	w := string(wb)
+	sh := &statsHandler{
+		stats: &dummyStats{data: wb},
+	}
+	rw := httptest.NewRecorder()
+	sh.serveStore(rw, &http.Request{Method: "GET"})
+	if rw.Code != http.StatusOK {
+		t.Errorf("code = %d, want %d", rw.Code, http.StatusOK)
+	}
+	wct := "application/json"
+	if gct := rw.Header().Get("Content-Type"); gct != wct {
+		t.Errorf("Content-Type = %q, want %q", gct, wct)
+	}
+	if g := rw.Body.String(); g != w {
+		t.Errorf("body = %s, want %s", g, w)
+	}
+
+}
+
+func TestServeVersion(t *testing.T) {
+	req, err := http.NewRequest("GET", "", nil)
+	if err != nil {
+		t.Fatalf("error creating request: %v", err)
+	}
+	rw := httptest.NewRecorder()
+	serveVersion(rw, req, "2.1.0")
+	if rw.Code != http.StatusOK {
+		t.Errorf("code=%d, want %d", rw.Code, http.StatusOK)
+	}
+	vs := version.Versions{
+		Server:  version.Version,
+		Cluster: "2.1.0",
+	}
+	w, err := json.Marshal(&vs)
+	if err != nil {
+		t.Fatal(err)
+	}
+	if g := rw.Body.String(); g != string(w) {
+		t.Fatalf("body = %q, want %q", g, string(w))
+	}
+	if ct := rw.HeaderMap.Get("Content-Type"); ct != "application/json" {
+		t.Errorf("contet-type header = %s, want %s", ct, "application/json")
+	}
+}
+
+func TestServeVersionFails(t *testing.T) {
+	for _, m := range []string{
+		"CONNECT", "TRACE", "PUT", "POST", "HEAD",
+	} {
+		req, err := http.NewRequest(m, "", nil)
+		if err != nil {
+			t.Fatalf("error creating request: %v", err)
+		}
+		rw := httptest.NewRecorder()
+		serveVersion(rw, req, "2.1.0")
+		if rw.Code != http.StatusMethodNotAllowed {
+			t.Errorf("method %s: code=%d, want %d", m, rw.Code, http.StatusMethodNotAllowed)
+		}
+	}
+}
+
+func TestBadServeKeys(t *testing.T) {
+	testBadCases := []struct {
+		req    *http.Request
+		server etcdserver.Server
+
+		wcode int
+		wbody string
+	}{
+		{
+			// bad method
+			&http.Request{
+				Method: "CONNECT",
+			},
+			&resServer{},
+
+			http.StatusMethodNotAllowed,
+			"Method Not Allowed",
+		},
+		{
+			// bad method
+			&http.Request{
+				Method: "TRACE",
+			},
+			&resServer{},
+
+			http.StatusMethodNotAllowed,
+			"Method Not Allowed",
+		},
+		{
+			// parseRequest error
+			&http.Request{
+				Body:   nil,
+				Method: "PUT",
+			},
+			&resServer{},
+
+			http.StatusBadRequest,
+			`{"errorCode":210,"message":"Invalid POST form","cause":"missing form body","index":0}`,
+		},
+		{
+			// etcdserver.Server error
+			mustNewRequest(t, "foo"),
+			&errServer{
+				errors.New("Internal Server Error"),
+			},
+
+			http.StatusInternalServerError,
+			`{"errorCode":300,"message":"Raft Internal Error","cause":"Internal Server Error","index":0}`,
+		},
+		{
+			// etcdserver.Server etcd error
+			mustNewRequest(t, "foo"),
+			&errServer{
+				etcdErr.NewError(etcdErr.EcodeKeyNotFound, "/1/pant", 0),
+			},
+
+			http.StatusNotFound,
+			`{"errorCode":100,"message":"Key not found","cause":"/pant","index":0}`,
+		},
+		{
+			// non-event/watcher response from etcdserver.Server
+			mustNewRequest(t, "foo"),
+			&resServer{
+				etcdserver.Response{},
+			},
+
+			http.StatusInternalServerError,
+			`{"errorCode":300,"message":"Raft Internal Error","cause":"received response with no Event/Watcher!","index":0}`,
+		},
+	}
+	for i, tt := range testBadCases {
+		h := &keysHandler{
+			timeout: 0, // context times out immediately
+			server:  tt.server,
+			cluster: &fakeCluster{id: 1},
+		}
+		rw := httptest.NewRecorder()
+		h.ServeHTTP(rw, tt.req)
+		if rw.Code != tt.wcode {
+			t.Errorf("#%d: got code=%d, want %d", i, rw.Code, tt.wcode)
+		}
+		if rw.Code != http.StatusMethodNotAllowed {
+			gcid := rw.Header().Get("X-Etcd-Cluster-ID")
+			wcid := h.cluster.ID().String()
+			if gcid != wcid {
+				t.Errorf("#%d: cid = %s, want %s", i, gcid, wcid)
+			}
+		}
+		if g := strings.TrimSuffix(rw.Body.String(), "\n"); g != tt.wbody {
+			t.Errorf("#%d: body = %s, want %s", i, g, tt.wbody)
+		}
+	}
+}
+
+func TestServeKeysGood(t *testing.T) {
+	tests := []struct {
+		req   *http.Request
+		wcode int
+	}{
+		{
+			mustNewMethodRequest(t, "HEAD", "foo"),
+			http.StatusOK,
+		},
+		{
+			mustNewMethodRequest(t, "GET", "foo"),
+			http.StatusOK,
+		},
+		{
+			mustNewForm(t, "foo", url.Values{"value": []string{"bar"}}),
+			http.StatusOK,
+		},
+		{
+			mustNewMethodRequest(t, "DELETE", "foo"),
+			http.StatusOK,
+		},
+		{
+			mustNewPostForm(t, "foo", url.Values{"value": []string{"bar"}}),
+			http.StatusOK,
+		},
+	}
+	server := &resServer{
+		etcdserver.Response{
+			Event: &store.Event{
+				Action: store.Get,
+				Node:   &store.NodeExtern{},
+			},
+		},
+	}
+	for i, tt := range tests {
+		h := &keysHandler{
+			timeout: time.Hour,
+			server:  server,
+			timer:   &dummyRaftTimer{},
+			cluster: &fakeCluster{id: 1},
+		}
+		rw := httptest.NewRecorder()
+		h.ServeHTTP(rw, tt.req)
+		if rw.Code != tt.wcode {
+			t.Errorf("#%d: got code=%d, want %d", i, rw.Code, tt.wcode)
+		}
+	}
+}
+
+func TestServeKeysEvent(t *testing.T) {
+	req := mustNewRequest(t, "foo")
+	server := &resServer{
+		etcdserver.Response{
+			Event: &store.Event{
+				Action: store.Get,
+				Node:   &store.NodeExtern{},
+			},
+		},
+	}
+	h := &keysHandler{
+		timeout: time.Hour,
+		server:  server,
+		cluster: &fakeCluster{id: 1},
+		timer:   &dummyRaftTimer{},
+	}
+	rw := httptest.NewRecorder()
+
+	h.ServeHTTP(rw, req)
+
+	wcode := http.StatusOK
+	wbody := mustMarshalEvent(
+		t,
+		&store.Event{
+			Action: store.Get,
+			Node:   &store.NodeExtern{},
+		},
+	)
+
+	if rw.Code != wcode {
+		t.Errorf("got code=%d, want %d", rw.Code, wcode)
+	}
+	gcid := rw.Header().Get("X-Etcd-Cluster-ID")
+	wcid := h.cluster.ID().String()
+	if gcid != wcid {
+		t.Errorf("cid = %s, want %s", gcid, wcid)
+	}
+	g := rw.Body.String()
+	if g != wbody {
+		t.Errorf("got body=%#v, want %#v", g, wbody)
+	}
+}
+
+func TestServeKeysWatch(t *testing.T) {
+	req := mustNewRequest(t, "/foo/bar")
+	ec := make(chan *store.Event)
+	dw := &dummyWatcher{
+		echan: ec,
+	}
+	server := &resServer{
+		etcdserver.Response{
+			Watcher: dw,
+		},
+	}
+	h := &keysHandler{
+		timeout: time.Hour,
+		server:  server,
+		cluster: &fakeCluster{id: 1},
+		timer:   &dummyRaftTimer{},
+	}
+	go func() {
+		ec <- &store.Event{
+			Action: store.Get,
+			Node:   &store.NodeExtern{},
+		}
+	}()
+	rw := httptest.NewRecorder()
+
+	h.ServeHTTP(rw, req)
+
+	wcode := http.StatusOK
+	wbody := mustMarshalEvent(
+		t,
+		&store.Event{
+			Action: store.Get,
+			Node:   &store.NodeExtern{},
+		},
+	)
+
+	if rw.Code != wcode {
+		t.Errorf("got code=%d, want %d", rw.Code, wcode)
+	}
+	gcid := rw.Header().Get("X-Etcd-Cluster-ID")
+	wcid := h.cluster.ID().String()
+	if gcid != wcid {
+		t.Errorf("cid = %s, want %s", gcid, wcid)
+	}
+	g := rw.Body.String()
+	if g != wbody {
+		t.Errorf("got body=%#v, want %#v", g, wbody)
+	}
+}
+
+type recordingCloseNotifier struct {
+	*httptest.ResponseRecorder
+	cn chan bool
+}
+
+func (rcn *recordingCloseNotifier) CloseNotify() <-chan bool {
+	return rcn.cn
+}
+
+func TestHandleWatch(t *testing.T) {
+	defaultRwRr := func() (http.ResponseWriter, *httptest.ResponseRecorder) {
+		r := httptest.NewRecorder()
+		return r, r
+	}
+	noopEv := func(chan *store.Event) {}
+
+	tests := []struct {
+		getCtx   func() context.Context
+		getRwRr  func() (http.ResponseWriter, *httptest.ResponseRecorder)
+		doToChan func(chan *store.Event)
+
+		wbody string
+	}{
+		{
+			// Normal case: one event
+			context.Background,
+			defaultRwRr,
+			func(ch chan *store.Event) {
+				ch <- &store.Event{
+					Action: store.Get,
+					Node:   &store.NodeExtern{},
+				}
+			},
+
+			mustMarshalEvent(
+				t,
+				&store.Event{
+					Action: store.Get,
+					Node:   &store.NodeExtern{},
+				},
+			),
+		},
+		{
+			// Channel is closed, no event
+			context.Background,
+			defaultRwRr,
+			func(ch chan *store.Event) {
+				close(ch)
+			},
+
+			"",
+		},
+		{
+			// Simulate a timed-out context
+			func() context.Context {
+				ctx, cancel := context.WithCancel(context.Background())
+				cancel()
+				return ctx
+			},
+			defaultRwRr,
+			noopEv,
+
+			"",
+		},
+		{
+			// Close-notifying request
+			context.Background,
+			func() (http.ResponseWriter, *httptest.ResponseRecorder) {
+				rw := &recordingCloseNotifier{
+					ResponseRecorder: httptest.NewRecorder(),
+					cn:               make(chan bool, 1),
+				}
+				rw.cn <- true
+				return rw, rw.ResponseRecorder
+			},
+			noopEv,
+
+			"",
+		},
+	}
+
+	for i, tt := range tests {
+		rw, rr := tt.getRwRr()
+		wa := &dummyWatcher{
+			echan: make(chan *store.Event, 1),
+			sidx:  10,
+		}
+		tt.doToChan(wa.echan)
+
+		handleKeyWatch(tt.getCtx(), rw, wa, false, dummyRaftTimer{})
+
+		wcode := http.StatusOK
+		wct := "application/json"
+		wei := "10"
+		wri := "100"
+		wrt := "5"
+
+		if rr.Code != wcode {
+			t.Errorf("#%d: got code=%d, want %d", i, rr.Code, wcode)
+		}
+		h := rr.Header()
+		if ct := h.Get("Content-Type"); ct != wct {
+			t.Errorf("#%d: Content-Type=%q, want %q", i, ct, wct)
+		}
+		if ei := h.Get("X-Etcd-Index"); ei != wei {
+			t.Errorf("#%d: X-Etcd-Index=%q, want %q", i, ei, wei)
+		}
+		if ri := h.Get("X-Raft-Index"); ri != wri {
+			t.Errorf("#%d: X-Raft-Index=%q, want %q", i, ri, wri)
+		}
+		if rt := h.Get("X-Raft-Term"); rt != wrt {
+			t.Errorf("#%d: X-Raft-Term=%q, want %q", i, rt, wrt)
+		}
+		g := rr.Body.String()
+		if g != tt.wbody {
+			t.Errorf("#%d: got body=%#v, want %#v", i, g, tt.wbody)
+		}
+	}
+}
+
+func TestHandleWatchStreaming(t *testing.T) {
+	rw := &flushingRecorder{
+		httptest.NewRecorder(),
+		make(chan struct{}, 1),
+	}
+	wa := &dummyWatcher{
+		echan: make(chan *store.Event),
+	}
+
+	// Launch the streaming handler in the background with a cancellable context
+	ctx, cancel := context.WithCancel(context.Background())
+	done := make(chan struct{})
+	go func() {
+		handleKeyWatch(ctx, rw, wa, true, dummyRaftTimer{})
+		close(done)
+	}()
+
+	// Expect one Flush for the headers etc.
+	select {
+	case <-rw.ch:
+	case <-time.After(time.Second):
+		t.Fatalf("timed out waiting for flush")
+	}
+
+	// Expect headers but no body
+	wcode := http.StatusOK
+	wct := "application/json"
+	wbody := ""
+
+	if rw.Code != wcode {
+		t.Errorf("got code=%d, want %d", rw.Code, wcode)
+	}
+	h := rw.Header()
+	if ct := h.Get("Content-Type"); ct != wct {
+		t.Errorf("Content-Type=%q, want %q", ct, wct)
+	}
+	g := rw.Body.String()
+	if g != wbody {
+		t.Errorf("got body=%#v, want %#v", g, wbody)
+	}
+
+	// Now send the first event
+	select {
+	case wa.echan <- &store.Event{
+		Action: store.Get,
+		Node:   &store.NodeExtern{},
+	}:
+	case <-time.After(time.Second):
+		t.Fatal("timed out waiting for send")
+	}
+
+	// Wait for it to be flushed...
+	select {
+	case <-rw.ch:
+	case <-time.After(time.Second):
+		t.Fatalf("timed out waiting for flush")
+	}
+
+	// And check the body is as expected
+	wbody = mustMarshalEvent(
+		t,
+		&store.Event{
+			Action: store.Get,
+			Node:   &store.NodeExtern{},
+		},
+	)
+	g = rw.Body.String()
+	if g != wbody {
+		t.Errorf("got body=%#v, want %#v", g, wbody)
+	}
+
+	// Rinse and repeat
+	select {
+	case wa.echan <- &store.Event{
+		Action: store.Get,
+		Node:   &store.NodeExtern{},
+	}:
+	case <-time.After(time.Second):
+		t.Fatal("timed out waiting for send")
+	}
+
+	select {
+	case <-rw.ch:
+	case <-time.After(time.Second):
+		t.Fatalf("timed out waiting for flush")
+	}
+
+	// This time, we expect to see both events
+	wbody = wbody + wbody
+	g = rw.Body.String()
+	if g != wbody {
+		t.Errorf("got body=%#v, want %#v", g, wbody)
+	}
+
+	// Finally, time out the connection and ensure the serving goroutine returns
+	cancel()
+
+	select {
+	case <-done:
+	case <-time.After(time.Second):
+		t.Fatalf("timed out waiting for done")
+	}
+}
+
+func TestTrimEventPrefix(t *testing.T) {
+	pre := "/abc"
+	tests := []struct {
+		ev  *store.Event
+		wev *store.Event
+	}{
+		{
+			nil,
+			nil,
+		},
+		{
+			&store.Event{},
+			&store.Event{},
+		},
+		{
+			&store.Event{Node: &store.NodeExtern{Key: "/abc/def"}},
+			&store.Event{Node: &store.NodeExtern{Key: "/def"}},
+		},
+		{
+			&store.Event{PrevNode: &store.NodeExtern{Key: "/abc/ghi"}},
+			&store.Event{PrevNode: &store.NodeExtern{Key: "/ghi"}},
+		},
+		{
+			&store.Event{
+				Node:     &store.NodeExtern{Key: "/abc/def"},
+				PrevNode: &store.NodeExtern{Key: "/abc/ghi"},
+			},
+			&store.Event{
+				Node:     &store.NodeExtern{Key: "/def"},
+				PrevNode: &store.NodeExtern{Key: "/ghi"},
+			},
+		},
+	}
+	for i, tt := range tests {
+		ev := trimEventPrefix(tt.ev, pre)
+		if !reflect.DeepEqual(ev, tt.wev) {
+			t.Errorf("#%d: event = %+v, want %+v", i, ev, tt.wev)
+		}
+	}
+}
+
+func TestTrimNodeExternPrefix(t *testing.T) {
+	pre := "/abc"
+	tests := []struct {
+		n  *store.NodeExtern
+		wn *store.NodeExtern
+	}{
+		{
+			nil,
+			nil,
+		},
+		{
+			&store.NodeExtern{Key: "/abc/def"},
+			&store.NodeExtern{Key: "/def"},
+		},
+		{
+			&store.NodeExtern{
+				Key: "/abc/def",
+				Nodes: []*store.NodeExtern{
+					{Key: "/abc/def/1"},
+					{Key: "/abc/def/2"},
+				},
+			},
+			&store.NodeExtern{
+				Key: "/def",
+				Nodes: []*store.NodeExtern{
+					{Key: "/def/1"},
+					{Key: "/def/2"},
+				},
+			},
+		},
+	}
+	for i, tt := range tests {
+		n := trimNodeExternPrefix(tt.n, pre)
+		if !reflect.DeepEqual(n, tt.wn) {
+			t.Errorf("#%d: node = %+v, want %+v", i, n, tt.wn)
+		}
+	}
+}
+
+func TestTrimPrefix(t *testing.T) {
+	tests := []struct {
+		in     string
+		prefix string
+		w      string
+	}{
+		{"/v2/members", "/v2/members", ""},
+		{"/v2/members/", "/v2/members", ""},
+		{"/v2/members/foo", "/v2/members", "foo"},
+	}
+	for i, tt := range tests {
+		if g := trimPrefix(tt.in, tt.prefix); g != tt.w {
+			t.Errorf("#%d: trimPrefix = %q, want %q", i, g, tt.w)
+		}
+	}
+}
+
+func TestNewMemberCollection(t *testing.T) {
+	fixture := []*etcdserver.Member{
+		{
+			ID:             12,
+			Attributes:     etcdserver.Attributes{ClientURLs: []string{"http://localhost:8080", "http://localhost:8081"}},
+			RaftAttributes: etcdserver.RaftAttributes{PeerURLs: []string{"http://localhost:8082", "http://localhost:8083"}},
+		},
+		{
+			ID:             13,
+			Attributes:     etcdserver.Attributes{ClientURLs: []string{"http://localhost:9090", "http://localhost:9091"}},
+			RaftAttributes: etcdserver.RaftAttributes{PeerURLs: []string{"http://localhost:9092", "http://localhost:9093"}},
+		},
+	}
+	got := newMemberCollection(fixture)
+
+	want := httptypes.MemberCollection([]httptypes.Member{
+		{
+			ID:         "c",
+			ClientURLs: []string{"http://localhost:8080", "http://localhost:8081"},
+			PeerURLs:   []string{"http://localhost:8082", "http://localhost:8083"},
+		},
+		{
+			ID:         "d",
+			ClientURLs: []string{"http://localhost:9090", "http://localhost:9091"},
+			PeerURLs:   []string{"http://localhost:9092", "http://localhost:9093"},
+		},
+	})
+
+	if !reflect.DeepEqual(&want, got) {
+		t.Fatalf("newMemberCollection failure: want=%#v, got=%#v", &want, got)
+	}
+}
+
+func TestNewMember(t *testing.T) {
+	fixture := &etcdserver.Member{
+		ID:             12,
+		Attributes:     etcdserver.Attributes{ClientURLs: []string{"http://localhost:8080", "http://localhost:8081"}},
+		RaftAttributes: etcdserver.RaftAttributes{PeerURLs: []string{"http://localhost:8082", "http://localhost:8083"}},
+	}
+	got := newMember(fixture)
+
+	want := httptypes.Member{
+		ID:         "c",
+		ClientURLs: []string{"http://localhost:8080", "http://localhost:8081"},
+		PeerURLs:   []string{"http://localhost:8082", "http://localhost:8083"},
+	}
+
+	if !reflect.DeepEqual(want, got) {
+		t.Fatalf("newMember failure: want=%#v, got=%#v", want, got)
+	}
+}
diff --git a/etcdserver/api/v2http/doc.go b/etcdserver/api/v2http/doc.go
new file mode 100644
index 0000000..3b306ef
--- /dev/null
+++ b/etcdserver/api/v2http/doc.go
@@ -0,0 +1,16 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package v2http provides etcd client and server implementations.
+package v2http
diff --git a/etcdserver/api/v2http/http.go b/etcdserver/api/v2http/http.go
new file mode 100644
index 0000000..1fd3883
--- /dev/null
+++ b/etcdserver/api/v2http/http.go
@@ -0,0 +1,95 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2http
+
+import (
+	"errors"
+	"math"
+	"net/http"
+	"strings"
+	"time"
+
+	etcdErr "github.com/coreos/etcd/error"
+	"github.com/coreos/etcd/etcdserver"
+	"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
+	"github.com/coreos/etcd/etcdserver/auth"
+	"github.com/coreos/etcd/pkg/logutil"
+	"github.com/coreos/pkg/capnslog"
+)
+
+const (
+	// time to wait for a Watch request
+	defaultWatchTimeout = time.Duration(math.MaxInt64)
+)
+
+var (
+	plog      = capnslog.NewPackageLogger("github.com/coreos/etcd/etcdserver/api", "v2http")
+	mlog      = logutil.NewMergeLogger(plog)
+	errClosed = errors.New("v2http: client closed connection")
+)
+
+// writeError logs and writes the given Error to the ResponseWriter
+// If Error is an etcdErr, it is rendered to the ResponseWriter
+// Otherwise, it is assumed to be a StatusInternalServerError
+func writeError(w http.ResponseWriter, r *http.Request, err error) {
+	if err == nil {
+		return
+	}
+	switch e := err.(type) {
+	case *etcdErr.Error:
+		e.WriteTo(w)
+	case *httptypes.HTTPError:
+		if et := e.WriteTo(w); et != nil {
+			plog.Debugf("error writing HTTPError (%v) to %s", et, r.RemoteAddr)
+		}
+	case auth.Error:
+		herr := httptypes.NewHTTPError(e.HTTPStatus(), e.Error())
+		if et := herr.WriteTo(w); et != nil {
+			plog.Debugf("error writing HTTPError (%v) to %s", et, r.RemoteAddr)
+		}
+	default:
+		switch err {
+		case etcdserver.ErrTimeoutDueToLeaderFail, etcdserver.ErrTimeoutDueToConnectionLost, etcdserver.ErrNotEnoughStartedMembers:
+			mlog.MergeError(err)
+		default:
+			mlog.MergeErrorf("got unexpected response error (%v)", err)
+		}
+		herr := httptypes.NewHTTPError(http.StatusInternalServerError, "Internal Server Error")
+		if et := herr.WriteTo(w); et != nil {
+			plog.Debugf("error writing HTTPError (%v) to %s", et, r.RemoteAddr)
+		}
+	}
+}
+
+// allowMethod verifies that the given method is one of the allowed methods,
+// and if not, it writes an error to w.  A boolean is returned indicating
+// whether or not the method is allowed.
+func allowMethod(w http.ResponseWriter, m string, ms ...string) bool {
+	for _, meth := range ms {
+		if m == meth {
+			return true
+		}
+	}
+	w.Header().Set("Allow", strings.Join(ms, ","))
+	http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
+	return false
+}
+
+func requestLogger(handler http.Handler) http.Handler {
+	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		plog.Debugf("[%s] %s remote:%s", r.Method, r.RequestURI, r.RemoteAddr)
+		handler.ServeHTTP(w, r)
+	})
+}
diff --git a/etcdserver/api/v2http/http_test.go b/etcdserver/api/v2http/http_test.go
new file mode 100644
index 0000000..21715e6
--- /dev/null
+++ b/etcdserver/api/v2http/http_test.go
@@ -0,0 +1,192 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2http
+
+import (
+	"errors"
+	"net/http"
+	"net/http/httptest"
+	"sort"
+	"testing"
+
+	etcdErr "github.com/coreos/etcd/error"
+	"github.com/coreos/etcd/etcdserver"
+	"github.com/coreos/etcd/etcdserver/etcdserverpb"
+	"github.com/coreos/etcd/pkg/types"
+	"github.com/coreos/etcd/raft/raftpb"
+	"github.com/coreos/go-semver/semver"
+	"golang.org/x/net/context"
+)
+
+type fakeCluster struct {
+	id         uint64
+	clientURLs []string
+	members    map[uint64]*etcdserver.Member
+}
+
+func (c *fakeCluster) ID() types.ID         { return types.ID(c.id) }
+func (c *fakeCluster) ClientURLs() []string { return c.clientURLs }
+func (c *fakeCluster) Members() []*etcdserver.Member {
+	var ms etcdserver.MembersByID
+	for _, m := range c.members {
+		ms = append(ms, m)
+	}
+	sort.Sort(ms)
+	return []*etcdserver.Member(ms)
+}
+func (c *fakeCluster) Member(id types.ID) *etcdserver.Member { return c.members[uint64(id)] }
+func (c *fakeCluster) IsIDRemoved(id types.ID) bool          { return false }
+func (c *fakeCluster) Version() *semver.Version              { return nil }
+
+// errServer implements the etcd.Server interface for testing.
+// It returns the given error from any Do/Process/AddMember/RemoveMember calls.
+type errServer struct {
+	err error
+}
+
+func (fs *errServer) Start()           {}
+func (fs *errServer) Stop()            {}
+func (fs *errServer) ID() types.ID     { return types.ID(1) }
+func (fs *errServer) Leader() types.ID { return types.ID(1) }
+func (fs *errServer) Do(ctx context.Context, r etcdserverpb.Request) (etcdserver.Response, error) {
+	return etcdserver.Response{}, fs.err
+}
+func (fs *errServer) Process(ctx context.Context, m raftpb.Message) error {
+	return fs.err
+}
+func (fs *errServer) AddMember(ctx context.Context, m etcdserver.Member) error {
+	return fs.err
+}
+func (fs *errServer) RemoveMember(ctx context.Context, id uint64) error {
+	return fs.err
+}
+func (fs *errServer) UpdateMember(ctx context.Context, m etcdserver.Member) error {
+	return fs.err
+}
+
+func (fs *errServer) ClusterVersion() *semver.Version { return nil }
+
+func TestWriteError(t *testing.T) {
+	// nil error should not panic
+	rec := httptest.NewRecorder()
+	r := new(http.Request)
+	writeError(rec, r, nil)
+	h := rec.Header()
+	if len(h) > 0 {
+		t.Fatalf("unexpected non-empty headers: %#v", h)
+	}
+	b := rec.Body.String()
+	if len(b) > 0 {
+		t.Fatalf("unexpected non-empty body: %q", b)
+	}
+
+	tests := []struct {
+		err   error
+		wcode int
+		wi    string
+	}{
+		{
+			etcdErr.NewError(etcdErr.EcodeKeyNotFound, "/foo/bar", 123),
+			http.StatusNotFound,
+			"123",
+		},
+		{
+			etcdErr.NewError(etcdErr.EcodeTestFailed, "/foo/bar", 456),
+			http.StatusPreconditionFailed,
+			"456",
+		},
+		{
+			err:   errors.New("something went wrong"),
+			wcode: http.StatusInternalServerError,
+		},
+	}
+
+	for i, tt := range tests {
+		rw := httptest.NewRecorder()
+		writeError(rw, r, tt.err)
+		if code := rw.Code; code != tt.wcode {
+			t.Errorf("#%d: code=%d, want %d", i, code, tt.wcode)
+		}
+		if idx := rw.Header().Get("X-Etcd-Index"); idx != tt.wi {
+			t.Errorf("#%d: X-Etcd-Index=%q, want %q", i, idx, tt.wi)
+		}
+	}
+}
+
+func TestAllowMethod(t *testing.T) {
+	tests := []struct {
+		m  string
+		ms []string
+		w  bool
+		wh string
+	}{
+		// Accepted methods
+		{
+			m:  "GET",
+			ms: []string{"GET", "POST", "PUT"},
+			w:  true,
+		},
+		{
+			m:  "POST",
+			ms: []string{"POST"},
+			w:  true,
+		},
+		// Made-up methods no good
+		{
+			m:  "FAKE",
+			ms: []string{"GET", "POST", "PUT"},
+			w:  false,
+			wh: "GET,POST,PUT",
+		},
+		// Empty methods no good
+		{
+			m:  "",
+			ms: []string{"GET", "POST"},
+			w:  false,
+			wh: "GET,POST",
+		},
+		// Empty accepted methods no good
+		{
+			m:  "GET",
+			ms: []string{""},
+			w:  false,
+			wh: "",
+		},
+		// No methods accepted
+		{
+			m:  "GET",
+			ms: []string{},
+			w:  false,
+			wh: "",
+		},
+	}
+
+	for i, tt := range tests {
+		rw := httptest.NewRecorder()
+		g := allowMethod(rw, tt.m, tt.ms...)
+		if g != tt.w {
+			t.Errorf("#%d: got allowMethod()=%t, want %t", i, g, tt.w)
+		}
+		if !tt.w {
+			if rw.Code != http.StatusMethodNotAllowed {
+				t.Errorf("#%d: code=%d, want %d", i, rw.Code, http.StatusMethodNotAllowed)
+			}
+			gh := rw.Header().Get("Allow")
+			if gh != tt.wh {
+				t.Errorf("#%d: Allow header=%q, want %q", i, gh, tt.wh)
+			}
+		}
+	}
+}
diff --git a/etcdserver/api/v2http/httptypes/errors.go b/etcdserver/api/v2http/httptypes/errors.go
new file mode 100644
index 0000000..396dc59
--- /dev/null
+++ b/etcdserver/api/v2http/httptypes/errors.go
@@ -0,0 +1,56 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package httptypes
+
+import (
+	"encoding/json"
+	"net/http"
+
+	"github.com/coreos/pkg/capnslog"
+)
+
+var (
+	plog = capnslog.NewPackageLogger("github.com/coreos/etcd/etcdserver/api/v2http", "httptypes")
+)
+
+type HTTPError struct {
+	Message string `json:"message"`
+	// Code is the HTTP status code
+	Code int `json:"-"`
+}
+
+func (e HTTPError) Error() string {
+	return e.Message
+}
+
+func (e HTTPError) WriteTo(w http.ResponseWriter) error {
+	w.Header().Set("Content-Type", "application/json")
+	w.WriteHeader(e.Code)
+	b, err := json.Marshal(e)
+	if err != nil {
+		plog.Panicf("marshal HTTPError should never fail (%v)", err)
+	}
+	if _, err := w.Write(b); err != nil {
+		return err
+	}
+	return nil
+}
+
+func NewHTTPError(code int, m string) *HTTPError {
+	return &HTTPError{
+		Message: m,
+		Code:    code,
+	}
+}
diff --git a/etcdserver/api/v2http/httptypes/errors_test.go b/etcdserver/api/v2http/httptypes/errors_test.go
new file mode 100644
index 0000000..6ef1b3e
--- /dev/null
+++ b/etcdserver/api/v2http/httptypes/errors_test.go
@@ -0,0 +1,49 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package httptypes
+
+import (
+	"net/http"
+	"net/http/httptest"
+	"reflect"
+	"testing"
+)
+
+func TestHTTPErrorWriteTo(t *testing.T) {
+	err := NewHTTPError(http.StatusBadRequest, "what a bad request you made!")
+	rr := httptest.NewRecorder()
+	if e := err.WriteTo(rr); e != nil {
+		t.Fatalf("HTTPError.WriteTo error (%v)", e)
+	}
+
+	wcode := http.StatusBadRequest
+	wheader := http.Header(map[string][]string{
+		"Content-Type": {"application/json"},
+	})
+	wbody := `{"message":"what a bad request you made!"}`
+
+	if wcode != rr.Code {
+		t.Errorf("HTTP status code %d, want %d", rr.Code, wcode)
+	}
+
+	if !reflect.DeepEqual(wheader, rr.HeaderMap) {
+		t.Errorf("HTTP headers %v, want %v", rr.HeaderMap, wheader)
+	}
+
+	gbody := rr.Body.String()
+	if wbody != gbody {
+		t.Errorf("HTTP body %q, want %q", gbody, wbody)
+	}
+}
diff --git a/etcdserver/api/v2http/httptypes/member.go b/etcdserver/api/v2http/httptypes/member.go
new file mode 100644
index 0000000..432f73a
--- /dev/null
+++ b/etcdserver/api/v2http/httptypes/member.go
@@ -0,0 +1,69 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package httptypes defines how etcd's HTTP API entities are serialized to and
+// deserialized from JSON.
+package httptypes
+
+import (
+	"encoding/json"
+
+	"github.com/coreos/etcd/pkg/types"
+)
+
+type Member struct {
+	ID         string   `json:"id"`
+	Name       string   `json:"name"`
+	PeerURLs   []string `json:"peerURLs"`
+	ClientURLs []string `json:"clientURLs"`
+}
+
+type MemberCreateRequest struct {
+	PeerURLs types.URLs
+}
+
+type MemberUpdateRequest struct {
+	MemberCreateRequest
+}
+
+func (m *MemberCreateRequest) UnmarshalJSON(data []byte) error {
+	s := struct {
+		PeerURLs []string `json:"peerURLs"`
+	}{}
+
+	err := json.Unmarshal(data, &s)
+	if err != nil {
+		return err
+	}
+
+	urls, err := types.NewURLs(s.PeerURLs)
+	if err != nil {
+		return err
+	}
+
+	m.PeerURLs = urls
+	return nil
+}
+
+type MemberCollection []Member
+
+func (c *MemberCollection) MarshalJSON() ([]byte, error) {
+	d := struct {
+		Members []Member `json:"members"`
+	}{
+		Members: []Member(*c),
+	}
+
+	return json.Marshal(d)
+}
diff --git a/etcdserver/api/v2http/httptypes/member_test.go b/etcdserver/api/v2http/httptypes/member_test.go
new file mode 100644
index 0000000..4ea4320
--- /dev/null
+++ b/etcdserver/api/v2http/httptypes/member_test.go
@@ -0,0 +1,135 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package httptypes
+
+import (
+	"encoding/json"
+	"net/url"
+	"reflect"
+	"testing"
+
+	"github.com/coreos/etcd/pkg/types"
+)
+
+func TestMemberUnmarshal(t *testing.T) {
+	tests := []struct {
+		body       []byte
+		wantMember Member
+		wantError  bool
+	}{
+		// no URLs, just check ID & Name
+		{
+			body:       []byte(`{"id": "c", "name": "dungarees"}`),
+			wantMember: Member{ID: "c", Name: "dungarees", PeerURLs: nil, ClientURLs: nil},
+		},
+
+		// both client and peer URLs
+		{
+			body: []byte(`{"peerURLs": ["http://127.0.0.1:2379"], "clientURLs": ["http://127.0.0.1:2379"]}`),
+			wantMember: Member{
+				PeerURLs: []string{
+					"http://127.0.0.1:2379",
+				},
+				ClientURLs: []string{
+					"http://127.0.0.1:2379",
+				},
+			},
+		},
+
+		// multiple peer URLs
+		{
+			body: []byte(`{"peerURLs": ["http://127.0.0.1:2379", "https://example.com"]}`),
+			wantMember: Member{
+				PeerURLs: []string{
+					"http://127.0.0.1:2379",
+					"https://example.com",
+				},
+				ClientURLs: nil,
+			},
+		},
+
+		// multiple client URLs
+		{
+			body: []byte(`{"clientURLs": ["http://127.0.0.1:2379", "https://example.com"]}`),
+			wantMember: Member{
+				PeerURLs: nil,
+				ClientURLs: []string{
+					"http://127.0.0.1:2379",
+					"https://example.com",
+				},
+			},
+		},
+
+		// invalid JSON
+		{
+			body:      []byte(`{"peerU`),
+			wantError: true,
+		},
+	}
+
+	for i, tt := range tests {
+		got := Member{}
+		err := json.Unmarshal(tt.body, &got)
+		if tt.wantError != (err != nil) {
+			t.Errorf("#%d: want error %t, got %v", i, tt.wantError, err)
+			continue
+		}
+
+		if !reflect.DeepEqual(tt.wantMember, got) {
+			t.Errorf("#%d: incorrect output: want=%#v, got=%#v", i, tt.wantMember, got)
+		}
+	}
+}
+
+func TestMemberCreateRequestUnmarshal(t *testing.T) {
+	body := []byte(`{"peerURLs": ["http://127.0.0.1:8081", "https://127.0.0.1:8080"]}`)
+	want := MemberCreateRequest{
+		PeerURLs: types.URLs([]url.URL{
+			{Scheme: "http", Host: "127.0.0.1:8081"},
+			{Scheme: "https", Host: "127.0.0.1:8080"},
+		}),
+	}
+
+	var req MemberCreateRequest
+	if err := json.Unmarshal(body, &req); err != nil {
+		t.Fatalf("Unmarshal returned unexpected err=%v", err)
+	}
+
+	if !reflect.DeepEqual(want, req) {
+		t.Fatalf("Failed to unmarshal MemberCreateRequest: want=%#v, got=%#v", want, req)
+	}
+}
+
+func TestMemberCreateRequestUnmarshalFail(t *testing.T) {
+	tests := [][]byte{
+		// invalid JSON
+		[]byte(``),
+		[]byte(`{`),
+
+		// spot-check validation done in types.NewURLs
+		[]byte(`{"peerURLs": "foo"}`),
+		[]byte(`{"peerURLs": ["."]}`),
+		[]byte(`{"peerURLs": []}`),
+		[]byte(`{"peerURLs": ["http://127.0.0.1:2379/foo"]}`),
+		[]byte(`{"peerURLs": ["http://127.0.0.1"]}`),
+	}
+
+	for i, tt := range tests {
+		var req MemberCreateRequest
+		if err := json.Unmarshal(tt, &req); err == nil {
+			t.Errorf("#%d: expected err, got nil", i)
+		}
+	}
+}
diff --git a/etcdserver/api/v2http/metrics.go b/etcdserver/api/v2http/metrics.go
new file mode 100644
index 0000000..c6b4a53
--- /dev/null
+++ b/etcdserver/api/v2http/metrics.go
@@ -0,0 +1,96 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2http
+
+import (
+	"strconv"
+	"time"
+
+	"net/http"
+
+	etcdErr "github.com/coreos/etcd/error"
+	"github.com/coreos/etcd/etcdserver"
+	"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
+	"github.com/coreos/etcd/etcdserver/etcdserverpb"
+	"github.com/prometheus/client_golang/prometheus"
+)
+
+var (
+	incomingEvents = prometheus.NewCounterVec(
+		prometheus.CounterOpts{
+			Namespace: "etcd",
+			Subsystem: "http",
+			Name:      "received_total",
+			Help:      "Counter of requests received into the system (successfully parsed and authd).",
+		}, []string{"method"})
+
+	failedEvents = prometheus.NewCounterVec(
+		prometheus.CounterOpts{
+			Namespace: "etcd",
+			Subsystem: "http",
+			Name:      "failed_total",
+			Help:      "Counter of handle failures of requests (non-watches), by method (GET/PUT etc.) and code (400, 500 etc.).",
+		}, []string{"method", "code"})
+
+	successfulEventsHandlingTime = prometheus.NewHistogramVec(
+		prometheus.HistogramOpts{
+			Namespace: "etcd",
+			Subsystem: "http",
+			Name:      "successful_duration_second",
+			Help:      "Bucketed histogram of processing time (s) of successfully handled requests (non-watches), by method (GET/PUT etc.).",
+			Buckets:   prometheus.ExponentialBuckets(0.0005, 2, 13),
+		}, []string{"method"})
+)
+
+func init() {
+	prometheus.MustRegister(incomingEvents)
+	prometheus.MustRegister(failedEvents)
+	prometheus.MustRegister(successfulEventsHandlingTime)
+}
+
+func reportRequestReceived(request etcdserverpb.Request) {
+	incomingEvents.WithLabelValues(methodFromRequest(request)).Inc()
+}
+
+func reportRequestCompleted(request etcdserverpb.Request, response etcdserver.Response, startTime time.Time) {
+	method := methodFromRequest(request)
+	successfulEventsHandlingTime.WithLabelValues(method).Observe(time.Since(startTime).Seconds())
+}
+
+func reportRequestFailed(request etcdserverpb.Request, err error) {
+	method := methodFromRequest(request)
+	failedEvents.WithLabelValues(method, strconv.Itoa(codeFromError(err))).Inc()
+}
+
+func methodFromRequest(request etcdserverpb.Request) string {
+	if request.Method == "GET" && request.Quorum {
+		return "QGET"
+	}
+	return request.Method
+}
+
+func codeFromError(err error) int {
+	if err == nil {
+		return http.StatusInternalServerError
+	}
+	switch e := err.(type) {
+	case *etcdErr.Error:
+		return (*etcdErr.Error)(e).StatusCode()
+	case *httptypes.HTTPError:
+		return (*httptypes.HTTPError)(e).Code
+	default:
+		return http.StatusInternalServerError
+	}
+}
diff --git a/etcdserver/api/v2http/peer.go b/etcdserver/api/v2http/peer.go
new file mode 100644
index 0000000..6fd0708
--- /dev/null
+++ b/etcdserver/api/v2http/peer.go
@@ -0,0 +1,76 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2http
+
+import (
+	"encoding/json"
+	"net/http"
+
+	"github.com/coreos/etcd/etcdserver"
+	"github.com/coreos/etcd/lease/leasehttp"
+	"github.com/coreos/etcd/rafthttp"
+)
+
+const (
+	peerMembersPrefix = "/members"
+	leasesPrefix      = "/leases"
+)
+
+// NewPeerHandler generates an http.Handler to handle etcd peer requests.
+func NewPeerHandler(s *etcdserver.EtcdServer) http.Handler {
+	var lh http.Handler
+	if l := s.Lessor(); l != nil {
+		lh = leasehttp.NewHandler(l)
+	}
+	return newPeerHandler(s.Cluster(), s.RaftHandler(), lh)
+}
+
+func newPeerHandler(cluster etcdserver.Cluster, raftHandler http.Handler, leaseHandler http.Handler) http.Handler {
+	mh := &peerMembersHandler{
+		cluster: cluster,
+	}
+
+	mux := http.NewServeMux()
+	mux.HandleFunc("/", http.NotFound)
+	mux.Handle(rafthttp.RaftPrefix, raftHandler)
+	mux.Handle(rafthttp.RaftPrefix+"/", raftHandler)
+	mux.Handle(peerMembersPrefix, mh)
+	if leaseHandler != nil {
+		mux.Handle(leasesPrefix, leaseHandler)
+	}
+	mux.HandleFunc(versionPath, versionHandler(cluster, serveVersion))
+	return mux
+}
+
+type peerMembersHandler struct {
+	cluster etcdserver.Cluster
+}
+
+func (h *peerMembersHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+	if !allowMethod(w, r.Method, "GET") {
+		return
+	}
+	w.Header().Set("X-Etcd-Cluster-ID", h.cluster.ID().String())
+
+	if r.URL.Path != peerMembersPrefix {
+		http.Error(w, "bad path", http.StatusBadRequest)
+		return
+	}
+	ms := h.cluster.Members()
+	w.Header().Set("Content-Type", "application/json")
+	if err := json.NewEncoder(w).Encode(ms); err != nil {
+		plog.Warningf("failed to encode members response (%v)", err)
+	}
+}
diff --git a/etcdserver/api/v2http/peer_test.go b/etcdserver/api/v2http/peer_test.go
new file mode 100644
index 0000000..874f283
--- /dev/null
+++ b/etcdserver/api/v2http/peer_test.go
@@ -0,0 +1,134 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2http
+
+import (
+	"encoding/json"
+	"io/ioutil"
+	"net/http"
+	"net/http/httptest"
+	"path"
+	"testing"
+
+	"github.com/coreos/etcd/etcdserver"
+	"github.com/coreos/etcd/pkg/testutil"
+	"github.com/coreos/etcd/rafthttp"
+)
+
+// TestNewPeerHandlerOnRaftPrefix tests that NewPeerHandler returns a handler that
+// handles raft-prefix requests well.
+func TestNewPeerHandlerOnRaftPrefix(t *testing.T) {
+	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		w.Write([]byte("test data"))
+	})
+	ph := newPeerHandler(&fakeCluster{}, h, nil)
+	srv := httptest.NewServer(ph)
+	defer srv.Close()
+
+	tests := []string{
+		rafthttp.RaftPrefix,
+		rafthttp.RaftPrefix + "/hello",
+	}
+	for i, tt := range tests {
+		resp, err := http.Get(srv.URL + tt)
+		if err != nil {
+			t.Fatalf("unexpected http.Get error: %v", err)
+		}
+		body, err := ioutil.ReadAll(resp.Body)
+		if err != nil {
+			t.Fatalf("unexpected ioutil.ReadAll error: %v", err)
+		}
+		if w := "test data"; string(body) != w {
+			t.Errorf("#%d: body = %s, want %s", i, body, w)
+		}
+	}
+}
+
+func TestServeMembersFails(t *testing.T) {
+	tests := []struct {
+		method string
+		wcode  int
+	}{
+		{
+			"POST",
+			http.StatusMethodNotAllowed,
+		},
+		{
+			"DELETE",
+			http.StatusMethodNotAllowed,
+		},
+		{
+			"BAD",
+			http.StatusMethodNotAllowed,
+		},
+	}
+	for i, tt := range tests {
+		rw := httptest.NewRecorder()
+		h := &peerMembersHandler{cluster: nil}
+		h.ServeHTTP(rw, &http.Request{Method: tt.method})
+		if rw.Code != tt.wcode {
+			t.Errorf("#%d: code=%d, want %d", i, rw.Code, tt.wcode)
+		}
+	}
+}
+
+func TestServeMembersGet(t *testing.T) {
+	memb1 := etcdserver.Member{ID: 1, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8080"}}}
+	memb2 := etcdserver.Member{ID: 2, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8081"}}}
+	cluster := &fakeCluster{
+		id:      1,
+		members: map[uint64]*etcdserver.Member{1: &memb1, 2: &memb2},
+	}
+	h := &peerMembersHandler{cluster: cluster}
+	msb, err := json.Marshal([]etcdserver.Member{memb1, memb2})
+	if err != nil {
+		t.Fatal(err)
+	}
+	wms := string(msb) + "\n"
+
+	tests := []struct {
+		path  string
+		wcode int
+		wct   string
+		wbody string
+	}{
+		{peerMembersPrefix, http.StatusOK, "application/json", wms},
+		{path.Join(peerMembersPrefix, "bad"), http.StatusBadRequest, "text/plain; charset=utf-8", "bad path\n"},
+	}
+
+	for i, tt := range tests {
+		req, err := http.NewRequest("GET", testutil.MustNewURL(t, tt.path).String(), nil)
+		if err != nil {
+			t.Fatal(err)
+		}
+		rw := httptest.NewRecorder()
+		h.ServeHTTP(rw, req)
+
+		if rw.Code != tt.wcode {
+			t.Errorf("#%d: code=%d, want %d", i, rw.Code, tt.wcode)
+		}
+		if gct := rw.Header().Get("Content-Type"); gct != tt.wct {
+			t.Errorf("#%d: content-type = %s, want %s", i, gct, tt.wct)
+		}
+		if rw.Body.String() != tt.wbody {
+			t.Errorf("#%d: body = %s, want %s", i, rw.Body.String(), tt.wbody)
+		}
+		gcid := rw.Header().Get("X-Etcd-Cluster-ID")
+		wcid := cluster.ID().String()
+		if gcid != wcid {
+			t.Errorf("#%d: cid = %s, want %s", i, gcid, wcid)
+		}
+	}
+}
diff --git a/etcdserver/etcdhttp/capability.go b/etcdserver/etcdhttp/capability.go
deleted file mode 100644
index cc99cf7..0000000
--- a/etcdserver/etcdhttp/capability.go
+++ /dev/null
@@ -1,100 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package etcdhttp
-
-import (
-	"fmt"
-	"net/http"
-	"sync"
-	"time"
-
-	"github.com/coreos/etcd/etcdserver"
-	"github.com/coreos/etcd/etcdserver/etcdhttp/httptypes"
-	"github.com/coreos/go-semver/semver"
-)
-
-type capability string
-
-const (
-	authCapability capability = "auth"
-)
-
-var (
-	// capabilityMaps is a static map of version to capability map.
-	// the base capabilities is the set of capability 2.0 supports.
-	capabilityMaps = map[string]map[capability]bool{
-		"2.1.0": {authCapability: true},
-		"2.2.0": {authCapability: true},
-		"2.3.0": {authCapability: true},
-	}
-
-	enableMapMu sync.Mutex
-	// enabledMap points to a map in capabilityMaps
-	enabledMap map[capability]bool
-)
-
-// capabilityLoop checks the cluster version every 500ms and updates
-// the enabledMap when the cluster version increased.
-// capabilityLoop MUST be ran in a goroutine before checking capability
-// or using capabilityHandler.
-func capabilityLoop(s *etcdserver.EtcdServer) {
-	stopped := s.StopNotify()
-
-	var pv *semver.Version
-	for {
-		if v := s.ClusterVersion(); v != pv {
-			if pv == nil {
-				pv = v
-			} else if v != nil && pv.LessThan(*v) {
-				pv = v
-			}
-			enableMapMu.Lock()
-			enabledMap = capabilityMaps[pv.String()]
-			enableMapMu.Unlock()
-		}
-
-		select {
-		case <-stopped:
-			return
-		case <-time.After(500 * time.Millisecond):
-		}
-	}
-}
-
-func isCapabilityEnabled(c capability) bool {
-	enableMapMu.Lock()
-	defer enableMapMu.Unlock()
-	if enabledMap == nil {
-		return false
-	}
-	return enabledMap[c]
-}
-
-func capabilityHandler(c capability, fn func(http.ResponseWriter, *http.Request)) http.HandlerFunc {
-	return func(w http.ResponseWriter, r *http.Request) {
-		if !isCapabilityEnabled(c) {
-			notCapable(w, r, c)
-			return
-		}
-		fn(w, r)
-	}
-}
-
-func notCapable(w http.ResponseWriter, r *http.Request, c capability) {
-	herr := httptypes.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf("Not capable of accessing %s feature during rolling upgrades.", c))
-	if err := herr.WriteTo(w); err != nil {
-		plog.Debugf("error writing HTTPError (%v) to %s", err, r.RemoteAddr)
-	}
-}
diff --git a/etcdserver/etcdhttp/client.go b/etcdserver/etcdhttp/client.go
deleted file mode 100644
index b3828ab..0000000
--- a/etcdserver/etcdhttp/client.go
+++ /dev/null
@@ -1,828 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package etcdhttp
-
-import (
-	"encoding/json"
-	"errors"
-	"expvar"
-	"fmt"
-	"io/ioutil"
-	"net/http"
-	"net/http/pprof"
-	"net/url"
-	"path"
-	"strconv"
-	"strings"
-	"time"
-
-	etcdErr "github.com/coreos/etcd/error"
-	"github.com/coreos/etcd/etcdserver"
-	"github.com/coreos/etcd/etcdserver/auth"
-	"github.com/coreos/etcd/etcdserver/etcdhttp/httptypes"
-	"github.com/coreos/etcd/etcdserver/etcdserverpb"
-	"github.com/coreos/etcd/etcdserver/stats"
-	"github.com/coreos/etcd/pkg/types"
-	"github.com/coreos/etcd/raft"
-	"github.com/coreos/etcd/store"
-	"github.com/coreos/etcd/version"
-	"github.com/coreos/pkg/capnslog"
-	"github.com/jonboulle/clockwork"
-	"github.com/prometheus/client_golang/prometheus"
-	"golang.org/x/net/context"
-)
-
-const (
-	authPrefix               = "/v2/auth"
-	keysPrefix               = "/v2/keys"
-	deprecatedMachinesPrefix = "/v2/machines"
-	membersPrefix            = "/v2/members"
-	statsPrefix              = "/v2/stats"
-	varsPath                 = "/debug/vars"
-	metricsPath              = "/metrics"
-	healthPath               = "/health"
-	versionPath              = "/version"
-	configPath               = "/config"
-	pprofPrefix              = "/debug/pprof"
-)
-
-// NewClientHandler generates a muxed http.Handler with the given parameters to serve etcd client requests.
-func NewClientHandler(server *etcdserver.EtcdServer, timeout time.Duration) http.Handler {
-	go capabilityLoop(server)
-
-	sec := auth.NewStore(server, timeout)
-
-	kh := &keysHandler{
-		sec:     sec,
-		server:  server,
-		cluster: server.Cluster(),
-		timer:   server,
-		timeout: timeout,
-	}
-
-	sh := &statsHandler{
-		stats: server,
-	}
-
-	mh := &membersHandler{
-		sec:     sec,
-		server:  server,
-		cluster: server.Cluster(),
-		timeout: timeout,
-		clock:   clockwork.NewRealClock(),
-	}
-
-	dmh := &deprecatedMachinesHandler{
-		cluster: server.Cluster(),
-	}
-
-	sech := &authHandler{
-		sec:     sec,
-		cluster: server.Cluster(),
-	}
-
-	mux := http.NewServeMux()
-	mux.HandleFunc("/", http.NotFound)
-	mux.Handle(healthPath, healthHandler(server))
-	mux.HandleFunc(versionPath, versionHandler(server.Cluster(), serveVersion))
-	mux.Handle(keysPrefix, kh)
-	mux.Handle(keysPrefix+"/", kh)
-	mux.HandleFunc(statsPrefix+"/store", sh.serveStore)
-	mux.HandleFunc(statsPrefix+"/self", sh.serveSelf)
-	mux.HandleFunc(statsPrefix+"/leader", sh.serveLeader)
-	mux.HandleFunc(varsPath, serveVars)
-	mux.HandleFunc(configPath+"/local/log", logHandleFunc)
-	mux.Handle(metricsPath, prometheus.Handler())
-	mux.Handle(membersPrefix, mh)
-	mux.Handle(membersPrefix+"/", mh)
-	mux.Handle(deprecatedMachinesPrefix, dmh)
-	handleAuth(mux, sech)
-
-	if server.IsPprofEnabled() {
-		plog.Infof("pprof is enabled under %s", pprofPrefix)
-
-		mux.HandleFunc(pprofPrefix, pprof.Index)
-		mux.HandleFunc(pprofPrefix+"/profile", pprof.Profile)
-		mux.HandleFunc(pprofPrefix+"/symbol", pprof.Symbol)
-		mux.HandleFunc(pprofPrefix+"/cmdline", pprof.Cmdline)
-		// TODO: currently, we don't create an entry for pprof.Trace,
-		// because go 1.4 doesn't provide it. After support of go 1.4 is dropped,
-		// we should add the entry.
-
-		mux.Handle(pprofPrefix+"/heap", pprof.Handler("heap"))
-		mux.Handle(pprofPrefix+"/goroutine", pprof.Handler("goroutine"))
-		mux.Handle(pprofPrefix+"/threadcreate", pprof.Handler("threadcreate"))
-		mux.Handle(pprofPrefix+"/block", pprof.Handler("block"))
-	}
-
-	return requestLogger(mux)
-}
-
-type keysHandler struct {
-	sec     auth.Store
-	server  etcdserver.Server
-	cluster etcdserver.Cluster
-	timer   etcdserver.RaftTimer
-	timeout time.Duration
-}
-
-func (h *keysHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "HEAD", "GET", "PUT", "POST", "DELETE") {
-		return
-	}
-
-	w.Header().Set("X-Etcd-Cluster-ID", h.cluster.ID().String())
-
-	ctx, cancel := context.WithTimeout(context.Background(), h.timeout)
-	defer cancel()
-	clock := clockwork.NewRealClock()
-	startTime := clock.Now()
-	rr, err := parseKeyRequest(r, clock)
-	if err != nil {
-		writeKeyError(w, err)
-		return
-	}
-	// The path must be valid at this point (we've parsed the request successfully).
-	if !hasKeyPrefixAccess(h.sec, r, r.URL.Path[len(keysPrefix):], rr.Recursive) {
-		writeKeyNoAuth(w)
-		return
-	}
-	if !rr.Wait {
-		reportRequestReceived(rr)
-	}
-	resp, err := h.server.Do(ctx, rr)
-	if err != nil {
-		err = trimErrorPrefix(err, etcdserver.StoreKeysPrefix)
-		writeKeyError(w, err)
-		reportRequestFailed(rr, err)
-		return
-	}
-	switch {
-	case resp.Event != nil:
-		if err := writeKeyEvent(w, resp.Event, h.timer); err != nil {
-			// Should never be reached
-			plog.Errorf("error writing event (%v)", err)
-		}
-		reportRequestCompleted(rr, resp, startTime)
-	case resp.Watcher != nil:
-		ctx, cancel := context.WithTimeout(context.Background(), defaultWatchTimeout)
-		defer cancel()
-		handleKeyWatch(ctx, w, resp.Watcher, rr.Stream, h.timer)
-	default:
-		writeKeyError(w, errors.New("received response with no Event/Watcher!"))
-	}
-}
-
-type deprecatedMachinesHandler struct {
-	cluster etcdserver.Cluster
-}
-
-func (h *deprecatedMachinesHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "GET", "HEAD") {
-		return
-	}
-	endpoints := h.cluster.ClientURLs()
-	w.Write([]byte(strings.Join(endpoints, ", ")))
-}
-
-type membersHandler struct {
-	sec     auth.Store
-	server  etcdserver.Server
-	cluster etcdserver.Cluster
-	timeout time.Duration
-	clock   clockwork.Clock
-}
-
-func (h *membersHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "GET", "POST", "DELETE", "PUT") {
-		return
-	}
-	if !hasWriteRootAccess(h.sec, r) {
-		writeNoAuth(w, r)
-		return
-	}
-	w.Header().Set("X-Etcd-Cluster-ID", h.cluster.ID().String())
-
-	ctx, cancel := context.WithTimeout(context.Background(), h.timeout)
-	defer cancel()
-
-	switch r.Method {
-	case "GET":
-		switch trimPrefix(r.URL.Path, membersPrefix) {
-		case "":
-			mc := newMemberCollection(h.cluster.Members())
-			w.Header().Set("Content-Type", "application/json")
-			if err := json.NewEncoder(w).Encode(mc); err != nil {
-				plog.Warningf("failed to encode members response (%v)", err)
-			}
-		case "leader":
-			id := h.server.Leader()
-			if id == 0 {
-				writeError(w, r, httptypes.NewHTTPError(http.StatusServiceUnavailable, "During election"))
-				return
-			}
-			m := newMember(h.cluster.Member(id))
-			w.Header().Set("Content-Type", "application/json")
-			if err := json.NewEncoder(w).Encode(m); err != nil {
-				plog.Warningf("failed to encode members response (%v)", err)
-			}
-		default:
-			writeError(w, r, httptypes.NewHTTPError(http.StatusNotFound, "Not found"))
-		}
-	case "POST":
-		req := httptypes.MemberCreateRequest{}
-		if ok := unmarshalRequest(r, &req, w); !ok {
-			return
-		}
-		now := h.clock.Now()
-		m := etcdserver.NewMember("", req.PeerURLs, "", &now)
-		err := h.server.AddMember(ctx, *m)
-		switch {
-		case err == etcdserver.ErrIDExists || err == etcdserver.ErrPeerURLexists:
-			writeError(w, r, httptypes.NewHTTPError(http.StatusConflict, err.Error()))
-			return
-		case err != nil:
-			plog.Errorf("error adding member %s (%v)", m.ID, err)
-			writeError(w, r, err)
-			return
-		}
-		res := newMember(m)
-		w.Header().Set("Content-Type", "application/json")
-		w.WriteHeader(http.StatusCreated)
-		if err := json.NewEncoder(w).Encode(res); err != nil {
-			plog.Warningf("failed to encode members response (%v)", err)
-		}
-	case "DELETE":
-		id, ok := getID(r.URL.Path, w)
-		if !ok {
-			return
-		}
-		err := h.server.RemoveMember(ctx, uint64(id))
-		switch {
-		case err == etcdserver.ErrIDRemoved:
-			writeError(w, r, httptypes.NewHTTPError(http.StatusGone, fmt.Sprintf("Member permanently removed: %s", id)))
-		case err == etcdserver.ErrIDNotFound:
-			writeError(w, r, httptypes.NewHTTPError(http.StatusNotFound, fmt.Sprintf("No such member: %s", id)))
-		case err != nil:
-			plog.Errorf("error removing member %s (%v)", id, err)
-			writeError(w, r, err)
-		default:
-			w.WriteHeader(http.StatusNoContent)
-		}
-	case "PUT":
-		id, ok := getID(r.URL.Path, w)
-		if !ok {
-			return
-		}
-		req := httptypes.MemberUpdateRequest{}
-		if ok := unmarshalRequest(r, &req, w); !ok {
-			return
-		}
-		m := etcdserver.Member{
-			ID:             id,
-			RaftAttributes: etcdserver.RaftAttributes{PeerURLs: req.PeerURLs.StringSlice()},
-		}
-		err := h.server.UpdateMember(ctx, m)
-		switch {
-		case err == etcdserver.ErrPeerURLexists:
-			writeError(w, r, httptypes.NewHTTPError(http.StatusConflict, err.Error()))
-		case err == etcdserver.ErrIDNotFound:
-			writeError(w, r, httptypes.NewHTTPError(http.StatusNotFound, fmt.Sprintf("No such member: %s", id)))
-		case err != nil:
-			plog.Errorf("error updating member %s (%v)", m.ID, err)
-			writeError(w, r, err)
-		default:
-			w.WriteHeader(http.StatusNoContent)
-		}
-	}
-}
-
-type statsHandler struct {
-	stats stats.Stats
-}
-
-func (h *statsHandler) serveStore(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "GET") {
-		return
-	}
-	w.Header().Set("Content-Type", "application/json")
-	w.Write(h.stats.StoreStats())
-}
-
-func (h *statsHandler) serveSelf(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "GET") {
-		return
-	}
-	w.Header().Set("Content-Type", "application/json")
-	w.Write(h.stats.SelfStats())
-}
-
-func (h *statsHandler) serveLeader(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "GET") {
-		return
-	}
-	stats := h.stats.LeaderStats()
-	if stats == nil {
-		writeError(w, r, httptypes.NewHTTPError(http.StatusForbidden, "not current leader"))
-		return
-	}
-	w.Header().Set("Content-Type", "application/json")
-	w.Write(stats)
-}
-
-func serveVars(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "GET") {
-		return
-	}
-
-	w.Header().Set("Content-Type", "application/json; charset=utf-8")
-	fmt.Fprintf(w, "{\n")
-	first := true
-	expvar.Do(func(kv expvar.KeyValue) {
-		if !first {
-			fmt.Fprintf(w, ",\n")
-		}
-		first = false
-		fmt.Fprintf(w, "%q: %s", kv.Key, kv.Value)
-	})
-	fmt.Fprintf(w, "\n}\n")
-}
-
-// TODO: change etcdserver to raft interface when we have it.
-//       add test for healthHandler when we have the interface ready.
-func healthHandler(server *etcdserver.EtcdServer) http.HandlerFunc {
-	return func(w http.ResponseWriter, r *http.Request) {
-		if !allowMethod(w, r.Method, "GET") {
-			return
-		}
-
-		if uint64(server.Leader()) == raft.None {
-			http.Error(w, `{"health": "false"}`, http.StatusServiceUnavailable)
-			return
-		}
-
-		// wait for raft's progress
-		index := server.Index()
-		for i := 0; i < 3; i++ {
-			time.Sleep(250 * time.Millisecond)
-			if server.Index() > index {
-				w.WriteHeader(http.StatusOK)
-				w.Write([]byte(`{"health": "true"}`))
-				return
-			}
-		}
-
-		http.Error(w, `{"health": "false"}`, http.StatusServiceUnavailable)
-		return
-	}
-}
-
-func versionHandler(c etcdserver.Cluster, fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
-	return func(w http.ResponseWriter, r *http.Request) {
-		v := c.Version()
-		if v != nil {
-			fn(w, r, v.String())
-		} else {
-			fn(w, r, "not_decided")
-		}
-	}
-}
-
-func serveVersion(w http.ResponseWriter, r *http.Request, clusterV string) {
-	if !allowMethod(w, r.Method, "GET") {
-		return
-	}
-	vs := version.Versions{
-		Server:  version.Version,
-		Cluster: clusterV,
-	}
-
-	w.Header().Set("Content-Type", "application/json")
-	b, err := json.Marshal(&vs)
-	if err != nil {
-		plog.Panicf("cannot marshal versions to json (%v)", err)
-	}
-	w.Write(b)
-}
-
-func logHandleFunc(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "PUT") {
-		return
-	}
-
-	in := struct{ Level string }{}
-
-	d := json.NewDecoder(r.Body)
-	if err := d.Decode(&in); err != nil {
-		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid json body"))
-		return
-	}
-
-	logl, err := capnslog.ParseLevel(strings.ToUpper(in.Level))
-	if err != nil {
-		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid log level "+in.Level))
-		return
-	}
-
-	plog.Noticef("globalLogLevel set to %q", logl.String())
-	capnslog.SetGlobalLogLevel(logl)
-	w.WriteHeader(http.StatusNoContent)
-}
-
-// parseKeyRequest converts a received http.Request on keysPrefix to
-// a server Request, performing validation of supplied fields as appropriate.
-// If any validation fails, an empty Request and non-nil error is returned.
-func parseKeyRequest(r *http.Request, clock clockwork.Clock) (etcdserverpb.Request, error) {
-	emptyReq := etcdserverpb.Request{}
-
-	err := r.ParseForm()
-	if err != nil {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodeInvalidForm,
-			err.Error(),
-		)
-	}
-
-	if !strings.HasPrefix(r.URL.Path, keysPrefix) {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodeInvalidForm,
-			"incorrect key prefix",
-		)
-	}
-	p := path.Join(etcdserver.StoreKeysPrefix, r.URL.Path[len(keysPrefix):])
-
-	var pIdx, wIdx uint64
-	if pIdx, err = getUint64(r.Form, "prevIndex"); err != nil {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodeIndexNaN,
-			`invalid value for "prevIndex"`,
-		)
-	}
-	if wIdx, err = getUint64(r.Form, "waitIndex"); err != nil {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodeIndexNaN,
-			`invalid value for "waitIndex"`,
-		)
-	}
-
-	var rec, sort, wait, dir, quorum, stream bool
-	if rec, err = getBool(r.Form, "recursive"); err != nil {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodeInvalidField,
-			`invalid value for "recursive"`,
-		)
-	}
-	if sort, err = getBool(r.Form, "sorted"); err != nil {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodeInvalidField,
-			`invalid value for "sorted"`,
-		)
-	}
-	if wait, err = getBool(r.Form, "wait"); err != nil {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodeInvalidField,
-			`invalid value for "wait"`,
-		)
-	}
-	// TODO(jonboulle): define what parameters dir is/isn't compatible with?
-	if dir, err = getBool(r.Form, "dir"); err != nil {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodeInvalidField,
-			`invalid value for "dir"`,
-		)
-	}
-	if quorum, err = getBool(r.Form, "quorum"); err != nil {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodeInvalidField,
-			`invalid value for "quorum"`,
-		)
-	}
-	if stream, err = getBool(r.Form, "stream"); err != nil {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodeInvalidField,
-			`invalid value for "stream"`,
-		)
-	}
-
-	if wait && r.Method != "GET" {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodeInvalidField,
-			`"wait" can only be used with GET requests`,
-		)
-	}
-
-	pV := r.FormValue("prevValue")
-	if _, ok := r.Form["prevValue"]; ok && pV == "" {
-		return emptyReq, etcdErr.NewRequestError(
-			etcdErr.EcodePrevValueRequired,
-			`"prevValue" cannot be empty`,
-		)
-	}
-
-	// TTL is nullable, so leave it null if not specified
-	// or an empty string
-	var ttl *uint64
-	if len(r.FormValue("ttl")) > 0 {
-		i, err := getUint64(r.Form, "ttl")
-		if err != nil {
-			return emptyReq, etcdErr.NewRequestError(
-				etcdErr.EcodeTTLNaN,
-				`invalid value for "ttl"`,
-			)
-		}
-		ttl = &i
-	}
-
-	// prevExist is nullable, so leave it null if not specified
-	var pe *bool
-	if _, ok := r.Form["prevExist"]; ok {
-		bv, err := getBool(r.Form, "prevExist")
-		if err != nil {
-			return emptyReq, etcdErr.NewRequestError(
-				etcdErr.EcodeInvalidField,
-				"invalid value for prevExist",
-			)
-		}
-		pe = &bv
-	}
-
-	// refresh is nullable, so leave it null if not specified
-	var refresh *bool
-	if _, ok := r.Form["refresh"]; ok {
-		bv, err := getBool(r.Form, "refresh")
-		if err != nil {
-			return emptyReq, etcdErr.NewRequestError(
-				etcdErr.EcodeInvalidField,
-				"invalid value for refresh",
-			)
-		}
-		refresh = &bv
-		if refresh != nil && *refresh {
-			val := r.FormValue("value")
-			if _, ok := r.Form["value"]; ok && val != "" {
-				return emptyReq, etcdErr.NewRequestError(
-					etcdErr.EcodeRefreshValue,
-					`A value was provided on a refresh`,
-				)
-			}
-			if ttl == nil {
-				return emptyReq, etcdErr.NewRequestError(
-					etcdErr.EcodeRefreshTTLRequired,
-					`No TTL value set`,
-				)
-			}
-		}
-	}
-
-	rr := etcdserverpb.Request{
-		Method:    r.Method,
-		Path:      p,
-		Val:       r.FormValue("value"),
-		Dir:       dir,
-		PrevValue: pV,
-		PrevIndex: pIdx,
-		PrevExist: pe,
-		Wait:      wait,
-		Since:     wIdx,
-		Recursive: rec,
-		Sorted:    sort,
-		Quorum:    quorum,
-		Stream:    stream,
-	}
-
-	if pe != nil {
-		rr.PrevExist = pe
-	}
-
-	if refresh != nil {
-		rr.Refresh = refresh
-	}
-
-	// Null TTL is equivalent to unset Expiration
-	if ttl != nil {
-		expr := time.Duration(*ttl) * time.Second
-		rr.Expiration = clock.Now().Add(expr).UnixNano()
-	}
-
-	return rr, nil
-}
-
-// writeKeyEvent trims the prefix of key path in a single Event under
-// StoreKeysPrefix, serializes it and writes the resulting JSON to the given
-// ResponseWriter, along with the appropriate headers.
-func writeKeyEvent(w http.ResponseWriter, ev *store.Event, rt etcdserver.RaftTimer) error {
-	if ev == nil {
-		return errors.New("cannot write empty Event!")
-	}
-	w.Header().Set("Content-Type", "application/json")
-	w.Header().Set("X-Etcd-Index", fmt.Sprint(ev.EtcdIndex))
-	w.Header().Set("X-Raft-Index", fmt.Sprint(rt.Index()))
-	w.Header().Set("X-Raft-Term", fmt.Sprint(rt.Term()))
-
-	if ev.IsCreated() {
-		w.WriteHeader(http.StatusCreated)
-	}
-
-	ev = trimEventPrefix(ev, etcdserver.StoreKeysPrefix)
-	return json.NewEncoder(w).Encode(ev)
-}
-
-func writeKeyNoAuth(w http.ResponseWriter) {
-	e := etcdErr.NewError(etcdErr.EcodeUnauthorized, "Insufficient credentials", 0)
-	e.WriteTo(w)
-}
-
-// writeKeyError logs and writes the given Error to the ResponseWriter.
-// If Error is not an etcdErr, the error will be converted to an etcd error.
-func writeKeyError(w http.ResponseWriter, err error) {
-	if err == nil {
-		return
-	}
-	switch e := err.(type) {
-	case *etcdErr.Error:
-		e.WriteTo(w)
-	default:
-		switch err {
-		case etcdserver.ErrTimeoutDueToLeaderFail, etcdserver.ErrTimeoutDueToConnectionLost:
-			mlog.MergeError(err)
-		default:
-			mlog.MergeErrorf("got unexpected response error (%v)", err)
-		}
-		ee := etcdErr.NewError(etcdErr.EcodeRaftInternal, err.Error(), 0)
-		ee.WriteTo(w)
-	}
-}
-
-func handleKeyWatch(ctx context.Context, w http.ResponseWriter, wa store.Watcher, stream bool, rt etcdserver.RaftTimer) {
-	defer wa.Remove()
-	ech := wa.EventChan()
-	var nch <-chan bool
-	if x, ok := w.(http.CloseNotifier); ok {
-		nch = x.CloseNotify()
-	}
-
-	w.Header().Set("Content-Type", "application/json")
-	w.Header().Set("X-Etcd-Index", fmt.Sprint(wa.StartIndex()))
-	w.Header().Set("X-Raft-Index", fmt.Sprint(rt.Index()))
-	w.Header().Set("X-Raft-Term", fmt.Sprint(rt.Term()))
-	w.WriteHeader(http.StatusOK)
-
-	// Ensure headers are flushed early, in case of long polling
-	w.(http.Flusher).Flush()
-
-	for {
-		select {
-		case <-nch:
-			// Client closed connection. Nothing to do.
-			return
-		case <-ctx.Done():
-			// Timed out. net/http will close the connection for us, so nothing to do.
-			return
-		case ev, ok := <-ech:
-			if !ok {
-				// If the channel is closed this may be an indication of
-				// that notifications are much more than we are able to
-				// send to the client in time. Then we simply end streaming.
-				return
-			}
-			ev = trimEventPrefix(ev, etcdserver.StoreKeysPrefix)
-			if err := json.NewEncoder(w).Encode(ev); err != nil {
-				// Should never be reached
-				plog.Warningf("error writing event (%v)", err)
-				return
-			}
-			if !stream {
-				return
-			}
-			w.(http.Flusher).Flush()
-		}
-	}
-}
-
-func trimEventPrefix(ev *store.Event, prefix string) *store.Event {
-	if ev == nil {
-		return nil
-	}
-	// Since the *Event may reference one in the store history
-	// history, we must copy it before modifying
-	e := ev.Clone()
-	e.Node = trimNodeExternPrefix(e.Node, prefix)
-	e.PrevNode = trimNodeExternPrefix(e.PrevNode, prefix)
-	return e
-}
-
-func trimNodeExternPrefix(n *store.NodeExtern, prefix string) *store.NodeExtern {
-	if n == nil {
-		return nil
-	}
-	n.Key = strings.TrimPrefix(n.Key, prefix)
-	for _, nn := range n.Nodes {
-		nn = trimNodeExternPrefix(nn, prefix)
-	}
-	return n
-}
-
-func trimErrorPrefix(err error, prefix string) error {
-	if e, ok := err.(*etcdErr.Error); ok {
-		e.Cause = strings.TrimPrefix(e.Cause, prefix)
-	}
-	return err
-}
-
-func unmarshalRequest(r *http.Request, req json.Unmarshaler, w http.ResponseWriter) bool {
-	ctype := r.Header.Get("Content-Type")
-	if ctype != "application/json" {
-		writeError(w, r, httptypes.NewHTTPError(http.StatusUnsupportedMediaType, fmt.Sprintf("Bad Content-Type %s, accept application/json", ctype)))
-		return false
-	}
-	b, err := ioutil.ReadAll(r.Body)
-	if err != nil {
-		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, err.Error()))
-		return false
-	}
-	if err := req.UnmarshalJSON(b); err != nil {
-		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, err.Error()))
-		return false
-	}
-	return true
-}
-
-func getID(p string, w http.ResponseWriter) (types.ID, bool) {
-	idStr := trimPrefix(p, membersPrefix)
-	if idStr == "" {
-		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
-		return 0, false
-	}
-	id, err := types.IDFromString(idStr)
-	if err != nil {
-		writeError(w, nil, httptypes.NewHTTPError(http.StatusNotFound, fmt.Sprintf("No such member: %s", idStr)))
-		return 0, false
-	}
-	return id, true
-}
-
-// getUint64 extracts a uint64 by the given key from a Form. If the key does
-// not exist in the form, 0 is returned. If the key exists but the value is
-// badly formed, an error is returned. If multiple values are present only the
-// first is considered.
-func getUint64(form url.Values, key string) (i uint64, err error) {
-	if vals, ok := form[key]; ok {
-		i, err = strconv.ParseUint(vals[0], 10, 64)
-	}
-	return
-}
-
-// getBool extracts a bool by the given key from a Form. If the key does not
-// exist in the form, false is returned. If the key exists but the value is
-// badly formed, an error is returned. If multiple values are present only the
-// first is considered.
-func getBool(form url.Values, key string) (b bool, err error) {
-	if vals, ok := form[key]; ok {
-		b, err = strconv.ParseBool(vals[0])
-	}
-	return
-}
-
-// trimPrefix removes a given prefix and any slash following the prefix
-// e.g.: trimPrefix("foo", "foo") == trimPrefix("foo/", "foo") == ""
-func trimPrefix(p, prefix string) (s string) {
-	s = strings.TrimPrefix(p, prefix)
-	s = strings.TrimPrefix(s, "/")
-	return
-}
-
-func newMemberCollection(ms []*etcdserver.Member) *httptypes.MemberCollection {
-	c := httptypes.MemberCollection(make([]httptypes.Member, len(ms)))
-
-	for i, m := range ms {
-		c[i] = newMember(m)
-	}
-
-	return &c
-}
-
-func newMember(m *etcdserver.Member) httptypes.Member {
-	tm := httptypes.Member{
-		ID:         m.ID.String(),
-		Name:       m.Name,
-		PeerURLs:   make([]string, len(m.PeerURLs)),
-		ClientURLs: make([]string, len(m.ClientURLs)),
-	}
-
-	copy(tm.PeerURLs, m.PeerURLs)
-	copy(tm.ClientURLs, m.ClientURLs)
-
-	return tm
-}
diff --git a/etcdserver/etcdhttp/client_auth.go b/etcdserver/etcdhttp/client_auth.go
deleted file mode 100644
index c5678ad..0000000
--- a/etcdserver/etcdhttp/client_auth.go
+++ /dev/null
@@ -1,507 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package etcdhttp
-
-import (
-	"encoding/json"
-	"net/http"
-	"path"
-	"strings"
-
-	"github.com/coreos/etcd/etcdserver"
-	"github.com/coreos/etcd/etcdserver/auth"
-	"github.com/coreos/etcd/etcdserver/etcdhttp/httptypes"
-)
-
-type authHandler struct {
-	sec     auth.Store
-	cluster etcdserver.Cluster
-}
-
-func hasWriteRootAccess(sec auth.Store, r *http.Request) bool {
-	if r.Method == "GET" || r.Method == "HEAD" {
-		return true
-	}
-	return hasRootAccess(sec, r)
-}
-
-func hasRootAccess(sec auth.Store, r *http.Request) bool {
-	if sec == nil {
-		// No store means no auth available, eg, tests.
-		return true
-	}
-	if !sec.AuthEnabled() {
-		return true
-	}
-	username, password, ok := r.BasicAuth()
-	if !ok {
-		return false
-	}
-	rootUser, err := sec.GetUser(username)
-	if err != nil {
-		return false
-	}
-
-	ok = sec.CheckPassword(rootUser, password)
-	if !ok {
-		plog.Warningf("auth: wrong password for user %s", username)
-		return false
-	}
-	for _, role := range rootUser.Roles {
-		if role == auth.RootRoleName {
-			return true
-		}
-	}
-	plog.Warningf("auth: user %s does not have the %s role for resource %s.", username, auth.RootRoleName, r.URL.Path)
-	return false
-}
-
-func hasKeyPrefixAccess(sec auth.Store, r *http.Request, key string, recursive bool) bool {
-	if sec == nil {
-		// No store means no auth available, eg, tests.
-		return true
-	}
-	if !sec.AuthEnabled() {
-		return true
-	}
-	if r.Header.Get("Authorization") == "" {
-		plog.Warningf("auth: no authorization provided, checking guest access")
-		return hasGuestAccess(sec, r, key)
-	}
-	username, password, ok := r.BasicAuth()
-	if !ok {
-		plog.Warningf("auth: malformed basic auth encoding")
-		return false
-	}
-	user, err := sec.GetUser(username)
-	if err != nil {
-		plog.Warningf("auth: no such user: %s.", username)
-		return false
-	}
-	authAsUser := sec.CheckPassword(user, password)
-	if !authAsUser {
-		plog.Warningf("auth: incorrect password for user: %s.", username)
-		return false
-	}
-	writeAccess := r.Method != "GET" && r.Method != "HEAD"
-	for _, roleName := range user.Roles {
-		role, err := sec.GetRole(roleName)
-		if err != nil {
-			continue
-		}
-		if recursive {
-			if role.HasRecursiveAccess(key, writeAccess) {
-				return true
-			}
-		} else if role.HasKeyAccess(key, writeAccess) {
-			return true
-		}
-	}
-	plog.Warningf("auth: invalid access for user %s on key %s.", username, key)
-	return false
-}
-
-func hasGuestAccess(sec auth.Store, r *http.Request, key string) bool {
-	writeAccess := r.Method != "GET" && r.Method != "HEAD"
-	role, err := sec.GetRole(auth.GuestRoleName)
-	if err != nil {
-		return false
-	}
-	if role.HasKeyAccess(key, writeAccess) {
-		return true
-	}
-	plog.Warningf("auth: invalid access for unauthenticated user on resource %s.", key)
-	return false
-}
-
-func writeNoAuth(w http.ResponseWriter, r *http.Request) {
-	herr := httptypes.NewHTTPError(http.StatusUnauthorized, "Insufficient credentials")
-	if err := herr.WriteTo(w); err != nil {
-		plog.Debugf("error writing HTTPError (%v) to %s", err, r.RemoteAddr)
-	}
-}
-
-func handleAuth(mux *http.ServeMux, sh *authHandler) {
-	mux.HandleFunc(authPrefix+"/roles", capabilityHandler(authCapability, sh.baseRoles))
-	mux.HandleFunc(authPrefix+"/roles/", capabilityHandler(authCapability, sh.handleRoles))
-	mux.HandleFunc(authPrefix+"/users", capabilityHandler(authCapability, sh.baseUsers))
-	mux.HandleFunc(authPrefix+"/users/", capabilityHandler(authCapability, sh.handleUsers))
-	mux.HandleFunc(authPrefix+"/enable", capabilityHandler(authCapability, sh.enableDisable))
-}
-
-func (sh *authHandler) baseRoles(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "GET") {
-		return
-	}
-	if !hasRootAccess(sh.sec, r) {
-		writeNoAuth(w, r)
-		return
-	}
-
-	w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
-	w.Header().Set("Content-Type", "application/json")
-
-	roles, err := sh.sec.AllRoles()
-	if err != nil {
-		writeError(w, r, err)
-		return
-	}
-	if roles == nil {
-		roles = make([]string, 0)
-	}
-
-	err = r.ParseForm()
-	if err != nil {
-		writeError(w, r, err)
-		return
-	}
-
-	var rolesCollections struct {
-		Roles []auth.Role `json:"roles"`
-	}
-	for _, roleName := range roles {
-		var role auth.Role
-		role, err = sh.sec.GetRole(roleName)
-		if err != nil {
-			writeError(w, r, err)
-			return
-		}
-		rolesCollections.Roles = append(rolesCollections.Roles, role)
-	}
-	err = json.NewEncoder(w).Encode(rolesCollections)
-
-	if err != nil {
-		plog.Warningf("baseRoles error encoding on %s", r.URL)
-		writeError(w, r, err)
-		return
-	}
-}
-
-func (sh *authHandler) handleRoles(w http.ResponseWriter, r *http.Request) {
-	subpath := path.Clean(r.URL.Path[len(authPrefix):])
-	// Split "/roles/rolename/command".
-	// First item is an empty string, second is "roles"
-	pieces := strings.Split(subpath, "/")
-	if len(pieces) == 2 {
-		sh.baseRoles(w, r)
-		return
-	}
-	if len(pieces) != 3 {
-		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid path"))
-		return
-	}
-	sh.forRole(w, r, pieces[2])
-}
-
-func (sh *authHandler) forRole(w http.ResponseWriter, r *http.Request, role string) {
-	if !allowMethod(w, r.Method, "GET", "PUT", "DELETE") {
-		return
-	}
-	if !hasRootAccess(sh.sec, r) {
-		writeNoAuth(w, r)
-		return
-	}
-	w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
-	w.Header().Set("Content-Type", "application/json")
-
-	switch r.Method {
-	case "GET":
-		data, err := sh.sec.GetRole(role)
-		if err != nil {
-			writeError(w, r, err)
-			return
-		}
-		err = json.NewEncoder(w).Encode(data)
-		if err != nil {
-			plog.Warningf("forRole error encoding on %s", r.URL)
-			return
-		}
-		return
-	case "PUT":
-		var in auth.Role
-		err := json.NewDecoder(r.Body).Decode(&in)
-		if err != nil {
-			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid JSON in request body."))
-			return
-		}
-		if in.Role != role {
-			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Role JSON name does not match the name in the URL"))
-			return
-		}
-
-		var out auth.Role
-
-		// create
-		if in.Grant.IsEmpty() && in.Revoke.IsEmpty() {
-			err = sh.sec.CreateRole(in)
-			if err != nil {
-				writeError(w, r, err)
-				return
-			}
-			w.WriteHeader(http.StatusCreated)
-			out = in
-		} else {
-			if !in.Permissions.IsEmpty() {
-				writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Role JSON contains both permissions and grant/revoke"))
-				return
-			}
-			out, err = sh.sec.UpdateRole(in)
-			if err != nil {
-				writeError(w, r, err)
-				return
-			}
-			w.WriteHeader(http.StatusOK)
-		}
-
-		err = json.NewEncoder(w).Encode(out)
-		if err != nil {
-			plog.Warningf("forRole error encoding on %s", r.URL)
-			return
-		}
-		return
-	case "DELETE":
-		err := sh.sec.DeleteRole(role)
-		if err != nil {
-			writeError(w, r, err)
-			return
-		}
-	}
-}
-
-type userWithRoles struct {
-	User  string      `json:"user"`
-	Roles []auth.Role `json:"roles,omitempty"`
-}
-
-func (sh *authHandler) baseUsers(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "GET") {
-		return
-	}
-	if !hasRootAccess(sh.sec, r) {
-		writeNoAuth(w, r)
-		return
-	}
-	w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
-	w.Header().Set("Content-Type", "application/json")
-
-	users, err := sh.sec.AllUsers()
-	if err != nil {
-		writeError(w, r, err)
-		return
-	}
-	if users == nil {
-		users = make([]string, 0)
-	}
-
-	err = r.ParseForm()
-	if err != nil {
-		writeError(w, r, err)
-		return
-	}
-
-	var usersCollections struct {
-		Users []userWithRoles `json:"users"`
-	}
-	for _, userName := range users {
-		var user auth.User
-		user, err = sh.sec.GetUser(userName)
-		if err != nil {
-			writeError(w, r, err)
-			return
-		}
-
-		uwr := userWithRoles{User: user.User}
-		for _, roleName := range user.Roles {
-			var role auth.Role
-			role, err = sh.sec.GetRole(roleName)
-			if err != nil {
-				writeError(w, r, err)
-				return
-			}
-			uwr.Roles = append(uwr.Roles, role)
-		}
-
-		usersCollections.Users = append(usersCollections.Users, uwr)
-	}
-	err = json.NewEncoder(w).Encode(usersCollections)
-
-	if err != nil {
-		plog.Warningf("baseUsers error encoding on %s", r.URL)
-		writeError(w, r, err)
-		return
-	}
-}
-
-func (sh *authHandler) handleUsers(w http.ResponseWriter, r *http.Request) {
-	subpath := path.Clean(r.URL.Path[len(authPrefix):])
-	// Split "/users/username".
-	// First item is an empty string, second is "users"
-	pieces := strings.Split(subpath, "/")
-	if len(pieces) == 2 {
-		sh.baseUsers(w, r)
-		return
-	}
-	if len(pieces) != 3 {
-		writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid path"))
-		return
-	}
-	sh.forUser(w, r, pieces[2])
-}
-
-func (sh *authHandler) forUser(w http.ResponseWriter, r *http.Request, user string) {
-	if !allowMethod(w, r.Method, "GET", "PUT", "DELETE") {
-		return
-	}
-	if !hasRootAccess(sh.sec, r) {
-		writeNoAuth(w, r)
-		return
-	}
-	w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
-	w.Header().Set("Content-Type", "application/json")
-
-	switch r.Method {
-	case "GET":
-		u, err := sh.sec.GetUser(user)
-		if err != nil {
-			writeError(w, r, err)
-			return
-		}
-
-		err = r.ParseForm()
-		if err != nil {
-			writeError(w, r, err)
-			return
-		}
-
-		uwr := userWithRoles{User: u.User}
-		for _, roleName := range u.Roles {
-			var role auth.Role
-			role, err = sh.sec.GetRole(roleName)
-			if err != nil {
-				writeError(w, r, err)
-				return
-			}
-			uwr.Roles = append(uwr.Roles, role)
-		}
-		err = json.NewEncoder(w).Encode(uwr)
-
-		if err != nil {
-			plog.Warningf("forUser error encoding on %s", r.URL)
-			return
-		}
-		return
-	case "PUT":
-		var u auth.User
-		err := json.NewDecoder(r.Body).Decode(&u)
-		if err != nil {
-			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid JSON in request body."))
-			return
-		}
-		if u.User != user {
-			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "User JSON name does not match the name in the URL"))
-			return
-		}
-
-		var (
-			out     auth.User
-			created bool
-		)
-
-		if len(u.Grant) == 0 && len(u.Revoke) == 0 {
-			// create or update
-			if len(u.Roles) != 0 {
-				out, err = sh.sec.CreateUser(u)
-			} else {
-				// if user passes in both password and roles, we are unsure about his/her
-				// intention.
-				out, created, err = sh.sec.CreateOrUpdateUser(u)
-			}
-
-			if err != nil {
-				writeError(w, r, err)
-				return
-			}
-		} else {
-			// update case
-			if len(u.Roles) != 0 {
-				writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "User JSON contains both roles and grant/revoke"))
-				return
-			}
-			out, err = sh.sec.UpdateUser(u)
-			if err != nil {
-				writeError(w, r, err)
-				return
-			}
-		}
-
-		if created {
-			w.WriteHeader(http.StatusCreated)
-		} else {
-			w.WriteHeader(http.StatusOK)
-		}
-
-		out.Password = ""
-
-		err = json.NewEncoder(w).Encode(out)
-		if err != nil {
-			plog.Warningf("forUser error encoding on %s", r.URL)
-			return
-		}
-		return
-	case "DELETE":
-		err := sh.sec.DeleteUser(user)
-		if err != nil {
-			writeError(w, r, err)
-			return
-		}
-	}
-}
-
-type enabled struct {
-	Enabled bool `json:"enabled"`
-}
-
-func (sh *authHandler) enableDisable(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "GET", "PUT", "DELETE") {
-		return
-	}
-	if !hasWriteRootAccess(sh.sec, r) {
-		writeNoAuth(w, r)
-		return
-	}
-	w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
-	w.Header().Set("Content-Type", "application/json")
-	isEnabled := sh.sec.AuthEnabled()
-	switch r.Method {
-	case "GET":
-		jsonDict := enabled{isEnabled}
-		err := json.NewEncoder(w).Encode(jsonDict)
-		if err != nil {
-			plog.Warningf("error encoding auth state on %s", r.URL)
-		}
-	case "PUT":
-		err := sh.sec.EnableAuth()
-		if err != nil {
-			writeError(w, r, err)
-			return
-		}
-	case "DELETE":
-		err := sh.sec.DisableAuth()
-		if err != nil {
-			writeError(w, r, err)
-			return
-		}
-	}
-}
diff --git a/etcdserver/etcdhttp/client_auth_test.go b/etcdserver/etcdhttp/client_auth_test.go
deleted file mode 100644
index 4bf190e..0000000
--- a/etcdserver/etcdhttp/client_auth_test.go
+++ /dev/null
@@ -1,633 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package etcdhttp
-
-import (
-	"errors"
-	"net/http"
-	"net/http/httptest"
-	"path"
-	"strings"
-	"testing"
-
-	"github.com/coreos/etcd/etcdserver/auth"
-)
-
-const goodPassword = "good"
-
-func mustJSONRequest(t *testing.T, method string, p string, body string) *http.Request {
-	req, err := http.NewRequest(method, path.Join(authPrefix, p), strings.NewReader(body))
-	if err != nil {
-		t.Fatalf("Error making JSON request: %s %s %s\n", method, p, body)
-	}
-	req.Header.Set("Content-Type", "application/json")
-	return req
-}
-
-type mockAuthStore struct {
-	users   map[string]*auth.User
-	roles   map[string]*auth.Role
-	err     error
-	enabled bool
-}
-
-func (s *mockAuthStore) AllUsers() ([]string, error) { return []string{"alice", "bob", "root"}, s.err }
-func (s *mockAuthStore) GetUser(name string) (auth.User, error) {
-	u, ok := s.users[name]
-	if !ok {
-		return auth.User{}, s.err
-	}
-	return *u, s.err
-}
-func (s *mockAuthStore) CreateOrUpdateUser(user auth.User) (out auth.User, created bool, err error) {
-	if s.users == nil {
-		u, err := s.CreateUser(user)
-		return u, true, err
-	}
-	u, err := s.UpdateUser(user)
-	return u, false, err
-}
-func (s *mockAuthStore) CreateUser(user auth.User) (auth.User, error) { return user, s.err }
-func (s *mockAuthStore) DeleteUser(name string) error                 { return s.err }
-func (s *mockAuthStore) UpdateUser(user auth.User) (auth.User, error) {
-	return *s.users[user.User], s.err
-}
-func (s *mockAuthStore) AllRoles() ([]string, error) {
-	return []string{"awesome", "guest", "root"}, s.err
-}
-func (s *mockAuthStore) GetRole(name string) (auth.Role, error) { return *s.roles[name], s.err }
-func (s *mockAuthStore) CreateRole(role auth.Role) error        { return s.err }
-func (s *mockAuthStore) DeleteRole(name string) error           { return s.err }
-func (s *mockAuthStore) UpdateRole(role auth.Role) (auth.Role, error) {
-	return *s.roles[role.Role], s.err
-}
-func (s *mockAuthStore) AuthEnabled() bool  { return s.enabled }
-func (s *mockAuthStore) EnableAuth() error  { return s.err }
-func (s *mockAuthStore) DisableAuth() error { return s.err }
-
-func (s *mockAuthStore) CheckPassword(user auth.User, password string) bool {
-	return user.Password == password
-}
-
-func (s *mockAuthStore) HashPassword(password string) (string, error) {
-	return password, nil
-}
-
-func TestAuthFlow(t *testing.T) {
-	enableMapMu.Lock()
-	enabledMap = make(map[capability]bool)
-	enabledMap[authCapability] = true
-	enableMapMu.Unlock()
-	var testCases = []struct {
-		req   *http.Request
-		store mockAuthStore
-
-		wcode int
-		wbody string
-	}{
-		{
-			req:   mustJSONRequest(t, "PUT", "users/alice", `{{{{{{{`),
-			store: mockAuthStore{},
-			wcode: http.StatusBadRequest,
-			wbody: `{"message":"Invalid JSON in request body."}`,
-		},
-		{
-			req:   mustJSONRequest(t, "PUT", "users/alice", `{"user": "alice", "password": "goodpassword"}`),
-			store: mockAuthStore{enabled: true},
-			wcode: http.StatusUnauthorized,
-			wbody: `{"message":"Insufficient credentials"}`,
-		},
-		// Users
-		{
-			req: mustJSONRequest(t, "GET", "users", ""),
-			store: mockAuthStore{
-				users: map[string]*auth.User{
-					"alice": {
-						User:     "alice",
-						Roles:    []string{"alicerole", "guest"},
-						Password: "wheeee",
-					},
-					"bob": {
-						User:     "bob",
-						Roles:    []string{"guest"},
-						Password: "wheeee",
-					},
-					"root": {
-						User:     "root",
-						Roles:    []string{"root"},
-						Password: "wheeee",
-					},
-				},
-				roles: map[string]*auth.Role{
-					"alicerole": {
-						Role: "alicerole",
-					},
-					"guest": {
-						Role: "guest",
-					},
-					"root": {
-						Role: "root",
-					},
-				},
-			},
-			wcode: http.StatusOK,
-			wbody: `{"users":[` +
-				`{"user":"alice","roles":[` +
-				`{"role":"alicerole","permissions":{"kv":{"read":null,"write":null}}},` +
-				`{"role":"guest","permissions":{"kv":{"read":null,"write":null}}}` +
-				`]},` +
-				`{"user":"bob","roles":[{"role":"guest","permissions":{"kv":{"read":null,"write":null}}}]},` +
-				`{"user":"root","roles":[{"role":"root","permissions":{"kv":{"read":null,"write":null}}}]}]}`,
-		},
-		{
-			req: mustJSONRequest(t, "GET", "users/alice", ""),
-			store: mockAuthStore{
-				users: map[string]*auth.User{
-					"alice": {
-						User:     "alice",
-						Roles:    []string{"alicerole"},
-						Password: "wheeee",
-					},
-				},
-				roles: map[string]*auth.Role{
-					"alicerole": {
-						Role: "alicerole",
-					},
-				},
-			},
-			wcode: http.StatusOK,
-			wbody: `{"user":"alice","roles":[{"role":"alicerole","permissions":{"kv":{"read":null,"write":null}}}]}`,
-		},
-		{
-			req:   mustJSONRequest(t, "PUT", "users/alice", `{"user": "alice", "password": "goodpassword"}`),
-			store: mockAuthStore{},
-			wcode: http.StatusCreated,
-			wbody: `{"user":"alice","roles":null}`,
-		},
-		{
-			req:   mustJSONRequest(t, "DELETE", "users/alice", ``),
-			store: mockAuthStore{},
-			wcode: http.StatusOK,
-			wbody: ``,
-		},
-		{
-			req: mustJSONRequest(t, "PUT", "users/alice", `{"user": "alice", "password": "goodpassword"}`),
-			store: mockAuthStore{
-				users: map[string]*auth.User{
-					"alice": {
-						User:     "alice",
-						Roles:    []string{"alicerole", "guest"},
-						Password: "wheeee",
-					},
-				},
-			},
-			wcode: http.StatusOK,
-			wbody: `{"user":"alice","roles":["alicerole","guest"]}`,
-		},
-		{
-			req: mustJSONRequest(t, "PUT", "users/alice", `{"user": "alice", "grant": ["alicerole"]}`),
-			store: mockAuthStore{
-				users: map[string]*auth.User{
-					"alice": {
-						User:     "alice",
-						Roles:    []string{"alicerole", "guest"},
-						Password: "wheeee",
-					},
-				},
-			},
-			wcode: http.StatusOK,
-			wbody: `{"user":"alice","roles":["alicerole","guest"]}`,
-		},
-		{
-			req: mustJSONRequest(t, "GET", "users/alice", ``),
-			store: mockAuthStore{
-				users: map[string]*auth.User{},
-				err:   auth.Error{Status: http.StatusNotFound, Errmsg: "auth: User alice doesn't exist."},
-			},
-			wcode: http.StatusNotFound,
-			wbody: `{"message":"auth: User alice doesn't exist."}`,
-		},
-		{
-			req: mustJSONRequest(t, "GET", "roles/manager", ""),
-			store: mockAuthStore{
-				roles: map[string]*auth.Role{
-					"manager": {
-						Role: "manager",
-					},
-				},
-			},
-			wcode: http.StatusOK,
-			wbody: `{"role":"manager","permissions":{"kv":{"read":null,"write":null}}}`,
-		},
-		{
-			req:   mustJSONRequest(t, "DELETE", "roles/manager", ``),
-			store: mockAuthStore{},
-			wcode: http.StatusOK,
-			wbody: ``,
-		},
-		{
-			req:   mustJSONRequest(t, "PUT", "roles/manager", `{"role":"manager","permissions":{"kv":{"read":[],"write":[]}}}`),
-			store: mockAuthStore{},
-			wcode: http.StatusCreated,
-			wbody: `{"role":"manager","permissions":{"kv":{"read":[],"write":[]}}}`,
-		},
-		{
-			req: mustJSONRequest(t, "PUT", "roles/manager", `{"role":"manager","revoke":{"kv":{"read":["foo"],"write":[]}}}`),
-			store: mockAuthStore{
-				roles: map[string]*auth.Role{
-					"manager": {
-						Role: "manager",
-					},
-				},
-			},
-			wcode: http.StatusOK,
-			wbody: `{"role":"manager","permissions":{"kv":{"read":null,"write":null}}}`,
-		},
-		{
-			req: mustJSONRequest(t, "GET", "roles", ""),
-			store: mockAuthStore{
-				roles: map[string]*auth.Role{
-					"awesome": {
-						Role: "awesome",
-					},
-					"guest": {
-						Role: "guest",
-					},
-					"root": {
-						Role: "root",
-					},
-				},
-			},
-			wcode: http.StatusOK,
-			wbody: `{"roles":[{"role":"awesome","permissions":{"kv":{"read":null,"write":null}}},` +
-				`{"role":"guest","permissions":{"kv":{"read":null,"write":null}}},` +
-				`{"role":"root","permissions":{"kv":{"read":null,"write":null}}}]}`,
-		},
-		{
-			req: mustJSONRequest(t, "GET", "enable", ""),
-			store: mockAuthStore{
-				enabled: true,
-			},
-			wcode: http.StatusOK,
-			wbody: `{"enabled":true}`,
-		},
-		{
-			req: mustJSONRequest(t, "PUT", "enable", ""),
-			store: mockAuthStore{
-				enabled: false,
-			},
-			wcode: http.StatusOK,
-			wbody: ``,
-		},
-		{
-			req: (func() *http.Request {
-				req := mustJSONRequest(t, "DELETE", "enable", "")
-				req.SetBasicAuth("root", "good")
-				return req
-			})(),
-			store: mockAuthStore{
-				enabled: true,
-				users: map[string]*auth.User{
-					"root": {
-						User:     "root",
-						Password: goodPassword,
-						Roles:    []string{"root"},
-					},
-				},
-				roles: map[string]*auth.Role{
-					"root": {
-						Role: "root",
-					},
-				},
-			},
-			wcode: http.StatusOK,
-			wbody: ``,
-		},
-		{
-			req: (func() *http.Request {
-				req := mustJSONRequest(t, "DELETE", "enable", "")
-				req.SetBasicAuth("root", "bad")
-				return req
-			})(),
-			store: mockAuthStore{
-				enabled: true,
-				users: map[string]*auth.User{
-					"root": {
-						User:     "root",
-						Password: goodPassword,
-						Roles:    []string{"root"},
-					},
-				},
-				roles: map[string]*auth.Role{
-					"root": {
-						Role: "guest",
-					},
-				},
-			},
-			wcode: http.StatusUnauthorized,
-			wbody: `{"message":"Insufficient credentials"}`,
-		},
-	}
-
-	for i, tt := range testCases {
-		mux := http.NewServeMux()
-		h := &authHandler{
-			sec:     &tt.store,
-			cluster: &fakeCluster{id: 1},
-		}
-		handleAuth(mux, h)
-		rw := httptest.NewRecorder()
-		mux.ServeHTTP(rw, tt.req)
-		if rw.Code != tt.wcode {
-			t.Errorf("#%d: got code=%d, want %d", i, rw.Code, tt.wcode)
-		}
-		g := rw.Body.String()
-		g = strings.TrimSpace(g)
-		if g != tt.wbody {
-			t.Errorf("#%d: got body=%s, want %s", i, g, tt.wbody)
-		}
-	}
-}
-
-func mustAuthRequest(method, username, password string) *http.Request {
-	req, err := http.NewRequest(method, "path", strings.NewReader(""))
-	if err != nil {
-		panic("Cannot make auth request: " + err.Error())
-	}
-	req.SetBasicAuth(username, password)
-	return req
-}
-
-func TestPrefixAccess(t *testing.T) {
-	var table = []struct {
-		key                string
-		req                *http.Request
-		store              *mockAuthStore
-		hasRoot            bool
-		hasKeyPrefixAccess bool
-		hasRecursiveAccess bool
-	}{
-		{
-			key: "/foo",
-			req: mustAuthRequest("GET", "root", "good"),
-			store: &mockAuthStore{
-				users: map[string]*auth.User{
-					"root": {
-						User:     "root",
-						Password: goodPassword,
-						Roles:    []string{"root"},
-					},
-				},
-				roles: map[string]*auth.Role{
-					"root": {
-						Role: "root",
-					},
-				},
-				enabled: true,
-			},
-			hasRoot:            true,
-			hasKeyPrefixAccess: true,
-			hasRecursiveAccess: true,
-		},
-		{
-			key: "/foo",
-			req: mustAuthRequest("GET", "user", "good"),
-			store: &mockAuthStore{
-				users: map[string]*auth.User{
-					"user": {
-						User:     "user",
-						Password: goodPassword,
-						Roles:    []string{"foorole"},
-					},
-				},
-				roles: map[string]*auth.Role{
-					"foorole": {
-						Role: "foorole",
-						Permissions: auth.Permissions{
-							KV: auth.RWPermission{
-								Read:  []string{"/foo"},
-								Write: []string{"/foo"},
-							},
-						},
-					},
-				},
-				enabled: true,
-			},
-			hasRoot:            false,
-			hasKeyPrefixAccess: true,
-			hasRecursiveAccess: false,
-		},
-		{
-			key: "/foo",
-			req: mustAuthRequest("GET", "user", "good"),
-			store: &mockAuthStore{
-				users: map[string]*auth.User{
-					"user": {
-						User:     "user",
-						Password: goodPassword,
-						Roles:    []string{"foorole"},
-					},
-				},
-				roles: map[string]*auth.Role{
-					"foorole": {
-						Role: "foorole",
-						Permissions: auth.Permissions{
-							KV: auth.RWPermission{
-								Read:  []string{"/foo*"},
-								Write: []string{"/foo*"},
-							},
-						},
-					},
-				},
-				enabled: true,
-			},
-			hasRoot:            false,
-			hasKeyPrefixAccess: true,
-			hasRecursiveAccess: true,
-		},
-		{
-			key: "/foo",
-			req: mustAuthRequest("GET", "user", "bad"),
-			store: &mockAuthStore{
-				users: map[string]*auth.User{
-					"user": {
-						User:     "user",
-						Password: goodPassword,
-						Roles:    []string{"foorole"},
-					},
-				},
-				roles: map[string]*auth.Role{
-					"foorole": {
-						Role: "foorole",
-						Permissions: auth.Permissions{
-							KV: auth.RWPermission{
-								Read:  []string{"/foo*"},
-								Write: []string{"/foo*"},
-							},
-						},
-					},
-				},
-				enabled: true,
-			},
-			hasRoot:            false,
-			hasKeyPrefixAccess: false,
-			hasRecursiveAccess: false,
-		},
-		{
-			key: "/foo",
-			req: mustAuthRequest("GET", "user", "good"),
-			store: &mockAuthStore{
-				users:   map[string]*auth.User{},
-				err:     errors.New("Not the user"),
-				enabled: true,
-			},
-			hasRoot:            false,
-			hasKeyPrefixAccess: false,
-			hasRecursiveAccess: false,
-		},
-		{
-			key: "/foo",
-			req: mustJSONRequest(t, "GET", "somepath", ""),
-			store: &mockAuthStore{
-				users: map[string]*auth.User{
-					"user": {
-						User:     "user",
-						Password: goodPassword,
-						Roles:    []string{"foorole"},
-					},
-				},
-				roles: map[string]*auth.Role{
-					"guest": {
-						Role: "guest",
-						Permissions: auth.Permissions{
-							KV: auth.RWPermission{
-								Read:  []string{"/foo*"},
-								Write: []string{"/foo*"},
-							},
-						},
-					},
-				},
-				enabled: true,
-			},
-			hasRoot:            false,
-			hasKeyPrefixAccess: true,
-			hasRecursiveAccess: true,
-		},
-		{
-			key: "/bar",
-			req: mustJSONRequest(t, "GET", "somepath", ""),
-			store: &mockAuthStore{
-				users: map[string]*auth.User{
-					"user": {
-						User:     "user",
-						Password: goodPassword,
-						Roles:    []string{"foorole"},
-					},
-				},
-				roles: map[string]*auth.Role{
-					"guest": {
-						Role: "guest",
-						Permissions: auth.Permissions{
-							KV: auth.RWPermission{
-								Read:  []string{"/foo*"},
-								Write: []string{"/foo*"},
-							},
-						},
-					},
-				},
-				enabled: true,
-			},
-			hasRoot:            false,
-			hasKeyPrefixAccess: false,
-			hasRecursiveAccess: false,
-		},
-		// check access for multiple roles
-		{
-			key: "/foo",
-			req: mustAuthRequest("GET", "user", "good"),
-			store: &mockAuthStore{
-				users: map[string]*auth.User{
-					"user": {
-						User:     "user",
-						Password: goodPassword,
-						Roles:    []string{"role1", "role2"},
-					},
-				},
-				roles: map[string]*auth.Role{
-					"role1": {
-						Role: "role1",
-					},
-					"role2": {
-						Role: "role2",
-						Permissions: auth.Permissions{
-							KV: auth.RWPermission{
-								Read:  []string{"/foo"},
-								Write: []string{"/foo"},
-							},
-						},
-					},
-				},
-				enabled: true,
-			},
-			hasRoot:            false,
-			hasKeyPrefixAccess: true,
-			hasRecursiveAccess: false,
-		},
-		{
-			key: "/foo",
-			req: (func() *http.Request {
-				req := mustJSONRequest(t, "GET", "somepath", "")
-				req.Header.Set("Authorization", "malformedencoding")
-				return req
-			})(),
-			store: &mockAuthStore{
-				enabled: true,
-				users: map[string]*auth.User{
-					"root": {
-						User:     "root",
-						Password: goodPassword,
-						Roles:    []string{"root"},
-					},
-				},
-				roles: map[string]*auth.Role{
-					"guest": {
-						Role: "guest",
-						Permissions: auth.Permissions{
-							KV: auth.RWPermission{
-								Read:  []string{"/foo*"},
-								Write: []string{"/foo*"},
-							},
-						},
-					},
-				},
-			},
-			hasRoot:            false,
-			hasKeyPrefixAccess: false,
-			hasRecursiveAccess: false,
-		},
-	}
-
-	for i, tt := range table {
-		if tt.hasRoot != hasRootAccess(tt.store, tt.req) {
-			t.Errorf("#%d: hasRoot doesn't match (expected %v)", i, tt.hasRoot)
-		}
-		if tt.hasKeyPrefixAccess != hasKeyPrefixAccess(tt.store, tt.req, tt.key, false) {
-			t.Errorf("#%d: hasKeyPrefixAccess doesn't match (expected %v)", i, tt.hasRoot)
-		}
-		if tt.hasRecursiveAccess != hasKeyPrefixAccess(tt.store, tt.req, tt.key, true) {
-			t.Errorf("#%d: hasRecursiveAccess doesn't match (expected %v)", i, tt.hasRoot)
-		}
-	}
-}
diff --git a/etcdserver/etcdhttp/client_test.go b/etcdserver/etcdhttp/client_test.go
deleted file mode 100644
index 29cc6c7..0000000
--- a/etcdserver/etcdhttp/client_test.go
+++ /dev/null
@@ -1,2015 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package etcdhttp
-
-import (
-	"bytes"
-	"encoding/json"
-	"errors"
-	"io/ioutil"
-	"net/http"
-	"net/http/httptest"
-	"net/url"
-	"path"
-	"reflect"
-	"strings"
-	"testing"
-	"time"
-
-	etcdErr "github.com/coreos/etcd/error"
-	"github.com/coreos/etcd/etcdserver"
-	"github.com/coreos/etcd/etcdserver/etcdhttp/httptypes"
-	"github.com/coreos/etcd/etcdserver/etcdserverpb"
-	"github.com/coreos/etcd/pkg/testutil"
-	"github.com/coreos/etcd/pkg/types"
-	"github.com/coreos/etcd/raft/raftpb"
-	"github.com/coreos/etcd/store"
-	"github.com/coreos/etcd/version"
-	"github.com/coreos/go-semver/semver"
-	"github.com/jonboulle/clockwork"
-	"golang.org/x/net/context"
-)
-
-func mustMarshalEvent(t *testing.T, ev *store.Event) string {
-	b := new(bytes.Buffer)
-	if err := json.NewEncoder(b).Encode(ev); err != nil {
-		t.Fatalf("error marshalling event %#v: %v", ev, err)
-	}
-	return b.String()
-}
-
-// mustNewForm takes a set of Values and constructs a PUT *http.Request,
-// with a URL constructed from appending the given path to the standard keysPrefix
-func mustNewForm(t *testing.T, p string, vals url.Values) *http.Request {
-	u := testutil.MustNewURL(t, path.Join(keysPrefix, p))
-	req, err := http.NewRequest("PUT", u.String(), strings.NewReader(vals.Encode()))
-	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
-	if err != nil {
-		t.Fatalf("error creating new request: %v", err)
-	}
-	return req
-}
-
-// mustNewPostForm takes a set of Values and constructs a POST *http.Request,
-// with a URL constructed from appending the given path to the standard keysPrefix
-func mustNewPostForm(t *testing.T, p string, vals url.Values) *http.Request {
-	u := testutil.MustNewURL(t, path.Join(keysPrefix, p))
-	req, err := http.NewRequest("POST", u.String(), strings.NewReader(vals.Encode()))
-	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
-	if err != nil {
-		t.Fatalf("error creating new request: %v", err)
-	}
-	return req
-}
-
-// mustNewRequest takes a path, appends it to the standard keysPrefix, and constructs
-// a GET *http.Request referencing the resulting URL
-func mustNewRequest(t *testing.T, p string) *http.Request {
-	return mustNewMethodRequest(t, "GET", p)
-}
-
-func mustNewMethodRequest(t *testing.T, m, p string) *http.Request {
-	return &http.Request{
-		Method: m,
-		URL:    testutil.MustNewURL(t, path.Join(keysPrefix, p)),
-	}
-}
-
-type serverRecorder struct {
-	actions []action
-}
-
-func (s *serverRecorder) Start()           {}
-func (s *serverRecorder) Stop()            {}
-func (s *serverRecorder) Leader() types.ID { return types.ID(1) }
-func (s *serverRecorder) ID() types.ID     { return types.ID(1) }
-func (s *serverRecorder) Do(_ context.Context, r etcdserverpb.Request) (etcdserver.Response, error) {
-	s.actions = append(s.actions, action{name: "Do", params: []interface{}{r}})
-	return etcdserver.Response{}, nil
-}
-func (s *serverRecorder) Process(_ context.Context, m raftpb.Message) error {
-	s.actions = append(s.actions, action{name: "Process", params: []interface{}{m}})
-	return nil
-}
-func (s *serverRecorder) AddMember(_ context.Context, m etcdserver.Member) error {
-	s.actions = append(s.actions, action{name: "AddMember", params: []interface{}{m}})
-	return nil
-}
-func (s *serverRecorder) RemoveMember(_ context.Context, id uint64) error {
-	s.actions = append(s.actions, action{name: "RemoveMember", params: []interface{}{id}})
-	return nil
-}
-
-func (s *serverRecorder) UpdateMember(_ context.Context, m etcdserver.Member) error {
-	s.actions = append(s.actions, action{name: "UpdateMember", params: []interface{}{m}})
-	return nil
-}
-
-func (s *serverRecorder) ClusterVersion() *semver.Version { return nil }
-
-type action struct {
-	name   string
-	params []interface{}
-}
-
-// flushingRecorder provides a channel to allow users to block until the Recorder is Flushed()
-type flushingRecorder struct {
-	*httptest.ResponseRecorder
-	ch chan struct{}
-}
-
-func (fr *flushingRecorder) Flush() {
-	fr.ResponseRecorder.Flush()
-	fr.ch <- struct{}{}
-}
-
-// resServer implements the etcd.Server interface for testing.
-// It returns the given response from any Do calls, and nil error
-type resServer struct {
-	res etcdserver.Response
-}
-
-func (rs *resServer) Start()           {}
-func (rs *resServer) Stop()            {}
-func (rs *resServer) ID() types.ID     { return types.ID(1) }
-func (rs *resServer) Leader() types.ID { return types.ID(1) }
-func (rs *resServer) Do(_ context.Context, _ etcdserverpb.Request) (etcdserver.Response, error) {
-	return rs.res, nil
-}
-func (rs *resServer) Process(_ context.Context, _ raftpb.Message) error         { return nil }
-func (rs *resServer) AddMember(_ context.Context, _ etcdserver.Member) error    { return nil }
-func (rs *resServer) RemoveMember(_ context.Context, _ uint64) error            { return nil }
-func (rs *resServer) UpdateMember(_ context.Context, _ etcdserver.Member) error { return nil }
-func (rs *resServer) ClusterVersion() *semver.Version                           { return nil }
-
-func boolp(b bool) *bool { return &b }
-
-type dummyRaftTimer struct{}
-
-func (drt dummyRaftTimer) Index() uint64 { return uint64(100) }
-func (drt dummyRaftTimer) Term() uint64  { return uint64(5) }
-
-type dummyWatcher struct {
-	echan chan *store.Event
-	sidx  uint64
-}
-
-func (w *dummyWatcher) EventChan() chan *store.Event {
-	return w.echan
-}
-func (w *dummyWatcher) StartIndex() uint64 { return w.sidx }
-func (w *dummyWatcher) Remove()            {}
-
-func TestBadRefreshRequest(t *testing.T) {
-	tests := []struct {
-		in    *http.Request
-		wcode int
-	}{
-		{
-			mustNewRequest(t, "foo?refresh=true&value=test"),
-			etcdErr.EcodeRefreshValue,
-		},
-		{
-			mustNewRequest(t, "foo?refresh=true&value=10"),
-			etcdErr.EcodeRefreshValue,
-		},
-		{
-			mustNewRequest(t, "foo?refresh=true"),
-			etcdErr.EcodeRefreshTTLRequired,
-		},
-		{
-			mustNewRequest(t, "foo?refresh=true&ttl="),
-			etcdErr.EcodeRefreshTTLRequired,
-		},
-	}
-	for i, tt := range tests {
-		got, err := parseKeyRequest(tt.in, clockwork.NewFakeClock())
-		if err == nil {
-			t.Errorf("#%d: unexpected nil error!", i)
-			continue
-		}
-		ee, ok := err.(*etcdErr.Error)
-		if !ok {
-			t.Errorf("#%d: err is not etcd.Error!", i)
-			continue
-		}
-		if ee.ErrorCode != tt.wcode {
-			t.Errorf("#%d: code=%d, want %v", i, ee.ErrorCode, tt.wcode)
-			t.Logf("cause: %#v", ee.Cause)
-		}
-		if !reflect.DeepEqual(got, etcdserverpb.Request{}) {
-			t.Errorf("#%d: unexpected non-empty Request: %#v", i, got)
-		}
-	}
-}
-
-func TestBadParseRequest(t *testing.T) {
-	tests := []struct {
-		in    *http.Request
-		wcode int
-	}{
-		{
-			// parseForm failure
-			&http.Request{
-				Body:   nil,
-				Method: "PUT",
-			},
-			etcdErr.EcodeInvalidForm,
-		},
-		{
-			// bad key prefix
-			&http.Request{
-				URL: testutil.MustNewURL(t, "/badprefix/"),
-			},
-			etcdErr.EcodeInvalidForm,
-		},
-		// bad values for prevIndex, waitIndex, ttl
-		{
-			mustNewForm(t, "foo", url.Values{"prevIndex": []string{"garbage"}}),
-			etcdErr.EcodeIndexNaN,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"prevIndex": []string{"1.5"}}),
-			etcdErr.EcodeIndexNaN,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"prevIndex": []string{"-1"}}),
-			etcdErr.EcodeIndexNaN,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"waitIndex": []string{"garbage"}}),
-			etcdErr.EcodeIndexNaN,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"waitIndex": []string{"??"}}),
-			etcdErr.EcodeIndexNaN,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"ttl": []string{"-1"}}),
-			etcdErr.EcodeTTLNaN,
-		},
-		// bad values for recursive, sorted, wait, prevExist, dir, stream
-		{
-			mustNewForm(t, "foo", url.Values{"recursive": []string{"hahaha"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"recursive": []string{"1234"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"recursive": []string{"?"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"sorted": []string{"?"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"sorted": []string{"x"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"wait": []string{"?!"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"wait": []string{"yes"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"prevExist": []string{"yes"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"prevExist": []string{"#2"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"dir": []string{"no"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"dir": []string{"file"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"quorum": []string{"no"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"quorum": []string{"file"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"stream": []string{"zzz"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"stream": []string{"something"}}),
-			etcdErr.EcodeInvalidField,
-		},
-		// prevValue cannot be empty
-		{
-			mustNewForm(t, "foo", url.Values{"prevValue": []string{""}}),
-			etcdErr.EcodePrevValueRequired,
-		},
-		// wait is only valid with GET requests
-		{
-			mustNewMethodRequest(t, "HEAD", "foo?wait=true"),
-			etcdErr.EcodeInvalidField,
-		},
-		// query values are considered
-		{
-			mustNewRequest(t, "foo?prevExist=wrong"),
-			etcdErr.EcodeInvalidField,
-		},
-		{
-			mustNewRequest(t, "foo?ttl=wrong"),
-			etcdErr.EcodeTTLNaN,
-		},
-		// but body takes precedence if both are specified
-		{
-			mustNewForm(
-				t,
-				"foo?ttl=12",
-				url.Values{"ttl": []string{"garbage"}},
-			),
-			etcdErr.EcodeTTLNaN,
-		},
-		{
-			mustNewForm(
-				t,
-				"foo?prevExist=false",
-				url.Values{"prevExist": []string{"yes"}},
-			),
-			etcdErr.EcodeInvalidField,
-		},
-	}
-	for i, tt := range tests {
-		got, err := parseKeyRequest(tt.in, clockwork.NewFakeClock())
-		if err == nil {
-			t.Errorf("#%d: unexpected nil error!", i)
-			continue
-		}
-		ee, ok := err.(*etcdErr.Error)
-		if !ok {
-			t.Errorf("#%d: err is not etcd.Error!", i)
-			continue
-		}
-		if ee.ErrorCode != tt.wcode {
-			t.Errorf("#%d: code=%d, want %v", i, ee.ErrorCode, tt.wcode)
-			t.Logf("cause: %#v", ee.Cause)
-		}
-		if !reflect.DeepEqual(got, etcdserverpb.Request{}) {
-			t.Errorf("#%d: unexpected non-empty Request: %#v", i, got)
-		}
-	}
-}
-
-func TestGoodParseRequest(t *testing.T) {
-	fc := clockwork.NewFakeClock()
-	fc.Advance(1111)
-	tests := []struct {
-		in *http.Request
-		w  etcdserverpb.Request
-	}{
-		{
-			// good prefix, all other values default
-			mustNewRequest(t, "foo"),
-			etcdserverpb.Request{
-				Method: "GET",
-				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		{
-			// value specified
-			mustNewForm(
-				t,
-				"foo",
-				url.Values{"value": []string{"some_value"}},
-			),
-			etcdserverpb.Request{
-				Method: "PUT",
-				Val:    "some_value",
-				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		{
-			// prevIndex specified
-			mustNewForm(
-				t,
-				"foo",
-				url.Values{"prevIndex": []string{"98765"}},
-			),
-			etcdserverpb.Request{
-				Method:    "PUT",
-				PrevIndex: 98765,
-				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		{
-			// recursive specified
-			mustNewForm(
-				t,
-				"foo",
-				url.Values{"recursive": []string{"true"}},
-			),
-			etcdserverpb.Request{
-				Method:    "PUT",
-				Recursive: true,
-				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		{
-			// sorted specified
-			mustNewForm(
-				t,
-				"foo",
-				url.Values{"sorted": []string{"true"}},
-			),
-			etcdserverpb.Request{
-				Method: "PUT",
-				Sorted: true,
-				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		{
-			// quorum specified
-			mustNewForm(
-				t,
-				"foo",
-				url.Values{"quorum": []string{"true"}},
-			),
-			etcdserverpb.Request{
-				Method: "PUT",
-				Quorum: true,
-				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		{
-			// wait specified
-			mustNewRequest(t, "foo?wait=true"),
-			etcdserverpb.Request{
-				Method: "GET",
-				Wait:   true,
-				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		{
-			// empty TTL specified
-			mustNewRequest(t, "foo?ttl="),
-			etcdserverpb.Request{
-				Method:     "GET",
-				Path:       path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-				Expiration: 0,
-			},
-		},
-		{
-			// non-empty TTL specified
-			mustNewRequest(t, "foo?ttl=5678"),
-			etcdserverpb.Request{
-				Method:     "GET",
-				Path:       path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-				Expiration: fc.Now().Add(5678 * time.Second).UnixNano(),
-			},
-		},
-		{
-			// zero TTL specified
-			mustNewRequest(t, "foo?ttl=0"),
-			etcdserverpb.Request{
-				Method:     "GET",
-				Path:       path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-				Expiration: fc.Now().UnixNano(),
-			},
-		},
-		{
-			// dir specified
-			mustNewRequest(t, "foo?dir=true"),
-			etcdserverpb.Request{
-				Method: "GET",
-				Dir:    true,
-				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		{
-			// dir specified negatively
-			mustNewRequest(t, "foo?dir=false"),
-			etcdserverpb.Request{
-				Method: "GET",
-				Dir:    false,
-				Path:   path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		{
-			// prevExist should be non-null if specified
-			mustNewForm(
-				t,
-				"foo",
-				url.Values{"prevExist": []string{"true"}},
-			),
-			etcdserverpb.Request{
-				Method:    "PUT",
-				PrevExist: boolp(true),
-				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		{
-			// prevExist should be non-null if specified
-			mustNewForm(
-				t,
-				"foo",
-				url.Values{"prevExist": []string{"false"}},
-			),
-			etcdserverpb.Request{
-				Method:    "PUT",
-				PrevExist: boolp(false),
-				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		// mix various fields
-		{
-			mustNewForm(
-				t,
-				"foo",
-				url.Values{
-					"value":     []string{"some value"},
-					"prevExist": []string{"true"},
-					"prevValue": []string{"previous value"},
-				},
-			),
-			etcdserverpb.Request{
-				Method:    "PUT",
-				PrevExist: boolp(true),
-				PrevValue: "previous value",
-				Val:       "some value",
-				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		// query parameters should be used if given
-		{
-			mustNewForm(
-				t,
-				"foo?prevValue=woof",
-				url.Values{},
-			),
-			etcdserverpb.Request{
-				Method:    "PUT",
-				PrevValue: "woof",
-				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-		// but form values should take precedence over query parameters
-		{
-			mustNewForm(
-				t,
-				"foo?prevValue=woof",
-				url.Values{
-					"prevValue": []string{"miaow"},
-				},
-			),
-			etcdserverpb.Request{
-				Method:    "PUT",
-				PrevValue: "miaow",
-				Path:      path.Join(etcdserver.StoreKeysPrefix, "/foo"),
-			},
-		},
-	}
-
-	for i, tt := range tests {
-		got, err := parseKeyRequest(tt.in, fc)
-		if err != nil {
-			t.Errorf("#%d: err = %v, want %v", i, err, nil)
-		}
-		if !reflect.DeepEqual(got, tt.w) {
-			t.Errorf("#%d: request=%#v, want %#v", i, got, tt.w)
-		}
-	}
-}
-
-func TestServeMembers(t *testing.T) {
-	memb1 := etcdserver.Member{ID: 12, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8080"}}}
-	memb2 := etcdserver.Member{ID: 13, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8081"}}}
-	cluster := &fakeCluster{
-		id:      1,
-		members: map[uint64]*etcdserver.Member{1: &memb1, 2: &memb2},
-	}
-	h := &membersHandler{
-		server:  &serverRecorder{},
-		clock:   clockwork.NewFakeClock(),
-		cluster: cluster,
-	}
-
-	wmc := string(`{"members":[{"id":"c","name":"","peerURLs":[],"clientURLs":["http://localhost:8080"]},{"id":"d","name":"","peerURLs":[],"clientURLs":["http://localhost:8081"]}]}`)
-
-	tests := []struct {
-		path  string
-		wcode int
-		wct   string
-		wbody string
-	}{
-		{membersPrefix, http.StatusOK, "application/json", wmc + "\n"},
-		{membersPrefix + "/", http.StatusOK, "application/json", wmc + "\n"},
-		{path.Join(membersPrefix, "100"), http.StatusNotFound, "application/json", `{"message":"Not found"}`},
-		{path.Join(membersPrefix, "foobar"), http.StatusNotFound, "application/json", `{"message":"Not found"}`},
-	}
-
-	for i, tt := range tests {
-		req, err := http.NewRequest("GET", testutil.MustNewURL(t, tt.path).String(), nil)
-		if err != nil {
-			t.Fatal(err)
-		}
-		rw := httptest.NewRecorder()
-		h.ServeHTTP(rw, req)
-
-		if rw.Code != tt.wcode {
-			t.Errorf("#%d: code=%d, want %d", i, rw.Code, tt.wcode)
-		}
-		if gct := rw.Header().Get("Content-Type"); gct != tt.wct {
-			t.Errorf("#%d: content-type = %s, want %s", i, gct, tt.wct)
-		}
-		gcid := rw.Header().Get("X-Etcd-Cluster-ID")
-		wcid := cluster.ID().String()
-		if gcid != wcid {
-			t.Errorf("#%d: cid = %s, want %s", i, gcid, wcid)
-		}
-		if rw.Body.String() != tt.wbody {
-			t.Errorf("#%d: body = %q, want %q", i, rw.Body.String(), tt.wbody)
-		}
-	}
-}
-
-// TODO: consolidate **ALL** fake server implementations and add no leader test case.
-func TestServeLeader(t *testing.T) {
-	memb1 := etcdserver.Member{ID: 1, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8080"}}}
-	memb2 := etcdserver.Member{ID: 2, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8081"}}}
-	cluster := &fakeCluster{
-		id:      1,
-		members: map[uint64]*etcdserver.Member{1: &memb1, 2: &memb2},
-	}
-	h := &membersHandler{
-		server:  &serverRecorder{},
-		clock:   clockwork.NewFakeClock(),
-		cluster: cluster,
-	}
-
-	wmc := string(`{"id":"1","name":"","peerURLs":[],"clientURLs":["http://localhost:8080"]}`)
-
-	tests := []struct {
-		path  string
-		wcode int
-		wct   string
-		wbody string
-	}{
-		{membersPrefix + "leader", http.StatusOK, "application/json", wmc + "\n"},
-		// TODO: add no leader case
-	}
-
-	for i, tt := range tests {
-		req, err := http.NewRequest("GET", testutil.MustNewURL(t, tt.path).String(), nil)
-		if err != nil {
-			t.Fatal(err)
-		}
-		rw := httptest.NewRecorder()
-		h.ServeHTTP(rw, req)
-
-		if rw.Code != tt.wcode {
-			t.Errorf("#%d: code=%d, want %d", i, rw.Code, tt.wcode)
-		}
-		if gct := rw.Header().Get("Content-Type"); gct != tt.wct {
-			t.Errorf("#%d: content-type = %s, want %s", i, gct, tt.wct)
-		}
-		gcid := rw.Header().Get("X-Etcd-Cluster-ID")
-		wcid := cluster.ID().String()
-		if gcid != wcid {
-			t.Errorf("#%d: cid = %s, want %s", i, gcid, wcid)
-		}
-		if rw.Body.String() != tt.wbody {
-			t.Errorf("#%d: body = %q, want %q", i, rw.Body.String(), tt.wbody)
-		}
-	}
-}
-
-func TestServeMembersCreate(t *testing.T) {
-	u := testutil.MustNewURL(t, membersPrefix)
-	b := []byte(`{"peerURLs":["http://127.0.0.1:1"]}`)
-	req, err := http.NewRequest("POST", u.String(), bytes.NewReader(b))
-	if err != nil {
-		t.Fatal(err)
-	}
-	req.Header.Set("Content-Type", "application/json")
-	s := &serverRecorder{}
-	h := &membersHandler{
-		server:  s,
-		clock:   clockwork.NewFakeClock(),
-		cluster: &fakeCluster{id: 1},
-	}
-	rw := httptest.NewRecorder()
-
-	h.ServeHTTP(rw, req)
-
-	wcode := http.StatusCreated
-	if rw.Code != wcode {
-		t.Errorf("code=%d, want %d", rw.Code, wcode)
-	}
-
-	wct := "application/json"
-	if gct := rw.Header().Get("Content-Type"); gct != wct {
-		t.Errorf("content-type = %s, want %s", gct, wct)
-	}
-	gcid := rw.Header().Get("X-Etcd-Cluster-ID")
-	wcid := h.cluster.ID().String()
-	if gcid != wcid {
-		t.Errorf("cid = %s, want %s", gcid, wcid)
-	}
-
-	wb := `{"id":"2a86a83729b330d5","name":"","peerURLs":["http://127.0.0.1:1"],"clientURLs":[]}` + "\n"
-	g := rw.Body.String()
-	if g != wb {
-		t.Errorf("got body=%q, want %q", g, wb)
-	}
-
-	wm := etcdserver.Member{
-		ID: 3064321551348478165,
-		RaftAttributes: etcdserver.RaftAttributes{
-			PeerURLs: []string{"http://127.0.0.1:1"},
-		},
-	}
-
-	wactions := []action{{name: "AddMember", params: []interface{}{wm}}}
-	if !reflect.DeepEqual(s.actions, wactions) {
-		t.Errorf("actions = %+v, want %+v", s.actions, wactions)
-	}
-}
-
-func TestServeMembersDelete(t *testing.T) {
-	req := &http.Request{
-		Method: "DELETE",
-		URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "BEEF")),
-	}
-	s := &serverRecorder{}
-	h := &membersHandler{
-		server:  s,
-		cluster: &fakeCluster{id: 1},
-	}
-	rw := httptest.NewRecorder()
-
-	h.ServeHTTP(rw, req)
-
-	wcode := http.StatusNoContent
-	if rw.Code != wcode {
-		t.Errorf("code=%d, want %d", rw.Code, wcode)
-	}
-	gcid := rw.Header().Get("X-Etcd-Cluster-ID")
-	wcid := h.cluster.ID().String()
-	if gcid != wcid {
-		t.Errorf("cid = %s, want %s", gcid, wcid)
-	}
-	g := rw.Body.String()
-	if g != "" {
-		t.Errorf("got body=%q, want %q", g, "")
-	}
-	wactions := []action{{name: "RemoveMember", params: []interface{}{uint64(0xBEEF)}}}
-	if !reflect.DeepEqual(s.actions, wactions) {
-		t.Errorf("actions = %+v, want %+v", s.actions, wactions)
-	}
-}
-
-func TestServeMembersUpdate(t *testing.T) {
-	u := testutil.MustNewURL(t, path.Join(membersPrefix, "1"))
-	b := []byte(`{"peerURLs":["http://127.0.0.1:1"]}`)
-	req, err := http.NewRequest("PUT", u.String(), bytes.NewReader(b))
-	if err != nil {
-		t.Fatal(err)
-	}
-	req.Header.Set("Content-Type", "application/json")
-	s := &serverRecorder{}
-	h := &membersHandler{
-		server:  s,
-		clock:   clockwork.NewFakeClock(),
-		cluster: &fakeCluster{id: 1},
-	}
-	rw := httptest.NewRecorder()
-
-	h.ServeHTTP(rw, req)
-
-	wcode := http.StatusNoContent
-	if rw.Code != wcode {
-		t.Errorf("code=%d, want %d", rw.Code, wcode)
-	}
-
-	gcid := rw.Header().Get("X-Etcd-Cluster-ID")
-	wcid := h.cluster.ID().String()
-	if gcid != wcid {
-		t.Errorf("cid = %s, want %s", gcid, wcid)
-	}
-
-	wm := etcdserver.Member{
-		ID: 1,
-		RaftAttributes: etcdserver.RaftAttributes{
-			PeerURLs: []string{"http://127.0.0.1:1"},
-		},
-	}
-
-	wactions := []action{{name: "UpdateMember", params: []interface{}{wm}}}
-	if !reflect.DeepEqual(s.actions, wactions) {
-		t.Errorf("actions = %+v, want %+v", s.actions, wactions)
-	}
-}
-
-func TestServeMembersFail(t *testing.T) {
-	tests := []struct {
-		req    *http.Request
-		server etcdserver.Server
-
-		wcode int
-	}{
-		{
-			// bad method
-			&http.Request{
-				Method: "CONNECT",
-			},
-			&resServer{},
-
-			http.StatusMethodNotAllowed,
-		},
-		{
-			// bad method
-			&http.Request{
-				Method: "TRACE",
-			},
-			&resServer{},
-
-			http.StatusMethodNotAllowed,
-		},
-		{
-			// parse body error
-			&http.Request{
-				URL:    testutil.MustNewURL(t, membersPrefix),
-				Method: "POST",
-				Body:   ioutil.NopCloser(strings.NewReader("bad json")),
-				Header: map[string][]string{"Content-Type": {"application/json"}},
-			},
-			&resServer{},
-
-			http.StatusBadRequest,
-		},
-		{
-			// bad content type
-			&http.Request{
-				URL:    testutil.MustNewURL(t, membersPrefix),
-				Method: "POST",
-				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
-				Header: map[string][]string{"Content-Type": {"application/bad"}},
-			},
-			&errServer{},
-
-			http.StatusUnsupportedMediaType,
-		},
-		{
-			// bad url
-			&http.Request{
-				URL:    testutil.MustNewURL(t, membersPrefix),
-				Method: "POST",
-				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://a"]}`)),
-				Header: map[string][]string{"Content-Type": {"application/json"}},
-			},
-			&errServer{},
-
-			http.StatusBadRequest,
-		},
-		{
-			// etcdserver.AddMember error
-			&http.Request{
-				URL:    testutil.MustNewURL(t, membersPrefix),
-				Method: "POST",
-				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
-				Header: map[string][]string{"Content-Type": {"application/json"}},
-			},
-			&errServer{
-				errors.New("Error while adding a member"),
-			},
-
-			http.StatusInternalServerError,
-		},
-		{
-			// etcdserver.AddMember error
-			&http.Request{
-				URL:    testutil.MustNewURL(t, membersPrefix),
-				Method: "POST",
-				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
-				Header: map[string][]string{"Content-Type": {"application/json"}},
-			},
-			&errServer{
-				etcdserver.ErrIDExists,
-			},
-
-			http.StatusConflict,
-		},
-		{
-			// etcdserver.AddMember error
-			&http.Request{
-				URL:    testutil.MustNewURL(t, membersPrefix),
-				Method: "POST",
-				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
-				Header: map[string][]string{"Content-Type": {"application/json"}},
-			},
-			&errServer{
-				etcdserver.ErrPeerURLexists,
-			},
-
-			http.StatusConflict,
-		},
-		{
-			// etcdserver.RemoveMember error with arbitrary server error
-			&http.Request{
-				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "1")),
-				Method: "DELETE",
-			},
-			&errServer{
-				errors.New("Error while removing member"),
-			},
-
-			http.StatusInternalServerError,
-		},
-		{
-			// etcdserver.RemoveMember error with previously removed ID
-			&http.Request{
-				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
-				Method: "DELETE",
-			},
-			&errServer{
-				etcdserver.ErrIDRemoved,
-			},
-
-			http.StatusGone,
-		},
-		{
-			// etcdserver.RemoveMember error with nonexistent ID
-			&http.Request{
-				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
-				Method: "DELETE",
-			},
-			&errServer{
-				etcdserver.ErrIDNotFound,
-			},
-
-			http.StatusNotFound,
-		},
-		{
-			// etcdserver.RemoveMember error with badly formed ID
-			&http.Request{
-				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "bad_id")),
-				Method: "DELETE",
-			},
-			nil,
-
-			http.StatusNotFound,
-		},
-		{
-			// etcdserver.RemoveMember with no ID
-			&http.Request{
-				URL:    testutil.MustNewURL(t, membersPrefix),
-				Method: "DELETE",
-			},
-			nil,
-
-			http.StatusMethodNotAllowed,
-		},
-		{
-			// parse body error
-			&http.Request{
-				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
-				Method: "PUT",
-				Body:   ioutil.NopCloser(strings.NewReader("bad json")),
-				Header: map[string][]string{"Content-Type": {"application/json"}},
-			},
-			&resServer{},
-
-			http.StatusBadRequest,
-		},
-		{
-			// bad content type
-			&http.Request{
-				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
-				Method: "PUT",
-				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
-				Header: map[string][]string{"Content-Type": {"application/bad"}},
-			},
-			&errServer{},
-
-			http.StatusUnsupportedMediaType,
-		},
-		{
-			// bad url
-			&http.Request{
-				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
-				Method: "PUT",
-				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://a"]}`)),
-				Header: map[string][]string{"Content-Type": {"application/json"}},
-			},
-			&errServer{},
-
-			http.StatusBadRequest,
-		},
-		{
-			// etcdserver.UpdateMember error
-			&http.Request{
-				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
-				Method: "PUT",
-				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
-				Header: map[string][]string{"Content-Type": {"application/json"}},
-			},
-			&errServer{
-				errors.New("blah"),
-			},
-
-			http.StatusInternalServerError,
-		},
-		{
-			// etcdserver.UpdateMember error
-			&http.Request{
-				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
-				Method: "PUT",
-				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
-				Header: map[string][]string{"Content-Type": {"application/json"}},
-			},
-			&errServer{
-				etcdserver.ErrPeerURLexists,
-			},
-
-			http.StatusConflict,
-		},
-		{
-			// etcdserver.UpdateMember error
-			&http.Request{
-				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "0")),
-				Method: "PUT",
-				Body:   ioutil.NopCloser(strings.NewReader(`{"PeerURLs": ["http://127.0.0.1:1"]}`)),
-				Header: map[string][]string{"Content-Type": {"application/json"}},
-			},
-			&errServer{
-				etcdserver.ErrIDNotFound,
-			},
-
-			http.StatusNotFound,
-		},
-		{
-			// etcdserver.UpdateMember error with badly formed ID
-			&http.Request{
-				URL:    testutil.MustNewURL(t, path.Join(membersPrefix, "bad_id")),
-				Method: "PUT",
-			},
-			nil,
-
-			http.StatusNotFound,
-		},
-		{
-			// etcdserver.UpdateMember with no ID
-			&http.Request{
-				URL:    testutil.MustNewURL(t, membersPrefix),
-				Method: "PUT",
-			},
-			nil,
-
-			http.StatusMethodNotAllowed,
-		},
-	}
-	for i, tt := range tests {
-		h := &membersHandler{
-			server:  tt.server,
-			cluster: &fakeCluster{id: 1},
-			clock:   clockwork.NewFakeClock(),
-		}
-		rw := httptest.NewRecorder()
-		h.ServeHTTP(rw, tt.req)
-		if rw.Code != tt.wcode {
-			t.Errorf("#%d: code=%d, want %d", i, rw.Code, tt.wcode)
-		}
-		if rw.Code != http.StatusMethodNotAllowed {
-			gcid := rw.Header().Get("X-Etcd-Cluster-ID")
-			wcid := h.cluster.ID().String()
-			if gcid != wcid {
-				t.Errorf("#%d: cid = %s, want %s", i, gcid, wcid)
-			}
-		}
-	}
-}
-
-func TestWriteEvent(t *testing.T) {
-	// nil event should not panic
-	rec := httptest.NewRecorder()
-	writeKeyEvent(rec, nil, dummyRaftTimer{})
-	h := rec.Header()
-	if len(h) > 0 {
-		t.Fatalf("unexpected non-empty headers: %#v", h)
-	}
-	b := rec.Body.String()
-	if len(b) > 0 {
-		t.Fatalf("unexpected non-empty body: %q", b)
-	}
-
-	tests := []struct {
-		ev  *store.Event
-		idx string
-		// TODO(jonboulle): check body as well as just status code
-		code int
-		err  error
-	}{
-		// standard case, standard 200 response
-		{
-			&store.Event{
-				Action:   store.Get,
-				Node:     &store.NodeExtern{},
-				PrevNode: &store.NodeExtern{},
-			},
-			"0",
-			http.StatusOK,
-			nil,
-		},
-		// check new nodes return StatusCreated
-		{
-			&store.Event{
-				Action:   store.Create,
-				Node:     &store.NodeExtern{},
-				PrevNode: &store.NodeExtern{},
-			},
-			"0",
-			http.StatusCreated,
-			nil,
-		},
-	}
-
-	for i, tt := range tests {
-		rw := httptest.NewRecorder()
-		writeKeyEvent(rw, tt.ev, dummyRaftTimer{})
-		if gct := rw.Header().Get("Content-Type"); gct != "application/json" {
-			t.Errorf("case %d: bad Content-Type: got %q, want application/json", i, gct)
-		}
-		if gri := rw.Header().Get("X-Raft-Index"); gri != "100" {
-			t.Errorf("case %d: bad X-Raft-Index header: got %s, want %s", i, gri, "100")
-		}
-		if grt := rw.Header().Get("X-Raft-Term"); grt != "5" {
-			t.Errorf("case %d: bad X-Raft-Term header: got %s, want %s", i, grt, "5")
-		}
-		if gei := rw.Header().Get("X-Etcd-Index"); gei != tt.idx {
-			t.Errorf("case %d: bad X-Etcd-Index header: got %s, want %s", i, gei, tt.idx)
-		}
-		if rw.Code != tt.code {
-			t.Errorf("case %d: bad response code: got %d, want %v", i, rw.Code, tt.code)
-		}
-
-	}
-}
-
-func TestV2DeprecatedMachinesEndpoint(t *testing.T) {
-	tests := []struct {
-		method string
-		wcode  int
-	}{
-		{"GET", http.StatusOK},
-		{"HEAD", http.StatusOK},
-		{"POST", http.StatusMethodNotAllowed},
-	}
-
-	m := &deprecatedMachinesHandler{cluster: &fakeCluster{}}
-	s := httptest.NewServer(m)
-	defer s.Close()
-
-	for _, tt := range tests {
-		req, err := http.NewRequest(tt.method, s.URL+deprecatedMachinesPrefix, nil)
-		if err != nil {
-			t.Fatal(err)
-		}
-		resp, err := http.DefaultClient.Do(req)
-		if err != nil {
-			t.Fatal(err)
-		}
-
-		if resp.StatusCode != tt.wcode {
-			t.Errorf("StatusCode = %d, expected %d", resp.StatusCode, tt.wcode)
-		}
-	}
-}
-
-func TestServeMachines(t *testing.T) {
-	cluster := &fakeCluster{
-		clientURLs: []string{"http://localhost:8080", "http://localhost:8081", "http://localhost:8082"},
-	}
-	writer := httptest.NewRecorder()
-	req, err := http.NewRequest("GET", "", nil)
-	if err != nil {
-		t.Fatal(err)
-	}
-	h := &deprecatedMachinesHandler{cluster: cluster}
-	h.ServeHTTP(writer, req)
-	w := "http://localhost:8080, http://localhost:8081, http://localhost:8082"
-	if g := writer.Body.String(); g != w {
-		t.Errorf("body = %s, want %s", g, w)
-	}
-	if writer.Code != http.StatusOK {
-		t.Errorf("code = %d, want %d", writer.Code, http.StatusOK)
-	}
-}
-
-func TestGetID(t *testing.T) {
-	tests := []struct {
-		path string
-
-		wok   bool
-		wid   types.ID
-		wcode int
-	}{
-		{
-			"123",
-			true, 0x123, http.StatusOK,
-		},
-		{
-			"bad_id",
-			false, 0, http.StatusNotFound,
-		},
-		{
-			"",
-			false, 0, http.StatusMethodNotAllowed,
-		},
-	}
-
-	for i, tt := range tests {
-		w := httptest.NewRecorder()
-		id, ok := getID(tt.path, w)
-		if id != tt.wid {
-			t.Errorf("#%d: id = %d, want %d", i, id, tt.wid)
-		}
-		if ok != tt.wok {
-			t.Errorf("#%d: ok = %t, want %t", i, ok, tt.wok)
-		}
-		if w.Code != tt.wcode {
-			t.Errorf("#%d code = %d, want %d", i, w.Code, tt.wcode)
-		}
-	}
-}
-
-type dummyStats struct {
-	data []byte
-}
-
-func (ds *dummyStats) SelfStats() []byte                 { return ds.data }
-func (ds *dummyStats) LeaderStats() []byte               { return ds.data }
-func (ds *dummyStats) StoreStats() []byte                { return ds.data }
-func (ds *dummyStats) UpdateRecvApp(_ types.ID, _ int64) {}
-
-func TestServeSelfStats(t *testing.T) {
-	wb := []byte("some statistics")
-	w := string(wb)
-	sh := &statsHandler{
-		stats: &dummyStats{data: wb},
-	}
-	rw := httptest.NewRecorder()
-	sh.serveSelf(rw, &http.Request{Method: "GET"})
-	if rw.Code != http.StatusOK {
-		t.Errorf("code = %d, want %d", rw.Code, http.StatusOK)
-	}
-	wct := "application/json"
-	if gct := rw.Header().Get("Content-Type"); gct != wct {
-		t.Errorf("Content-Type = %q, want %q", gct, wct)
-	}
-	if g := rw.Body.String(); g != w {
-		t.Errorf("body = %s, want %s", g, w)
-	}
-}
-
-func TestSelfServeStatsBad(t *testing.T) {
-	for _, m := range []string{"PUT", "POST", "DELETE"} {
-		sh := &statsHandler{}
-		rw := httptest.NewRecorder()
-		sh.serveSelf(
-			rw,
-			&http.Request{
-				Method: m,
-			},
-		)
-		if rw.Code != http.StatusMethodNotAllowed {
-			t.Errorf("method %s: code=%d, want %d", m, rw.Code, http.StatusMethodNotAllowed)
-		}
-	}
-}
-
-func TestLeaderServeStatsBad(t *testing.T) {
-	for _, m := range []string{"PUT", "POST", "DELETE"} {
-		sh := &statsHandler{}
-		rw := httptest.NewRecorder()
-		sh.serveLeader(
-			rw,
-			&http.Request{
-				Method: m,
-			},
-		)
-		if rw.Code != http.StatusMethodNotAllowed {
-			t.Errorf("method %s: code=%d, want %d", m, rw.Code, http.StatusMethodNotAllowed)
-		}
-	}
-}
-
-func TestServeLeaderStats(t *testing.T) {
-	wb := []byte("some statistics")
-	w := string(wb)
-	sh := &statsHandler{
-		stats: &dummyStats{data: wb},
-	}
-	rw := httptest.NewRecorder()
-	sh.serveLeader(rw, &http.Request{Method: "GET"})
-	if rw.Code != http.StatusOK {
-		t.Errorf("code = %d, want %d", rw.Code, http.StatusOK)
-	}
-	wct := "application/json"
-	if gct := rw.Header().Get("Content-Type"); gct != wct {
-		t.Errorf("Content-Type = %q, want %q", gct, wct)
-	}
-	if g := rw.Body.String(); g != w {
-		t.Errorf("body = %s, want %s", g, w)
-	}
-}
-
-func TestServeStoreStats(t *testing.T) {
-	wb := []byte("some statistics")
-	w := string(wb)
-	sh := &statsHandler{
-		stats: &dummyStats{data: wb},
-	}
-	rw := httptest.NewRecorder()
-	sh.serveStore(rw, &http.Request{Method: "GET"})
-	if rw.Code != http.StatusOK {
-		t.Errorf("code = %d, want %d", rw.Code, http.StatusOK)
-	}
-	wct := "application/json"
-	if gct := rw.Header().Get("Content-Type"); gct != wct {
-		t.Errorf("Content-Type = %q, want %q", gct, wct)
-	}
-	if g := rw.Body.String(); g != w {
-		t.Errorf("body = %s, want %s", g, w)
-	}
-
-}
-
-func TestServeVersion(t *testing.T) {
-	req, err := http.NewRequest("GET", "", nil)
-	if err != nil {
-		t.Fatalf("error creating request: %v", err)
-	}
-	rw := httptest.NewRecorder()
-	serveVersion(rw, req, "2.1.0")
-	if rw.Code != http.StatusOK {
-		t.Errorf("code=%d, want %d", rw.Code, http.StatusOK)
-	}
-	vs := version.Versions{
-		Server:  version.Version,
-		Cluster: "2.1.0",
-	}
-	w, err := json.Marshal(&vs)
-	if err != nil {
-		t.Fatal(err)
-	}
-	if g := rw.Body.String(); g != string(w) {
-		t.Fatalf("body = %q, want %q", g, string(w))
-	}
-	if ct := rw.HeaderMap.Get("Content-Type"); ct != "application/json" {
-		t.Errorf("contet-type header = %s, want %s", ct, "application/json")
-	}
-}
-
-func TestServeVersionFails(t *testing.T) {
-	for _, m := range []string{
-		"CONNECT", "TRACE", "PUT", "POST", "HEAD",
-	} {
-		req, err := http.NewRequest(m, "", nil)
-		if err != nil {
-			t.Fatalf("error creating request: %v", err)
-		}
-		rw := httptest.NewRecorder()
-		serveVersion(rw, req, "2.1.0")
-		if rw.Code != http.StatusMethodNotAllowed {
-			t.Errorf("method %s: code=%d, want %d", m, rw.Code, http.StatusMethodNotAllowed)
-		}
-	}
-}
-
-func TestBadServeKeys(t *testing.T) {
-	testBadCases := []struct {
-		req    *http.Request
-		server etcdserver.Server
-
-		wcode int
-		wbody string
-	}{
-		{
-			// bad method
-			&http.Request{
-				Method: "CONNECT",
-			},
-			&resServer{},
-
-			http.StatusMethodNotAllowed,
-			"Method Not Allowed",
-		},
-		{
-			// bad method
-			&http.Request{
-				Method: "TRACE",
-			},
-			&resServer{},
-
-			http.StatusMethodNotAllowed,
-			"Method Not Allowed",
-		},
-		{
-			// parseRequest error
-			&http.Request{
-				Body:   nil,
-				Method: "PUT",
-			},
-			&resServer{},
-
-			http.StatusBadRequest,
-			`{"errorCode":210,"message":"Invalid POST form","cause":"missing form body","index":0}`,
-		},
-		{
-			// etcdserver.Server error
-			mustNewRequest(t, "foo"),
-			&errServer{
-				errors.New("Internal Server Error"),
-			},
-
-			http.StatusInternalServerError,
-			`{"errorCode":300,"message":"Raft Internal Error","cause":"Internal Server Error","index":0}`,
-		},
-		{
-			// etcdserver.Server etcd error
-			mustNewRequest(t, "foo"),
-			&errServer{
-				etcdErr.NewError(etcdErr.EcodeKeyNotFound, "/1/pant", 0),
-			},
-
-			http.StatusNotFound,
-			`{"errorCode":100,"message":"Key not found","cause":"/pant","index":0}`,
-		},
-		{
-			// non-event/watcher response from etcdserver.Server
-			mustNewRequest(t, "foo"),
-			&resServer{
-				etcdserver.Response{},
-			},
-
-			http.StatusInternalServerError,
-			`{"errorCode":300,"message":"Raft Internal Error","cause":"received response with no Event/Watcher!","index":0}`,
-		},
-	}
-	for i, tt := range testBadCases {
-		h := &keysHandler{
-			timeout: 0, // context times out immediately
-			server:  tt.server,
-			cluster: &fakeCluster{id: 1},
-		}
-		rw := httptest.NewRecorder()
-		h.ServeHTTP(rw, tt.req)
-		if rw.Code != tt.wcode {
-			t.Errorf("#%d: got code=%d, want %d", i, rw.Code, tt.wcode)
-		}
-		if rw.Code != http.StatusMethodNotAllowed {
-			gcid := rw.Header().Get("X-Etcd-Cluster-ID")
-			wcid := h.cluster.ID().String()
-			if gcid != wcid {
-				t.Errorf("#%d: cid = %s, want %s", i, gcid, wcid)
-			}
-		}
-		if g := strings.TrimSuffix(rw.Body.String(), "\n"); g != tt.wbody {
-			t.Errorf("#%d: body = %s, want %s", i, g, tt.wbody)
-		}
-	}
-}
-
-func TestServeKeysGood(t *testing.T) {
-	tests := []struct {
-		req   *http.Request
-		wcode int
-	}{
-		{
-			mustNewMethodRequest(t, "HEAD", "foo"),
-			http.StatusOK,
-		},
-		{
-			mustNewMethodRequest(t, "GET", "foo"),
-			http.StatusOK,
-		},
-		{
-			mustNewForm(t, "foo", url.Values{"value": []string{"bar"}}),
-			http.StatusOK,
-		},
-		{
-			mustNewMethodRequest(t, "DELETE", "foo"),
-			http.StatusOK,
-		},
-		{
-			mustNewPostForm(t, "foo", url.Values{"value": []string{"bar"}}),
-			http.StatusOK,
-		},
-	}
-	server := &resServer{
-		etcdserver.Response{
-			Event: &store.Event{
-				Action: store.Get,
-				Node:   &store.NodeExtern{},
-			},
-		},
-	}
-	for i, tt := range tests {
-		h := &keysHandler{
-			timeout: time.Hour,
-			server:  server,
-			timer:   &dummyRaftTimer{},
-			cluster: &fakeCluster{id: 1},
-		}
-		rw := httptest.NewRecorder()
-		h.ServeHTTP(rw, tt.req)
-		if rw.Code != tt.wcode {
-			t.Errorf("#%d: got code=%d, want %d", i, rw.Code, tt.wcode)
-		}
-	}
-}
-
-func TestServeKeysEvent(t *testing.T) {
-	req := mustNewRequest(t, "foo")
-	server := &resServer{
-		etcdserver.Response{
-			Event: &store.Event{
-				Action: store.Get,
-				Node:   &store.NodeExtern{},
-			},
-		},
-	}
-	h := &keysHandler{
-		timeout: time.Hour,
-		server:  server,
-		cluster: &fakeCluster{id: 1},
-		timer:   &dummyRaftTimer{},
-	}
-	rw := httptest.NewRecorder()
-
-	h.ServeHTTP(rw, req)
-
-	wcode := http.StatusOK
-	wbody := mustMarshalEvent(
-		t,
-		&store.Event{
-			Action: store.Get,
-			Node:   &store.NodeExtern{},
-		},
-	)
-
-	if rw.Code != wcode {
-		t.Errorf("got code=%d, want %d", rw.Code, wcode)
-	}
-	gcid := rw.Header().Get("X-Etcd-Cluster-ID")
-	wcid := h.cluster.ID().String()
-	if gcid != wcid {
-		t.Errorf("cid = %s, want %s", gcid, wcid)
-	}
-	g := rw.Body.String()
-	if g != wbody {
-		t.Errorf("got body=%#v, want %#v", g, wbody)
-	}
-}
-
-func TestServeKeysWatch(t *testing.T) {
-	req := mustNewRequest(t, "/foo/bar")
-	ec := make(chan *store.Event)
-	dw := &dummyWatcher{
-		echan: ec,
-	}
-	server := &resServer{
-		etcdserver.Response{
-			Watcher: dw,
-		},
-	}
-	h := &keysHandler{
-		timeout: time.Hour,
-		server:  server,
-		cluster: &fakeCluster{id: 1},
-		timer:   &dummyRaftTimer{},
-	}
-	go func() {
-		ec <- &store.Event{
-			Action: store.Get,
-			Node:   &store.NodeExtern{},
-		}
-	}()
-	rw := httptest.NewRecorder()
-
-	h.ServeHTTP(rw, req)
-
-	wcode := http.StatusOK
-	wbody := mustMarshalEvent(
-		t,
-		&store.Event{
-			Action: store.Get,
-			Node:   &store.NodeExtern{},
-		},
-	)
-
-	if rw.Code != wcode {
-		t.Errorf("got code=%d, want %d", rw.Code, wcode)
-	}
-	gcid := rw.Header().Get("X-Etcd-Cluster-ID")
-	wcid := h.cluster.ID().String()
-	if gcid != wcid {
-		t.Errorf("cid = %s, want %s", gcid, wcid)
-	}
-	g := rw.Body.String()
-	if g != wbody {
-		t.Errorf("got body=%#v, want %#v", g, wbody)
-	}
-}
-
-type recordingCloseNotifier struct {
-	*httptest.ResponseRecorder
-	cn chan bool
-}
-
-func (rcn *recordingCloseNotifier) CloseNotify() <-chan bool {
-	return rcn.cn
-}
-
-func TestHandleWatch(t *testing.T) {
-	defaultRwRr := func() (http.ResponseWriter, *httptest.ResponseRecorder) {
-		r := httptest.NewRecorder()
-		return r, r
-	}
-	noopEv := func(chan *store.Event) {}
-
-	tests := []struct {
-		getCtx   func() context.Context
-		getRwRr  func() (http.ResponseWriter, *httptest.ResponseRecorder)
-		doToChan func(chan *store.Event)
-
-		wbody string
-	}{
-		{
-			// Normal case: one event
-			context.Background,
-			defaultRwRr,
-			func(ch chan *store.Event) {
-				ch <- &store.Event{
-					Action: store.Get,
-					Node:   &store.NodeExtern{},
-				}
-			},
-
-			mustMarshalEvent(
-				t,
-				&store.Event{
-					Action: store.Get,
-					Node:   &store.NodeExtern{},
-				},
-			),
-		},
-		{
-			// Channel is closed, no event
-			context.Background,
-			defaultRwRr,
-			func(ch chan *store.Event) {
-				close(ch)
-			},
-
-			"",
-		},
-		{
-			// Simulate a timed-out context
-			func() context.Context {
-				ctx, cancel := context.WithCancel(context.Background())
-				cancel()
-				return ctx
-			},
-			defaultRwRr,
-			noopEv,
-
-			"",
-		},
-		{
-			// Close-notifying request
-			context.Background,
-			func() (http.ResponseWriter, *httptest.ResponseRecorder) {
-				rw := &recordingCloseNotifier{
-					ResponseRecorder: httptest.NewRecorder(),
-					cn:               make(chan bool, 1),
-				}
-				rw.cn <- true
-				return rw, rw.ResponseRecorder
-			},
-			noopEv,
-
-			"",
-		},
-	}
-
-	for i, tt := range tests {
-		rw, rr := tt.getRwRr()
-		wa := &dummyWatcher{
-			echan: make(chan *store.Event, 1),
-			sidx:  10,
-		}
-		tt.doToChan(wa.echan)
-
-		handleKeyWatch(tt.getCtx(), rw, wa, false, dummyRaftTimer{})
-
-		wcode := http.StatusOK
-		wct := "application/json"
-		wei := "10"
-		wri := "100"
-		wrt := "5"
-
-		if rr.Code != wcode {
-			t.Errorf("#%d: got code=%d, want %d", i, rr.Code, wcode)
-		}
-		h := rr.Header()
-		if ct := h.Get("Content-Type"); ct != wct {
-			t.Errorf("#%d: Content-Type=%q, want %q", i, ct, wct)
-		}
-		if ei := h.Get("X-Etcd-Index"); ei != wei {
-			t.Errorf("#%d: X-Etcd-Index=%q, want %q", i, ei, wei)
-		}
-		if ri := h.Get("X-Raft-Index"); ri != wri {
-			t.Errorf("#%d: X-Raft-Index=%q, want %q", i, ri, wri)
-		}
-		if rt := h.Get("X-Raft-Term"); rt != wrt {
-			t.Errorf("#%d: X-Raft-Term=%q, want %q", i, rt, wrt)
-		}
-		g := rr.Body.String()
-		if g != tt.wbody {
-			t.Errorf("#%d: got body=%#v, want %#v", i, g, tt.wbody)
-		}
-	}
-}
-
-func TestHandleWatchStreaming(t *testing.T) {
-	rw := &flushingRecorder{
-		httptest.NewRecorder(),
-		make(chan struct{}, 1),
-	}
-	wa := &dummyWatcher{
-		echan: make(chan *store.Event),
-	}
-
-	// Launch the streaming handler in the background with a cancellable context
-	ctx, cancel := context.WithCancel(context.Background())
-	done := make(chan struct{})
-	go func() {
-		handleKeyWatch(ctx, rw, wa, true, dummyRaftTimer{})
-		close(done)
-	}()
-
-	// Expect one Flush for the headers etc.
-	select {
-	case <-rw.ch:
-	case <-time.After(time.Second):
-		t.Fatalf("timed out waiting for flush")
-	}
-
-	// Expect headers but no body
-	wcode := http.StatusOK
-	wct := "application/json"
-	wbody := ""
-
-	if rw.Code != wcode {
-		t.Errorf("got code=%d, want %d", rw.Code, wcode)
-	}
-	h := rw.Header()
-	if ct := h.Get("Content-Type"); ct != wct {
-		t.Errorf("Content-Type=%q, want %q", ct, wct)
-	}
-	g := rw.Body.String()
-	if g != wbody {
-		t.Errorf("got body=%#v, want %#v", g, wbody)
-	}
-
-	// Now send the first event
-	select {
-	case wa.echan <- &store.Event{
-		Action: store.Get,
-		Node:   &store.NodeExtern{},
-	}:
-	case <-time.After(time.Second):
-		t.Fatal("timed out waiting for send")
-	}
-
-	// Wait for it to be flushed...
-	select {
-	case <-rw.ch:
-	case <-time.After(time.Second):
-		t.Fatalf("timed out waiting for flush")
-	}
-
-	// And check the body is as expected
-	wbody = mustMarshalEvent(
-		t,
-		&store.Event{
-			Action: store.Get,
-			Node:   &store.NodeExtern{},
-		},
-	)
-	g = rw.Body.String()
-	if g != wbody {
-		t.Errorf("got body=%#v, want %#v", g, wbody)
-	}
-
-	// Rinse and repeat
-	select {
-	case wa.echan <- &store.Event{
-		Action: store.Get,
-		Node:   &store.NodeExtern{},
-	}:
-	case <-time.After(time.Second):
-		t.Fatal("timed out waiting for send")
-	}
-
-	select {
-	case <-rw.ch:
-	case <-time.After(time.Second):
-		t.Fatalf("timed out waiting for flush")
-	}
-
-	// This time, we expect to see both events
-	wbody = wbody + wbody
-	g = rw.Body.String()
-	if g != wbody {
-		t.Errorf("got body=%#v, want %#v", g, wbody)
-	}
-
-	// Finally, time out the connection and ensure the serving goroutine returns
-	cancel()
-
-	select {
-	case <-done:
-	case <-time.After(time.Second):
-		t.Fatalf("timed out waiting for done")
-	}
-}
-
-func TestTrimEventPrefix(t *testing.T) {
-	pre := "/abc"
-	tests := []struct {
-		ev  *store.Event
-		wev *store.Event
-	}{
-		{
-			nil,
-			nil,
-		},
-		{
-			&store.Event{},
-			&store.Event{},
-		},
-		{
-			&store.Event{Node: &store.NodeExtern{Key: "/abc/def"}},
-			&store.Event{Node: &store.NodeExtern{Key: "/def"}},
-		},
-		{
-			&store.Event{PrevNode: &store.NodeExtern{Key: "/abc/ghi"}},
-			&store.Event{PrevNode: &store.NodeExtern{Key: "/ghi"}},
-		},
-		{
-			&store.Event{
-				Node:     &store.NodeExtern{Key: "/abc/def"},
-				PrevNode: &store.NodeExtern{Key: "/abc/ghi"},
-			},
-			&store.Event{
-				Node:     &store.NodeExtern{Key: "/def"},
-				PrevNode: &store.NodeExtern{Key: "/ghi"},
-			},
-		},
-	}
-	for i, tt := range tests {
-		ev := trimEventPrefix(tt.ev, pre)
-		if !reflect.DeepEqual(ev, tt.wev) {
-			t.Errorf("#%d: event = %+v, want %+v", i, ev, tt.wev)
-		}
-	}
-}
-
-func TestTrimNodeExternPrefix(t *testing.T) {
-	pre := "/abc"
-	tests := []struct {
-		n  *store.NodeExtern
-		wn *store.NodeExtern
-	}{
-		{
-			nil,
-			nil,
-		},
-		{
-			&store.NodeExtern{Key: "/abc/def"},
-			&store.NodeExtern{Key: "/def"},
-		},
-		{
-			&store.NodeExtern{
-				Key: "/abc/def",
-				Nodes: []*store.NodeExtern{
-					{Key: "/abc/def/1"},
-					{Key: "/abc/def/2"},
-				},
-			},
-			&store.NodeExtern{
-				Key: "/def",
-				Nodes: []*store.NodeExtern{
-					{Key: "/def/1"},
-					{Key: "/def/2"},
-				},
-			},
-		},
-	}
-	for i, tt := range tests {
-		n := trimNodeExternPrefix(tt.n, pre)
-		if !reflect.DeepEqual(n, tt.wn) {
-			t.Errorf("#%d: node = %+v, want %+v", i, n, tt.wn)
-		}
-	}
-}
-
-func TestTrimPrefix(t *testing.T) {
-	tests := []struct {
-		in     string
-		prefix string
-		w      string
-	}{
-		{"/v2/members", "/v2/members", ""},
-		{"/v2/members/", "/v2/members", ""},
-		{"/v2/members/foo", "/v2/members", "foo"},
-	}
-	for i, tt := range tests {
-		if g := trimPrefix(tt.in, tt.prefix); g != tt.w {
-			t.Errorf("#%d: trimPrefix = %q, want %q", i, g, tt.w)
-		}
-	}
-}
-
-func TestNewMemberCollection(t *testing.T) {
-	fixture := []*etcdserver.Member{
-		{
-			ID:             12,
-			Attributes:     etcdserver.Attributes{ClientURLs: []string{"http://localhost:8080", "http://localhost:8081"}},
-			RaftAttributes: etcdserver.RaftAttributes{PeerURLs: []string{"http://localhost:8082", "http://localhost:8083"}},
-		},
-		{
-			ID:             13,
-			Attributes:     etcdserver.Attributes{ClientURLs: []string{"http://localhost:9090", "http://localhost:9091"}},
-			RaftAttributes: etcdserver.RaftAttributes{PeerURLs: []string{"http://localhost:9092", "http://localhost:9093"}},
-		},
-	}
-	got := newMemberCollection(fixture)
-
-	want := httptypes.MemberCollection([]httptypes.Member{
-		{
-			ID:         "c",
-			ClientURLs: []string{"http://localhost:8080", "http://localhost:8081"},
-			PeerURLs:   []string{"http://localhost:8082", "http://localhost:8083"},
-		},
-		{
-			ID:         "d",
-			ClientURLs: []string{"http://localhost:9090", "http://localhost:9091"},
-			PeerURLs:   []string{"http://localhost:9092", "http://localhost:9093"},
-		},
-	})
-
-	if !reflect.DeepEqual(&want, got) {
-		t.Fatalf("newMemberCollection failure: want=%#v, got=%#v", &want, got)
-	}
-}
-
-func TestNewMember(t *testing.T) {
-	fixture := &etcdserver.Member{
-		ID:             12,
-		Attributes:     etcdserver.Attributes{ClientURLs: []string{"http://localhost:8080", "http://localhost:8081"}},
-		RaftAttributes: etcdserver.RaftAttributes{PeerURLs: []string{"http://localhost:8082", "http://localhost:8083"}},
-	}
-	got := newMember(fixture)
-
-	want := httptypes.Member{
-		ID:         "c",
-		ClientURLs: []string{"http://localhost:8080", "http://localhost:8081"},
-		PeerURLs:   []string{"http://localhost:8082", "http://localhost:8083"},
-	}
-
-	if !reflect.DeepEqual(want, got) {
-		t.Fatalf("newMember failure: want=%#v, got=%#v", want, got)
-	}
-}
diff --git a/etcdserver/etcdhttp/doc.go b/etcdserver/etcdhttp/doc.go
deleted file mode 100644
index 84883aa..0000000
--- a/etcdserver/etcdhttp/doc.go
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Package etcdhttp provides etcd client and server implementations.
-package etcdhttp
diff --git a/etcdserver/etcdhttp/http.go b/etcdserver/etcdhttp/http.go
deleted file mode 100644
index ea22bdf..0000000
--- a/etcdserver/etcdhttp/http.go
+++ /dev/null
@@ -1,95 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package etcdhttp
-
-import (
-	"errors"
-	"math"
-	"net/http"
-	"strings"
-	"time"
-
-	etcdErr "github.com/coreos/etcd/error"
-	"github.com/coreos/etcd/etcdserver"
-	"github.com/coreos/etcd/etcdserver/auth"
-	"github.com/coreos/etcd/etcdserver/etcdhttp/httptypes"
-	"github.com/coreos/etcd/pkg/logutil"
-	"github.com/coreos/pkg/capnslog"
-)
-
-const (
-	// time to wait for a Watch request
-	defaultWatchTimeout = time.Duration(math.MaxInt64)
-)
-
-var (
-	plog      = capnslog.NewPackageLogger("github.com/coreos/etcd", "etcdhttp")
-	mlog      = logutil.NewMergeLogger(plog)
-	errClosed = errors.New("etcdhttp: client closed connection")
-)
-
-// writeError logs and writes the given Error to the ResponseWriter
-// If Error is an etcdErr, it is rendered to the ResponseWriter
-// Otherwise, it is assumed to be a StatusInternalServerError
-func writeError(w http.ResponseWriter, r *http.Request, err error) {
-	if err == nil {
-		return
-	}
-	switch e := err.(type) {
-	case *etcdErr.Error:
-		e.WriteTo(w)
-	case *httptypes.HTTPError:
-		if et := e.WriteTo(w); et != nil {
-			plog.Debugf("error writing HTTPError (%v) to %s", et, r.RemoteAddr)
-		}
-	case auth.Error:
-		herr := httptypes.NewHTTPError(e.HTTPStatus(), e.Error())
-		if et := herr.WriteTo(w); et != nil {
-			plog.Debugf("error writing HTTPError (%v) to %s", et, r.RemoteAddr)
-		}
-	default:
-		switch err {
-		case etcdserver.ErrTimeoutDueToLeaderFail, etcdserver.ErrTimeoutDueToConnectionLost, etcdserver.ErrNotEnoughStartedMembers:
-			mlog.MergeError(err)
-		default:
-			mlog.MergeErrorf("got unexpected response error (%v)", err)
-		}
-		herr := httptypes.NewHTTPError(http.StatusInternalServerError, "Internal Server Error")
-		if et := herr.WriteTo(w); et != nil {
-			plog.Debugf("error writing HTTPError (%v) to %s", et, r.RemoteAddr)
-		}
-	}
-}
-
-// allowMethod verifies that the given method is one of the allowed methods,
-// and if not, it writes an error to w.  A boolean is returned indicating
-// whether or not the method is allowed.
-func allowMethod(w http.ResponseWriter, m string, ms ...string) bool {
-	for _, meth := range ms {
-		if m == meth {
-			return true
-		}
-	}
-	w.Header().Set("Allow", strings.Join(ms, ","))
-	http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
-	return false
-}
-
-func requestLogger(handler http.Handler) http.Handler {
-	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		plog.Debugf("[%s] %s remote:%s", r.Method, r.RequestURI, r.RemoteAddr)
-		handler.ServeHTTP(w, r)
-	})
-}
diff --git a/etcdserver/etcdhttp/http_test.go b/etcdserver/etcdhttp/http_test.go
deleted file mode 100644
index f68f62d..0000000
--- a/etcdserver/etcdhttp/http_test.go
+++ /dev/null
@@ -1,192 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package etcdhttp
-
-import (
-	"errors"
-	"net/http"
-	"net/http/httptest"
-	"sort"
-	"testing"
-
-	etcdErr "github.com/coreos/etcd/error"
-	"github.com/coreos/etcd/etcdserver"
-	"github.com/coreos/etcd/etcdserver/etcdserverpb"
-	"github.com/coreos/etcd/pkg/types"
-	"github.com/coreos/etcd/raft/raftpb"
-	"github.com/coreos/go-semver/semver"
-	"golang.org/x/net/context"
-)
-
-type fakeCluster struct {
-	id         uint64
-	clientURLs []string
-	members    map[uint64]*etcdserver.Member
-}
-
-func (c *fakeCluster) ID() types.ID         { return types.ID(c.id) }
-func (c *fakeCluster) ClientURLs() []string { return c.clientURLs }
-func (c *fakeCluster) Members() []*etcdserver.Member {
-	var ms etcdserver.MembersByID
-	for _, m := range c.members {
-		ms = append(ms, m)
-	}
-	sort.Sort(ms)
-	return []*etcdserver.Member(ms)
-}
-func (c *fakeCluster) Member(id types.ID) *etcdserver.Member { return c.members[uint64(id)] }
-func (c *fakeCluster) IsIDRemoved(id types.ID) bool          { return false }
-func (c *fakeCluster) Version() *semver.Version              { return nil }
-
-// errServer implements the etcd.Server interface for testing.
-// It returns the given error from any Do/Process/AddMember/RemoveMember calls.
-type errServer struct {
-	err error
-}
-
-func (fs *errServer) Start()           {}
-func (fs *errServer) Stop()            {}
-func (fs *errServer) ID() types.ID     { return types.ID(1) }
-func (fs *errServer) Leader() types.ID { return types.ID(1) }
-func (fs *errServer) Do(ctx context.Context, r etcdserverpb.Request) (etcdserver.Response, error) {
-	return etcdserver.Response{}, fs.err
-}
-func (fs *errServer) Process(ctx context.Context, m raftpb.Message) error {
-	return fs.err
-}
-func (fs *errServer) AddMember(ctx context.Context, m etcdserver.Member) error {
-	return fs.err
-}
-func (fs *errServer) RemoveMember(ctx context.Context, id uint64) error {
-	return fs.err
-}
-func (fs *errServer) UpdateMember(ctx context.Context, m etcdserver.Member) error {
-	return fs.err
-}
-
-func (fs *errServer) ClusterVersion() *semver.Version { return nil }
-
-func TestWriteError(t *testing.T) {
-	// nil error should not panic
-	rec := httptest.NewRecorder()
-	r := new(http.Request)
-	writeError(rec, r, nil)
-	h := rec.Header()
-	if len(h) > 0 {
-		t.Fatalf("unexpected non-empty headers: %#v", h)
-	}
-	b := rec.Body.String()
-	if len(b) > 0 {
-		t.Fatalf("unexpected non-empty body: %q", b)
-	}
-
-	tests := []struct {
-		err   error
-		wcode int
-		wi    string
-	}{
-		{
-			etcdErr.NewError(etcdErr.EcodeKeyNotFound, "/foo/bar", 123),
-			http.StatusNotFound,
-			"123",
-		},
-		{
-			etcdErr.NewError(etcdErr.EcodeTestFailed, "/foo/bar", 456),
-			http.StatusPreconditionFailed,
-			"456",
-		},
-		{
-			err:   errors.New("something went wrong"),
-			wcode: http.StatusInternalServerError,
-		},
-	}
-
-	for i, tt := range tests {
-		rw := httptest.NewRecorder()
-		writeError(rw, r, tt.err)
-		if code := rw.Code; code != tt.wcode {
-			t.Errorf("#%d: code=%d, want %d", i, code, tt.wcode)
-		}
-		if idx := rw.Header().Get("X-Etcd-Index"); idx != tt.wi {
-			t.Errorf("#%d: X-Etcd-Index=%q, want %q", i, idx, tt.wi)
-		}
-	}
-}
-
-func TestAllowMethod(t *testing.T) {
-	tests := []struct {
-		m  string
-		ms []string
-		w  bool
-		wh string
-	}{
-		// Accepted methods
-		{
-			m:  "GET",
-			ms: []string{"GET", "POST", "PUT"},
-			w:  true,
-		},
-		{
-			m:  "POST",
-			ms: []string{"POST"},
-			w:  true,
-		},
-		// Made-up methods no good
-		{
-			m:  "FAKE",
-			ms: []string{"GET", "POST", "PUT"},
-			w:  false,
-			wh: "GET,POST,PUT",
-		},
-		// Empty methods no good
-		{
-			m:  "",
-			ms: []string{"GET", "POST"},
-			w:  false,
-			wh: "GET,POST",
-		},
-		// Empty accepted methods no good
-		{
-			m:  "GET",
-			ms: []string{""},
-			w:  false,
-			wh: "",
-		},
-		// No methods accepted
-		{
-			m:  "GET",
-			ms: []string{},
-			w:  false,
-			wh: "",
-		},
-	}
-
-	for i, tt := range tests {
-		rw := httptest.NewRecorder()
-		g := allowMethod(rw, tt.m, tt.ms...)
-		if g != tt.w {
-			t.Errorf("#%d: got allowMethod()=%t, want %t", i, g, tt.w)
-		}
-		if !tt.w {
-			if rw.Code != http.StatusMethodNotAllowed {
-				t.Errorf("#%d: code=%d, want %d", i, rw.Code, http.StatusMethodNotAllowed)
-			}
-			gh := rw.Header().Get("Allow")
-			if gh != tt.wh {
-				t.Errorf("#%d: Allow header=%q, want %q", i, gh, tt.wh)
-			}
-		}
-	}
-}
diff --git a/etcdserver/etcdhttp/httptypes/errors.go b/etcdserver/etcdhttp/httptypes/errors.go
deleted file mode 100644
index 870c148..0000000
--- a/etcdserver/etcdhttp/httptypes/errors.go
+++ /dev/null
@@ -1,56 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package httptypes
-
-import (
-	"encoding/json"
-	"net/http"
-
-	"github.com/coreos/pkg/capnslog"
-)
-
-var (
-	plog = capnslog.NewPackageLogger("github.com/coreos/etcd/etcdserver/etcdhttp", "httptypes")
-)
-
-type HTTPError struct {
-	Message string `json:"message"`
-	// Code is the HTTP status code
-	Code int `json:"-"`
-}
-
-func (e HTTPError) Error() string {
-	return e.Message
-}
-
-func (e HTTPError) WriteTo(w http.ResponseWriter) error {
-	w.Header().Set("Content-Type", "application/json")
-	w.WriteHeader(e.Code)
-	b, err := json.Marshal(e)
-	if err != nil {
-		plog.Panicf("marshal HTTPError should never fail (%v)", err)
-	}
-	if _, err := w.Write(b); err != nil {
-		return err
-	}
-	return nil
-}
-
-func NewHTTPError(code int, m string) *HTTPError {
-	return &HTTPError{
-		Message: m,
-		Code:    code,
-	}
-}
diff --git a/etcdserver/etcdhttp/httptypes/errors_test.go b/etcdserver/etcdhttp/httptypes/errors_test.go
deleted file mode 100644
index 6ef1b3e..0000000
--- a/etcdserver/etcdhttp/httptypes/errors_test.go
+++ /dev/null
@@ -1,49 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package httptypes
-
-import (
-	"net/http"
-	"net/http/httptest"
-	"reflect"
-	"testing"
-)
-
-func TestHTTPErrorWriteTo(t *testing.T) {
-	err := NewHTTPError(http.StatusBadRequest, "what a bad request you made!")
-	rr := httptest.NewRecorder()
-	if e := err.WriteTo(rr); e != nil {
-		t.Fatalf("HTTPError.WriteTo error (%v)", e)
-	}
-
-	wcode := http.StatusBadRequest
-	wheader := http.Header(map[string][]string{
-		"Content-Type": {"application/json"},
-	})
-	wbody := `{"message":"what a bad request you made!"}`
-
-	if wcode != rr.Code {
-		t.Errorf("HTTP status code %d, want %d", rr.Code, wcode)
-	}
-
-	if !reflect.DeepEqual(wheader, rr.HeaderMap) {
-		t.Errorf("HTTP headers %v, want %v", rr.HeaderMap, wheader)
-	}
-
-	gbody := rr.Body.String()
-	if wbody != gbody {
-		t.Errorf("HTTP body %q, want %q", gbody, wbody)
-	}
-}
diff --git a/etcdserver/etcdhttp/httptypes/member.go b/etcdserver/etcdhttp/httptypes/member.go
deleted file mode 100644
index 432f73a..0000000
--- a/etcdserver/etcdhttp/httptypes/member.go
+++ /dev/null
@@ -1,69 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Package httptypes defines how etcd's HTTP API entities are serialized to and
-// deserialized from JSON.
-package httptypes
-
-import (
-	"encoding/json"
-
-	"github.com/coreos/etcd/pkg/types"
-)
-
-type Member struct {
-	ID         string   `json:"id"`
-	Name       string   `json:"name"`
-	PeerURLs   []string `json:"peerURLs"`
-	ClientURLs []string `json:"clientURLs"`
-}
-
-type MemberCreateRequest struct {
-	PeerURLs types.URLs
-}
-
-type MemberUpdateRequest struct {
-	MemberCreateRequest
-}
-
-func (m *MemberCreateRequest) UnmarshalJSON(data []byte) error {
-	s := struct {
-		PeerURLs []string `json:"peerURLs"`
-	}{}
-
-	err := json.Unmarshal(data, &s)
-	if err != nil {
-		return err
-	}
-
-	urls, err := types.NewURLs(s.PeerURLs)
-	if err != nil {
-		return err
-	}
-
-	m.PeerURLs = urls
-	return nil
-}
-
-type MemberCollection []Member
-
-func (c *MemberCollection) MarshalJSON() ([]byte, error) {
-	d := struct {
-		Members []Member `json:"members"`
-	}{
-		Members: []Member(*c),
-	}
-
-	return json.Marshal(d)
-}
diff --git a/etcdserver/etcdhttp/httptypes/member_test.go b/etcdserver/etcdhttp/httptypes/member_test.go
deleted file mode 100644
index 4ea4320..0000000
--- a/etcdserver/etcdhttp/httptypes/member_test.go
+++ /dev/null
@@ -1,135 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package httptypes
-
-import (
-	"encoding/json"
-	"net/url"
-	"reflect"
-	"testing"
-
-	"github.com/coreos/etcd/pkg/types"
-)
-
-func TestMemberUnmarshal(t *testing.T) {
-	tests := []struct {
-		body       []byte
-		wantMember Member
-		wantError  bool
-	}{
-		// no URLs, just check ID & Name
-		{
-			body:       []byte(`{"id": "c", "name": "dungarees"}`),
-			wantMember: Member{ID: "c", Name: "dungarees", PeerURLs: nil, ClientURLs: nil},
-		},
-
-		// both client and peer URLs
-		{
-			body: []byte(`{"peerURLs": ["http://127.0.0.1:2379"], "clientURLs": ["http://127.0.0.1:2379"]}`),
-			wantMember: Member{
-				PeerURLs: []string{
-					"http://127.0.0.1:2379",
-				},
-				ClientURLs: []string{
-					"http://127.0.0.1:2379",
-				},
-			},
-		},
-
-		// multiple peer URLs
-		{
-			body: []byte(`{"peerURLs": ["http://127.0.0.1:2379", "https://example.com"]}`),
-			wantMember: Member{
-				PeerURLs: []string{
-					"http://127.0.0.1:2379",
-					"https://example.com",
-				},
-				ClientURLs: nil,
-			},
-		},
-
-		// multiple client URLs
-		{
-			body: []byte(`{"clientURLs": ["http://127.0.0.1:2379", "https://example.com"]}`),
-			wantMember: Member{
-				PeerURLs: nil,
-				ClientURLs: []string{
-					"http://127.0.0.1:2379",
-					"https://example.com",
-				},
-			},
-		},
-
-		// invalid JSON
-		{
-			body:      []byte(`{"peerU`),
-			wantError: true,
-		},
-	}
-
-	for i, tt := range tests {
-		got := Member{}
-		err := json.Unmarshal(tt.body, &got)
-		if tt.wantError != (err != nil) {
-			t.Errorf("#%d: want error %t, got %v", i, tt.wantError, err)
-			continue
-		}
-
-		if !reflect.DeepEqual(tt.wantMember, got) {
-			t.Errorf("#%d: incorrect output: want=%#v, got=%#v", i, tt.wantMember, got)
-		}
-	}
-}
-
-func TestMemberCreateRequestUnmarshal(t *testing.T) {
-	body := []byte(`{"peerURLs": ["http://127.0.0.1:8081", "https://127.0.0.1:8080"]}`)
-	want := MemberCreateRequest{
-		PeerURLs: types.URLs([]url.URL{
-			{Scheme: "http", Host: "127.0.0.1:8081"},
-			{Scheme: "https", Host: "127.0.0.1:8080"},
-		}),
-	}
-
-	var req MemberCreateRequest
-	if err := json.Unmarshal(body, &req); err != nil {
-		t.Fatalf("Unmarshal returned unexpected err=%v", err)
-	}
-
-	if !reflect.DeepEqual(want, req) {
-		t.Fatalf("Failed to unmarshal MemberCreateRequest: want=%#v, got=%#v", want, req)
-	}
-}
-
-func TestMemberCreateRequestUnmarshalFail(t *testing.T) {
-	tests := [][]byte{
-		// invalid JSON
-		[]byte(``),
-		[]byte(`{`),
-
-		// spot-check validation done in types.NewURLs
-		[]byte(`{"peerURLs": "foo"}`),
-		[]byte(`{"peerURLs": ["."]}`),
-		[]byte(`{"peerURLs": []}`),
-		[]byte(`{"peerURLs": ["http://127.0.0.1:2379/foo"]}`),
-		[]byte(`{"peerURLs": ["http://127.0.0.1"]}`),
-	}
-
-	for i, tt := range tests {
-		var req MemberCreateRequest
-		if err := json.Unmarshal(tt, &req); err == nil {
-			t.Errorf("#%d: expected err, got nil", i)
-		}
-	}
-}
diff --git a/etcdserver/etcdhttp/metrics.go b/etcdserver/etcdhttp/metrics.go
deleted file mode 100644
index 8e55500..0000000
--- a/etcdserver/etcdhttp/metrics.go
+++ /dev/null
@@ -1,96 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package etcdhttp
-
-import (
-	"strconv"
-	"time"
-
-	"net/http"
-
-	etcdErr "github.com/coreos/etcd/error"
-	"github.com/coreos/etcd/etcdserver"
-	"github.com/coreos/etcd/etcdserver/etcdhttp/httptypes"
-	"github.com/coreos/etcd/etcdserver/etcdserverpb"
-	"github.com/prometheus/client_golang/prometheus"
-)
-
-var (
-	incomingEvents = prometheus.NewCounterVec(
-		prometheus.CounterOpts{
-			Namespace: "etcd",
-			Subsystem: "http",
-			Name:      "received_total",
-			Help:      "Counter of requests received into the system (successfully parsed and authd).",
-		}, []string{"method"})
-
-	failedEvents = prometheus.NewCounterVec(
-		prometheus.CounterOpts{
-			Namespace: "etcd",
-			Subsystem: "http",
-			Name:      "failed_total",
-			Help:      "Counter of handle failures of requests (non-watches), by method (GET/PUT etc.) and code (400, 500 etc.).",
-		}, []string{"method", "code"})
-
-	successfulEventsHandlingTime = prometheus.NewHistogramVec(
-		prometheus.HistogramOpts{
-			Namespace: "etcd",
-			Subsystem: "http",
-			Name:      "successful_duration_second",
-			Help:      "Bucketed histogram of processing time (s) of successfully handled requests (non-watches), by method (GET/PUT etc.).",
-			Buckets:   prometheus.ExponentialBuckets(0.0005, 2, 13),
-		}, []string{"method"})
-)
-
-func init() {
-	prometheus.MustRegister(incomingEvents)
-	prometheus.MustRegister(failedEvents)
-	prometheus.MustRegister(successfulEventsHandlingTime)
-}
-
-func reportRequestReceived(request etcdserverpb.Request) {
-	incomingEvents.WithLabelValues(methodFromRequest(request)).Inc()
-}
-
-func reportRequestCompleted(request etcdserverpb.Request, response etcdserver.Response, startTime time.Time) {
-	method := methodFromRequest(request)
-	successfulEventsHandlingTime.WithLabelValues(method).Observe(time.Since(startTime).Seconds())
-}
-
-func reportRequestFailed(request etcdserverpb.Request, err error) {
-	method := methodFromRequest(request)
-	failedEvents.WithLabelValues(method, strconv.Itoa(codeFromError(err))).Inc()
-}
-
-func methodFromRequest(request etcdserverpb.Request) string {
-	if request.Method == "GET" && request.Quorum {
-		return "QGET"
-	}
-	return request.Method
-}
-
-func codeFromError(err error) int {
-	if err == nil {
-		return http.StatusInternalServerError
-	}
-	switch e := err.(type) {
-	case *etcdErr.Error:
-		return (*etcdErr.Error)(e).StatusCode()
-	case *httptypes.HTTPError:
-		return (*httptypes.HTTPError)(e).Code
-	default:
-		return http.StatusInternalServerError
-	}
-}
diff --git a/etcdserver/etcdhttp/peer.go b/etcdserver/etcdhttp/peer.go
deleted file mode 100644
index f142f70..0000000
--- a/etcdserver/etcdhttp/peer.go
+++ /dev/null
@@ -1,76 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package etcdhttp
-
-import (
-	"encoding/json"
-	"net/http"
-
-	"github.com/coreos/etcd/etcdserver"
-	"github.com/coreos/etcd/lease/leasehttp"
-	"github.com/coreos/etcd/rafthttp"
-)
-
-const (
-	peerMembersPrefix = "/members"
-	leasesPrefix      = "/leases"
-)
-
-// NewPeerHandler generates an http.Handler to handle etcd peer requests.
-func NewPeerHandler(s *etcdserver.EtcdServer) http.Handler {
-	var lh http.Handler
-	if l := s.Lessor(); l != nil {
-		lh = leasehttp.NewHandler(l)
-	}
-	return newPeerHandler(s.Cluster(), s.RaftHandler(), lh)
-}
-
-func newPeerHandler(cluster etcdserver.Cluster, raftHandler http.Handler, leaseHandler http.Handler) http.Handler {
-	mh := &peerMembersHandler{
-		cluster: cluster,
-	}
-
-	mux := http.NewServeMux()
-	mux.HandleFunc("/", http.NotFound)
-	mux.Handle(rafthttp.RaftPrefix, raftHandler)
-	mux.Handle(rafthttp.RaftPrefix+"/", raftHandler)
-	mux.Handle(peerMembersPrefix, mh)
-	if leaseHandler != nil {
-		mux.Handle(leasesPrefix, leaseHandler)
-	}
-	mux.HandleFunc(versionPath, versionHandler(cluster, serveVersion))
-	return mux
-}
-
-type peerMembersHandler struct {
-	cluster etcdserver.Cluster
-}
-
-func (h *peerMembersHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-	if !allowMethod(w, r.Method, "GET") {
-		return
-	}
-	w.Header().Set("X-Etcd-Cluster-ID", h.cluster.ID().String())
-
-	if r.URL.Path != peerMembersPrefix {
-		http.Error(w, "bad path", http.StatusBadRequest)
-		return
-	}
-	ms := h.cluster.Members()
-	w.Header().Set("Content-Type", "application/json")
-	if err := json.NewEncoder(w).Encode(ms); err != nil {
-		plog.Warningf("failed to encode members response (%v)", err)
-	}
-}
diff --git a/etcdserver/etcdhttp/peer_test.go b/etcdserver/etcdhttp/peer_test.go
deleted file mode 100644
index 0352caa..0000000
--- a/etcdserver/etcdhttp/peer_test.go
+++ /dev/null
@@ -1,134 +0,0 @@
-// Copyright 2015 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package etcdhttp
-
-import (
-	"encoding/json"
-	"io/ioutil"
-	"net/http"
-	"net/http/httptest"
-	"path"
-	"testing"
-
-	"github.com/coreos/etcd/etcdserver"
-	"github.com/coreos/etcd/pkg/testutil"
-	"github.com/coreos/etcd/rafthttp"
-)
-
-// TestNewPeerHandlerOnRaftPrefix tests that NewPeerHandler returns a handler that
-// handles raft-prefix requests well.
-func TestNewPeerHandlerOnRaftPrefix(t *testing.T) {
-	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte("test data"))
-	})
-	ph := newPeerHandler(&fakeCluster{}, h, nil)
-	srv := httptest.NewServer(ph)
-	defer srv.Close()
-
-	tests := []string{
-		rafthttp.RaftPrefix,
-		rafthttp.RaftPrefix + "/hello",
-	}
-	for i, tt := range tests {
-		resp, err := http.Get(srv.URL + tt)
-		if err != nil {
-			t.Fatalf("unexpected http.Get error: %v", err)
-		}
-		body, err := ioutil.ReadAll(resp.Body)
-		if err != nil {
-			t.Fatalf("unexpected ioutil.ReadAll error: %v", err)
-		}
-		if w := "test data"; string(body) != w {
-			t.Errorf("#%d: body = %s, want %s", i, body, w)
-		}
-	}
-}
-
-func TestServeMembersFails(t *testing.T) {
-	tests := []struct {
-		method string
-		wcode  int
-	}{
-		{
-			"POST",
-			http.StatusMethodNotAllowed,
-		},
-		{
-			"DELETE",
-			http.StatusMethodNotAllowed,
-		},
-		{
-			"BAD",
-			http.StatusMethodNotAllowed,
-		},
-	}
-	for i, tt := range tests {
-		rw := httptest.NewRecorder()
-		h := &peerMembersHandler{cluster: nil}
-		h.ServeHTTP(rw, &http.Request{Method: tt.method})
-		if rw.Code != tt.wcode {
-			t.Errorf("#%d: code=%d, want %d", i, rw.Code, tt.wcode)
-		}
-	}
-}
-
-func TestServeMembersGet(t *testing.T) {
-	memb1 := etcdserver.Member{ID: 1, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8080"}}}
-	memb2 := etcdserver.Member{ID: 2, Attributes: etcdserver.Attributes{ClientURLs: []string{"http://localhost:8081"}}}
-	cluster := &fakeCluster{
-		id:      1,
-		members: map[uint64]*etcdserver.Member{1: &memb1, 2: &memb2},
-	}
-	h := &peerMembersHandler{cluster: cluster}
-	msb, err := json.Marshal([]etcdserver.Member{memb1, memb2})
-	if err != nil {
-		t.Fatal(err)
-	}
-	wms := string(msb) + "\n"
-
-	tests := []struct {
-		path  string
-		wcode int
-		wct   string
-		wbody string
-	}{
-		{peerMembersPrefix, http.StatusOK, "application/json", wms},
-		{path.Join(peerMembersPrefix, "bad"), http.StatusBadRequest, "text/plain; charset=utf-8", "bad path\n"},
-	}
-
-	for i, tt := range tests {
-		req, err := http.NewRequest("GET", testutil.MustNewURL(t, tt.path).String(), nil)
-		if err != nil {
-			t.Fatal(err)
-		}
-		rw := httptest.NewRecorder()
-		h.ServeHTTP(rw, req)
-
-		if rw.Code != tt.wcode {
-			t.Errorf("#%d: code=%d, want %d", i, rw.Code, tt.wcode)
-		}
-		if gct := rw.Header().Get("Content-Type"); gct != tt.wct {
-			t.Errorf("#%d: content-type = %s, want %s", i, gct, tt.wct)
-		}
-		if rw.Body.String() != tt.wbody {
-			t.Errorf("#%d: body = %s, want %s", i, rw.Body.String(), tt.wbody)
-		}
-		gcid := rw.Header().Get("X-Etcd-Cluster-ID")
-		wcid := cluster.ID().String()
-		if gcid != wcid {
-			t.Errorf("#%d: cid = %s, want %s", i, gcid, wcid)
-		}
-	}
-}
diff --git a/etcdserver/server.go b/etcdserver/server.go
index 4339f1c..c0e7cdc 100644
--- a/etcdserver/server.go
+++ b/etcdserver/server.go
@@ -31,7 +31,7 @@ import (
 	"github.com/coreos/etcd/auth"
 	"github.com/coreos/etcd/compactor"
 	"github.com/coreos/etcd/discovery"
-	"github.com/coreos/etcd/etcdserver/etcdhttp/httptypes"
+	"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
 	pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
 	"github.com/coreos/etcd/etcdserver/stats"
 	"github.com/coreos/etcd/lease"
diff --git a/integration/cluster.go b/integration/cluster.go
index bbf3943..4798aeb 100644
--- a/integration/cluster.go
+++ b/integration/cluster.go
@@ -37,8 +37,8 @@ import (
 	"github.com/coreos/etcd/client"
 	"github.com/coreos/etcd/clientv3"
 	"github.com/coreos/etcd/etcdserver"
+	"github.com/coreos/etcd/etcdserver/api/v2http"
 	"github.com/coreos/etcd/etcdserver/api/v3rpc"
-	"github.com/coreos/etcd/etcdserver/etcdhttp"
 	pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
 	"github.com/coreos/etcd/pkg/testutil"
 	"github.com/coreos/etcd/pkg/transport"
@@ -546,7 +546,7 @@ func (m *member) Launch() error {
 	m.s.SyncTicker = time.Tick(500 * time.Millisecond)
 	m.s.Start()
 
-	m.raftHandler = &testutil.PauseableHandler{Next: etcdhttp.NewPeerHandler(m.s)}
+	m.raftHandler = &testutil.PauseableHandler{Next: v2http.NewPeerHandler(m.s)}
 
 	for _, ln := range m.PeerListeners {
 		hs := &httptest.Server{
@@ -567,7 +567,7 @@ func (m *member) Launch() error {
 	for _, ln := range m.ClientListeners {
 		hs := &httptest.Server{
 			Listener: ln,
-			Config:   &http.Server{Handler: etcdhttp.NewClientHandler(m.s, m.ServerConfig.ReqTimeout())},
+			Config:   &http.Server{Handler: v2http.NewClientHandler(m.s, m.ServerConfig.ReqTimeout())},
 		}
 		if m.ClientTLSInfo == nil {
 			hs.Start()
diff --git a/proxy/reverse.go b/proxy/reverse.go
index aa3ef2f..93b8fe6 100644
--- a/proxy/reverse.go
+++ b/proxy/reverse.go
@@ -28,7 +28,7 @@ import (
 
 	"time"
 
-	"github.com/coreos/etcd/etcdserver/etcdhttp/httptypes"
+	"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
 	"github.com/coreos/etcd/pkg/httputil"
 	"github.com/coreos/pkg/capnslog"
 )
diff --git a/test b/test
index 63cd7a8..ba9f87f 100755
--- a/test
+++ b/test
@@ -18,7 +18,7 @@ source ./build
 
 # Hack: gofmt ./ will recursively check the .git directory. So use *.go for gofmt.
 PKGS=`ls pkg/*/*go  | cut -f1,2 -d/ | sort | uniq`
-TESTABLE_AND_FORMATTABLE="client clientv3 discovery error etcdctl/ctlv2 etcdctl/ctlv3 etcdmain etcdserver etcdserver/auth etcdserver/etcdhttp etcdserver/etcdhttp/httptypes $PKGS proxy raft snap storage storage/backend store version wal"
+TESTABLE_AND_FORMATTABLE="client clientv3 discovery error etcdctl/ctlv2 etcdctl/ctlv3 etcdmain etcdserver etcdserver/auth etcdserver/api/v2http etcdserver/api/v2http/httptypes $PKGS proxy raft snap storage storage/backend store version wal"
 # TODO: add it to race testing when the issue is resolved
 # https://github.com/golang/go/issues/9946
 NO_RACE_TESTABLE="rafthttp"
