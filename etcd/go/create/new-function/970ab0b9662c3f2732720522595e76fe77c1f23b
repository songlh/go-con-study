commit 970ab0b9662c3f2732720522595e76fe77c1f23b
Author: Gyuho Lee <gyuhox@gmail.com>
Date:   Tue Jan 16 15:08:03 2018 -0800

    vendor: regenerate
    
    Signed-off-by: Gyuho Lee <gyuhox@gmail.com>

diff --git a/vendor/github.com/coreos/etcd b/vendor/github.com/coreos/etcd
deleted file mode 120000
index 11a54ed..0000000
--- a/vendor/github.com/coreos/etcd
+++ /dev/null
@@ -1 +0,0 @@
-../../../../
\ No newline at end of file
diff --git a/vendor/github.com/coreos/go-semver/example.go b/vendor/github.com/coreos/go-semver/example.go
new file mode 100644
index 0000000..fd2ee5a
--- /dev/null
+++ b/vendor/github.com/coreos/go-semver/example.go
@@ -0,0 +1,20 @@
+package main
+
+import (
+	"fmt"
+	"github.com/coreos/go-semver/semver"
+	"os"
+)
+
+func main() {
+	vA, err := semver.NewVersion(os.Args[1])
+	if err != nil {
+		fmt.Println(err.Error())
+	}
+	vB, err := semver.NewVersion(os.Args[2])
+	if err != nil {
+		fmt.Println(err.Error())
+	}
+
+	fmt.Printf("%s < %s == %t\n", vA, vB, vA.LessThan(*vB))
+}
diff --git a/vendor/github.com/cpuguy83/go-md2man/md2man.go b/vendor/github.com/cpuguy83/go-md2man/md2man.go
new file mode 100644
index 0000000..8f6dcda
--- /dev/null
+++ b/vendor/github.com/cpuguy83/go-md2man/md2man.go
@@ -0,0 +1,51 @@
+package main
+
+import (
+	"flag"
+	"fmt"
+	"io/ioutil"
+	"os"
+
+	"github.com/cpuguy83/go-md2man/md2man"
+)
+
+var inFilePath = flag.String("in", "", "Path to file to be processed (default: stdin)")
+var outFilePath = flag.String("out", "", "Path to output processed file (default: stdout)")
+
+func main() {
+	var err error
+	flag.Parse()
+
+	inFile := os.Stdin
+	if *inFilePath != "" {
+		inFile, err = os.Open(*inFilePath)
+		if err != nil {
+			fmt.Println(err)
+			os.Exit(1)
+		}
+	}
+	defer inFile.Close()
+
+	doc, err := ioutil.ReadAll(inFile)
+	if err != nil {
+		fmt.Println(err)
+		os.Exit(1)
+	}
+
+	out := md2man.Render(doc)
+
+	outFile := os.Stdout
+	if *outFilePath != "" {
+		outFile, err = os.Create(*outFilePath)
+		if err != nil {
+			fmt.Println(err)
+			os.Exit(1)
+		}
+		defer outFile.Close()
+	}
+	_, err = outFile.Write(out)
+	if err != nil {
+		fmt.Println(err)
+		os.Exit(1)
+	}
+}
diff --git a/vendor/github.com/gogo/protobuf/protoc-gen-gogo/doc.go b/vendor/github.com/gogo/protobuf/protoc-gen-gogo/doc.go
new file mode 100644
index 0000000..15c7cf4
--- /dev/null
+++ b/vendor/github.com/gogo/protobuf/protoc-gen-gogo/doc.go
@@ -0,0 +1,51 @@
+// Go support for Protocol Buffers - Google's data interchange format
+//
+// Copyright 2010 The Go Authors.  All rights reserved.
+// https://github.com/golang/protobuf
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+/*
+	A plugin for the Google protocol buffer compiler to generate Go code.
+	Run it by building this program and putting it in your path with the name
+		protoc-gen-gogo
+	That word 'gogo' at the end becomes part of the option string set for the
+	protocol compiler, so once the protocol compiler (protoc) is installed
+	you can run
+		protoc --gogo_out=output_directory input_directory/file.proto
+	to generate Go bindings for the protocol defined by file.proto.
+	With that input, the output will be written to
+		output_directory/go_package/file.pb.go
+
+	The generated code is documented in the package comment for
+	the library.
+
+	See the README and documentation for protocol buffers to learn more:
+		https://developers.google.com/protocol-buffers/
+
+*/
+package documentation
diff --git a/vendor/github.com/gogo/protobuf/protoc-gen-gogo/main.go b/vendor/github.com/gogo/protobuf/protoc-gen-gogo/main.go
new file mode 100644
index 0000000..dd8e795
--- /dev/null
+++ b/vendor/github.com/gogo/protobuf/protoc-gen-gogo/main.go
@@ -0,0 +1,57 @@
+// Go support for Protocol Buffers - Google's data interchange format
+//
+// Copyright 2010 The Go Authors.  All rights reserved.
+// https://github.com/golang/protobuf
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// protoc-gen-go is a plugin for the Google protocol buffer compiler to generate
+// Go code.  Run it by building this program and putting it in your path with
+// the name
+// 	protoc-gen-gogo
+// That word 'gogo' at the end becomes part of the option string set for the
+// protocol compiler, so once the protocol compiler (protoc) is installed
+// you can run
+// 	protoc --gogo_out=output_directory input_directory/file.proto
+// to generate Go bindings for the protocol defined by file.proto.
+// With that input, the output will be written to
+// 	output_directory/file.pb.go
+//
+// The generated code is documented in the package comment for
+// the library.
+//
+// See the README and documentation for protocol buffers to learn more:
+// 	https://developers.google.com/protocol-buffers/
+package main
+
+import (
+	"github.com/gogo/protobuf/vanity/command"
+)
+
+func main() {
+	command.Write(command.Generate(command.Read()))
+}
diff --git a/vendor/github.com/golang/groupcache/byteview.go b/vendor/github.com/golang/groupcache/byteview.go
new file mode 100644
index 0000000..035a9ee
--- /dev/null
+++ b/vendor/github.com/golang/groupcache/byteview.go
@@ -0,0 +1,160 @@
+/*
+Copyright 2012 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package groupcache
+
+import (
+	"bytes"
+	"errors"
+	"io"
+	"strings"
+)
+
+// A ByteView holds an immutable view of bytes.
+// Internally it wraps either a []byte or a string,
+// but that detail is invisible to callers.
+//
+// A ByteView is meant to be used as a value type, not
+// a pointer (like a time.Time).
+type ByteView struct {
+	// If b is non-nil, b is used, else s is used.
+	b []byte
+	s string
+}
+
+// Len returns the view's length.
+func (v ByteView) Len() int {
+	if v.b != nil {
+		return len(v.b)
+	}
+	return len(v.s)
+}
+
+// ByteSlice returns a copy of the data as a byte slice.
+func (v ByteView) ByteSlice() []byte {
+	if v.b != nil {
+		return cloneBytes(v.b)
+	}
+	return []byte(v.s)
+}
+
+// String returns the data as a string, making a copy if necessary.
+func (v ByteView) String() string {
+	if v.b != nil {
+		return string(v.b)
+	}
+	return v.s
+}
+
+// At returns the byte at index i.
+func (v ByteView) At(i int) byte {
+	if v.b != nil {
+		return v.b[i]
+	}
+	return v.s[i]
+}
+
+// Slice slices the view between the provided from and to indices.
+func (v ByteView) Slice(from, to int) ByteView {
+	if v.b != nil {
+		return ByteView{b: v.b[from:to]}
+	}
+	return ByteView{s: v.s[from:to]}
+}
+
+// SliceFrom slices the view from the provided index until the end.
+func (v ByteView) SliceFrom(from int) ByteView {
+	if v.b != nil {
+		return ByteView{b: v.b[from:]}
+	}
+	return ByteView{s: v.s[from:]}
+}
+
+// Copy copies b into dest and returns the number of bytes copied.
+func (v ByteView) Copy(dest []byte) int {
+	if v.b != nil {
+		return copy(dest, v.b)
+	}
+	return copy(dest, v.s)
+}
+
+// Equal returns whether the bytes in b are the same as the bytes in
+// b2.
+func (v ByteView) Equal(b2 ByteView) bool {
+	if b2.b == nil {
+		return v.EqualString(b2.s)
+	}
+	return v.EqualBytes(b2.b)
+}
+
+// EqualString returns whether the bytes in b are the same as the bytes
+// in s.
+func (v ByteView) EqualString(s string) bool {
+	if v.b == nil {
+		return v.s == s
+	}
+	l := v.Len()
+	if len(s) != l {
+		return false
+	}
+	for i, bi := range v.b {
+		if bi != s[i] {
+			return false
+		}
+	}
+	return true
+}
+
+// EqualBytes returns whether the bytes in b are the same as the bytes
+// in b2.
+func (v ByteView) EqualBytes(b2 []byte) bool {
+	if v.b != nil {
+		return bytes.Equal(v.b, b2)
+	}
+	l := v.Len()
+	if len(b2) != l {
+		return false
+	}
+	for i, bi := range b2 {
+		if bi != v.s[i] {
+			return false
+		}
+	}
+	return true
+}
+
+// Reader returns an io.ReadSeeker for the bytes in v.
+func (v ByteView) Reader() io.ReadSeeker {
+	if v.b != nil {
+		return bytes.NewReader(v.b)
+	}
+	return strings.NewReader(v.s)
+}
+
+// ReadAt implements io.ReaderAt on the bytes in v.
+func (v ByteView) ReadAt(p []byte, off int64) (n int, err error) {
+	if off < 0 {
+		return 0, errors.New("view: invalid offset")
+	}
+	if off >= int64(v.Len()) {
+		return 0, io.EOF
+	}
+	n = v.SliceFrom(int(off)).Copy(p)
+	if n < len(p) {
+		err = io.EOF
+	}
+	return
+}
diff --git a/vendor/github.com/golang/groupcache/groupcache.go b/vendor/github.com/golang/groupcache/groupcache.go
new file mode 100644
index 0000000..9499dbb
--- /dev/null
+++ b/vendor/github.com/golang/groupcache/groupcache.go
@@ -0,0 +1,489 @@
+/*
+Copyright 2012 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Package groupcache provides a data loading mechanism with caching
+// and de-duplication that works across a set of peer processes.
+//
+// Each data Get first consults its local cache, otherwise delegates
+// to the requested key's canonical owner, which then checks its cache
+// or finally gets the data.  In the common case, many concurrent
+// cache misses across a set of peers for the same key result in just
+// one cache fill.
+package groupcache
+
+import (
+	"errors"
+	"math/rand"
+	"strconv"
+	"sync"
+	"sync/atomic"
+
+	pb "github.com/golang/groupcache/groupcachepb"
+	"github.com/golang/groupcache/lru"
+	"github.com/golang/groupcache/singleflight"
+)
+
+// A Getter loads data for a key.
+type Getter interface {
+	// Get returns the value identified by key, populating dest.
+	//
+	// The returned data must be unversioned. That is, key must
+	// uniquely describe the loaded data, without an implicit
+	// current time, and without relying on cache expiration
+	// mechanisms.
+	Get(ctx Context, key string, dest Sink) error
+}
+
+// A GetterFunc implements Getter with a function.
+type GetterFunc func(ctx Context, key string, dest Sink) error
+
+func (f GetterFunc) Get(ctx Context, key string, dest Sink) error {
+	return f(ctx, key, dest)
+}
+
+var (
+	mu     sync.RWMutex
+	groups = make(map[string]*Group)
+
+	initPeerServerOnce sync.Once
+	initPeerServer     func()
+)
+
+// GetGroup returns the named group previously created with NewGroup, or
+// nil if there's no such group.
+func GetGroup(name string) *Group {
+	mu.RLock()
+	g := groups[name]
+	mu.RUnlock()
+	return g
+}
+
+// NewGroup creates a coordinated group-aware Getter from a Getter.
+//
+// The returned Getter tries (but does not guarantee) to run only one
+// Get call at once for a given key across an entire set of peer
+// processes. Concurrent callers both in the local process and in
+// other processes receive copies of the answer once the original Get
+// completes.
+//
+// The group name must be unique for each getter.
+func NewGroup(name string, cacheBytes int64, getter Getter) *Group {
+	return newGroup(name, cacheBytes, getter, nil)
+}
+
+// If peers is nil, the peerPicker is called via a sync.Once to initialize it.
+func newGroup(name string, cacheBytes int64, getter Getter, peers PeerPicker) *Group {
+	if getter == nil {
+		panic("nil Getter")
+	}
+	mu.Lock()
+	defer mu.Unlock()
+	initPeerServerOnce.Do(callInitPeerServer)
+	if _, dup := groups[name]; dup {
+		panic("duplicate registration of group " + name)
+	}
+	g := &Group{
+		name:       name,
+		getter:     getter,
+		peers:      peers,
+		cacheBytes: cacheBytes,
+		loadGroup:  &singleflight.Group{},
+	}
+	if fn := newGroupHook; fn != nil {
+		fn(g)
+	}
+	groups[name] = g
+	return g
+}
+
+// newGroupHook, if non-nil, is called right after a new group is created.
+var newGroupHook func(*Group)
+
+// RegisterNewGroupHook registers a hook that is run each time
+// a group is created.
+func RegisterNewGroupHook(fn func(*Group)) {
+	if newGroupHook != nil {
+		panic("RegisterNewGroupHook called more than once")
+	}
+	newGroupHook = fn
+}
+
+// RegisterServerStart registers a hook that is run when the first
+// group is created.
+func RegisterServerStart(fn func()) {
+	if initPeerServer != nil {
+		panic("RegisterServerStart called more than once")
+	}
+	initPeerServer = fn
+}
+
+func callInitPeerServer() {
+	if initPeerServer != nil {
+		initPeerServer()
+	}
+}
+
+// A Group is a cache namespace and associated data loaded spread over
+// a group of 1 or more machines.
+type Group struct {
+	name       string
+	getter     Getter
+	peersOnce  sync.Once
+	peers      PeerPicker
+	cacheBytes int64 // limit for sum of mainCache and hotCache size
+
+	// mainCache is a cache of the keys for which this process
+	// (amongst its peers) is authoritative. That is, this cache
+	// contains keys which consistent hash on to this process's
+	// peer number.
+	mainCache cache
+
+	// hotCache contains keys/values for which this peer is not
+	// authoritative (otherwise they would be in mainCache), but
+	// are popular enough to warrant mirroring in this process to
+	// avoid going over the network to fetch from a peer.  Having
+	// a hotCache avoids network hotspotting, where a peer's
+	// network card could become the bottleneck on a popular key.
+	// This cache is used sparingly to maximize the total number
+	// of key/value pairs that can be stored globally.
+	hotCache cache
+
+	// loadGroup ensures that each key is only fetched once
+	// (either locally or remotely), regardless of the number of
+	// concurrent callers.
+	loadGroup flightGroup
+
+	// Stats are statistics on the group.
+	Stats Stats
+}
+
+// flightGroup is defined as an interface which flightgroup.Group
+// satisfies.  We define this so that we may test with an alternate
+// implementation.
+type flightGroup interface {
+	// Done is called when Do is done.
+	Do(key string, fn func() (interface{}, error)) (interface{}, error)
+}
+
+// Stats are per-group statistics.
+type Stats struct {
+	Gets           AtomicInt // any Get request, including from peers
+	CacheHits      AtomicInt // either cache was good
+	PeerLoads      AtomicInt // either remote load or remote cache hit (not an error)
+	PeerErrors     AtomicInt
+	Loads          AtomicInt // (gets - cacheHits)
+	LoadsDeduped   AtomicInt // after singleflight
+	LocalLoads     AtomicInt // total good local loads
+	LocalLoadErrs  AtomicInt // total bad local loads
+	ServerRequests AtomicInt // gets that came over the network from peers
+}
+
+// Name returns the name of the group.
+func (g *Group) Name() string {
+	return g.name
+}
+
+func (g *Group) initPeers() {
+	if g.peers == nil {
+		g.peers = getPeers()
+	}
+}
+
+func (g *Group) Get(ctx Context, key string, dest Sink) error {
+	g.peersOnce.Do(g.initPeers)
+	g.Stats.Gets.Add(1)
+	if dest == nil {
+		return errors.New("groupcache: nil dest Sink")
+	}
+	value, cacheHit := g.lookupCache(key)
+
+	if cacheHit {
+		g.Stats.CacheHits.Add(1)
+		return setSinkView(dest, value)
+	}
+
+	// Optimization to avoid double unmarshalling or copying: keep
+	// track of whether the dest was already populated. One caller
+	// (if local) will set this; the losers will not. The common
+	// case will likely be one caller.
+	destPopulated := false
+	value, destPopulated, err := g.load(ctx, key, dest)
+	if err != nil {
+		return err
+	}
+	if destPopulated {
+		return nil
+	}
+	return setSinkView(dest, value)
+}
+
+// load loads key either by invoking the getter locally or by sending it to another machine.
+func (g *Group) load(ctx Context, key string, dest Sink) (value ByteView, destPopulated bool, err error) {
+	g.Stats.Loads.Add(1)
+	viewi, err := g.loadGroup.Do(key, func() (interface{}, error) {
+		// Check the cache again because singleflight can only dedup calls
+		// that overlap concurrently.  It's possible for 2 concurrent
+		// requests to miss the cache, resulting in 2 load() calls.  An
+		// unfortunate goroutine scheduling would result in this callback
+		// being run twice, serially.  If we don't check the cache again,
+		// cache.nbytes would be incremented below even though there will
+		// be only one entry for this key.
+		//
+		// Consider the following serialized event ordering for two
+		// goroutines in which this callback gets called twice for hte
+		// same key:
+		// 1: Get("key")
+		// 2: Get("key")
+		// 1: lookupCache("key")
+		// 2: lookupCache("key")
+		// 1: load("key")
+		// 2: load("key")
+		// 1: loadGroup.Do("key", fn)
+		// 1: fn()
+		// 2: loadGroup.Do("key", fn)
+		// 2: fn()
+		if value, cacheHit := g.lookupCache(key); cacheHit {
+			g.Stats.CacheHits.Add(1)
+			return value, nil
+		}
+		g.Stats.LoadsDeduped.Add(1)
+		var value ByteView
+		var err error
+		if peer, ok := g.peers.PickPeer(key); ok {
+			value, err = g.getFromPeer(ctx, peer, key)
+			if err == nil {
+				g.Stats.PeerLoads.Add(1)
+				return value, nil
+			}
+			g.Stats.PeerErrors.Add(1)
+			// TODO(bradfitz): log the peer's error? keep
+			// log of the past few for /groupcachez?  It's
+			// probably boring (normal task movement), so not
+			// worth logging I imagine.
+		}
+		value, err = g.getLocally(ctx, key, dest)
+		if err != nil {
+			g.Stats.LocalLoadErrs.Add(1)
+			return nil, err
+		}
+		g.Stats.LocalLoads.Add(1)
+		destPopulated = true // only one caller of load gets this return value
+		g.populateCache(key, value, &g.mainCache)
+		return value, nil
+	})
+	if err == nil {
+		value = viewi.(ByteView)
+	}
+	return
+}
+
+func (g *Group) getLocally(ctx Context, key string, dest Sink) (ByteView, error) {
+	err := g.getter.Get(ctx, key, dest)
+	if err != nil {
+		return ByteView{}, err
+	}
+	return dest.view()
+}
+
+func (g *Group) getFromPeer(ctx Context, peer ProtoGetter, key string) (ByteView, error) {
+	req := &pb.GetRequest{
+		Group: &g.name,
+		Key:   &key,
+	}
+	res := &pb.GetResponse{}
+	err := peer.Get(ctx, req, res)
+	if err != nil {
+		return ByteView{}, err
+	}
+	value := ByteView{b: res.Value}
+	// TODO(bradfitz): use res.MinuteQps or something smart to
+	// conditionally populate hotCache.  For now just do it some
+	// percentage of the time.
+	if rand.Intn(10) == 0 {
+		g.populateCache(key, value, &g.hotCache)
+	}
+	return value, nil
+}
+
+func (g *Group) lookupCache(key string) (value ByteView, ok bool) {
+	if g.cacheBytes <= 0 {
+		return
+	}
+	value, ok = g.mainCache.get(key)
+	if ok {
+		return
+	}
+	value, ok = g.hotCache.get(key)
+	return
+}
+
+func (g *Group) populateCache(key string, value ByteView, cache *cache) {
+	if g.cacheBytes <= 0 {
+		return
+	}
+	cache.add(key, value)
+
+	// Evict items from cache(s) if necessary.
+	for {
+		mainBytes := g.mainCache.bytes()
+		hotBytes := g.hotCache.bytes()
+		if mainBytes+hotBytes <= g.cacheBytes {
+			return
+		}
+
+		// TODO(bradfitz): this is good-enough-for-now logic.
+		// It should be something based on measurements and/or
+		// respecting the costs of different resources.
+		victim := &g.mainCache
+		if hotBytes > mainBytes/8 {
+			victim = &g.hotCache
+		}
+		victim.removeOldest()
+	}
+}
+
+// CacheType represents a type of cache.
+type CacheType int
+
+const (
+	// The MainCache is the cache for items that this peer is the
+	// owner for.
+	MainCache CacheType = iota + 1
+
+	// The HotCache is the cache for items that seem popular
+	// enough to replicate to this node, even though it's not the
+	// owner.
+	HotCache
+)
+
+// CacheStats returns stats about the provided cache within the group.
+func (g *Group) CacheStats(which CacheType) CacheStats {
+	switch which {
+	case MainCache:
+		return g.mainCache.stats()
+	case HotCache:
+		return g.hotCache.stats()
+	default:
+		return CacheStats{}
+	}
+}
+
+// cache is a wrapper around an *lru.Cache that adds synchronization,
+// makes values always be ByteView, and counts the size of all keys and
+// values.
+type cache struct {
+	mu         sync.RWMutex
+	nbytes     int64 // of all keys and values
+	lru        *lru.Cache
+	nhit, nget int64
+	nevict     int64 // number of evictions
+}
+
+func (c *cache) stats() CacheStats {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return CacheStats{
+		Bytes:     c.nbytes,
+		Items:     c.itemsLocked(),
+		Gets:      c.nget,
+		Hits:      c.nhit,
+		Evictions: c.nevict,
+	}
+}
+
+func (c *cache) add(key string, value ByteView) {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	if c.lru == nil {
+		c.lru = &lru.Cache{
+			OnEvicted: func(key lru.Key, value interface{}) {
+				val := value.(ByteView)
+				c.nbytes -= int64(len(key.(string))) + int64(val.Len())
+				c.nevict++
+			},
+		}
+	}
+	c.lru.Add(key, value)
+	c.nbytes += int64(len(key)) + int64(value.Len())
+}
+
+func (c *cache) get(key string) (value ByteView, ok bool) {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	c.nget++
+	if c.lru == nil {
+		return
+	}
+	vi, ok := c.lru.Get(key)
+	if !ok {
+		return
+	}
+	c.nhit++
+	return vi.(ByteView), true
+}
+
+func (c *cache) removeOldest() {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	if c.lru != nil {
+		c.lru.RemoveOldest()
+	}
+}
+
+func (c *cache) bytes() int64 {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return c.nbytes
+}
+
+func (c *cache) items() int64 {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return c.itemsLocked()
+}
+
+func (c *cache) itemsLocked() int64 {
+	if c.lru == nil {
+		return 0
+	}
+	return int64(c.lru.Len())
+}
+
+// An AtomicInt is an int64 to be accessed atomically.
+type AtomicInt int64
+
+// Add atomically adds n to i.
+func (i *AtomicInt) Add(n int64) {
+	atomic.AddInt64((*int64)(i), n)
+}
+
+// Get atomically gets the value of i.
+func (i *AtomicInt) Get() int64 {
+	return atomic.LoadInt64((*int64)(i))
+}
+
+func (i *AtomicInt) String() string {
+	return strconv.FormatInt(i.Get(), 10)
+}
+
+// CacheStats are returned by stats accessors on Group.
+type CacheStats struct {
+	Bytes     int64
+	Items     int64
+	Gets      int64
+	Hits      int64
+	Evictions int64
+}
diff --git a/vendor/github.com/golang/groupcache/http.go b/vendor/github.com/golang/groupcache/http.go
new file mode 100644
index 0000000..14eb345
--- /dev/null
+++ b/vendor/github.com/golang/groupcache/http.go
@@ -0,0 +1,227 @@
+/*
+Copyright 2013 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package groupcache
+
+import (
+	"bytes"
+	"fmt"
+	"io"
+	"net/http"
+	"net/url"
+	"strings"
+	"sync"
+
+	"github.com/golang/groupcache/consistenthash"
+	pb "github.com/golang/groupcache/groupcachepb"
+	"github.com/golang/protobuf/proto"
+)
+
+const defaultBasePath = "/_groupcache/"
+
+const defaultReplicas = 50
+
+// HTTPPool implements PeerPicker for a pool of HTTP peers.
+type HTTPPool struct {
+	// Context optionally specifies a context for the server to use when it
+	// receives a request.
+	// If nil, the server uses a nil Context.
+	Context func(*http.Request) Context
+
+	// Transport optionally specifies an http.RoundTripper for the client
+	// to use when it makes a request.
+	// If nil, the client uses http.DefaultTransport.
+	Transport func(Context) http.RoundTripper
+
+	// this peer's base URL, e.g. "https://example.net:8000"
+	self string
+
+	// opts specifies the options.
+	opts HTTPPoolOptions
+
+	mu          sync.Mutex // guards peers and httpGetters
+	peers       *consistenthash.Map
+	httpGetters map[string]*httpGetter // keyed by e.g. "http://10.0.0.2:8008"
+}
+
+// HTTPPoolOptions are the configurations of a HTTPPool.
+type HTTPPoolOptions struct {
+	// BasePath specifies the HTTP path that will serve groupcache requests.
+	// If blank, it defaults to "/_groupcache/".
+	BasePath string
+
+	// Replicas specifies the number of key replicas on the consistent hash.
+	// If blank, it defaults to 50.
+	Replicas int
+
+	// HashFn specifies the hash function of the consistent hash.
+	// If blank, it defaults to crc32.ChecksumIEEE.
+	HashFn consistenthash.Hash
+}
+
+// NewHTTPPool initializes an HTTP pool of peers, and registers itself as a PeerPicker.
+// For convenience, it also registers itself as an http.Handler with http.DefaultServeMux.
+// The self argument be a valid base URL that points to the current server,
+// for example "http://example.net:8000".
+func NewHTTPPool(self string) *HTTPPool {
+	p := NewHTTPPoolOpts(self, nil)
+	http.Handle(p.opts.BasePath, p)
+	return p
+}
+
+var httpPoolMade bool
+
+// NewHTTPPoolOpts initializes an HTTP pool of peers with the given options.
+// Unlike NewHTTPPool, this function does not register the created pool as an HTTP handler.
+// The returned *HTTPPool implements http.Handler and must be registered using http.Handle.
+func NewHTTPPoolOpts(self string, o *HTTPPoolOptions) *HTTPPool {
+	if httpPoolMade {
+		panic("groupcache: NewHTTPPool must be called only once")
+	}
+	httpPoolMade = true
+
+	p := &HTTPPool{
+		self:        self,
+		httpGetters: make(map[string]*httpGetter),
+	}
+	if o != nil {
+		p.opts = *o
+	}
+	if p.opts.BasePath == "" {
+		p.opts.BasePath = defaultBasePath
+	}
+	if p.opts.Replicas == 0 {
+		p.opts.Replicas = defaultReplicas
+	}
+	p.peers = consistenthash.New(p.opts.Replicas, p.opts.HashFn)
+
+	RegisterPeerPicker(func() PeerPicker { return p })
+	return p
+}
+
+// Set updates the pool's list of peers.
+// Each peer value should be a valid base URL,
+// for example "http://example.net:8000".
+func (p *HTTPPool) Set(peers ...string) {
+	p.mu.Lock()
+	defer p.mu.Unlock()
+	p.peers = consistenthash.New(p.opts.Replicas, p.opts.HashFn)
+	p.peers.Add(peers...)
+	p.httpGetters = make(map[string]*httpGetter, len(peers))
+	for _, peer := range peers {
+		p.httpGetters[peer] = &httpGetter{transport: p.Transport, baseURL: peer + p.opts.BasePath}
+	}
+}
+
+func (p *HTTPPool) PickPeer(key string) (ProtoGetter, bool) {
+	p.mu.Lock()
+	defer p.mu.Unlock()
+	if p.peers.IsEmpty() {
+		return nil, false
+	}
+	if peer := p.peers.Get(key); peer != p.self {
+		return p.httpGetters[peer], true
+	}
+	return nil, false
+}
+
+func (p *HTTPPool) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+	// Parse request.
+	if !strings.HasPrefix(r.URL.Path, p.opts.BasePath) {
+		panic("HTTPPool serving unexpected path: " + r.URL.Path)
+	}
+	parts := strings.SplitN(r.URL.Path[len(p.opts.BasePath):], "/", 2)
+	if len(parts) != 2 {
+		http.Error(w, "bad request", http.StatusBadRequest)
+		return
+	}
+	groupName := parts[0]
+	key := parts[1]
+
+	// Fetch the value for this group/key.
+	group := GetGroup(groupName)
+	if group == nil {
+		http.Error(w, "no such group: "+groupName, http.StatusNotFound)
+		return
+	}
+	var ctx Context
+	if p.Context != nil {
+		ctx = p.Context(r)
+	}
+
+	group.Stats.ServerRequests.Add(1)
+	var value []byte
+	err := group.Get(ctx, key, AllocatingByteSliceSink(&value))
+	if err != nil {
+		http.Error(w, err.Error(), http.StatusInternalServerError)
+		return
+	}
+
+	// Write the value to the response body as a proto message.
+	body, err := proto.Marshal(&pb.GetResponse{Value: value})
+	if err != nil {
+		http.Error(w, err.Error(), http.StatusInternalServerError)
+		return
+	}
+	w.Header().Set("Content-Type", "application/x-protobuf")
+	w.Write(body)
+}
+
+type httpGetter struct {
+	transport func(Context) http.RoundTripper
+	baseURL   string
+}
+
+var bufferPool = sync.Pool{
+	New: func() interface{} { return new(bytes.Buffer) },
+}
+
+func (h *httpGetter) Get(context Context, in *pb.GetRequest, out *pb.GetResponse) error {
+	u := fmt.Sprintf(
+		"%v%v/%v",
+		h.baseURL,
+		url.QueryEscape(in.GetGroup()),
+		url.QueryEscape(in.GetKey()),
+	)
+	req, err := http.NewRequest("GET", u, nil)
+	if err != nil {
+		return err
+	}
+	tr := http.DefaultTransport
+	if h.transport != nil {
+		tr = h.transport(context)
+	}
+	res, err := tr.RoundTrip(req)
+	if err != nil {
+		return err
+	}
+	defer res.Body.Close()
+	if res.StatusCode != http.StatusOK {
+		return fmt.Errorf("server returned: %v", res.Status)
+	}
+	b := bufferPool.Get().(*bytes.Buffer)
+	b.Reset()
+	defer bufferPool.Put(b)
+	_, err = io.Copy(b, res.Body)
+	if err != nil {
+		return fmt.Errorf("reading response body: %v", err)
+	}
+	err = proto.Unmarshal(b.Bytes(), out)
+	if err != nil {
+		return fmt.Errorf("decoding response body: %v", err)
+	}
+	return nil
+}
diff --git a/vendor/github.com/golang/groupcache/peers.go b/vendor/github.com/golang/groupcache/peers.go
new file mode 100644
index 0000000..a74a79b
--- /dev/null
+++ b/vendor/github.com/golang/groupcache/peers.go
@@ -0,0 +1,71 @@
+/*
+Copyright 2012 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// peers.go defines how processes find and communicate with their peers.
+
+package groupcache
+
+import (
+	pb "github.com/golang/groupcache/groupcachepb"
+)
+
+// Context is an opaque value passed through calls to the
+// ProtoGetter. It may be nil if your ProtoGetter implementation does
+// not require a context.
+type Context interface{}
+
+// ProtoGetter is the interface that must be implemented by a peer.
+type ProtoGetter interface {
+	Get(context Context, in *pb.GetRequest, out *pb.GetResponse) error
+}
+
+// PeerPicker is the interface that must be implemented to locate
+// the peer that owns a specific key.
+type PeerPicker interface {
+	// PickPeer returns the peer that owns the specific key
+	// and true to indicate that a remote peer was nominated.
+	// It returns nil, false if the key owner is the current peer.
+	PickPeer(key string) (peer ProtoGetter, ok bool)
+}
+
+// NoPeers is an implementation of PeerPicker that never finds a peer.
+type NoPeers struct{}
+
+func (NoPeers) PickPeer(key string) (peer ProtoGetter, ok bool) { return }
+
+var (
+	portPicker func() PeerPicker
+)
+
+// RegisterPeerPicker registers the peer initialization function.
+// It is called once, when the first group is created.
+func RegisterPeerPicker(fn func() PeerPicker) {
+	if portPicker != nil {
+		panic("RegisterPeerPicker called more than once")
+	}
+	portPicker = fn
+}
+
+func getPeers() PeerPicker {
+	if portPicker == nil {
+		return NoPeers{}
+	}
+	pk := portPicker()
+	if pk == nil {
+		pk = NoPeers{}
+	}
+	return pk
+}
diff --git a/vendor/github.com/golang/groupcache/sinks.go b/vendor/github.com/golang/groupcache/sinks.go
new file mode 100644
index 0000000..cb42b41
--- /dev/null
+++ b/vendor/github.com/golang/groupcache/sinks.go
@@ -0,0 +1,322 @@
+/*
+Copyright 2012 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package groupcache
+
+import (
+	"errors"
+
+	"github.com/golang/protobuf/proto"
+)
+
+// A Sink receives data from a Get call.
+//
+// Implementation of Getter must call exactly one of the Set methods
+// on success.
+type Sink interface {
+	// SetString sets the value to s.
+	SetString(s string) error
+
+	// SetBytes sets the value to the contents of v.
+	// The caller retains ownership of v.
+	SetBytes(v []byte) error
+
+	// SetProto sets the value to the encoded version of m.
+	// The caller retains ownership of m.
+	SetProto(m proto.Message) error
+
+	// view returns a frozen view of the bytes for caching.
+	view() (ByteView, error)
+}
+
+func cloneBytes(b []byte) []byte {
+	c := make([]byte, len(b))
+	copy(c, b)
+	return c
+}
+
+func setSinkView(s Sink, v ByteView) error {
+	// A viewSetter is a Sink that can also receive its value from
+	// a ByteView. This is a fast path to minimize copies when the
+	// item was already cached locally in memory (where it's
+	// cached as a ByteView)
+	type viewSetter interface {
+		setView(v ByteView) error
+	}
+	if vs, ok := s.(viewSetter); ok {
+		return vs.setView(v)
+	}
+	if v.b != nil {
+		return s.SetBytes(v.b)
+	}
+	return s.SetString(v.s)
+}
+
+// StringSink returns a Sink that populates the provided string pointer.
+func StringSink(sp *string) Sink {
+	return &stringSink{sp: sp}
+}
+
+type stringSink struct {
+	sp *string
+	v  ByteView
+	// TODO(bradfitz): track whether any Sets were called.
+}
+
+func (s *stringSink) view() (ByteView, error) {
+	// TODO(bradfitz): return an error if no Set was called
+	return s.v, nil
+}
+
+func (s *stringSink) SetString(v string) error {
+	s.v.b = nil
+	s.v.s = v
+	*s.sp = v
+	return nil
+}
+
+func (s *stringSink) SetBytes(v []byte) error {
+	return s.SetString(string(v))
+}
+
+func (s *stringSink) SetProto(m proto.Message) error {
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return err
+	}
+	s.v.b = b
+	*s.sp = string(b)
+	return nil
+}
+
+// ByteViewSink returns a Sink that populates a ByteView.
+func ByteViewSink(dst *ByteView) Sink {
+	if dst == nil {
+		panic("nil dst")
+	}
+	return &byteViewSink{dst: dst}
+}
+
+type byteViewSink struct {
+	dst *ByteView
+
+	// if this code ever ends up tracking that at least one set*
+	// method was called, don't make it an error to call set
+	// methods multiple times. Lorry's payload.go does that, and
+	// it makes sense. The comment at the top of this file about
+	// "exactly one of the Set methods" is overly strict. We
+	// really care about at least once (in a handler), but if
+	// multiple handlers fail (or multiple functions in a program
+	// using a Sink), it's okay to re-use the same one.
+}
+
+func (s *byteViewSink) setView(v ByteView) error {
+	*s.dst = v
+	return nil
+}
+
+func (s *byteViewSink) view() (ByteView, error) {
+	return *s.dst, nil
+}
+
+func (s *byteViewSink) SetProto(m proto.Message) error {
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return err
+	}
+	*s.dst = ByteView{b: b}
+	return nil
+}
+
+func (s *byteViewSink) SetBytes(b []byte) error {
+	*s.dst = ByteView{b: cloneBytes(b)}
+	return nil
+}
+
+func (s *byteViewSink) SetString(v string) error {
+	*s.dst = ByteView{s: v}
+	return nil
+}
+
+// ProtoSink returns a sink that unmarshals binary proto values into m.
+func ProtoSink(m proto.Message) Sink {
+	return &protoSink{
+		dst: m,
+	}
+}
+
+type protoSink struct {
+	dst proto.Message // authorative value
+	typ string
+
+	v ByteView // encoded
+}
+
+func (s *protoSink) view() (ByteView, error) {
+	return s.v, nil
+}
+
+func (s *protoSink) SetBytes(b []byte) error {
+	err := proto.Unmarshal(b, s.dst)
+	if err != nil {
+		return err
+	}
+	s.v.b = cloneBytes(b)
+	s.v.s = ""
+	return nil
+}
+
+func (s *protoSink) SetString(v string) error {
+	b := []byte(v)
+	err := proto.Unmarshal(b, s.dst)
+	if err != nil {
+		return err
+	}
+	s.v.b = b
+	s.v.s = ""
+	return nil
+}
+
+func (s *protoSink) SetProto(m proto.Message) error {
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return err
+	}
+	// TODO(bradfitz): optimize for same-task case more and write
+	// right through? would need to document ownership rules at
+	// the same time. but then we could just assign *dst = *m
+	// here. This works for now:
+	err = proto.Unmarshal(b, s.dst)
+	if err != nil {
+		return err
+	}
+	s.v.b = b
+	s.v.s = ""
+	return nil
+}
+
+// AllocatingByteSliceSink returns a Sink that allocates
+// a byte slice to hold the received value and assigns
+// it to *dst. The memory is not retained by groupcache.
+func AllocatingByteSliceSink(dst *[]byte) Sink {
+	return &allocBytesSink{dst: dst}
+}
+
+type allocBytesSink struct {
+	dst *[]byte
+	v   ByteView
+}
+
+func (s *allocBytesSink) view() (ByteView, error) {
+	return s.v, nil
+}
+
+func (s *allocBytesSink) setView(v ByteView) error {
+	if v.b != nil {
+		*s.dst = cloneBytes(v.b)
+	} else {
+		*s.dst = []byte(v.s)
+	}
+	s.v = v
+	return nil
+}
+
+func (s *allocBytesSink) SetProto(m proto.Message) error {
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return err
+	}
+	return s.setBytesOwned(b)
+}
+
+func (s *allocBytesSink) SetBytes(b []byte) error {
+	return s.setBytesOwned(cloneBytes(b))
+}
+
+func (s *allocBytesSink) setBytesOwned(b []byte) error {
+	if s.dst == nil {
+		return errors.New("nil AllocatingByteSliceSink *[]byte dst")
+	}
+	*s.dst = cloneBytes(b) // another copy, protecting the read-only s.v.b view
+	s.v.b = b
+	s.v.s = ""
+	return nil
+}
+
+func (s *allocBytesSink) SetString(v string) error {
+	if s.dst == nil {
+		return errors.New("nil AllocatingByteSliceSink *[]byte dst")
+	}
+	*s.dst = []byte(v)
+	s.v.b = nil
+	s.v.s = v
+	return nil
+}
+
+// TruncatingByteSliceSink returns a Sink that writes up to len(*dst)
+// bytes to *dst. If more bytes are available, they're silently
+// truncated. If fewer bytes are available than len(*dst), *dst
+// is shrunk to fit the number of bytes available.
+func TruncatingByteSliceSink(dst *[]byte) Sink {
+	return &truncBytesSink{dst: dst}
+}
+
+type truncBytesSink struct {
+	dst *[]byte
+	v   ByteView
+}
+
+func (s *truncBytesSink) view() (ByteView, error) {
+	return s.v, nil
+}
+
+func (s *truncBytesSink) SetProto(m proto.Message) error {
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return err
+	}
+	return s.setBytesOwned(b)
+}
+
+func (s *truncBytesSink) SetBytes(b []byte) error {
+	return s.setBytesOwned(cloneBytes(b))
+}
+
+func (s *truncBytesSink) setBytesOwned(b []byte) error {
+	if s.dst == nil {
+		return errors.New("nil TruncatingByteSliceSink *[]byte dst")
+	}
+	n := copy(*s.dst, b)
+	if n < len(*s.dst) {
+		*s.dst = (*s.dst)[:n]
+	}
+	s.v.b = b
+	s.v.s = ""
+	return nil
+}
+
+func (s *truncBytesSink) SetString(v string) error {
+	if s.dst == nil {
+		return errors.New("nil TruncatingByteSliceSink *[]byte dst")
+	}
+	n := copy(*s.dst, v)
+	if n < len(*s.dst) {
+		*s.dst = (*s.dst)[:n]
+	}
+	s.v.b = nil
+	s.v.s = v
+	return nil
+}
diff --git a/vendor/github.com/petar/GoLLRB/LICENSE b/vendor/github.com/petar/GoLLRB/LICENSE
new file mode 100644
index 0000000..b75312c
--- /dev/null
+++ b/vendor/github.com/petar/GoLLRB/LICENSE
@@ -0,0 +1,27 @@
+Copyright (c) 2010, Petar Maymounkov
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+(*) Redistributions of source code must retain the above copyright notice, this list
+of conditions and the following disclaimer.
+
+(*) Redistributions in binary form must reproduce the above copyright notice, this
+list of conditions and the following disclaimer in the documentation and/or
+other materials provided with the distribution.
+
+(*) Neither the name of Petar Maymounkov nor the names of its contributors may be
+used to endorse or promote products derived from this software without specific
+prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/vendor/github.com/petar/GoLLRB/llrb/avgvar.go b/vendor/github.com/petar/GoLLRB/llrb/avgvar.go
new file mode 100644
index 0000000..2d7e2a3
--- /dev/null
+++ b/vendor/github.com/petar/GoLLRB/llrb/avgvar.go
@@ -0,0 +1,39 @@
+// Copyright 2010 Petar Maymounkov. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package llrb
+
+import "math"
+
+// avgVar maintains the average and variance of a stream of numbers
+// in a space-efficient manner.
+type avgVar struct {
+	count      int64
+	sum, sumsq float64
+}
+
+func (av *avgVar) Init() {
+	av.count = 0
+	av.sum = 0.0
+	av.sumsq = 0.0
+}
+
+func (av *avgVar) Add(sample float64) {
+	av.count++
+	av.sum += sample
+	av.sumsq += sample * sample
+}
+
+func (av *avgVar) GetCount() int64 { return av.count }
+
+func (av *avgVar) GetAvg() float64 { return av.sum / float64(av.count) }
+
+func (av *avgVar) GetTotal() float64 { return av.sum }
+
+func (av *avgVar) GetVar() float64 {
+	a := av.GetAvg()
+	return av.sumsq/float64(av.count) - a*a
+}
+
+func (av *avgVar) GetStdDev() float64 { return math.Sqrt(av.GetVar()) }
diff --git a/vendor/github.com/petar/GoLLRB/llrb/iterator.go b/vendor/github.com/petar/GoLLRB/llrb/iterator.go
new file mode 100644
index 0000000..ee7b27f
--- /dev/null
+++ b/vendor/github.com/petar/GoLLRB/llrb/iterator.go
@@ -0,0 +1,93 @@
+package llrb
+
+type ItemIterator func(i Item) bool
+
+//func (t *Tree) Ascend(iterator ItemIterator) {
+//	t.AscendGreaterOrEqual(Inf(-1), iterator)
+//}
+
+func (t *LLRB) AscendRange(greaterOrEqual, lessThan Item, iterator ItemIterator) {
+	t.ascendRange(t.root, greaterOrEqual, lessThan, iterator)
+}
+
+func (t *LLRB) ascendRange(h *Node, inf, sup Item, iterator ItemIterator) bool {
+	if h == nil {
+		return true
+	}
+	if !less(h.Item, sup) {
+		return t.ascendRange(h.Left, inf, sup, iterator)
+	}
+	if less(h.Item, inf) {
+		return t.ascendRange(h.Right, inf, sup, iterator)
+	}
+
+	if !t.ascendRange(h.Left, inf, sup, iterator) {
+		return false
+	}
+	if !iterator(h.Item) {
+		return false
+	}
+	return t.ascendRange(h.Right, inf, sup, iterator)
+}
+
+// AscendGreaterOrEqual will call iterator once for each element greater or equal to
+// pivot in ascending order. It will stop whenever the iterator returns false.
+func (t *LLRB) AscendGreaterOrEqual(pivot Item, iterator ItemIterator) {
+	t.ascendGreaterOrEqual(t.root, pivot, iterator)
+}
+
+func (t *LLRB) ascendGreaterOrEqual(h *Node, pivot Item, iterator ItemIterator) bool {
+	if h == nil {
+		return true
+	}
+	if !less(h.Item, pivot) {
+		if !t.ascendGreaterOrEqual(h.Left, pivot, iterator) {
+			return false
+		}
+		if !iterator(h.Item) {
+			return false
+		}
+	}
+	return t.ascendGreaterOrEqual(h.Right, pivot, iterator)
+}
+
+func (t *LLRB) AscendLessThan(pivot Item, iterator ItemIterator) {
+	t.ascendLessThan(t.root, pivot, iterator)
+}
+
+func (t *LLRB) ascendLessThan(h *Node, pivot Item, iterator ItemIterator) bool {
+	if h == nil {
+		return true
+	}
+	if !t.ascendLessThan(h.Left, pivot, iterator) {
+		return false
+	}
+	if !iterator(h.Item) {
+		return false
+	}
+	if less(h.Item, pivot) {
+		return t.ascendLessThan(h.Left, pivot, iterator)
+	}
+	return true
+}
+
+// DescendLessOrEqual will call iterator once for each element less than the
+// pivot in descending order. It will stop whenever the iterator returns false.
+func (t *LLRB) DescendLessOrEqual(pivot Item, iterator ItemIterator) {
+	t.descendLessOrEqual(t.root, pivot, iterator)
+}
+
+func (t *LLRB) descendLessOrEqual(h *Node, pivot Item, iterator ItemIterator) bool {
+	if h == nil {
+		return true
+	}
+	if less(h.Item, pivot) || !less(pivot, h.Item) {
+		if !t.descendLessOrEqual(h.Right, pivot, iterator) {
+			return false
+		}
+		if !iterator(h.Item) {
+			return false
+		}
+	}
+	return t.descendLessOrEqual(h.Left, pivot, iterator)
+}
diff --git a/vendor/github.com/petar/GoLLRB/llrb/llrb-stats.go b/vendor/github.com/petar/GoLLRB/llrb/llrb-stats.go
new file mode 100644
index 0000000..47126a3
--- /dev/null
+++ b/vendor/github.com/petar/GoLLRB/llrb/llrb-stats.go
@@ -0,0 +1,46 @@
+// Copyright 2010 Petar Maymounkov. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package llrb
+
+// GetHeight() returns an item in the tree with key @key, and it's height in the tree
+func (t *LLRB) GetHeight(key Item) (result Item, depth int) {
+	return t.getHeight(t.root, key)
+}
+
+func (t *LLRB) getHeight(h *Node, item Item) (Item, int) {
+	if h == nil {
+		return nil, 0
+	}
+	if less(item, h.Item) {
+		result, depth := t.getHeight(h.Left, item)
+		return result, depth + 1
+	}
+	if less(h.Item, item) {
+		result, depth := t.getHeight(h.Right, item)
+		return result, depth + 1
+	}
+	return h.Item, 0
+}
+
+// HeightStats() returns the average and standard deviation of the height
+// of elements in the tree
+func (t *LLRB) HeightStats() (avg, stddev float64) {
+	av := &avgVar{}
+	heightStats(t.root, 0, av)
+	return av.GetAvg(), av.GetStdDev()
+}
+
+func heightStats(h *Node, d int, av *avgVar) {
+	if h == nil {
+		return
+	}
+	av.Add(float64(d))
+	if h.Left != nil {
+		heightStats(h.Left, d+1, av)
+	}
+	if h.Right != nil {
+		heightStats(h.Right, d+1, av)
+	}
+}
diff --git a/vendor/github.com/petar/GoLLRB/llrb/llrb.go b/vendor/github.com/petar/GoLLRB/llrb/llrb.go
new file mode 100644
index 0000000..81373fb
--- /dev/null
+++ b/vendor/github.com/petar/GoLLRB/llrb/llrb.go
@@ -0,0 +1,456 @@
+// Copyright 2010 Petar Maymounkov. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// A Left-Leaning Red-Black (LLRB) implementation of 2-3 balanced binary search trees,
+// based on the following work:
+//
+//   http://www.cs.princeton.edu/~rs/talks/LLRB/08Penn.pdf
+//   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf
+//   http://www.cs.princeton.edu/~rs/talks/LLRB/Java/RedBlackBST.java
+//
+//  2-3 trees (and the run-time equivalent 2-3-4 trees) are the de facto standard BST
+//  algoritms found in implementations of Python, Java, and other libraries. The LLRB
+//  implementation of 2-3 trees is a recent improvement on the traditional implementation,
+//  observed and documented by Robert Sedgewick.
+//
+package llrb
+
+// Tree is a Left-Leaning Red-Black (LLRB) implementation of 2-3 trees
+type LLRB struct {
+	count int
+	root  *Node
+}
+
+type Node struct {
+	Item
+	Left, Right *Node // Pointers to left and right child nodes
+	Black       bool  // If set, the color of the link (incoming from the parent) is black
+	// In the LLRB, new nodes are always red, hence the zero-value for node
+}
+
+type Item interface {
+	Less(than Item) bool
+}
+
+//
+func less(x, y Item) bool {
+	if x == pinf {
+		return false
+	}
+	if x == ninf {
+		return true
+	}
+	return x.Less(y)
+}
+
+// Inf returns an Item that is "bigger than" any other item, if sign is positive.
+// Otherwise  it returns an Item that is "smaller than" any other item.
+func Inf(sign int) Item {
+	if sign == 0 {
+		panic("sign")
+	}
+	if sign > 0 {
+		return pinf
+	}
+	return ninf
+}
+
+var (
+	ninf = nInf{}
+	pinf = pInf{}
+)
+
+type nInf struct{}
+
+func (nInf) Less(Item) bool {
+	return true
+}
+
+type pInf struct{}
+
+func (pInf) Less(Item) bool {
+	return false
+}
+
+// New() allocates a new tree
+func New() *LLRB {
+	return &LLRB{}
+}
+
+// SetRoot sets the root node of the tree.
+// It is intended to be used by functions that deserialize the tree.
+func (t *LLRB) SetRoot(r *Node) {
+	t.root = r
+}
+
+// Root returns the root node of the tree.
+// It is intended to be used by functions that serialize the tree.
+func (t *LLRB) Root() *Node {
+	return t.root
+}
+
+// Len returns the number of nodes in the tree.
+func (t *LLRB) Len() int { return t.count }
+
+// Has returns true if the tree contains an element whose order is the same as that of key.
+func (t *LLRB) Has(key Item) bool {
+	return t.Get(key) != nil
+}
+
+// Get retrieves an element from the tree whose order is the same as that of key.
+func (t *LLRB) Get(key Item) Item {
+	h := t.root
+	for h != nil {
+		switch {
+		case less(key, h.Item):
+			h = h.Left
+		case less(h.Item, key):
+			h = h.Right
+		default:
+			return h.Item
+		}
+	}
+	return nil
+}
+
+// Min returns the minimum element in the tree.
+func (t *LLRB) Min() Item {
+	h := t.root
+	if h == nil {
+		return nil
+	}
+	for h.Left != nil {
+		h = h.Left
+	}
+	return h.Item
+}
+
+// Max returns the maximum element in the tree.
+func (t *LLRB) Max() Item {
+	h := t.root
+	if h == nil {
+		return nil
+	}
+	for h.Right != nil {
+		h = h.Right
+	}
+	return h.Item
+}
+
+func (t *LLRB) ReplaceOrInsertBulk(items ...Item) {
+	for _, i := range items {
+		t.ReplaceOrInsert(i)
+	}
+}
+
+func (t *LLRB) InsertNoReplaceBulk(items ...Item) {
+	for _, i := range items {
+		t.InsertNoReplace(i)
+	}
+}
+
+// ReplaceOrInsert inserts item into the tree. If an existing
+// element has the same order, it is removed from the tree and returned.
+func (t *LLRB) ReplaceOrInsert(item Item) Item {
+	if item == nil {
+		panic("inserting nil item")
+	}
+	var replaced Item
+	t.root, replaced = t.replaceOrInsert(t.root, item)
+	t.root.Black = true
+	if replaced == nil {
+		t.count++
+	}
+	return replaced
+}
+
+func (t *LLRB) replaceOrInsert(h *Node, item Item) (*Node, Item) {
+	if h == nil {
+		return newNode(item), nil
+	}
+
+	h = walkDownRot23(h)
+
+	var replaced Item
+	if less(item, h.Item) { // BUG
+		h.Left, replaced = t.replaceOrInsert(h.Left, item)
+	} else if less(h.Item, item) {
+		h.Right, replaced = t.replaceOrInsert(h.Right, item)
+	} else {
+		replaced, h.Item = h.Item, item
+	}
+
+	h = walkUpRot23(h)
+
+	return h, replaced
+}
+
+// InsertNoReplace inserts item into the tree. If an existing
+// element has the same order, both elements remain in the tree.
+func (t *LLRB) InsertNoReplace(item Item) {
+	if item == nil {
+		panic("inserting nil item")
+	}
+	t.root = t.insertNoReplace(t.root, item)
+	t.root.Black = true
+	t.count++
+}
+
+func (t *LLRB) insertNoReplace(h *Node, item Item) *Node {
+	if h == nil {
+		return newNode(item)
+	}
+
+	h = walkDownRot23(h)
+
+	if less(item, h.Item) {
+		h.Left = t.insertNoReplace(h.Left, item)
+	} else {
+		h.Right = t.insertNoReplace(h.Right, item)
+	}
+
+	return walkUpRot23(h)
+}
+
+// Rotation driver routines for 2-3 algorithm
+
+func walkDownRot23(h *Node) *Node { return h }
+
+func walkUpRot23(h *Node) *Node {
+	if isRed(h.Right) && !isRed(h.Left) {
+		h = rotateLeft(h)
+	}
+
+	if isRed(h.Left) && isRed(h.Left.Left) {
+		h = rotateRight(h)
+	}
+
+	if isRed(h.Left) && isRed(h.Right) {
+		flip(h)
+	}
+
+	return h
+}
+
+// Rotation driver routines for 2-3-4 algorithm
+
+func walkDownRot234(h *Node) *Node {
+	if isRed(h.Left) && isRed(h.Right) {
+		flip(h)
+	}
+
+	return h
+}
+
+func walkUpRot234(h *Node) *Node {
+	if isRed(h.Right) && !isRed(h.Left) {
+		h = rotateLeft(h)
+	}
+
+	if isRed(h.Left) && isRed(h.Left.Left) {
+		h = rotateRight(h)
+	}
+
+	return h
+}
+
+// DeleteMin deletes the minimum element in the tree and returns the
+// deleted item or nil otherwise.
+func (t *LLRB) DeleteMin() Item {
+	var deleted Item
+	t.root, deleted = deleteMin(t.root)
+	if t.root != nil {
+		t.root.Black = true
+	}
+	if deleted != nil {
+		t.count--
+	}
+	return deleted
+}
+
+// deleteMin code for LLRB 2-3 trees
+func deleteMin(h *Node) (*Node, Item) {
+	if h == nil {
+		return nil, nil
+	}
+	if h.Left == nil {
+		return nil, h.Item
+	}
+
+	if !isRed(h.Left) && !isRed(h.Left.Left) {
+		h = moveRedLeft(h)
+	}
+
+	var deleted Item
+	h.Left, deleted = deleteMin(h.Left)
+
+	return fixUp(h), deleted
+}
+
+// DeleteMax deletes the maximum element in the tree and returns
+// the deleted item or nil otherwise
+func (t *LLRB) DeleteMax() Item {
+	var deleted Item
+	t.root, deleted = deleteMax(t.root)
+	if t.root != nil {
+		t.root.Black = true
+	}
+	if deleted != nil {
+		t.count--
+	}
+	return deleted
+}
+
+func deleteMax(h *Node) (*Node, Item) {
+	if h == nil {
+		return nil, nil
+	}
+	if isRed(h.Left) {
+		h = rotateRight(h)
+	}
+	if h.Right == nil {
+		return nil, h.Item
+	}
+	if !isRed(h.Right) && !isRed(h.Right.Left) {
+		h = moveRedRight(h)
+	}
+	var deleted Item
+	h.Right, deleted = deleteMax(h.Right)
+
+	return fixUp(h), deleted
+}
+
+// Delete deletes an item from the tree whose key equals key.
+// The deleted item is return, otherwise nil is returned.
+func (t *LLRB) Delete(key Item) Item {
+	var deleted Item
+	t.root, deleted = t.delete(t.root, key)
+	if t.root != nil {
+		t.root.Black = true
+	}
+	if deleted != nil {
+		t.count--
+	}
+	return deleted
+}
+
+func (t *LLRB) delete(h *Node, item Item) (*Node, Item) {
+	var deleted Item
+	if h == nil {
+		return nil, nil
+	}
+	if less(item, h.Item) {
+		if h.Left == nil { // item not present. Nothing to delete
+			return h, nil
+		}
+		if !isRed(h.Left) && !isRed(h.Left.Left) {
+			h = moveRedLeft(h)
+		}
+		h.Left, deleted = t.delete(h.Left, item)
+	} else {
+		if isRed(h.Left) {
+			h = rotateRight(h)
+		}
+		// If @item equals @h.Item and no right children at @h
+		if !less(h.Item, item) && h.Right == nil {
+			return nil, h.Item
+		}
+		// PETAR: Added 'h.Right != nil' below
+		if h.Right != nil && !isRed(h.Right) && !isRed(h.Right.Left) {
+			h = moveRedRight(h)
+		}
+		// If @item equals @h.Item, and (from above) 'h.Right != nil'
+		if !less(h.Item, item) {
+			var subDeleted Item
+			h.Right, subDeleted = deleteMin(h.Right)
+			if subDeleted == nil {
+				panic("logic")
+			}
+			deleted, h.Item = h.Item, subDeleted
+		} else { // Else, @item is bigger than @h.Item
+			h.Right, deleted = t.delete(h.Right, item)
+		}
+	}
+
+	return fixUp(h), deleted
+}
+
+// Internal node manipulation routines
+
+func newNode(item Item) *Node { return &Node{Item: item} }
+
+func isRed(h *Node) bool {
+	if h == nil {
+		return false
+	}
+	return !h.Black
+}
+
+func rotateLeft(h *Node) *Node {
+	x := h.Right
+	if x.Black {
+		panic("rotating a black link")
+	}
+	h.Right = x.Left
+	x.Left = h
+	x.Black = h.Black
+	h.Black = false
+	return x
+}
+
+func rotateRight(h *Node) *Node {
+	x := h.Left
+	if x.Black {
+		panic("rotating a black link")
+	}
+	h.Left = x.Right
+	x.Right = h
+	x.Black = h.Black
+	h.Black = false
+	return x
+}
+
+// REQUIRE: Left and Right children must be present
+func flip(h *Node) {
+	h.Black = !h.Black
+	h.Left.Black = !h.Left.Black
+	h.Right.Black = !h.Right.Black
+}
+
+// REQUIRE: Left and Right children must be present
+func moveRedLeft(h *Node) *Node {
+	flip(h)
+	if isRed(h.Right.Left) {
+		h.Right = rotateRight(h.Right)
+		h = rotateLeft(h)
+		flip(h)
+	}
+	return h
+}
+
+// REQUIRE: Left and Right children must be present
+func moveRedRight(h *Node) *Node {
+	flip(h)
+	if isRed(h.Left.Left) {
+		h = rotateRight(h)
+		flip(h)
+	}
+	return h
+}
+
+func fixUp(h *Node) *Node {
+	if isRed(h.Right) {
+		h = rotateLeft(h)
+	}
+
+	if isRed(h.Left) && isRed(h.Left.Left) {
+		h = rotateRight(h)
+	}
+
+	if isRed(h.Left) && isRed(h.Right) {
+		flip(h)
+	}
+
+	return h
+}
diff --git a/vendor/github.com/petar/GoLLRB/llrb/util.go b/vendor/github.com/petar/GoLLRB/llrb/util.go
new file mode 100644
index 0000000..63dbdb2
--- /dev/null
+++ b/vendor/github.com/petar/GoLLRB/llrb/util.go
@@ -0,0 +1,17 @@
+// Copyright 2010 Petar Maymounkov. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package llrb
+
+type Int int
+
+func (x Int) Less(than Item) bool {
+	return x < than.(Int)
+}
+
+type String string
+
+func (x String) Less(than Item) bool {
+	return x < than.(String)
+}
diff --git a/vendor/golang.org/x/crypto/ssh/buffer.go b/vendor/golang.org/x/crypto/ssh/buffer.go
new file mode 100644
index 0000000..1ab07d0
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/buffer.go
@@ -0,0 +1,97 @@
+// Copyright 2012 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"io"
+	"sync"
+)
+
+// buffer provides a linked list buffer for data exchange
+// between producer and consumer. Theoretically the buffer is
+// of unlimited capacity as it does no allocation of its own.
+type buffer struct {
+	// protects concurrent access to head, tail and closed
+	*sync.Cond
+
+	head *element // the buffer that will be read first
+	tail *element // the buffer that will be read last
+
+	closed bool
+}
+
+// An element represents a single link in a linked list.
+type element struct {
+	buf  []byte
+	next *element
+}
+
+// newBuffer returns an empty buffer that is not closed.
+func newBuffer() *buffer {
+	e := new(element)
+	b := &buffer{
+		Cond: newCond(),
+		head: e,
+		tail: e,
+	}
+	return b
+}
+
+// write makes buf available for Read to receive.
+// buf must not be modified after the call to write.
+func (b *buffer) write(buf []byte) {
+	b.Cond.L.Lock()
+	e := &element{buf: buf}
+	b.tail.next = e
+	b.tail = e
+	b.Cond.Signal()
+	b.Cond.L.Unlock()
+}
+
+// eof closes the buffer. Reads from the buffer once all
+// the data has been consumed will receive io.EOF.
+func (b *buffer) eof() {
+	b.Cond.L.Lock()
+	b.closed = true
+	b.Cond.Signal()
+	b.Cond.L.Unlock()
+}
+
+// Read reads data from the internal buffer in buf.  Reads will block
+// if no data is available, or until the buffer is closed.
+func (b *buffer) Read(buf []byte) (n int, err error) {
+	b.Cond.L.Lock()
+	defer b.Cond.L.Unlock()
+
+	for len(buf) > 0 {
+		// if there is data in b.head, copy it
+		if len(b.head.buf) > 0 {
+			r := copy(buf, b.head.buf)
+			buf, b.head.buf = buf[r:], b.head.buf[r:]
+			n += r
+			continue
+		}
+		// if there is a next buffer, make it the head
+		if len(b.head.buf) == 0 && b.head != b.tail {
+			b.head = b.head.next
+			continue
+		}
+
+		// if at least one byte has been copied, return
+		if n > 0 {
+			break
+		}
+
+		// if nothing was read, and there is nothing outstanding
+		// check to see if the buffer is closed.
+		if b.closed {
+			err = io.EOF
+			break
+		}
+		// out of buffers, wait for producer
+		b.Cond.Wait()
+	}
+	return
+}
diff --git a/vendor/golang.org/x/crypto/ssh/certs.go b/vendor/golang.org/x/crypto/ssh/certs.go
new file mode 100644
index 0000000..b1f0220
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/certs.go
@@ -0,0 +1,519 @@
+// Copyright 2012 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"bytes"
+	"errors"
+	"fmt"
+	"io"
+	"net"
+	"sort"
+	"time"
+)
+
+// These constants from [PROTOCOL.certkeys] represent the algorithm names
+// for certificate types supported by this package.
+const (
+	CertAlgoRSAv01      = "ssh-rsa-cert-v01@openssh.com"
+	CertAlgoDSAv01      = "ssh-dss-cert-v01@openssh.com"
+	CertAlgoECDSA256v01 = "ecdsa-sha2-nistp256-cert-v01@openssh.com"
+	CertAlgoECDSA384v01 = "ecdsa-sha2-nistp384-cert-v01@openssh.com"
+	CertAlgoECDSA521v01 = "ecdsa-sha2-nistp521-cert-v01@openssh.com"
+	CertAlgoED25519v01  = "ssh-ed25519-cert-v01@openssh.com"
+)
+
+// Certificate types distinguish between host and user
+// certificates. The values can be set in the CertType field of
+// Certificate.
+const (
+	UserCert = 1
+	HostCert = 2
+)
+
+// Signature represents a cryptographic signature.
+type Signature struct {
+	Format string
+	Blob   []byte
+}
+
+// CertTimeInfinity can be used for OpenSSHCertV01.ValidBefore to indicate that
+// a certificate does not expire.
+const CertTimeInfinity = 1<<64 - 1
+
+// An Certificate represents an OpenSSH certificate as defined in
+// [PROTOCOL.certkeys]?rev=1.8.
+type Certificate struct {
+	Nonce           []byte
+	Key             PublicKey
+	Serial          uint64
+	CertType        uint32
+	KeyId           string
+	ValidPrincipals []string
+	ValidAfter      uint64
+	ValidBefore     uint64
+	Permissions
+	Reserved     []byte
+	SignatureKey PublicKey
+	Signature    *Signature
+}
+
+// genericCertData holds the key-independent part of the certificate data.
+// Overall, certificates contain an nonce, public key fields and
+// key-independent fields.
+type genericCertData struct {
+	Serial          uint64
+	CertType        uint32
+	KeyId           string
+	ValidPrincipals []byte
+	ValidAfter      uint64
+	ValidBefore     uint64
+	CriticalOptions []byte
+	Extensions      []byte
+	Reserved        []byte
+	SignatureKey    []byte
+	Signature       []byte
+}
+
+func marshalStringList(namelist []string) []byte {
+	var to []byte
+	for _, name := range namelist {
+		s := struct{ N string }{name}
+		to = append(to, Marshal(&s)...)
+	}
+	return to
+}
+
+type optionsTuple struct {
+	Key   string
+	Value []byte
+}
+
+type optionsTupleValue struct {
+	Value string
+}
+
+// serialize a map of critical options or extensions
+// issue #10569 - per [PROTOCOL.certkeys] and SSH implementation,
+// we need two length prefixes for a non-empty string value
+func marshalTuples(tups map[string]string) []byte {
+	keys := make([]string, 0, len(tups))
+	for key := range tups {
+		keys = append(keys, key)
+	}
+	sort.Strings(keys)
+
+	var ret []byte
+	for _, key := range keys {
+		s := optionsTuple{Key: key}
+		if value := tups[key]; len(value) > 0 {
+			s.Value = Marshal(&optionsTupleValue{value})
+		}
+		ret = append(ret, Marshal(&s)...)
+	}
+	return ret
+}
+
+// issue #10569 - per [PROTOCOL.certkeys] and SSH implementation,
+// we need two length prefixes for a non-empty option value
+func parseTuples(in []byte) (map[string]string, error) {
+	tups := map[string]string{}
+	var lastKey string
+	var haveLastKey bool
+
+	for len(in) > 0 {
+		var key, val, extra []byte
+		var ok bool
+
+		if key, in, ok = parseString(in); !ok {
+			return nil, errShortRead
+		}
+		keyStr := string(key)
+		// according to [PROTOCOL.certkeys], the names must be in
+		// lexical order.
+		if haveLastKey && keyStr <= lastKey {
+			return nil, fmt.Errorf("ssh: certificate options are not in lexical order")
+		}
+		lastKey, haveLastKey = keyStr, true
+		// the next field is a data field, which if non-empty has a string embedded
+		if val, in, ok = parseString(in); !ok {
+			return nil, errShortRead
+		}
+		if len(val) > 0 {
+			val, extra, ok = parseString(val)
+			if !ok {
+				return nil, errShortRead
+			}
+			if len(extra) > 0 {
+				return nil, fmt.Errorf("ssh: unexpected trailing data after certificate option value")
+			}
+			tups[keyStr] = string(val)
+		} else {
+			tups[keyStr] = ""
+		}
+	}
+	return tups, nil
+}
+
+func parseCert(in []byte, privAlgo string) (*Certificate, error) {
+	nonce, rest, ok := parseString(in)
+	if !ok {
+		return nil, errShortRead
+	}
+
+	key, rest, err := parsePubKey(rest, privAlgo)
+	if err != nil {
+		return nil, err
+	}
+
+	var g genericCertData
+	if err := Unmarshal(rest, &g); err != nil {
+		return nil, err
+	}
+
+	c := &Certificate{
+		Nonce:       nonce,
+		Key:         key,
+		Serial:      g.Serial,
+		CertType:    g.CertType,
+		KeyId:       g.KeyId,
+		ValidAfter:  g.ValidAfter,
+		ValidBefore: g.ValidBefore,
+	}
+
+	for principals := g.ValidPrincipals; len(principals) > 0; {
+		principal, rest, ok := parseString(principals)
+		if !ok {
+			return nil, errShortRead
+		}
+		c.ValidPrincipals = append(c.ValidPrincipals, string(principal))
+		principals = rest
+	}
+
+	c.CriticalOptions, err = parseTuples(g.CriticalOptions)
+	if err != nil {
+		return nil, err
+	}
+	c.Extensions, err = parseTuples(g.Extensions)
+	if err != nil {
+		return nil, err
+	}
+	c.Reserved = g.Reserved
+	k, err := ParsePublicKey(g.SignatureKey)
+	if err != nil {
+		return nil, err
+	}
+
+	c.SignatureKey = k
+	c.Signature, rest, ok = parseSignatureBody(g.Signature)
+	if !ok || len(rest) > 0 {
+		return nil, errors.New("ssh: signature parse error")
+	}
+
+	return c, nil
+}
+
+type openSSHCertSigner struct {
+	pub    *Certificate
+	signer Signer
+}
+
+// NewCertSigner returns a Signer that signs with the given Certificate, whose
+// private key is held by signer. It returns an error if the public key in cert
+// doesn't match the key used by signer.
+func NewCertSigner(cert *Certificate, signer Signer) (Signer, error) {
+	if bytes.Compare(cert.Key.Marshal(), signer.PublicKey().Marshal()) != 0 {
+		return nil, errors.New("ssh: signer and cert have different public key")
+	}
+
+	return &openSSHCertSigner{cert, signer}, nil
+}
+
+func (s *openSSHCertSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {
+	return s.signer.Sign(rand, data)
+}
+
+func (s *openSSHCertSigner) PublicKey() PublicKey {
+	return s.pub
+}
+
+const sourceAddressCriticalOption = "source-address"
+
+// CertChecker does the work of verifying a certificate. Its methods
+// can be plugged into ClientConfig.HostKeyCallback and
+// ServerConfig.PublicKeyCallback. For the CertChecker to work,
+// minimally, the IsAuthority callback should be set.
+type CertChecker struct {
+	// SupportedCriticalOptions lists the CriticalOptions that the
+	// server application layer understands. These are only used
+	// for user certificates.
+	SupportedCriticalOptions []string
+
+	// IsUserAuthority should return true if the key is recognized as an
+	// authority for the given user certificate. This allows for
+	// certificates to be signed by other certificates. This must be set
+	// if this CertChecker will be checking user certificates.
+	IsUserAuthority func(auth PublicKey) bool
+
+	// IsHostAuthority should report whether the key is recognized as
+	// an authority for this host. This allows for certificates to be
+	// signed by other keys, and for those other keys to only be valid
+	// signers for particular hostnames. This must be set if this
+	// CertChecker will be checking host certificates.
+	IsHostAuthority func(auth PublicKey, address string) bool
+
+	// Clock is used for verifying time stamps. If nil, time.Now
+	// is used.
+	Clock func() time.Time
+
+	// UserKeyFallback is called when CertChecker.Authenticate encounters a
+	// public key that is not a certificate. It must implement validation
+	// of user keys or else, if nil, all such keys are rejected.
+	UserKeyFallback func(conn ConnMetadata, key PublicKey) (*Permissions, error)
+
+	// HostKeyFallback is called when CertChecker.CheckHostKey encounters a
+	// public key that is not a certificate. It must implement host key
+	// validation or else, if nil, all such keys are rejected.
+	HostKeyFallback HostKeyCallback
+
+	// IsRevoked is called for each certificate so that revocation checking
+	// can be implemented. It should return true if the given certificate
+	// is revoked and false otherwise. If nil, no certificates are
+	// considered to have been revoked.
+	IsRevoked func(cert *Certificate) bool
+}
+
+// CheckHostKey checks a host key certificate. This method can be
+// plugged into ClientConfig.HostKeyCallback.
+func (c *CertChecker) CheckHostKey(addr string, remote net.Addr, key PublicKey) error {
+	cert, ok := key.(*Certificate)
+	if !ok {
+		if c.HostKeyFallback != nil {
+			return c.HostKeyFallback(addr, remote, key)
+		}
+		return errors.New("ssh: non-certificate host key")
+	}
+	if cert.CertType != HostCert {
+		return fmt.Errorf("ssh: certificate presented as a host key has type %d", cert.CertType)
+	}
+	if !c.IsHostAuthority(cert.SignatureKey, addr) {
+		return fmt.Errorf("ssh: no authorities for hostname: %v", addr)
+	}
+
+	hostname, _, err := net.SplitHostPort(addr)
+	if err != nil {
+		return err
+	}
+
+	// Pass hostname only as principal for host certificates (consistent with OpenSSH)
+	return c.CheckCert(hostname, cert)
+}
+
+// Authenticate checks a user certificate. Authenticate can be used as
+// a value for ServerConfig.PublicKeyCallback.
+func (c *CertChecker) Authenticate(conn ConnMetadata, pubKey PublicKey) (*Permissions, error) {
+	cert, ok := pubKey.(*Certificate)
+	if !ok {
+		if c.UserKeyFallback != nil {
+			return c.UserKeyFallback(conn, pubKey)
+		}
+		return nil, errors.New("ssh: normal key pairs not accepted")
+	}
+
+	if cert.CertType != UserCert {
+		return nil, fmt.Errorf("ssh: cert has type %d", cert.CertType)
+	}
+	if !c.IsUserAuthority(cert.SignatureKey) {
+		return nil, fmt.Errorf("ssh: certificate signed by unrecognized authority")
+	}
+
+	if err := c.CheckCert(conn.User(), cert); err != nil {
+		return nil, err
+	}
+
+	return &cert.Permissions, nil
+}
+
+// CheckCert checks CriticalOptions, ValidPrincipals, revocation, timestamp and
+// the signature of the certificate.
+func (c *CertChecker) CheckCert(principal string, cert *Certificate) error {
+	if c.IsRevoked != nil && c.IsRevoked(cert) {
+		return fmt.Errorf("ssh: certicate serial %d revoked", cert.Serial)
+	}
+
+	for opt, _ := range cert.CriticalOptions {
+		// sourceAddressCriticalOption will be enforced by
+		// serverAuthenticate
+		if opt == sourceAddressCriticalOption {
+			continue
+		}
+
+		found := false
+		for _, supp := range c.SupportedCriticalOptions {
+			if supp == opt {
+				found = true
+				break
+			}
+		}
+		if !found {
+			return fmt.Errorf("ssh: unsupported critical option %q in certificate", opt)
+		}
+	}
+
+	if len(cert.ValidPrincipals) > 0 {
+		// By default, certs are valid for all users/hosts.
+		found := false
+		for _, p := range cert.ValidPrincipals {
+			if p == principal {
+				found = true
+				break
+			}
+		}
+		if !found {
+			return fmt.Errorf("ssh: principal %q not in the set of valid principals for given certificate: %q", principal, cert.ValidPrincipals)
+		}
+	}
+
+	clock := c.Clock
+	if clock == nil {
+		clock = time.Now
+	}
+
+	unixNow := clock().Unix()
+	if after := int64(cert.ValidAfter); after < 0 || unixNow < int64(cert.ValidAfter) {
+		return fmt.Errorf("ssh: cert is not yet valid")
+	}
+	if before := int64(cert.ValidBefore); cert.ValidBefore != uint64(CertTimeInfinity) && (unixNow >= before || before < 0) {
+		return fmt.Errorf("ssh: cert has expired")
+	}
+	if err := cert.SignatureKey.Verify(cert.bytesForSigning(), cert.Signature); err != nil {
+		return fmt.Errorf("ssh: certificate signature does not verify")
+	}
+
+	return nil
+}
+
+// SignCert sets c.SignatureKey to the authority's public key and stores a
+// Signature, by authority, in the certificate.
+func (c *Certificate) SignCert(rand io.Reader, authority Signer) error {
+	c.Nonce = make([]byte, 32)
+	if _, err := io.ReadFull(rand, c.Nonce); err != nil {
+		return err
+	}
+	c.SignatureKey = authority.PublicKey()
+
+	sig, err := authority.Sign(rand, c.bytesForSigning())
+	if err != nil {
+		return err
+	}
+	c.Signature = sig
+	return nil
+}
+
+var certAlgoNames = map[string]string{
+	KeyAlgoRSA:      CertAlgoRSAv01,
+	KeyAlgoDSA:      CertAlgoDSAv01,
+	KeyAlgoECDSA256: CertAlgoECDSA256v01,
+	KeyAlgoECDSA384: CertAlgoECDSA384v01,
+	KeyAlgoECDSA521: CertAlgoECDSA521v01,
+	KeyAlgoED25519:  CertAlgoED25519v01,
+}
+
+// certToPrivAlgo returns the underlying algorithm for a certificate algorithm.
+// Panics if a non-certificate algorithm is passed.
+func certToPrivAlgo(algo string) string {
+	for privAlgo, pubAlgo := range certAlgoNames {
+		if pubAlgo == algo {
+			return privAlgo
+		}
+	}
+	panic("unknown cert algorithm")
+}
+
+func (cert *Certificate) bytesForSigning() []byte {
+	c2 := *cert
+	c2.Signature = nil
+	out := c2.Marshal()
+	// Drop trailing signature length.
+	return out[:len(out)-4]
+}
+
+// Marshal serializes c into OpenSSH's wire format. It is part of the
+// PublicKey interface.
+func (c *Certificate) Marshal() []byte {
+	generic := genericCertData{
+		Serial:          c.Serial,
+		CertType:        c.CertType,
+		KeyId:           c.KeyId,
+		ValidPrincipals: marshalStringList(c.ValidPrincipals),
+		ValidAfter:      uint64(c.ValidAfter),
+		ValidBefore:     uint64(c.ValidBefore),
+		CriticalOptions: marshalTuples(c.CriticalOptions),
+		Extensions:      marshalTuples(c.Extensions),
+		Reserved:        c.Reserved,
+		SignatureKey:    c.SignatureKey.Marshal(),
+	}
+	if c.Signature != nil {
+		generic.Signature = Marshal(c.Signature)
+	}
+	genericBytes := Marshal(&generic)
+	keyBytes := c.Key.Marshal()
+	_, keyBytes, _ = parseString(keyBytes)
+	prefix := Marshal(&struct {
+		Name  string
+		Nonce []byte
+		Key   []byte `ssh:"rest"`
+	}{c.Type(), c.Nonce, keyBytes})
+
+	result := make([]byte, 0, len(prefix)+len(genericBytes))
+	result = append(result, prefix...)
+	result = append(result, genericBytes...)
+	return result
+}
+
+// Type returns the key name. It is part of the PublicKey interface.
+func (c *Certificate) Type() string {
+	algo, ok := certAlgoNames[c.Key.Type()]
+	if !ok {
+		panic("unknown cert key type " + c.Key.Type())
+	}
+	return algo
+}
+
+// Verify verifies a signature against the certificate's public
+// key. It is part of the PublicKey interface.
+func (c *Certificate) Verify(data []byte, sig *Signature) error {
+	return c.Key.Verify(data, sig)
+}
+
+func parseSignatureBody(in []byte) (out *Signature, rest []byte, ok bool) {
+	format, in, ok := parseString(in)
+	if !ok {
+		return
+	}
+
+	out = &Signature{
+		Format: string(format),
+	}
+
+	if out.Blob, in, ok = parseString(in); !ok {
+		return
+	}
+
+	return out, in, ok
+}
+
+func parseSignature(in []byte) (out *Signature, rest []byte, ok bool) {
+	sigBytes, rest, ok := parseString(in)
+	if !ok {
+		return
+	}
+
+	out, trailing, ok := parseSignatureBody(sigBytes)
+	if !ok || len(trailing) > 0 {
+		return nil, nil, false
+	}
+	return
+}
diff --git a/vendor/golang.org/x/crypto/ssh/channel.go b/vendor/golang.org/x/crypto/ssh/channel.go
new file mode 100644
index 0000000..195530e
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/channel.go
@@ -0,0 +1,633 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"encoding/binary"
+	"errors"
+	"fmt"
+	"io"
+	"log"
+	"sync"
+)
+
+const (
+	minPacketLength = 9
+	// channelMaxPacket contains the maximum number of bytes that will be
+	// sent in a single packet. As per RFC 4253, section 6.1, 32k is also
+	// the minimum.
+	channelMaxPacket = 1 << 15
+	// We follow OpenSSH here.
+	channelWindowSize = 64 * channelMaxPacket
+)
+
+// NewChannel represents an incoming request to a channel. It must either be
+// accepted for use by calling Accept, or rejected by calling Reject.
+type NewChannel interface {
+	// Accept accepts the channel creation request. It returns the Channel
+	// and a Go channel containing SSH requests. The Go channel must be
+	// serviced otherwise the Channel will hang.
+	Accept() (Channel, <-chan *Request, error)
+
+	// Reject rejects the channel creation request. After calling
+	// this, no other methods on the Channel may be called.
+	Reject(reason RejectionReason, message string) error
+
+	// ChannelType returns the type of the channel, as supplied by the
+	// client.
+	ChannelType() string
+
+	// ExtraData returns the arbitrary payload for this channel, as supplied
+	// by the client. This data is specific to the channel type.
+	ExtraData() []byte
+}
+
+// A Channel is an ordered, reliable, flow-controlled, duplex stream
+// that is multiplexed over an SSH connection.
+type Channel interface {
+	// Read reads up to len(data) bytes from the channel.
+	Read(data []byte) (int, error)
+
+	// Write writes len(data) bytes to the channel.
+	Write(data []byte) (int, error)
+
+	// Close signals end of channel use. No data may be sent after this
+	// call.
+	Close() error
+
+	// CloseWrite signals the end of sending in-band
+	// data. Requests may still be sent, and the other side may
+	// still send data
+	CloseWrite() error
+
+	// SendRequest sends a channel request.  If wantReply is true,
+	// it will wait for a reply and return the result as a
+	// boolean, otherwise the return value will be false. Channel
+	// requests are out-of-band messages so they may be sent even
+	// if the data stream is closed or blocked by flow control.
+	// If the channel is closed before a reply is returned, io.EOF
+	// is returned.
+	SendRequest(name string, wantReply bool, payload []byte) (bool, error)
+
+	// Stderr returns an io.ReadWriter that writes to this channel
+	// with the extended data type set to stderr. Stderr may
+	// safely be read and written from a different goroutine than
+	// Read and Write respectively.
+	Stderr() io.ReadWriter
+}
+
+// Request is a request sent outside of the normal stream of
+// data. Requests can either be specific to an SSH channel, or they
+// can be global.
+type Request struct {
+	Type      string
+	WantReply bool
+	Payload   []byte
+
+	ch  *channel
+	mux *mux
+}
+
+// Reply sends a response to a request. It must be called for all requests
+// where WantReply is true and is a no-op otherwise. The payload argument is
+// ignored for replies to channel-specific requests.
+func (r *Request) Reply(ok bool, payload []byte) error {
+	if !r.WantReply {
+		return nil
+	}
+
+	if r.ch == nil {
+		return r.mux.ackRequest(ok, payload)
+	}
+
+	return r.ch.ackRequest(ok)
+}
+
+// RejectionReason is an enumeration used when rejecting channel creation
+// requests. See RFC 4254, section 5.1.
+type RejectionReason uint32
+
+const (
+	Prohibited RejectionReason = iota + 1
+	ConnectionFailed
+	UnknownChannelType
+	ResourceShortage
+)
+
+// String converts the rejection reason to human readable form.
+func (r RejectionReason) String() string {
+	switch r {
+	case Prohibited:
+		return "administratively prohibited"
+	case ConnectionFailed:
+		return "connect failed"
+	case UnknownChannelType:
+		return "unknown channel type"
+	case ResourceShortage:
+		return "resource shortage"
+	}
+	return fmt.Sprintf("unknown reason %d", int(r))
+}
+
+func min(a uint32, b int) uint32 {
+	if a < uint32(b) {
+		return a
+	}
+	return uint32(b)
+}
+
+type channelDirection uint8
+
+const (
+	channelInbound channelDirection = iota
+	channelOutbound
+)
+
+// channel is an implementation of the Channel interface that works
+// with the mux class.
+type channel struct {
+	// R/O after creation
+	chanType          string
+	extraData         []byte
+	localId, remoteId uint32
+
+	// maxIncomingPayload and maxRemotePayload are the maximum
+	// payload sizes of normal and extended data packets for
+	// receiving and sending, respectively. The wire packet will
+	// be 9 or 13 bytes larger (excluding encryption overhead).
+	maxIncomingPayload uint32
+	maxRemotePayload   uint32
+
+	mux *mux
+
+	// decided is set to true if an accept or reject message has been sent
+	// (for outbound channels) or received (for inbound channels).
+	decided bool
+
+	// direction contains either channelOutbound, for channels created
+	// locally, or channelInbound, for channels created by the peer.
+	direction channelDirection
+
+	// Pending internal channel messages.
+	msg chan interface{}
+
+	// Since requests have no ID, there can be only one request
+	// with WantReply=true outstanding.  This lock is held by a
+	// goroutine that has such an outgoing request pending.
+	sentRequestMu sync.Mutex
+
+	incomingRequests chan *Request
+
+	sentEOF bool
+
+	// thread-safe data
+	remoteWin  window
+	pending    *buffer
+	extPending *buffer
+
+	// windowMu protects myWindow, the flow-control window.
+	windowMu sync.Mutex
+	myWindow uint32
+
+	// writeMu serializes calls to mux.conn.writePacket() and
+	// protects sentClose and packetPool. This mutex must be
+	// different from windowMu, as writePacket can block if there
+	// is a key exchange pending.
+	writeMu   sync.Mutex
+	sentClose bool
+
+	// packetPool has a buffer for each extended channel ID to
+	// save allocations during writes.
+	packetPool map[uint32][]byte
+}
+
+// writePacket sends a packet. If the packet is a channel close, it updates
+// sentClose. This method takes the lock c.writeMu.
+func (c *channel) writePacket(packet []byte) error {
+	c.writeMu.Lock()
+	if c.sentClose {
+		c.writeMu.Unlock()
+		return io.EOF
+	}
+	c.sentClose = (packet[0] == msgChannelClose)
+	err := c.mux.conn.writePacket(packet)
+	c.writeMu.Unlock()
+	return err
+}
+
+func (c *channel) sendMessage(msg interface{}) error {
+	if debugMux {
+		log.Printf("send(%d): %#v", c.mux.chanList.offset, msg)
+	}
+
+	p := Marshal(msg)
+	binary.BigEndian.PutUint32(p[1:], c.remoteId)
+	return c.writePacket(p)
+}
+
+// WriteExtended writes data to a specific extended stream. These streams are
+// used, for example, for stderr.
+func (c *channel) WriteExtended(data []byte, extendedCode uint32) (n int, err error) {
+	if c.sentEOF {
+		return 0, io.EOF
+	}
+	// 1 byte message type, 4 bytes remoteId, 4 bytes data length
+	opCode := byte(msgChannelData)
+	headerLength := uint32(9)
+	if extendedCode > 0 {
+		headerLength += 4
+		opCode = msgChannelExtendedData
+	}
+
+	c.writeMu.Lock()
+	packet := c.packetPool[extendedCode]
+	// We don't remove the buffer from packetPool, so
+	// WriteExtended calls from different goroutines will be
+	// flagged as errors by the race detector.
+	c.writeMu.Unlock()
+
+	for len(data) > 0 {
+		space := min(c.maxRemotePayload, len(data))
+		if space, err = c.remoteWin.reserve(space); err != nil {
+			return n, err
+		}
+		if want := headerLength + space; uint32(cap(packet)) < want {
+			packet = make([]byte, want)
+		} else {
+			packet = packet[:want]
+		}
+
+		todo := data[:space]
+
+		packet[0] = opCode
+		binary.BigEndian.PutUint32(packet[1:], c.remoteId)
+		if extendedCode > 0 {
+			binary.BigEndian.PutUint32(packet[5:], uint32(extendedCode))
+		}
+		binary.BigEndian.PutUint32(packet[headerLength-4:], uint32(len(todo)))
+		copy(packet[headerLength:], todo)
+		if err = c.writePacket(packet); err != nil {
+			return n, err
+		}
+
+		n += len(todo)
+		data = data[len(todo):]
+	}
+
+	c.writeMu.Lock()
+	c.packetPool[extendedCode] = packet
+	c.writeMu.Unlock()
+
+	return n, err
+}
+
+func (c *channel) handleData(packet []byte) error {
+	headerLen := 9
+	isExtendedData := packet[0] == msgChannelExtendedData
+	if isExtendedData {
+		headerLen = 13
+	}
+	if len(packet) < headerLen {
+		// malformed data packet
+		return parseError(packet[0])
+	}
+
+	var extended uint32
+	if isExtendedData {
+		extended = binary.BigEndian.Uint32(packet[5:])
+	}
+
+	length := binary.BigEndian.Uint32(packet[headerLen-4 : headerLen])
+	if length == 0 {
+		return nil
+	}
+	if length > c.maxIncomingPayload {
+		// TODO(hanwen): should send Disconnect?
+		return errors.New("ssh: incoming packet exceeds maximum payload size")
+	}
+
+	data := packet[headerLen:]
+	if length != uint32(len(data)) {
+		return errors.New("ssh: wrong packet length")
+	}
+
+	c.windowMu.Lock()
+	if c.myWindow < length {
+		c.windowMu.Unlock()
+		// TODO(hanwen): should send Disconnect with reason?
+		return errors.New("ssh: remote side wrote too much")
+	}
+	c.myWindow -= length
+	c.windowMu.Unlock()
+
+	if extended == 1 {
+		c.extPending.write(data)
+	} else if extended > 0 {
+		// discard other extended data.
+	} else {
+		c.pending.write(data)
+	}
+	return nil
+}
+
+func (c *channel) adjustWindow(n uint32) error {
+	c.windowMu.Lock()
+	// Since myWindow is managed on our side, and can never exceed
+	// the initial window setting, we don't worry about overflow.
+	c.myWindow += uint32(n)
+	c.windowMu.Unlock()
+	return c.sendMessage(windowAdjustMsg{
+		AdditionalBytes: uint32(n),
+	})
+}
+
+func (c *channel) ReadExtended(data []byte, extended uint32) (n int, err error) {
+	switch extended {
+	case 1:
+		n, err = c.extPending.Read(data)
+	case 0:
+		n, err = c.pending.Read(data)
+	default:
+		return 0, fmt.Errorf("ssh: extended code %d unimplemented", extended)
+	}
+
+	if n > 0 {
+		err = c.adjustWindow(uint32(n))
+		// sendWindowAdjust can return io.EOF if the remote
+		// peer has closed the connection, however we want to
+		// defer forwarding io.EOF to the caller of Read until
+		// the buffer has been drained.
+		if n > 0 && err == io.EOF {
+			err = nil
+		}
+	}
+
+	return n, err
+}
+
+func (c *channel) close() {
+	c.pending.eof()
+	c.extPending.eof()
+	close(c.msg)
+	close(c.incomingRequests)
+	c.writeMu.Lock()
+	// This is not necessary for a normal channel teardown, but if
+	// there was another error, it is.
+	c.sentClose = true
+	c.writeMu.Unlock()
+	// Unblock writers.
+	c.remoteWin.close()
+}
+
+// responseMessageReceived is called when a success or failure message is
+// received on a channel to check that such a message is reasonable for the
+// given channel.
+func (c *channel) responseMessageReceived() error {
+	if c.direction == channelInbound {
+		return errors.New("ssh: channel response message received on inbound channel")
+	}
+	if c.decided {
+		return errors.New("ssh: duplicate response received for channel")
+	}
+	c.decided = true
+	return nil
+}
+
+func (c *channel) handlePacket(packet []byte) error {
+	switch packet[0] {
+	case msgChannelData, msgChannelExtendedData:
+		return c.handleData(packet)
+	case msgChannelClose:
+		c.sendMessage(channelCloseMsg{PeersId: c.remoteId})
+		c.mux.chanList.remove(c.localId)
+		c.close()
+		return nil
+	case msgChannelEOF:
+		// RFC 4254 is mute on how EOF affects dataExt messages but
+		// it is logical to signal EOF at the same time.
+		c.extPending.eof()
+		c.pending.eof()
+		return nil
+	}
+
+	decoded, err := decode(packet)
+	if err != nil {
+		return err
+	}
+
+	switch msg := decoded.(type) {
+	case *channelOpenFailureMsg:
+		if err := c.responseMessageReceived(); err != nil {
+			return err
+		}
+		c.mux.chanList.remove(msg.PeersId)
+		c.msg <- msg
+	case *channelOpenConfirmMsg:
+		if err := c.responseMessageReceived(); err != nil {
+			return err
+		}
+		if msg.MaxPacketSize < minPacketLength || msg.MaxPacketSize > 1<<31 {
+			return fmt.Errorf("ssh: invalid MaxPacketSize %d from peer", msg.MaxPacketSize)
+		}
+		c.remoteId = msg.MyId
+		c.maxRemotePayload = msg.MaxPacketSize
+		c.remoteWin.add(msg.MyWindow)
+		c.msg <- msg
+	case *windowAdjustMsg:
+		if !c.remoteWin.add(msg.AdditionalBytes) {
+			return fmt.Errorf("ssh: invalid window update for %d bytes", msg.AdditionalBytes)
+		}
+	case *channelRequestMsg:
+		req := Request{
+			Type:      msg.Request,
+			WantReply: msg.WantReply,
+			Payload:   msg.RequestSpecificData,
+			ch:        c,
+		}
+
+		c.incomingRequests <- &req
+	default:
+		c.msg <- msg
+	}
+	return nil
+}
+
+func (m *mux) newChannel(chanType string, direction channelDirection, extraData []byte) *channel {
+	ch := &channel{
+		remoteWin:        window{Cond: newCond()},
+		myWindow:         channelWindowSize,
+		pending:          newBuffer(),
+		extPending:       newBuffer(),
+		direction:        direction,
+		incomingRequests: make(chan *Request, chanSize),
+		msg:              make(chan interface{}, chanSize),
+		chanType:         chanType,
+		extraData:        extraData,
+		mux:              m,
+		packetPool:       make(map[uint32][]byte),
+	}
+	ch.localId = m.chanList.add(ch)
+	return ch
+}
+
+var errUndecided = errors.New("ssh: must Accept or Reject channel")
+var errDecidedAlready = errors.New("ssh: can call Accept or Reject only once")
+
+type extChannel struct {
+	code uint32
+	ch   *channel
+}
+
+func (e *extChannel) Write(data []byte) (n int, err error) {
+	return e.ch.WriteExtended(data, e.code)
+}
+
+func (e *extChannel) Read(data []byte) (n int, err error) {
+	return e.ch.ReadExtended(data, e.code)
+}
+
+func (c *channel) Accept() (Channel, <-chan *Request, error) {
+	if c.decided {
+		return nil, nil, errDecidedAlready
+	}
+	c.maxIncomingPayload = channelMaxPacket
+	confirm := channelOpenConfirmMsg{
+		PeersId:       c.remoteId,
+		MyId:          c.localId,
+		MyWindow:      c.myWindow,
+		MaxPacketSize: c.maxIncomingPayload,
+	}
+	c.decided = true
+	if err := c.sendMessage(confirm); err != nil {
+		return nil, nil, err
+	}
+
+	return c, c.incomingRequests, nil
+}
+
+func (ch *channel) Reject(reason RejectionReason, message string) error {
+	if ch.decided {
+		return errDecidedAlready
+	}
+	reject := channelOpenFailureMsg{
+		PeersId:  ch.remoteId,
+		Reason:   reason,
+		Message:  message,
+		Language: "en",
+	}
+	ch.decided = true
+	return ch.sendMessage(reject)
+}
+
+func (ch *channel) Read(data []byte) (int, error) {
+	if !ch.decided {
+		return 0, errUndecided
+	}
+	return ch.ReadExtended(data, 0)
+}
+
+func (ch *channel) Write(data []byte) (int, error) {
+	if !ch.decided {
+		return 0, errUndecided
+	}
+	return ch.WriteExtended(data, 0)
+}
+
+func (ch *channel) CloseWrite() error {
+	if !ch.decided {
+		return errUndecided
+	}
+	ch.sentEOF = true
+	return ch.sendMessage(channelEOFMsg{
+		PeersId: ch.remoteId})
+}
+
+func (ch *channel) Close() error {
+	if !ch.decided {
+		return errUndecided
+	}
+
+	return ch.sendMessage(channelCloseMsg{
+		PeersId: ch.remoteId})
+}
+
+// Extended returns an io.ReadWriter that sends and receives data on the given,
+// SSH extended stream. Such streams are used, for example, for stderr.
+func (ch *channel) Extended(code uint32) io.ReadWriter {
+	if !ch.decided {
+		return nil
+	}
+	return &extChannel{code, ch}
+}
+
+func (ch *channel) Stderr() io.ReadWriter {
+	return ch.Extended(1)
+}
+
+func (ch *channel) SendRequest(name string, wantReply bool, payload []byte) (bool, error) {
+	if !ch.decided {
+		return false, errUndecided
+	}
+
+	if wantReply {
+		ch.sentRequestMu.Lock()
+		defer ch.sentRequestMu.Unlock()
+	}
+
+	msg := channelRequestMsg{
+		PeersId:             ch.remoteId,
+		Request:             name,
+		WantReply:           wantReply,
+		RequestSpecificData: payload,
+	}
+
+	if err := ch.sendMessage(msg); err != nil {
+		return false, err
+	}
+
+	if wantReply {
+		m, ok := (<-ch.msg)
+		if !ok {
+			return false, io.EOF
+		}
+		switch m.(type) {
+		case *channelRequestFailureMsg:
+			return false, nil
+		case *channelRequestSuccessMsg:
+			return true, nil
+		default:
+			return false, fmt.Errorf("ssh: unexpected response to channel request: %#v", m)
+		}
+	}
+
+	return false, nil
+}
+
+// ackRequest either sends an ack or nack to the channel request.
+func (ch *channel) ackRequest(ok bool) error {
+	if !ch.decided {
+		return errUndecided
+	}
+
+	var msg interface{}
+	if !ok {
+		msg = channelRequestFailureMsg{
+			PeersId: ch.remoteId,
+		}
+	} else {
+		msg = channelRequestSuccessMsg{
+			PeersId: ch.remoteId,
+		}
+	}
+	return ch.sendMessage(msg)
+}
+
+func (ch *channel) ChannelType() string {
+	return ch.chanType
+}
+
+func (ch *channel) ExtraData() []byte {
+	return ch.extraData
+}
diff --git a/vendor/golang.org/x/crypto/ssh/cipher.go b/vendor/golang.org/x/crypto/ssh/cipher.go
new file mode 100644
index 0000000..22bb30c
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/cipher.go
@@ -0,0 +1,629 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"crypto/aes"
+	"crypto/cipher"
+	"crypto/des"
+	"crypto/rc4"
+	"crypto/subtle"
+	"encoding/binary"
+	"errors"
+	"fmt"
+	"hash"
+	"io"
+	"io/ioutil"
+)
+
+const (
+	packetSizeMultiple = 16 // TODO(huin) this should be determined by the cipher.
+
+	// RFC 4253 section 6.1 defines a minimum packet size of 32768 that implementations
+	// MUST be able to process (plus a few more kilobytes for padding and mac). The RFC
+	// indicates implementations SHOULD be able to handle larger packet sizes, but then
+	// waffles on about reasonable limits.
+	//
+	// OpenSSH caps their maxPacket at 256kB so we choose to do
+	// the same. maxPacket is also used to ensure that uint32
+	// length fields do not overflow, so it should remain well
+	// below 4G.
+	maxPacket = 256 * 1024
+)
+
+// noneCipher implements cipher.Stream and provides no encryption. It is used
+// by the transport before the first key-exchange.
+type noneCipher struct{}
+
+func (c noneCipher) XORKeyStream(dst, src []byte) {
+	copy(dst, src)
+}
+
+func newAESCTR(key, iv []byte) (cipher.Stream, error) {
+	c, err := aes.NewCipher(key)
+	if err != nil {
+		return nil, err
+	}
+	return cipher.NewCTR(c, iv), nil
+}
+
+func newRC4(key, iv []byte) (cipher.Stream, error) {
+	return rc4.NewCipher(key)
+}
+
+type streamCipherMode struct {
+	keySize    int
+	ivSize     int
+	skip       int
+	createFunc func(key, iv []byte) (cipher.Stream, error)
+}
+
+func (c *streamCipherMode) createStream(key, iv []byte) (cipher.Stream, error) {
+	if len(key) < c.keySize {
+		panic("ssh: key length too small for cipher")
+	}
+	if len(iv) < c.ivSize {
+		panic("ssh: iv too small for cipher")
+	}
+
+	stream, err := c.createFunc(key[:c.keySize], iv[:c.ivSize])
+	if err != nil {
+		return nil, err
+	}
+
+	var streamDump []byte
+	if c.skip > 0 {
+		streamDump = make([]byte, 512)
+	}
+
+	for remainingToDump := c.skip; remainingToDump > 0; {
+		dumpThisTime := remainingToDump
+		if dumpThisTime > len(streamDump) {
+			dumpThisTime = len(streamDump)
+		}
+		stream.XORKeyStream(streamDump[:dumpThisTime], streamDump[:dumpThisTime])
+		remainingToDump -= dumpThisTime
+	}
+
+	return stream, nil
+}
+
+// cipherModes documents properties of supported ciphers. Ciphers not included
+// are not supported and will not be negotiated, even if explicitly requested in
+// ClientConfig.Crypto.Ciphers.
+var cipherModes = map[string]*streamCipherMode{
+	// Ciphers from RFC4344, which introduced many CTR-based ciphers. Algorithms
+	// are defined in the order specified in the RFC.
+	"aes128-ctr": {16, aes.BlockSize, 0, newAESCTR},
+	"aes192-ctr": {24, aes.BlockSize, 0, newAESCTR},
+	"aes256-ctr": {32, aes.BlockSize, 0, newAESCTR},
+
+	// Ciphers from RFC4345, which introduces security-improved arcfour ciphers.
+	// They are defined in the order specified in the RFC.
+	"arcfour128": {16, 0, 1536, newRC4},
+	"arcfour256": {32, 0, 1536, newRC4},
+
+	// Cipher defined in RFC 4253, which describes SSH Transport Layer Protocol.
+	// Note that this cipher is not safe, as stated in RFC 4253: "Arcfour (and
+	// RC4) has problems with weak keys, and should be used with caution."
+	// RFC4345 introduces improved versions of Arcfour.
+	"arcfour": {16, 0, 0, newRC4},
+
+	// AES-GCM is not a stream cipher, so it is constructed with a
+	// special case. If we add any more non-stream ciphers, we
+	// should invest a cleaner way to do this.
+	gcmCipherID: {16, 12, 0, nil},
+
+	// CBC mode is insecure and so is not included in the default config.
+	// (See http://www.isg.rhul.ac.uk/~kp/SandPfinal.pdf). If absolutely
+	// needed, it's possible to specify a custom Config to enable it.
+	// You should expect that an active attacker can recover plaintext if
+	// you do.
+	aes128cbcID: {16, aes.BlockSize, 0, nil},
+
+	// 3des-cbc is insecure and is disabled by default.
+	tripledescbcID: {24, des.BlockSize, 0, nil},
+}
+
+// prefixLen is the length of the packet prefix that contains the packet length
+// and number of padding bytes.
+const prefixLen = 5
+
+// streamPacketCipher is a packetCipher using a stream cipher.
+type streamPacketCipher struct {
+	mac    hash.Hash
+	cipher cipher.Stream
+	etm    bool
+
+	// The following members are to avoid per-packet allocations.
+	prefix      [prefixLen]byte
+	seqNumBytes [4]byte
+	padding     [2 * packetSizeMultiple]byte
+	packetData  []byte
+	macResult   []byte
+}
+
+// readPacket reads and decrypt a single packet from the reader argument.
+func (s *streamPacketCipher) readPacket(seqNum uint32, r io.Reader) ([]byte, error) {
+	if _, err := io.ReadFull(r, s.prefix[:]); err != nil {
+		return nil, err
+	}
+
+	var encryptedPaddingLength [1]byte
+	if s.mac != nil && s.etm {
+		copy(encryptedPaddingLength[:], s.prefix[4:5])
+		s.cipher.XORKeyStream(s.prefix[4:5], s.prefix[4:5])
+	} else {
+		s.cipher.XORKeyStream(s.prefix[:], s.prefix[:])
+	}
+
+	length := binary.BigEndian.Uint32(s.prefix[0:4])
+	paddingLength := uint32(s.prefix[4])
+
+	var macSize uint32
+	if s.mac != nil {
+		s.mac.Reset()
+		binary.BigEndian.PutUint32(s.seqNumBytes[:], seqNum)
+		s.mac.Write(s.seqNumBytes[:])
+		if s.etm {
+			s.mac.Write(s.prefix[:4])
+			s.mac.Write(encryptedPaddingLength[:])
+		} else {
+			s.mac.Write(s.prefix[:])
+		}
+		macSize = uint32(s.mac.Size())
+	}
+
+	if length <= paddingLength+1 {
+		return nil, errors.New("ssh: invalid packet length, packet too small")
+	}
+
+	if length > maxPacket {
+		return nil, errors.New("ssh: invalid packet length, packet too large")
+	}
+
+	// the maxPacket check above ensures that length-1+macSize
+	// does not overflow.
+	if uint32(cap(s.packetData)) < length-1+macSize {
+		s.packetData = make([]byte, length-1+macSize)
+	} else {
+		s.packetData = s.packetData[:length-1+macSize]
+	}
+
+	if _, err := io.ReadFull(r, s.packetData); err != nil {
+		return nil, err
+	}
+	mac := s.packetData[length-1:]
+	data := s.packetData[:length-1]
+
+	if s.mac != nil && s.etm {
+		s.mac.Write(data)
+	}
+
+	s.cipher.XORKeyStream(data, data)
+
+	if s.mac != nil {
+		if !s.etm {
+			s.mac.Write(data)
+		}
+		s.macResult = s.mac.Sum(s.macResult[:0])
+		if subtle.ConstantTimeCompare(s.macResult, mac) != 1 {
+			return nil, errors.New("ssh: MAC failure")
+		}
+	}
+
+	return s.packetData[:length-paddingLength-1], nil
+}
+
+// writePacket encrypts and sends a packet of data to the writer argument
+func (s *streamPacketCipher) writePacket(seqNum uint32, w io.Writer, rand io.Reader, packet []byte) error {
+	if len(packet) > maxPacket {
+		return errors.New("ssh: packet too large")
+	}
+
+	aadlen := 0
+	if s.mac != nil && s.etm {
+		// packet length is not encrypted for EtM modes
+		aadlen = 4
+	}
+
+	paddingLength := packetSizeMultiple - (prefixLen+len(packet)-aadlen)%packetSizeMultiple
+	if paddingLength < 4 {
+		paddingLength += packetSizeMultiple
+	}
+
+	length := len(packet) + 1 + paddingLength
+	binary.BigEndian.PutUint32(s.prefix[:], uint32(length))
+	s.prefix[4] = byte(paddingLength)
+	padding := s.padding[:paddingLength]
+	if _, err := io.ReadFull(rand, padding); err != nil {
+		return err
+	}
+
+	if s.mac != nil {
+		s.mac.Reset()
+		binary.BigEndian.PutUint32(s.seqNumBytes[:], seqNum)
+		s.mac.Write(s.seqNumBytes[:])
+
+		if s.etm {
+			// For EtM algorithms, the packet length must stay unencrypted,
+			// but the following data (padding length) must be encrypted
+			s.cipher.XORKeyStream(s.prefix[4:5], s.prefix[4:5])
+		}
+
+		s.mac.Write(s.prefix[:])
+
+		if !s.etm {
+			// For non-EtM algorithms, the algorithm is applied on unencrypted data
+			s.mac.Write(packet)
+			s.mac.Write(padding)
+		}
+	}
+
+	if !(s.mac != nil && s.etm) {
+		// For EtM algorithms, the padding length has already been encrypted
+		// and the packet length must remain unencrypted
+		s.cipher.XORKeyStream(s.prefix[:], s.prefix[:])
+	}
+
+	s.cipher.XORKeyStream(packet, packet)
+	s.cipher.XORKeyStream(padding, padding)
+
+	if s.mac != nil && s.etm {
+		// For EtM algorithms, packet and padding must be encrypted
+		s.mac.Write(packet)
+		s.mac.Write(padding)
+	}
+
+	if _, err := w.Write(s.prefix[:]); err != nil {
+		return err
+	}
+	if _, err := w.Write(packet); err != nil {
+		return err
+	}
+	if _, err := w.Write(padding); err != nil {
+		return err
+	}
+
+	if s.mac != nil {
+		s.macResult = s.mac.Sum(s.macResult[:0])
+		if _, err := w.Write(s.macResult); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+type gcmCipher struct {
+	aead   cipher.AEAD
+	prefix [4]byte
+	iv     []byte
+	buf    []byte
+}
+
+func newGCMCipher(iv, key, macKey []byte) (packetCipher, error) {
+	c, err := aes.NewCipher(key)
+	if err != nil {
+		return nil, err
+	}
+
+	aead, err := cipher.NewGCM(c)
+	if err != nil {
+		return nil, err
+	}
+
+	return &gcmCipher{
+		aead: aead,
+		iv:   iv,
+	}, nil
+}
+
+const gcmTagSize = 16
+
+func (c *gcmCipher) writePacket(seqNum uint32, w io.Writer, rand io.Reader, packet []byte) error {
+	// Pad out to multiple of 16 bytes. This is different from the
+	// stream cipher because that encrypts the length too.
+	padding := byte(packetSizeMultiple - (1+len(packet))%packetSizeMultiple)
+	if padding < 4 {
+		padding += packetSizeMultiple
+	}
+
+	length := uint32(len(packet) + int(padding) + 1)
+	binary.BigEndian.PutUint32(c.prefix[:], length)
+	if _, err := w.Write(c.prefix[:]); err != nil {
+		return err
+	}
+
+	if cap(c.buf) < int(length) {
+		c.buf = make([]byte, length)
+	} else {
+		c.buf = c.buf[:length]
+	}
+
+	c.buf[0] = padding
+	copy(c.buf[1:], packet)
+	if _, err := io.ReadFull(rand, c.buf[1+len(packet):]); err != nil {
+		return err
+	}
+	c.buf = c.aead.Seal(c.buf[:0], c.iv, c.buf, c.prefix[:])
+	if _, err := w.Write(c.buf); err != nil {
+		return err
+	}
+	c.incIV()
+
+	return nil
+}
+
+func (c *gcmCipher) incIV() {
+	for i := 4 + 7; i >= 4; i-- {
+		c.iv[i]++
+		if c.iv[i] != 0 {
+			break
+		}
+	}
+}
+
+func (c *gcmCipher) readPacket(seqNum uint32, r io.Reader) ([]byte, error) {
+	if _, err := io.ReadFull(r, c.prefix[:]); err != nil {
+		return nil, err
+	}
+	length := binary.BigEndian.Uint32(c.prefix[:])
+	if length > maxPacket {
+		return nil, errors.New("ssh: max packet length exceeded.")
+	}
+
+	if cap(c.buf) < int(length+gcmTagSize) {
+		c.buf = make([]byte, length+gcmTagSize)
+	} else {
+		c.buf = c.buf[:length+gcmTagSize]
+	}
+
+	if _, err := io.ReadFull(r, c.buf); err != nil {
+		return nil, err
+	}
+
+	plain, err := c.aead.Open(c.buf[:0], c.iv, c.buf, c.prefix[:])
+	if err != nil {
+		return nil, err
+	}
+	c.incIV()
+
+	padding := plain[0]
+	if padding < 4 {
+		// padding is a byte, so it automatically satisfies
+		// the maximum size, which is 255.
+		return nil, fmt.Errorf("ssh: illegal padding %d", padding)
+	}
+
+	if int(padding+1) >= len(plain) {
+		return nil, fmt.Errorf("ssh: padding %d too large", padding)
+	}
+	plain = plain[1 : length-uint32(padding)]
+	return plain, nil
+}
+
+// cbcCipher implements aes128-cbc cipher defined in RFC 4253 section 6.1
+type cbcCipher struct {
+	mac       hash.Hash
+	macSize   uint32
+	decrypter cipher.BlockMode
+	encrypter cipher.BlockMode
+
+	// The following members are to avoid per-packet allocations.
+	seqNumBytes [4]byte
+	packetData  []byte
+	macResult   []byte
+
+	// Amount of data we should still read to hide which
+	// verification error triggered.
+	oracleCamouflage uint32
+}
+
+func newCBCCipher(c cipher.Block, iv, key, macKey []byte, algs directionAlgorithms) (packetCipher, error) {
+	cbc := &cbcCipher{
+		mac:        macModes[algs.MAC].new(macKey),
+		decrypter:  cipher.NewCBCDecrypter(c, iv),
+		encrypter:  cipher.NewCBCEncrypter(c, iv),
+		packetData: make([]byte, 1024),
+	}
+	if cbc.mac != nil {
+		cbc.macSize = uint32(cbc.mac.Size())
+	}
+
+	return cbc, nil
+}
+
+func newAESCBCCipher(iv, key, macKey []byte, algs directionAlgorithms) (packetCipher, error) {
+	c, err := aes.NewCipher(key)
+	if err != nil {
+		return nil, err
+	}
+
+	cbc, err := newCBCCipher(c, iv, key, macKey, algs)
+	if err != nil {
+		return nil, err
+	}
+
+	return cbc, nil
+}
+
+func newTripleDESCBCCipher(iv, key, macKey []byte, algs directionAlgorithms) (packetCipher, error) {
+	c, err := des.NewTripleDESCipher(key)
+	if err != nil {
+		return nil, err
+	}
+
+	cbc, err := newCBCCipher(c, iv, key, macKey, algs)
+	if err != nil {
+		return nil, err
+	}
+
+	return cbc, nil
+}
+
+func maxUInt32(a, b int) uint32 {
+	if a > b {
+		return uint32(a)
+	}
+	return uint32(b)
+}
+
+const (
+	cbcMinPacketSizeMultiple = 8
+	cbcMinPacketSize         = 16
+	cbcMinPaddingSize        = 4
+)
+
+// cbcError represents a verification error that may leak information.
+type cbcError string
+
+func (e cbcError) Error() string { return string(e) }
+
+func (c *cbcCipher) readPacket(seqNum uint32, r io.Reader) ([]byte, error) {
+	p, err := c.readPacketLeaky(seqNum, r)
+	if err != nil {
+		if _, ok := err.(cbcError); ok {
+			// Verification error: read a fixed amount of
+			// data, to make distinguishing between
+			// failing MAC and failing length check more
+			// difficult.
+			io.CopyN(ioutil.Discard, r, int64(c.oracleCamouflage))
+		}
+	}
+	return p, err
+}
+
+func (c *cbcCipher) readPacketLeaky(seqNum uint32, r io.Reader) ([]byte, error) {
+	blockSize := c.decrypter.BlockSize()
+
+	// Read the header, which will include some of the subsequent data in the
+	// case of block ciphers - this is copied back to the payload later.
+	// How many bytes of payload/padding will be read with this first read.
+	firstBlockLength := uint32((prefixLen + blockSize - 1) / blockSize * blockSize)
+	firstBlock := c.packetData[:firstBlockLength]
+	if _, err := io.ReadFull(r, firstBlock); err != nil {
+		return nil, err
+	}
+
+	c.oracleCamouflage = maxPacket + 4 + c.macSize - firstBlockLength
+
+	c.decrypter.CryptBlocks(firstBlock, firstBlock)
+	length := binary.BigEndian.Uint32(firstBlock[:4])
+	if length > maxPacket {
+		return nil, cbcError("ssh: packet too large")
+	}
+	if length+4 < maxUInt32(cbcMinPacketSize, blockSize) {
+		// The minimum size of a packet is 16 (or the cipher block size, whichever
+		// is larger) bytes.
+		return nil, cbcError("ssh: packet too small")
+	}
+	// The length of the packet (including the length field but not the MAC) must
+	// be a multiple of the block size or 8, whichever is larger.
+	if (length+4)%maxUInt32(cbcMinPacketSizeMultiple, blockSize) != 0 {
+		return nil, cbcError("ssh: invalid packet length multiple")
+	}
+
+	paddingLength := uint32(firstBlock[4])
+	if paddingLength < cbcMinPaddingSize || length <= paddingLength+1 {
+		return nil, cbcError("ssh: invalid packet length")
+	}
+
+	// Positions within the c.packetData buffer:
+	macStart := 4 + length
+	paddingStart := macStart - paddingLength
+
+	// Entire packet size, starting before length, ending at end of mac.
+	entirePacketSize := macStart + c.macSize
+
+	// Ensure c.packetData is large enough for the entire packet data.
+	if uint32(cap(c.packetData)) < entirePacketSize {
+		// Still need to upsize and copy, but this should be rare at runtime, only
+		// on upsizing the packetData buffer.
+		c.packetData = make([]byte, entirePacketSize)
+		copy(c.packetData, firstBlock)
+	} else {
+		c.packetData = c.packetData[:entirePacketSize]
+	}
+
+	if n, err := io.ReadFull(r, c.packetData[firstBlockLength:]); err != nil {
+		return nil, err
+	} else {
+		c.oracleCamouflage -= uint32(n)
+	}
+
+	remainingCrypted := c.packetData[firstBlockLength:macStart]
+	c.decrypter.CryptBlocks(remainingCrypted, remainingCrypted)
+
+	mac := c.packetData[macStart:]
+	if c.mac != nil {
+		c.mac.Reset()
+		binary.BigEndian.PutUint32(c.seqNumBytes[:], seqNum)
+		c.mac.Write(c.seqNumBytes[:])
+		c.mac.Write(c.packetData[:macStart])
+		c.macResult = c.mac.Sum(c.macResult[:0])
+		if subtle.ConstantTimeCompare(c.macResult, mac) != 1 {
+			return nil, cbcError("ssh: MAC failure")
+		}
+	}
+
+	return c.packetData[prefixLen:paddingStart], nil
+}
+
+func (c *cbcCipher) writePacket(seqNum uint32, w io.Writer, rand io.Reader, packet []byte) error {
+	effectiveBlockSize := maxUInt32(cbcMinPacketSizeMultiple, c.encrypter.BlockSize())
+
+	// Length of encrypted portion of the packet (header, payload, padding).
+	// Enforce minimum padding and packet size.
+	encLength := maxUInt32(prefixLen+len(packet)+cbcMinPaddingSize, cbcMinPaddingSize)
+	// Enforce block size.
+	encLength = (encLength + effectiveBlockSize - 1) / effectiveBlockSize * effectiveBlockSize
+
+	length := encLength - 4
+	paddingLength := int(length) - (1 + len(packet))
+
+	// Overall buffer contains: header, payload, padding, mac.
+	// Space for the MAC is reserved in the capacity but not the slice length.
+	bufferSize := encLength + c.macSize
+	if uint32(cap(c.packetData)) < bufferSize {
+		c.packetData = make([]byte, encLength, bufferSize)
+	} else {
+		c.packetData = c.packetData[:encLength]
+	}
+
+	p := c.packetData
+
+	// Packet header.
+	binary.BigEndian.PutUint32(p, length)
+	p = p[4:]
+	p[0] = byte(paddingLength)
+
+	// Payload.
+	p = p[1:]
+	copy(p, packet)
+
+	// Padding.
+	p = p[len(packet):]
+	if _, err := io.ReadFull(rand, p); err != nil {
+		return err
+	}
+
+	if c.mac != nil {
+		c.mac.Reset()
+		binary.BigEndian.PutUint32(c.seqNumBytes[:], seqNum)
+		c.mac.Write(c.seqNumBytes[:])
+		c.mac.Write(c.packetData)
+		// The MAC is now appended into the capacity reserved for it earlier.
+		c.packetData = c.mac.Sum(c.packetData)
+	}
+
+	c.encrypter.CryptBlocks(c.packetData[:encLength], c.packetData[:encLength])
+
+	if _, err := w.Write(c.packetData); err != nil {
+		return err
+	}
+
+	return nil
+}
diff --git a/vendor/golang.org/x/crypto/ssh/client.go b/vendor/golang.org/x/crypto/ssh/client.go
new file mode 100644
index 0000000..a7e3263
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/client.go
@@ -0,0 +1,257 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"bytes"
+	"errors"
+	"fmt"
+	"net"
+	"sync"
+	"time"
+)
+
+// Client implements a traditional SSH client that supports shells,
+// subprocesses, TCP port/streamlocal forwarding and tunneled dialing.
+type Client struct {
+	Conn
+
+	forwards        forwardList // forwarded tcpip connections from the remote side
+	mu              sync.Mutex
+	channelHandlers map[string]chan NewChannel
+}
+
+// HandleChannelOpen returns a channel on which NewChannel requests
+// for the given type are sent. If the type already is being handled,
+// nil is returned. The channel is closed when the connection is closed.
+func (c *Client) HandleChannelOpen(channelType string) <-chan NewChannel {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	if c.channelHandlers == nil {
+		// The SSH channel has been closed.
+		c := make(chan NewChannel)
+		close(c)
+		return c
+	}
+
+	ch := c.channelHandlers[channelType]
+	if ch != nil {
+		return nil
+	}
+
+	ch = make(chan NewChannel, chanSize)
+	c.channelHandlers[channelType] = ch
+	return ch
+}
+
+// NewClient creates a Client on top of the given connection.
+func NewClient(c Conn, chans <-chan NewChannel, reqs <-chan *Request) *Client {
+	conn := &Client{
+		Conn:            c,
+		channelHandlers: make(map[string]chan NewChannel, 1),
+	}
+
+	go conn.handleGlobalRequests(reqs)
+	go conn.handleChannelOpens(chans)
+	go func() {
+		conn.Wait()
+		conn.forwards.closeAll()
+	}()
+	go conn.forwards.handleChannels(conn.HandleChannelOpen("forwarded-tcpip"))
+	go conn.forwards.handleChannels(conn.HandleChannelOpen("forwarded-streamlocal@openssh.com"))
+	return conn
+}
+
+// NewClientConn establishes an authenticated SSH connection using c
+// as the underlying transport.  The Request and NewChannel channels
+// must be serviced or the connection will hang.
+func NewClientConn(c net.Conn, addr string, config *ClientConfig) (Conn, <-chan NewChannel, <-chan *Request, error) {
+	fullConf := *config
+	fullConf.SetDefaults()
+	if fullConf.HostKeyCallback == nil {
+		c.Close()
+		return nil, nil, nil, errors.New("ssh: must specify HostKeyCallback")
+	}
+
+	conn := &connection{
+		sshConn: sshConn{conn: c},
+	}
+
+	if err := conn.clientHandshake(addr, &fullConf); err != nil {
+		c.Close()
+		return nil, nil, nil, fmt.Errorf("ssh: handshake failed: %v", err)
+	}
+	conn.mux = newMux(conn.transport)
+	return conn, conn.mux.incomingChannels, conn.mux.incomingRequests, nil
+}
+
+// clientHandshake performs the client side key exchange. See RFC 4253 Section
+// 7.
+func (c *connection) clientHandshake(dialAddress string, config *ClientConfig) error {
+	if config.ClientVersion != "" {
+		c.clientVersion = []byte(config.ClientVersion)
+	} else {
+		c.clientVersion = []byte(packageVersion)
+	}
+	var err error
+	c.serverVersion, err = exchangeVersions(c.sshConn.conn, c.clientVersion)
+	if err != nil {
+		return err
+	}
+
+	c.transport = newClientTransport(
+		newTransport(c.sshConn.conn, config.Rand, true /* is client */),
+		c.clientVersion, c.serverVersion, config, dialAddress, c.sshConn.RemoteAddr())
+	if err := c.transport.waitSession(); err != nil {
+		return err
+	}
+
+	c.sessionID = c.transport.getSessionID()
+	return c.clientAuthenticate(config)
+}
+
+// verifyHostKeySignature verifies the host key obtained in the key
+// exchange.
+func verifyHostKeySignature(hostKey PublicKey, result *kexResult) error {
+	sig, rest, ok := parseSignatureBody(result.Signature)
+	if len(rest) > 0 || !ok {
+		return errors.New("ssh: signature parse error")
+	}
+
+	return hostKey.Verify(result.H, sig)
+}
+
+// NewSession opens a new Session for this client. (A session is a remote
+// execution of a program.)
+func (c *Client) NewSession() (*Session, error) {
+	ch, in, err := c.OpenChannel("session", nil)
+	if err != nil {
+		return nil, err
+	}
+	return newSession(ch, in)
+}
+
+func (c *Client) handleGlobalRequests(incoming <-chan *Request) {
+	for r := range incoming {
+		// This handles keepalive messages and matches
+		// the behaviour of OpenSSH.
+		r.Reply(false, nil)
+	}
+}
+
+// handleChannelOpens channel open messages from the remote side.
+func (c *Client) handleChannelOpens(in <-chan NewChannel) {
+	for ch := range in {
+		c.mu.Lock()
+		handler := c.channelHandlers[ch.ChannelType()]
+		c.mu.Unlock()
+
+		if handler != nil {
+			handler <- ch
+		} else {
+			ch.Reject(UnknownChannelType, fmt.Sprintf("unknown channel type: %v", ch.ChannelType()))
+		}
+	}
+
+	c.mu.Lock()
+	for _, ch := range c.channelHandlers {
+		close(ch)
+	}
+	c.channelHandlers = nil
+	c.mu.Unlock()
+}
+
+// Dial starts a client connection to the given SSH server. It is a
+// convenience function that connects to the given network address,
+// initiates the SSH handshake, and then sets up a Client.  For access
+// to incoming channels and requests, use net.Dial with NewClientConn
+// instead.
+func Dial(network, addr string, config *ClientConfig) (*Client, error) {
+	conn, err := net.DialTimeout(network, addr, config.Timeout)
+	if err != nil {
+		return nil, err
+	}
+	c, chans, reqs, err := NewClientConn(conn, addr, config)
+	if err != nil {
+		return nil, err
+	}
+	return NewClient(c, chans, reqs), nil
+}
+
+// HostKeyCallback is the function type used for verifying server
+// keys.  A HostKeyCallback must return nil if the host key is OK, or
+// an error to reject it. It receives the hostname as passed to Dial
+// or NewClientConn. The remote address is the RemoteAddr of the
+// net.Conn underlying the the SSH connection.
+type HostKeyCallback func(hostname string, remote net.Addr, key PublicKey) error
+
+// A ClientConfig structure is used to configure a Client. It must not be
+// modified after having been passed to an SSH function.
+type ClientConfig struct {
+	// Config contains configuration that is shared between clients and
+	// servers.
+	Config
+
+	// User contains the username to authenticate as.
+	User string
+
+	// Auth contains possible authentication methods to use with the
+	// server. Only the first instance of a particular RFC 4252 method will
+	// be used during authentication.
+	Auth []AuthMethod
+
+	// HostKeyCallback is called during the cryptographic
+	// handshake to validate the server's host key. The client
+	// configuration must supply this callback for the connection
+	// to succeed. The functions InsecureIgnoreHostKey or
+	// FixedHostKey can be used for simplistic host key checks.
+	HostKeyCallback HostKeyCallback
+
+	// ClientVersion contains the version identification string that will
+	// be used for the connection. If empty, a reasonable default is used.
+	ClientVersion string
+
+	// HostKeyAlgorithms lists the key types that the client will
+	// accept from the server as host key, in order of
+	// preference. If empty, a reasonable default is used. Any
+	// string returned from PublicKey.Type method may be used, or
+	// any of the CertAlgoXxxx and KeyAlgoXxxx constants.
+	HostKeyAlgorithms []string
+
+	// Timeout is the maximum amount of time for the TCP connection to establish.
+	//
+	// A Timeout of zero means no timeout.
+	Timeout time.Duration
+}
+
+// InsecureIgnoreHostKey returns a function that can be used for
+// ClientConfig.HostKeyCallback to accept any host key. It should
+// not be used for production code.
+func InsecureIgnoreHostKey() HostKeyCallback {
+	return func(hostname string, remote net.Addr, key PublicKey) error {
+		return nil
+	}
+}
+
+type fixedHostKey struct {
+	key PublicKey
+}
+
+func (f *fixedHostKey) check(hostname string, remote net.Addr, key PublicKey) error {
+	if f.key == nil {
+		return fmt.Errorf("ssh: required host key was nil")
+	}
+	if !bytes.Equal(key.Marshal(), f.key.Marshal()) {
+		return fmt.Errorf("ssh: host key mismatch")
+	}
+	return nil
+}
+
+// FixedHostKey returns a function for use in
+// ClientConfig.HostKeyCallback to accept only a specific host key.
+func FixedHostKey(key PublicKey) HostKeyCallback {
+	hk := &fixedHostKey{key}
+	return hk.check
+}
diff --git a/vendor/golang.org/x/crypto/ssh/client_auth.go b/vendor/golang.org/x/crypto/ssh/client_auth.go
new file mode 100644
index 0000000..3acd8d4
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/client_auth.go
@@ -0,0 +1,486 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"bytes"
+	"errors"
+	"fmt"
+	"io"
+)
+
+// clientAuthenticate authenticates with the remote server. See RFC 4252.
+func (c *connection) clientAuthenticate(config *ClientConfig) error {
+	// initiate user auth session
+	if err := c.transport.writePacket(Marshal(&serviceRequestMsg{serviceUserAuth})); err != nil {
+		return err
+	}
+	packet, err := c.transport.readPacket()
+	if err != nil {
+		return err
+	}
+	var serviceAccept serviceAcceptMsg
+	if err := Unmarshal(packet, &serviceAccept); err != nil {
+		return err
+	}
+
+	// during the authentication phase the client first attempts the "none" method
+	// then any untried methods suggested by the server.
+	tried := make(map[string]bool)
+	var lastMethods []string
+
+	sessionID := c.transport.getSessionID()
+	for auth := AuthMethod(new(noneAuth)); auth != nil; {
+		ok, methods, err := auth.auth(sessionID, config.User, c.transport, config.Rand)
+		if err != nil {
+			return err
+		}
+		if ok {
+			// success
+			return nil
+		}
+		tried[auth.method()] = true
+		if methods == nil {
+			methods = lastMethods
+		}
+		lastMethods = methods
+
+		auth = nil
+
+	findNext:
+		for _, a := range config.Auth {
+			candidateMethod := a.method()
+			if tried[candidateMethod] {
+				continue
+			}
+			for _, meth := range methods {
+				if meth == candidateMethod {
+					auth = a
+					break findNext
+				}
+			}
+		}
+	}
+	return fmt.Errorf("ssh: unable to authenticate, attempted methods %v, no supported methods remain", keys(tried))
+}
+
+func keys(m map[string]bool) []string {
+	s := make([]string, 0, len(m))
+
+	for key := range m {
+		s = append(s, key)
+	}
+	return s
+}
+
+// An AuthMethod represents an instance of an RFC 4252 authentication method.
+type AuthMethod interface {
+	// auth authenticates user over transport t.
+	// Returns true if authentication is successful.
+	// If authentication is not successful, a []string of alternative
+	// method names is returned. If the slice is nil, it will be ignored
+	// and the previous set of possible methods will be reused.
+	auth(session []byte, user string, p packetConn, rand io.Reader) (bool, []string, error)
+
+	// method returns the RFC 4252 method name.
+	method() string
+}
+
+// "none" authentication, RFC 4252 section 5.2.
+type noneAuth int
+
+func (n *noneAuth) auth(session []byte, user string, c packetConn, rand io.Reader) (bool, []string, error) {
+	if err := c.writePacket(Marshal(&userAuthRequestMsg{
+		User:    user,
+		Service: serviceSSH,
+		Method:  "none",
+	})); err != nil {
+		return false, nil, err
+	}
+
+	return handleAuthResponse(c)
+}
+
+func (n *noneAuth) method() string {
+	return "none"
+}
+
+// passwordCallback is an AuthMethod that fetches the password through
+// a function call, e.g. by prompting the user.
+type passwordCallback func() (password string, err error)
+
+func (cb passwordCallback) auth(session []byte, user string, c packetConn, rand io.Reader) (bool, []string, error) {
+	type passwordAuthMsg struct {
+		User     string `sshtype:"50"`
+		Service  string
+		Method   string
+		Reply    bool
+		Password string
+	}
+
+	pw, err := cb()
+	// REVIEW NOTE: is there a need to support skipping a password attempt?
+	// The program may only find out that the user doesn't have a password
+	// when prompting.
+	if err != nil {
+		return false, nil, err
+	}
+
+	if err := c.writePacket(Marshal(&passwordAuthMsg{
+		User:     user,
+		Service:  serviceSSH,
+		Method:   cb.method(),
+		Reply:    false,
+		Password: pw,
+	})); err != nil {
+		return false, nil, err
+	}
+
+	return handleAuthResponse(c)
+}
+
+func (cb passwordCallback) method() string {
+	return "password"
+}
+
+// Password returns an AuthMethod using the given password.
+func Password(secret string) AuthMethod {
+	return passwordCallback(func() (string, error) { return secret, nil })
+}
+
+// PasswordCallback returns an AuthMethod that uses a callback for
+// fetching a password.
+func PasswordCallback(prompt func() (secret string, err error)) AuthMethod {
+	return passwordCallback(prompt)
+}
+
+type publickeyAuthMsg struct {
+	User    string `sshtype:"50"`
+	Service string
+	Method  string
+	// HasSig indicates to the receiver packet that the auth request is signed and
+	// should be used for authentication of the request.
+	HasSig   bool
+	Algoname string
+	PubKey   []byte
+	// Sig is tagged with "rest" so Marshal will exclude it during
+	// validateKey
+	Sig []byte `ssh:"rest"`
+}
+
+// publicKeyCallback is an AuthMethod that uses a set of key
+// pairs for authentication.
+type publicKeyCallback func() ([]Signer, error)
+
+func (cb publicKeyCallback) method() string {
+	return "publickey"
+}
+
+func (cb publicKeyCallback) auth(session []byte, user string, c packetConn, rand io.Reader) (bool, []string, error) {
+	// Authentication is performed by sending an enquiry to test if a key is
+	// acceptable to the remote. If the key is acceptable, the client will
+	// attempt to authenticate with the valid key.  If not the client will repeat
+	// the process with the remaining keys.
+
+	signers, err := cb()
+	if err != nil {
+		return false, nil, err
+	}
+	var methods []string
+	for _, signer := range signers {
+		ok, err := validateKey(signer.PublicKey(), user, c)
+		if err != nil {
+			return false, nil, err
+		}
+		if !ok {
+			continue
+		}
+
+		pub := signer.PublicKey()
+		pubKey := pub.Marshal()
+		sign, err := signer.Sign(rand, buildDataSignedForAuth(session, userAuthRequestMsg{
+			User:    user,
+			Service: serviceSSH,
+			Method:  cb.method(),
+		}, []byte(pub.Type()), pubKey))
+		if err != nil {
+			return false, nil, err
+		}
+
+		// manually wrap the serialized signature in a string
+		s := Marshal(sign)
+		sig := make([]byte, stringLength(len(s)))
+		marshalString(sig, s)
+		msg := publickeyAuthMsg{
+			User:     user,
+			Service:  serviceSSH,
+			Method:   cb.method(),
+			HasSig:   true,
+			Algoname: pub.Type(),
+			PubKey:   pubKey,
+			Sig:      sig,
+		}
+		p := Marshal(&msg)
+		if err := c.writePacket(p); err != nil {
+			return false, nil, err
+		}
+		var success bool
+		success, methods, err = handleAuthResponse(c)
+		if err != nil {
+			return false, nil, err
+		}
+
+		// If authentication succeeds or the list of available methods does not
+		// contain the "publickey" method, do not attempt to authenticate with any
+		// other keys.  According to RFC 4252 Section 7, the latter can occur when
+		// additional authentication methods are required.
+		if success || !containsMethod(methods, cb.method()) {
+			return success, methods, err
+		}
+	}
+
+	return false, methods, nil
+}
+
+func containsMethod(methods []string, method string) bool {
+	for _, m := range methods {
+		if m == method {
+			return true
+		}
+	}
+
+	return false
+}
+
+// validateKey validates the key provided is acceptable to the server.
+func validateKey(key PublicKey, user string, c packetConn) (bool, error) {
+	pubKey := key.Marshal()
+	msg := publickeyAuthMsg{
+		User:     user,
+		Service:  serviceSSH,
+		Method:   "publickey",
+		HasSig:   false,
+		Algoname: key.Type(),
+		PubKey:   pubKey,
+	}
+	if err := c.writePacket(Marshal(&msg)); err != nil {
+		return false, err
+	}
+
+	return confirmKeyAck(key, c)
+}
+
+func confirmKeyAck(key PublicKey, c packetConn) (bool, error) {
+	pubKey := key.Marshal()
+	algoname := key.Type()
+
+	for {
+		packet, err := c.readPacket()
+		if err != nil {
+			return false, err
+		}
+		switch packet[0] {
+		case msgUserAuthBanner:
+			// TODO(gpaul): add callback to present the banner to the user
+		case msgUserAuthPubKeyOk:
+			var msg userAuthPubKeyOkMsg
+			if err := Unmarshal(packet, &msg); err != nil {
+				return false, err
+			}
+			if msg.Algo != algoname || !bytes.Equal(msg.PubKey, pubKey) {
+				return false, nil
+			}
+			return true, nil
+		case msgUserAuthFailure:
+			return false, nil
+		default:
+			return false, unexpectedMessageError(msgUserAuthSuccess, packet[0])
+		}
+	}
+}
+
+// PublicKeys returns an AuthMethod that uses the given key
+// pairs.
+func PublicKeys(signers ...Signer) AuthMethod {
+	return publicKeyCallback(func() ([]Signer, error) { return signers, nil })
+}
+
+// PublicKeysCallback returns an AuthMethod that runs the given
+// function to obtain a list of key pairs.
+func PublicKeysCallback(getSigners func() (signers []Signer, err error)) AuthMethod {
+	return publicKeyCallback(getSigners)
+}
+
+// handleAuthResponse returns whether the preceding authentication request succeeded
+// along with a list of remaining authentication methods to try next and
+// an error if an unexpected response was received.
+func handleAuthResponse(c packetConn) (bool, []string, error) {
+	for {
+		packet, err := c.readPacket()
+		if err != nil {
+			return false, nil, err
+		}
+
+		switch packet[0] {
+		case msgUserAuthBanner:
+			// TODO: add callback to present the banner to the user
+		case msgUserAuthFailure:
+			var msg userAuthFailureMsg
+			if err := Unmarshal(packet, &msg); err != nil {
+				return false, nil, err
+			}
+			return false, msg.Methods, nil
+		case msgUserAuthSuccess:
+			return true, nil, nil
+		default:
+			return false, nil, unexpectedMessageError(msgUserAuthSuccess, packet[0])
+		}
+	}
+}
+
+// KeyboardInteractiveChallenge should print questions, optionally
+// disabling echoing (e.g. for passwords), and return all the answers.
+// Challenge may be called multiple times in a single session. After
+// successful authentication, the server may send a challenge with no
+// questions, for which the user and instruction messages should be
+// printed.  RFC 4256 section 3.3 details how the UI should behave for
+// both CLI and GUI environments.
+type KeyboardInteractiveChallenge func(user, instruction string, questions []string, echos []bool) (answers []string, err error)
+
+// KeyboardInteractive returns an AuthMethod using a prompt/response
+// sequence controlled by the server.
+func KeyboardInteractive(challenge KeyboardInteractiveChallenge) AuthMethod {
+	return challenge
+}
+
+func (cb KeyboardInteractiveChallenge) method() string {
+	return "keyboard-interactive"
+}
+
+func (cb KeyboardInteractiveChallenge) auth(session []byte, user string, c packetConn, rand io.Reader) (bool, []string, error) {
+	type initiateMsg struct {
+		User       string `sshtype:"50"`
+		Service    string
+		Method     string
+		Language   string
+		Submethods string
+	}
+
+	if err := c.writePacket(Marshal(&initiateMsg{
+		User:    user,
+		Service: serviceSSH,
+		Method:  "keyboard-interactive",
+	})); err != nil {
+		return false, nil, err
+	}
+
+	for {
+		packet, err := c.readPacket()
+		if err != nil {
+			return false, nil, err
+		}
+
+		// like handleAuthResponse, but with less options.
+		switch packet[0] {
+		case msgUserAuthBanner:
+			// TODO: Print banners during userauth.
+			continue
+		case msgUserAuthInfoRequest:
+			// OK
+		case msgUserAuthFailure:
+			var msg userAuthFailureMsg
+			if err := Unmarshal(packet, &msg); err != nil {
+				return false, nil, err
+			}
+			return false, msg.Methods, nil
+		case msgUserAuthSuccess:
+			return true, nil, nil
+		default:
+			return false, nil, unexpectedMessageError(msgUserAuthInfoRequest, packet[0])
+		}
+
+		var msg userAuthInfoRequestMsg
+		if err := Unmarshal(packet, &msg); err != nil {
+			return false, nil, err
+		}
+
+		// Manually unpack the prompt/echo pairs.
+		rest := msg.Prompts
+		var prompts []string
+		var echos []bool
+		for i := 0; i < int(msg.NumPrompts); i++ {
+			prompt, r, ok := parseString(rest)
+			if !ok || len(r) == 0 {
+				return false, nil, errors.New("ssh: prompt format error")
+			}
+			prompts = append(prompts, string(prompt))
+			echos = append(echos, r[0] != 0)
+			rest = r[1:]
+		}
+
+		if len(rest) != 0 {
+			return false, nil, errors.New("ssh: extra data following keyboard-interactive pairs")
+		}
+
+		answers, err := cb(msg.User, msg.Instruction, prompts, echos)
+		if err != nil {
+			return false, nil, err
+		}
+
+		if len(answers) != len(prompts) {
+			return false, nil, errors.New("ssh: not enough answers from keyboard-interactive callback")
+		}
+		responseLength := 1 + 4
+		for _, a := range answers {
+			responseLength += stringLength(len(a))
+		}
+		serialized := make([]byte, responseLength)
+		p := serialized
+		p[0] = msgUserAuthInfoResponse
+		p = p[1:]
+		p = marshalUint32(p, uint32(len(answers)))
+		for _, a := range answers {
+			p = marshalString(p, []byte(a))
+		}
+
+		if err := c.writePacket(serialized); err != nil {
+			return false, nil, err
+		}
+	}
+}
+
+type retryableAuthMethod struct {
+	authMethod AuthMethod
+	maxTries   int
+}
+
+func (r *retryableAuthMethod) auth(session []byte, user string, c packetConn, rand io.Reader) (ok bool, methods []string, err error) {
+	for i := 0; r.maxTries <= 0 || i < r.maxTries; i++ {
+		ok, methods, err = r.authMethod.auth(session, user, c, rand)
+		if ok || err != nil { // either success or error terminate
+			return ok, methods, err
+		}
+	}
+	return ok, methods, err
+}
+
+func (r *retryableAuthMethod) method() string {
+	return r.authMethod.method()
+}
+
+// RetryableAuthMethod is a decorator for other auth methods enabling them to
+// be retried up to maxTries before considering that AuthMethod itself failed.
+// If maxTries is <= 0, will retry indefinitely
+//
+// This is useful for interactive clients using challenge/response type
+// authentication (e.g. Keyboard-Interactive, Password, etc) where the user
+// could mistype their response resulting in the server issuing a
+// SSH_MSG_USERAUTH_FAILURE (rfc4252 #8 [password] and rfc4256 #3.4
+// [keyboard-interactive]); Without this decorator, the non-retryable
+// AuthMethod would be removed from future consideration, and never tried again
+// (and so the user would never be able to retry their entry).
+func RetryableAuthMethod(auth AuthMethod, maxTries int) AuthMethod {
+	return &retryableAuthMethod{authMethod: auth, maxTries: maxTries}
+}
diff --git a/vendor/golang.org/x/crypto/ssh/common.go b/vendor/golang.org/x/crypto/ssh/common.go
new file mode 100644
index 0000000..dc39e4d
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/common.go
@@ -0,0 +1,373 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"crypto"
+	"crypto/rand"
+	"fmt"
+	"io"
+	"math"
+	"sync"
+
+	_ "crypto/sha1"
+	_ "crypto/sha256"
+	_ "crypto/sha512"
+)
+
+// These are string constants in the SSH protocol.
+const (
+	compressionNone = "none"
+	serviceUserAuth = "ssh-userauth"
+	serviceSSH      = "ssh-connection"
+)
+
+// supportedCiphers specifies the supported ciphers in preference order.
+var supportedCiphers = []string{
+	"aes128-ctr", "aes192-ctr", "aes256-ctr",
+	"aes128-gcm@openssh.com",
+	"arcfour256", "arcfour128",
+}
+
+// supportedKexAlgos specifies the supported key-exchange algorithms in
+// preference order.
+var supportedKexAlgos = []string{
+	kexAlgoCurve25519SHA256,
+	// P384 and P521 are not constant-time yet, but since we don't
+	// reuse ephemeral keys, using them for ECDH should be OK.
+	kexAlgoECDH256, kexAlgoECDH384, kexAlgoECDH521,
+	kexAlgoDH14SHA1, kexAlgoDH1SHA1,
+}
+
+// supportedHostKeyAlgos specifies the supported host-key algorithms (i.e. methods
+// of authenticating servers) in preference order.
+var supportedHostKeyAlgos = []string{
+	CertAlgoRSAv01, CertAlgoDSAv01, CertAlgoECDSA256v01,
+	CertAlgoECDSA384v01, CertAlgoECDSA521v01, CertAlgoED25519v01,
+
+	KeyAlgoECDSA256, KeyAlgoECDSA384, KeyAlgoECDSA521,
+	KeyAlgoRSA, KeyAlgoDSA,
+
+	KeyAlgoED25519,
+}
+
+// supportedMACs specifies a default set of MAC algorithms in preference order.
+// This is based on RFC 4253, section 6.4, but with hmac-md5 variants removed
+// because they have reached the end of their useful life.
+var supportedMACs = []string{
+	"hmac-sha2-256-etm@openssh.com", "hmac-sha2-256", "hmac-sha1", "hmac-sha1-96",
+}
+
+var supportedCompressions = []string{compressionNone}
+
+// hashFuncs keeps the mapping of supported algorithms to their respective
+// hashes needed for signature verification.
+var hashFuncs = map[string]crypto.Hash{
+	KeyAlgoRSA:          crypto.SHA1,
+	KeyAlgoDSA:          crypto.SHA1,
+	KeyAlgoECDSA256:     crypto.SHA256,
+	KeyAlgoECDSA384:     crypto.SHA384,
+	KeyAlgoECDSA521:     crypto.SHA512,
+	CertAlgoRSAv01:      crypto.SHA1,
+	CertAlgoDSAv01:      crypto.SHA1,
+	CertAlgoECDSA256v01: crypto.SHA256,
+	CertAlgoECDSA384v01: crypto.SHA384,
+	CertAlgoECDSA521v01: crypto.SHA512,
+}
+
+// unexpectedMessageError results when the SSH message that we received didn't
+// match what we wanted.
+func unexpectedMessageError(expected, got uint8) error {
+	return fmt.Errorf("ssh: unexpected message type %d (expected %d)", got, expected)
+}
+
+// parseError results from a malformed SSH message.
+func parseError(tag uint8) error {
+	return fmt.Errorf("ssh: parse error in message type %d", tag)
+}
+
+func findCommon(what string, client []string, server []string) (common string, err error) {
+	for _, c := range client {
+		for _, s := range server {
+			if c == s {
+				return c, nil
+			}
+		}
+	}
+	return "", fmt.Errorf("ssh: no common algorithm for %s; client offered: %v, server offered: %v", what, client, server)
+}
+
+type directionAlgorithms struct {
+	Cipher      string
+	MAC         string
+	Compression string
+}
+
+// rekeyBytes returns a rekeying intervals in bytes.
+func (a *directionAlgorithms) rekeyBytes() int64 {
+	// According to RFC4344 block ciphers should rekey after
+	// 2^(BLOCKSIZE/4) blocks. For all AES flavors BLOCKSIZE is
+	// 128.
+	switch a.Cipher {
+	case "aes128-ctr", "aes192-ctr", "aes256-ctr", gcmCipherID, aes128cbcID:
+		return 16 * (1 << 32)
+
+	}
+
+	// For others, stick with RFC4253 recommendation to rekey after 1 Gb of data.
+	return 1 << 30
+}
+
+type algorithms struct {
+	kex     string
+	hostKey string
+	w       directionAlgorithms
+	r       directionAlgorithms
+}
+
+func findAgreedAlgorithms(clientKexInit, serverKexInit *kexInitMsg) (algs *algorithms, err error) {
+	result := &algorithms{}
+
+	result.kex, err = findCommon("key exchange", clientKexInit.KexAlgos, serverKexInit.KexAlgos)
+	if err != nil {
+		return
+	}
+
+	result.hostKey, err = findCommon("host key", clientKexInit.ServerHostKeyAlgos, serverKexInit.ServerHostKeyAlgos)
+	if err != nil {
+		return
+	}
+
+	result.w.Cipher, err = findCommon("client to server cipher", clientKexInit.CiphersClientServer, serverKexInit.CiphersClientServer)
+	if err != nil {
+		return
+	}
+
+	result.r.Cipher, err = findCommon("server to client cipher", clientKexInit.CiphersServerClient, serverKexInit.CiphersServerClient)
+	if err != nil {
+		return
+	}
+
+	result.w.MAC, err = findCommon("client to server MAC", clientKexInit.MACsClientServer, serverKexInit.MACsClientServer)
+	if err != nil {
+		return
+	}
+
+	result.r.MAC, err = findCommon("server to client MAC", clientKexInit.MACsServerClient, serverKexInit.MACsServerClient)
+	if err != nil {
+		return
+	}
+
+	result.w.Compression, err = findCommon("client to server compression", clientKexInit.CompressionClientServer, serverKexInit.CompressionClientServer)
+	if err != nil {
+		return
+	}
+
+	result.r.Compression, err = findCommon("server to client compression", clientKexInit.CompressionServerClient, serverKexInit.CompressionServerClient)
+	if err != nil {
+		return
+	}
+
+	return result, nil
+}
+
+// If rekeythreshold is too small, we can't make any progress sending
+// stuff.
+const minRekeyThreshold uint64 = 256
+
+// Config contains configuration data common to both ServerConfig and
+// ClientConfig.
+type Config struct {
+	// Rand provides the source of entropy for cryptographic
+	// primitives. If Rand is nil, the cryptographic random reader
+	// in package crypto/rand will be used.
+	Rand io.Reader
+
+	// The maximum number of bytes sent or received after which a
+	// new key is negotiated. It must be at least 256. If
+	// unspecified, a size suitable for the chosen cipher is used.
+	RekeyThreshold uint64
+
+	// The allowed key exchanges algorithms. If unspecified then a
+	// default set of algorithms is used.
+	KeyExchanges []string
+
+	// The allowed cipher algorithms. If unspecified then a sensible
+	// default is used.
+	Ciphers []string
+
+	// The allowed MAC algorithms. If unspecified then a sensible default
+	// is used.
+	MACs []string
+}
+
+// SetDefaults sets sensible values for unset fields in config. This is
+// exported for testing: Configs passed to SSH functions are copied and have
+// default values set automatically.
+func (c *Config) SetDefaults() {
+	if c.Rand == nil {
+		c.Rand = rand.Reader
+	}
+	if c.Ciphers == nil {
+		c.Ciphers = supportedCiphers
+	}
+	var ciphers []string
+	for _, c := range c.Ciphers {
+		if cipherModes[c] != nil {
+			// reject the cipher if we have no cipherModes definition
+			ciphers = append(ciphers, c)
+		}
+	}
+	c.Ciphers = ciphers
+
+	if c.KeyExchanges == nil {
+		c.KeyExchanges = supportedKexAlgos
+	}
+
+	if c.MACs == nil {
+		c.MACs = supportedMACs
+	}
+
+	if c.RekeyThreshold == 0 {
+		// cipher specific default
+	} else if c.RekeyThreshold < minRekeyThreshold {
+		c.RekeyThreshold = minRekeyThreshold
+	} else if c.RekeyThreshold >= math.MaxInt64 {
+		// Avoid weirdness if somebody uses -1 as a threshold.
+		c.RekeyThreshold = math.MaxInt64
+	}
+}
+
+// buildDataSignedForAuth returns the data that is signed in order to prove
+// possession of a private key. See RFC 4252, section 7.
+func buildDataSignedForAuth(sessionId []byte, req userAuthRequestMsg, algo, pubKey []byte) []byte {
+	data := struct {
+		Session []byte
+		Type    byte
+		User    string
+		Service string
+		Method  string
+		Sign    bool
+		Algo    []byte
+		PubKey  []byte
+	}{
+		sessionId,
+		msgUserAuthRequest,
+		req.User,
+		req.Service,
+		req.Method,
+		true,
+		algo,
+		pubKey,
+	}
+	return Marshal(data)
+}
+
+func appendU16(buf []byte, n uint16) []byte {
+	return append(buf, byte(n>>8), byte(n))
+}
+
+func appendU32(buf []byte, n uint32) []byte {
+	return append(buf, byte(n>>24), byte(n>>16), byte(n>>8), byte(n))
+}
+
+func appendU64(buf []byte, n uint64) []byte {
+	return append(buf,
+		byte(n>>56), byte(n>>48), byte(n>>40), byte(n>>32),
+		byte(n>>24), byte(n>>16), byte(n>>8), byte(n))
+}
+
+func appendInt(buf []byte, n int) []byte {
+	return appendU32(buf, uint32(n))
+}
+
+func appendString(buf []byte, s string) []byte {
+	buf = appendU32(buf, uint32(len(s)))
+	buf = append(buf, s...)
+	return buf
+}
+
+func appendBool(buf []byte, b bool) []byte {
+	if b {
+		return append(buf, 1)
+	}
+	return append(buf, 0)
+}
+
+// newCond is a helper to hide the fact that there is no usable zero
+// value for sync.Cond.
+func newCond() *sync.Cond { return sync.NewCond(new(sync.Mutex)) }
+
+// window represents the buffer available to clients
+// wishing to write to a channel.
+type window struct {
+	*sync.Cond
+	win          uint32 // RFC 4254 5.2 says the window size can grow to 2^32-1
+	writeWaiters int
+	closed       bool
+}
+
+// add adds win to the amount of window available
+// for consumers.
+func (w *window) add(win uint32) bool {
+	// a zero sized window adjust is a noop.
+	if win == 0 {
+		return true
+	}
+	w.L.Lock()
+	if w.win+win < win {
+		w.L.Unlock()
+		return false
+	}
+	w.win += win
+	// It is unusual that multiple goroutines would be attempting to reserve
+	// window space, but not guaranteed. Use broadcast to notify all waiters
+	// that additional window is available.
+	w.Broadcast()
+	w.L.Unlock()
+	return true
+}
+
+// close sets the window to closed, so all reservations fail
+// immediately.
+func (w *window) close() {
+	w.L.Lock()
+	w.closed = true
+	w.Broadcast()
+	w.L.Unlock()
+}
+
+// reserve reserves win from the available window capacity.
+// If no capacity remains, reserve will block. reserve may
+// return less than requested.
+func (w *window) reserve(win uint32) (uint32, error) {
+	var err error
+	w.L.Lock()
+	w.writeWaiters++
+	w.Broadcast()
+	for w.win == 0 && !w.closed {
+		w.Wait()
+	}
+	w.writeWaiters--
+	if w.win < win {
+		win = w.win
+	}
+	w.win -= win
+	if w.closed {
+		err = io.EOF
+	}
+	w.L.Unlock()
+	return win, err
+}
+
+// waitWriterBlocked waits until some goroutine is blocked for further
+// writes. It is used in tests only.
+func (w *window) waitWriterBlocked() {
+	w.Cond.L.Lock()
+	for w.writeWaiters == 0 {
+		w.Cond.Wait()
+	}
+	w.Cond.L.Unlock()
+}
diff --git a/vendor/golang.org/x/crypto/ssh/connection.go b/vendor/golang.org/x/crypto/ssh/connection.go
new file mode 100644
index 0000000..fd6b068
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/connection.go
@@ -0,0 +1,143 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"fmt"
+	"net"
+)
+
+// OpenChannelError is returned if the other side rejects an
+// OpenChannel request.
+type OpenChannelError struct {
+	Reason  RejectionReason
+	Message string
+}
+
+func (e *OpenChannelError) Error() string {
+	return fmt.Sprintf("ssh: rejected: %s (%s)", e.Reason, e.Message)
+}
+
+// ConnMetadata holds metadata for the connection.
+type ConnMetadata interface {
+	// User returns the user ID for this connection.
+	User() string
+
+	// SessionID returns the session hash, also denoted by H.
+	SessionID() []byte
+
+	// ClientVersion returns the client's version string as hashed
+	// into the session ID.
+	ClientVersion() []byte
+
+	// ServerVersion returns the server's version string as hashed
+	// into the session ID.
+	ServerVersion() []byte
+
+	// RemoteAddr returns the remote address for this connection.
+	RemoteAddr() net.Addr
+
+	// LocalAddr returns the local address for this connection.
+	LocalAddr() net.Addr
+}
+
+// Conn represents an SSH connection for both server and client roles.
+// Conn is the basis for implementing an application layer, such
+// as ClientConn, which implements the traditional shell access for
+// clients.
+type Conn interface {
+	ConnMetadata
+
+	// SendRequest sends a global request, and returns the
+	// reply. If wantReply is true, it returns the response status
+	// and payload. See also RFC4254, section 4.
+	SendRequest(name string, wantReply bool, payload []byte) (bool, []byte, error)
+
+	// OpenChannel tries to open an channel. If the request is
+	// rejected, it returns *OpenChannelError. On success it returns
+	// the SSH Channel and a Go channel for incoming, out-of-band
+	// requests. The Go channel must be serviced, or the
+	// connection will hang.
+	OpenChannel(name string, data []byte) (Channel, <-chan *Request, error)
+
+	// Close closes the underlying network connection
+	Close() error
+
+	// Wait blocks until the connection has shut down, and returns the
+	// error causing the shutdown.
+	Wait() error
+
+	// TODO(hanwen): consider exposing:
+	//   RequestKeyChange
+	//   Disconnect
+}
+
+// DiscardRequests consumes and rejects all requests from the
+// passed-in channel.
+func DiscardRequests(in <-chan *Request) {
+	for req := range in {
+		if req.WantReply {
+			req.Reply(false, nil)
+		}
+	}
+}
+
+// A connection represents an incoming connection.
+type connection struct {
+	transport *handshakeTransport
+	sshConn
+
+	// The connection protocol.
+	*mux
+}
+
+func (c *connection) Close() error {
+	return c.sshConn.conn.Close()
+}
+
+// sshconn provides net.Conn metadata, but disallows direct reads and
+// writes.
+type sshConn struct {
+	conn net.Conn
+
+	user          string
+	sessionID     []byte
+	clientVersion []byte
+	serverVersion []byte
+}
+
+func dup(src []byte) []byte {
+	dst := make([]byte, len(src))
+	copy(dst, src)
+	return dst
+}
+
+func (c *sshConn) User() string {
+	return c.user
+}
+
+func (c *sshConn) RemoteAddr() net.Addr {
+	return c.conn.RemoteAddr()
+}
+
+func (c *sshConn) Close() error {
+	return c.conn.Close()
+}
+
+func (c *sshConn) LocalAddr() net.Addr {
+	return c.conn.LocalAddr()
+}
+
+func (c *sshConn) SessionID() []byte {
+	return dup(c.sessionID)
+}
+
+func (c *sshConn) ClientVersion() []byte {
+	return dup(c.clientVersion)
+}
+
+func (c *sshConn) ServerVersion() []byte {
+	return dup(c.serverVersion)
+}
diff --git a/vendor/golang.org/x/crypto/ssh/doc.go b/vendor/golang.org/x/crypto/ssh/doc.go
new file mode 100644
index 0000000..67b7322
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/doc.go
@@ -0,0 +1,21 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+/*
+Package ssh implements an SSH client and server.
+
+SSH is a transport security protocol, an authentication protocol and a
+family of application protocols. The most typical application level
+protocol is a remote shell and this is specifically implemented.  However,
+the multiplexed nature of SSH is exposed to users that wish to support
+others.
+
+References:
+  [PROTOCOL.certkeys]: http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.bin/ssh/PROTOCOL.certkeys?rev=HEAD
+  [SSH-PARAMETERS]:    http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xml#ssh-parameters-1
+
+This package does not fall under the stability promise of the Go language itself,
+so its API may be changed when pressing needs arise.
+*/
+package ssh // import "golang.org/x/crypto/ssh"
diff --git a/vendor/golang.org/x/crypto/ssh/handshake.go b/vendor/golang.org/x/crypto/ssh/handshake.go
new file mode 100644
index 0000000..932ce839
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/handshake.go
@@ -0,0 +1,640 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"crypto/rand"
+	"errors"
+	"fmt"
+	"io"
+	"log"
+	"net"
+	"sync"
+)
+
+// debugHandshake, if set, prints messages sent and received.  Key
+// exchange messages are printed as if DH were used, so the debug
+// messages are wrong when using ECDH.
+const debugHandshake = false
+
+// chanSize sets the amount of buffering SSH connections. This is
+// primarily for testing: setting chanSize=0 uncovers deadlocks more
+// quickly.
+const chanSize = 16
+
+// keyingTransport is a packet based transport that supports key
+// changes. It need not be thread-safe. It should pass through
+// msgNewKeys in both directions.
+type keyingTransport interface {
+	packetConn
+
+	// prepareKeyChange sets up a key change. The key change for a
+	// direction will be effected if a msgNewKeys message is sent
+	// or received.
+	prepareKeyChange(*algorithms, *kexResult) error
+}
+
+// handshakeTransport implements rekeying on top of a keyingTransport
+// and offers a thread-safe writePacket() interface.
+type handshakeTransport struct {
+	conn   keyingTransport
+	config *Config
+
+	serverVersion []byte
+	clientVersion []byte
+
+	// hostKeys is non-empty if we are the server. In that case,
+	// it contains all host keys that can be used to sign the
+	// connection.
+	hostKeys []Signer
+
+	// hostKeyAlgorithms is non-empty if we are the client. In that case,
+	// we accept these key types from the server as host key.
+	hostKeyAlgorithms []string
+
+	// On read error, incoming is closed, and readError is set.
+	incoming  chan []byte
+	readError error
+
+	mu             sync.Mutex
+	writeError     error
+	sentInitPacket []byte
+	sentInitMsg    *kexInitMsg
+	pendingPackets [][]byte // Used when a key exchange is in progress.
+
+	// If the read loop wants to schedule a kex, it pings this
+	// channel, and the write loop will send out a kex
+	// message.
+	requestKex chan struct{}
+
+	// If the other side requests or confirms a kex, its kexInit
+	// packet is sent here for the write loop to find it.
+	startKex chan *pendingKex
+
+	// data for host key checking
+	hostKeyCallback HostKeyCallback
+	dialAddress     string
+	remoteAddr      net.Addr
+
+	// Algorithms agreed in the last key exchange.
+	algorithms *algorithms
+
+	readPacketsLeft uint32
+	readBytesLeft   int64
+
+	writePacketsLeft uint32
+	writeBytesLeft   int64
+
+	// The session ID or nil if first kex did not complete yet.
+	sessionID []byte
+}
+
+type pendingKex struct {
+	otherInit []byte
+	done      chan error
+}
+
+func newHandshakeTransport(conn keyingTransport, config *Config, clientVersion, serverVersion []byte) *handshakeTransport {
+	t := &handshakeTransport{
+		conn:          conn,
+		serverVersion: serverVersion,
+		clientVersion: clientVersion,
+		incoming:      make(chan []byte, chanSize),
+		requestKex:    make(chan struct{}, 1),
+		startKex:      make(chan *pendingKex, 1),
+
+		config: config,
+	}
+	t.resetReadThresholds()
+	t.resetWriteThresholds()
+
+	// We always start with a mandatory key exchange.
+	t.requestKex <- struct{}{}
+	return t
+}
+
+func newClientTransport(conn keyingTransport, clientVersion, serverVersion []byte, config *ClientConfig, dialAddr string, addr net.Addr) *handshakeTransport {
+	t := newHandshakeTransport(conn, &config.Config, clientVersion, serverVersion)
+	t.dialAddress = dialAddr
+	t.remoteAddr = addr
+	t.hostKeyCallback = config.HostKeyCallback
+	if config.HostKeyAlgorithms != nil {
+		t.hostKeyAlgorithms = config.HostKeyAlgorithms
+	} else {
+		t.hostKeyAlgorithms = supportedHostKeyAlgos
+	}
+	go t.readLoop()
+	go t.kexLoop()
+	return t
+}
+
+func newServerTransport(conn keyingTransport, clientVersion, serverVersion []byte, config *ServerConfig) *handshakeTransport {
+	t := newHandshakeTransport(conn, &config.Config, clientVersion, serverVersion)
+	t.hostKeys = config.hostKeys
+	go t.readLoop()
+	go t.kexLoop()
+	return t
+}
+
+func (t *handshakeTransport) getSessionID() []byte {
+	return t.sessionID
+}
+
+// waitSession waits for the session to be established. This should be
+// the first thing to call after instantiating handshakeTransport.
+func (t *handshakeTransport) waitSession() error {
+	p, err := t.readPacket()
+	if err != nil {
+		return err
+	}
+	if p[0] != msgNewKeys {
+		return fmt.Errorf("ssh: first packet should be msgNewKeys")
+	}
+
+	return nil
+}
+
+func (t *handshakeTransport) id() string {
+	if len(t.hostKeys) > 0 {
+		return "server"
+	}
+	return "client"
+}
+
+func (t *handshakeTransport) printPacket(p []byte, write bool) {
+	action := "got"
+	if write {
+		action = "sent"
+	}
+
+	if p[0] == msgChannelData || p[0] == msgChannelExtendedData {
+		log.Printf("%s %s data (packet %d bytes)", t.id(), action, len(p))
+	} else {
+		msg, err := decode(p)
+		log.Printf("%s %s %T %v (%v)", t.id(), action, msg, msg, err)
+	}
+}
+
+func (t *handshakeTransport) readPacket() ([]byte, error) {
+	p, ok := <-t.incoming
+	if !ok {
+		return nil, t.readError
+	}
+	return p, nil
+}
+
+func (t *handshakeTransport) readLoop() {
+	first := true
+	for {
+		p, err := t.readOnePacket(first)
+		first = false
+		if err != nil {
+			t.readError = err
+			close(t.incoming)
+			break
+		}
+		if p[0] == msgIgnore || p[0] == msgDebug {
+			continue
+		}
+		t.incoming <- p
+	}
+
+	// Stop writers too.
+	t.recordWriteError(t.readError)
+
+	// Unblock the writer should it wait for this.
+	close(t.startKex)
+
+	// Don't close t.requestKex; it's also written to from writePacket.
+}
+
+func (t *handshakeTransport) pushPacket(p []byte) error {
+	if debugHandshake {
+		t.printPacket(p, true)
+	}
+	return t.conn.writePacket(p)
+}
+
+func (t *handshakeTransport) getWriteError() error {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+	return t.writeError
+}
+
+func (t *handshakeTransport) recordWriteError(err error) {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+	if t.writeError == nil && err != nil {
+		t.writeError = err
+	}
+}
+
+func (t *handshakeTransport) requestKeyExchange() {
+	select {
+	case t.requestKex <- struct{}{}:
+	default:
+		// something already requested a kex, so do nothing.
+	}
+}
+
+func (t *handshakeTransport) resetWriteThresholds() {
+	t.writePacketsLeft = packetRekeyThreshold
+	if t.config.RekeyThreshold > 0 {
+		t.writeBytesLeft = int64(t.config.RekeyThreshold)
+	} else if t.algorithms != nil {
+		t.writeBytesLeft = t.algorithms.w.rekeyBytes()
+	} else {
+		t.writeBytesLeft = 1 << 30
+	}
+}
+
+func (t *handshakeTransport) kexLoop() {
+
+write:
+	for t.getWriteError() == nil {
+		var request *pendingKex
+		var sent bool
+
+		for request == nil || !sent {
+			var ok bool
+			select {
+			case request, ok = <-t.startKex:
+				if !ok {
+					break write
+				}
+			case <-t.requestKex:
+				break
+			}
+
+			if !sent {
+				if err := t.sendKexInit(); err != nil {
+					t.recordWriteError(err)
+					break
+				}
+				sent = true
+			}
+		}
+
+		if err := t.getWriteError(); err != nil {
+			if request != nil {
+				request.done <- err
+			}
+			break
+		}
+
+		// We're not servicing t.requestKex, but that is OK:
+		// we never block on sending to t.requestKex.
+
+		// We're not servicing t.startKex, but the remote end
+		// has just sent us a kexInitMsg, so it can't send
+		// another key change request, until we close the done
+		// channel on the pendingKex request.
+
+		err := t.enterKeyExchange(request.otherInit)
+
+		t.mu.Lock()
+		t.writeError = err
+		t.sentInitPacket = nil
+		t.sentInitMsg = nil
+
+		t.resetWriteThresholds()
+
+		// we have completed the key exchange. Since the
+		// reader is still blocked, it is safe to clear out
+		// the requestKex channel. This avoids the situation
+		// where: 1) we consumed our own request for the
+		// initial kex, and 2) the kex from the remote side
+		// caused another send on the requestKex channel,
+	clear:
+		for {
+			select {
+			case <-t.requestKex:
+				//
+			default:
+				break clear
+			}
+		}
+
+		request.done <- t.writeError
+
+		// kex finished. Push packets that we received while
+		// the kex was in progress. Don't look at t.startKex
+		// and don't increment writtenSinceKex: if we trigger
+		// another kex while we are still busy with the last
+		// one, things will become very confusing.
+		for _, p := range t.pendingPackets {
+			t.writeError = t.pushPacket(p)
+			if t.writeError != nil {
+				break
+			}
+		}
+		t.pendingPackets = t.pendingPackets[:0]
+		t.mu.Unlock()
+	}
+
+	// drain startKex channel. We don't service t.requestKex
+	// because nobody does blocking sends there.
+	go func() {
+		for init := range t.startKex {
+			init.done <- t.writeError
+		}
+	}()
+
+	// Unblock reader.
+	t.conn.Close()
+}
+
+// The protocol uses uint32 for packet counters, so we can't let them
+// reach 1<<32.  We will actually read and write more packets than
+// this, though: the other side may send more packets, and after we
+// hit this limit on writing we will send a few more packets for the
+// key exchange itself.
+const packetRekeyThreshold = (1 << 31)
+
+func (t *handshakeTransport) resetReadThresholds() {
+	t.readPacketsLeft = packetRekeyThreshold
+	if t.config.RekeyThreshold > 0 {
+		t.readBytesLeft = int64(t.config.RekeyThreshold)
+	} else if t.algorithms != nil {
+		t.readBytesLeft = t.algorithms.r.rekeyBytes()
+	} else {
+		t.readBytesLeft = 1 << 30
+	}
+}
+
+func (t *handshakeTransport) readOnePacket(first bool) ([]byte, error) {
+	p, err := t.conn.readPacket()
+	if err != nil {
+		return nil, err
+	}
+
+	if t.readPacketsLeft > 0 {
+		t.readPacketsLeft--
+	} else {
+		t.requestKeyExchange()
+	}
+
+	if t.readBytesLeft > 0 {
+		t.readBytesLeft -= int64(len(p))
+	} else {
+		t.requestKeyExchange()
+	}
+
+	if debugHandshake {
+		t.printPacket(p, false)
+	}
+
+	if first && p[0] != msgKexInit {
+		return nil, fmt.Errorf("ssh: first packet should be msgKexInit")
+	}
+
+	if p[0] != msgKexInit {
+		return p, nil
+	}
+
+	firstKex := t.sessionID == nil
+
+	kex := pendingKex{
+		done:      make(chan error, 1),
+		otherInit: p,
+	}
+	t.startKex <- &kex
+	err = <-kex.done
+
+	if debugHandshake {
+		log.Printf("%s exited key exchange (first %v), err %v", t.id(), firstKex, err)
+	}
+
+	if err != nil {
+		return nil, err
+	}
+
+	t.resetReadThresholds()
+
+	// By default, a key exchange is hidden from higher layers by
+	// translating it into msgIgnore.
+	successPacket := []byte{msgIgnore}
+	if firstKex {
+		// sendKexInit() for the first kex waits for
+		// msgNewKeys so the authentication process is
+		// guaranteed to happen over an encrypted transport.
+		successPacket = []byte{msgNewKeys}
+	}
+
+	return successPacket, nil
+}
+
+// sendKexInit sends a key change message.
+func (t *handshakeTransport) sendKexInit() error {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+	if t.sentInitMsg != nil {
+		// kexInits may be sent either in response to the other side,
+		// or because our side wants to initiate a key change, so we
+		// may have already sent a kexInit. In that case, don't send a
+		// second kexInit.
+		return nil
+	}
+
+	msg := &kexInitMsg{
+		KexAlgos:                t.config.KeyExchanges,
+		CiphersClientServer:     t.config.Ciphers,
+		CiphersServerClient:     t.config.Ciphers,
+		MACsClientServer:        t.config.MACs,
+		MACsServerClient:        t.config.MACs,
+		CompressionClientServer: supportedCompressions,
+		CompressionServerClient: supportedCompressions,
+	}
+	io.ReadFull(rand.Reader, msg.Cookie[:])
+
+	if len(t.hostKeys) > 0 {
+		for _, k := range t.hostKeys {
+			msg.ServerHostKeyAlgos = append(
+				msg.ServerHostKeyAlgos, k.PublicKey().Type())
+		}
+	} else {
+		msg.ServerHostKeyAlgos = t.hostKeyAlgorithms
+	}
+	packet := Marshal(msg)
+
+	// writePacket destroys the contents, so save a copy.
+	packetCopy := make([]byte, len(packet))
+	copy(packetCopy, packet)
+
+	if err := t.pushPacket(packetCopy); err != nil {
+		return err
+	}
+
+	t.sentInitMsg = msg
+	t.sentInitPacket = packet
+
+	return nil
+}
+
+func (t *handshakeTransport) writePacket(p []byte) error {
+	switch p[0] {
+	case msgKexInit:
+		return errors.New("ssh: only handshakeTransport can send kexInit")
+	case msgNewKeys:
+		return errors.New("ssh: only handshakeTransport can send newKeys")
+	}
+
+	t.mu.Lock()
+	defer t.mu.Unlock()
+	if t.writeError != nil {
+		return t.writeError
+	}
+
+	if t.sentInitMsg != nil {
+		// Copy the packet so the writer can reuse the buffer.
+		cp := make([]byte, len(p))
+		copy(cp, p)
+		t.pendingPackets = append(t.pendingPackets, cp)
+		return nil
+	}
+
+	if t.writeBytesLeft > 0 {
+		t.writeBytesLeft -= int64(len(p))
+	} else {
+		t.requestKeyExchange()
+	}
+
+	if t.writePacketsLeft > 0 {
+		t.writePacketsLeft--
+	} else {
+		t.requestKeyExchange()
+	}
+
+	if err := t.pushPacket(p); err != nil {
+		t.writeError = err
+	}
+
+	return nil
+}
+
+func (t *handshakeTransport) Close() error {
+	return t.conn.Close()
+}
+
+func (t *handshakeTransport) enterKeyExchange(otherInitPacket []byte) error {
+	if debugHandshake {
+		log.Printf("%s entered key exchange", t.id())
+	}
+
+	otherInit := &kexInitMsg{}
+	if err := Unmarshal(otherInitPacket, otherInit); err != nil {
+		return err
+	}
+
+	magics := handshakeMagics{
+		clientVersion: t.clientVersion,
+		serverVersion: t.serverVersion,
+		clientKexInit: otherInitPacket,
+		serverKexInit: t.sentInitPacket,
+	}
+
+	clientInit := otherInit
+	serverInit := t.sentInitMsg
+	if len(t.hostKeys) == 0 {
+		clientInit, serverInit = serverInit, clientInit
+
+		magics.clientKexInit = t.sentInitPacket
+		magics.serverKexInit = otherInitPacket
+	}
+
+	var err error
+	t.algorithms, err = findAgreedAlgorithms(clientInit, serverInit)
+	if err != nil {
+		return err
+	}
+
+	// We don't send FirstKexFollows, but we handle receiving it.
+	//
+	// RFC 4253 section 7 defines the kex and the agreement method for
+	// first_kex_packet_follows. It states that the guessed packet
+	// should be ignored if the "kex algorithm and/or the host
+	// key algorithm is guessed wrong (server and client have
+	// different preferred algorithm), or if any of the other
+	// algorithms cannot be agreed upon". The other algorithms have
+	// already been checked above so the kex algorithm and host key
+	// algorithm are checked here.
+	if otherInit.FirstKexFollows && (clientInit.KexAlgos[0] != serverInit.KexAlgos[0] || clientInit.ServerHostKeyAlgos[0] != serverInit.ServerHostKeyAlgos[0]) {
+		// other side sent a kex message for the wrong algorithm,
+		// which we have to ignore.
+		if _, err := t.conn.readPacket(); err != nil {
+			return err
+		}
+	}
+
+	kex, ok := kexAlgoMap[t.algorithms.kex]
+	if !ok {
+		return fmt.Errorf("ssh: unexpected key exchange algorithm %v", t.algorithms.kex)
+	}
+
+	var result *kexResult
+	if len(t.hostKeys) > 0 {
+		result, err = t.server(kex, t.algorithms, &magics)
+	} else {
+		result, err = t.client(kex, t.algorithms, &magics)
+	}
+
+	if err != nil {
+		return err
+	}
+
+	if t.sessionID == nil {
+		t.sessionID = result.H
+	}
+	result.SessionID = t.sessionID
+
+	if err := t.conn.prepareKeyChange(t.algorithms, result); err != nil {
+		return err
+	}
+	if err = t.conn.writePacket([]byte{msgNewKeys}); err != nil {
+		return err
+	}
+	if packet, err := t.conn.readPacket(); err != nil {
+		return err
+	} else if packet[0] != msgNewKeys {
+		return unexpectedMessageError(msgNewKeys, packet[0])
+	}
+
+	return nil
+}
+
+func (t *handshakeTransport) server(kex kexAlgorithm, algs *algorithms, magics *handshakeMagics) (*kexResult, error) {
+	var hostKey Signer
+	for _, k := range t.hostKeys {
+		if algs.hostKey == k.PublicKey().Type() {
+			hostKey = k
+		}
+	}
+
+	r, err := kex.Server(t.conn, t.config.Rand, magics, hostKey)
+	return r, err
+}
+
+func (t *handshakeTransport) client(kex kexAlgorithm, algs *algorithms, magics *handshakeMagics) (*kexResult, error) {
+	result, err := kex.Client(t.conn, t.config.Rand, magics)
+	if err != nil {
+		return nil, err
+	}
+
+	hostKey, err := ParsePublicKey(result.HostKey)
+	if err != nil {
+		return nil, err
+	}
+
+	if err := verifyHostKeySignature(hostKey, result); err != nil {
+		return nil, err
+	}
+
+	err = t.hostKeyCallback(t.dialAddress, t.remoteAddr, hostKey)
+	if err != nil {
+		return nil, err
+	}
+
+	return result, nil
+}
diff --git a/vendor/golang.org/x/crypto/ssh/kex.go b/vendor/golang.org/x/crypto/ssh/kex.go
new file mode 100644
index 0000000..f91c277
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/kex.go
@@ -0,0 +1,540 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"crypto"
+	"crypto/ecdsa"
+	"crypto/elliptic"
+	"crypto/rand"
+	"crypto/subtle"
+	"errors"
+	"io"
+	"math/big"
+
+	"golang.org/x/crypto/curve25519"
+)
+
+const (
+	kexAlgoDH1SHA1          = "diffie-hellman-group1-sha1"
+	kexAlgoDH14SHA1         = "diffie-hellman-group14-sha1"
+	kexAlgoECDH256          = "ecdh-sha2-nistp256"
+	kexAlgoECDH384          = "ecdh-sha2-nistp384"
+	kexAlgoECDH521          = "ecdh-sha2-nistp521"
+	kexAlgoCurve25519SHA256 = "curve25519-sha256@libssh.org"
+)
+
+// kexResult captures the outcome of a key exchange.
+type kexResult struct {
+	// Session hash. See also RFC 4253, section 8.
+	H []byte
+
+	// Shared secret. See also RFC 4253, section 8.
+	K []byte
+
+	// Host key as hashed into H.
+	HostKey []byte
+
+	// Signature of H.
+	Signature []byte
+
+	// A cryptographic hash function that matches the security
+	// level of the key exchange algorithm. It is used for
+	// calculating H, and for deriving keys from H and K.
+	Hash crypto.Hash
+
+	// The session ID, which is the first H computed. This is used
+	// to derive key material inside the transport.
+	SessionID []byte
+}
+
+// handshakeMagics contains data that is always included in the
+// session hash.
+type handshakeMagics struct {
+	clientVersion, serverVersion []byte
+	clientKexInit, serverKexInit []byte
+}
+
+func (m *handshakeMagics) write(w io.Writer) {
+	writeString(w, m.clientVersion)
+	writeString(w, m.serverVersion)
+	writeString(w, m.clientKexInit)
+	writeString(w, m.serverKexInit)
+}
+
+// kexAlgorithm abstracts different key exchange algorithms.
+type kexAlgorithm interface {
+	// Server runs server-side key agreement, signing the result
+	// with a hostkey.
+	Server(p packetConn, rand io.Reader, magics *handshakeMagics, s Signer) (*kexResult, error)
+
+	// Client runs the client-side key agreement. Caller is
+	// responsible for verifying the host key signature.
+	Client(p packetConn, rand io.Reader, magics *handshakeMagics) (*kexResult, error)
+}
+
+// dhGroup is a multiplicative group suitable for implementing Diffie-Hellman key agreement.
+type dhGroup struct {
+	g, p, pMinus1 *big.Int
+}
+
+func (group *dhGroup) diffieHellman(theirPublic, myPrivate *big.Int) (*big.Int, error) {
+	if theirPublic.Cmp(bigOne) <= 0 || theirPublic.Cmp(group.pMinus1) >= 0 {
+		return nil, errors.New("ssh: DH parameter out of bounds")
+	}
+	return new(big.Int).Exp(theirPublic, myPrivate, group.p), nil
+}
+
+func (group *dhGroup) Client(c packetConn, randSource io.Reader, magics *handshakeMagics) (*kexResult, error) {
+	hashFunc := crypto.SHA1
+
+	var x *big.Int
+	for {
+		var err error
+		if x, err = rand.Int(randSource, group.pMinus1); err != nil {
+			return nil, err
+		}
+		if x.Sign() > 0 {
+			break
+		}
+	}
+
+	X := new(big.Int).Exp(group.g, x, group.p)
+	kexDHInit := kexDHInitMsg{
+		X: X,
+	}
+	if err := c.writePacket(Marshal(&kexDHInit)); err != nil {
+		return nil, err
+	}
+
+	packet, err := c.readPacket()
+	if err != nil {
+		return nil, err
+	}
+
+	var kexDHReply kexDHReplyMsg
+	if err = Unmarshal(packet, &kexDHReply); err != nil {
+		return nil, err
+	}
+
+	kInt, err := group.diffieHellman(kexDHReply.Y, x)
+	if err != nil {
+		return nil, err
+	}
+
+	h := hashFunc.New()
+	magics.write(h)
+	writeString(h, kexDHReply.HostKey)
+	writeInt(h, X)
+	writeInt(h, kexDHReply.Y)
+	K := make([]byte, intLength(kInt))
+	marshalInt(K, kInt)
+	h.Write(K)
+
+	return &kexResult{
+		H:         h.Sum(nil),
+		K:         K,
+		HostKey:   kexDHReply.HostKey,
+		Signature: kexDHReply.Signature,
+		Hash:      crypto.SHA1,
+	}, nil
+}
+
+func (group *dhGroup) Server(c packetConn, randSource io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
+	hashFunc := crypto.SHA1
+	packet, err := c.readPacket()
+	if err != nil {
+		return
+	}
+	var kexDHInit kexDHInitMsg
+	if err = Unmarshal(packet, &kexDHInit); err != nil {
+		return
+	}
+
+	var y *big.Int
+	for {
+		if y, err = rand.Int(randSource, group.pMinus1); err != nil {
+			return
+		}
+		if y.Sign() > 0 {
+			break
+		}
+	}
+
+	Y := new(big.Int).Exp(group.g, y, group.p)
+	kInt, err := group.diffieHellman(kexDHInit.X, y)
+	if err != nil {
+		return nil, err
+	}
+
+	hostKeyBytes := priv.PublicKey().Marshal()
+
+	h := hashFunc.New()
+	magics.write(h)
+	writeString(h, hostKeyBytes)
+	writeInt(h, kexDHInit.X)
+	writeInt(h, Y)
+
+	K := make([]byte, intLength(kInt))
+	marshalInt(K, kInt)
+	h.Write(K)
+
+	H := h.Sum(nil)
+
+	// H is already a hash, but the hostkey signing will apply its
+	// own key-specific hash algorithm.
+	sig, err := signAndMarshal(priv, randSource, H)
+	if err != nil {
+		return nil, err
+	}
+
+	kexDHReply := kexDHReplyMsg{
+		HostKey:   hostKeyBytes,
+		Y:         Y,
+		Signature: sig,
+	}
+	packet = Marshal(&kexDHReply)
+
+	err = c.writePacket(packet)
+	return &kexResult{
+		H:         H,
+		K:         K,
+		HostKey:   hostKeyBytes,
+		Signature: sig,
+		Hash:      crypto.SHA1,
+	}, nil
+}
+
+// ecdh performs Elliptic Curve Diffie-Hellman key exchange as
+// described in RFC 5656, section 4.
+type ecdh struct {
+	curve elliptic.Curve
+}
+
+func (kex *ecdh) Client(c packetConn, rand io.Reader, magics *handshakeMagics) (*kexResult, error) {
+	ephKey, err := ecdsa.GenerateKey(kex.curve, rand)
+	if err != nil {
+		return nil, err
+	}
+
+	kexInit := kexECDHInitMsg{
+		ClientPubKey: elliptic.Marshal(kex.curve, ephKey.PublicKey.X, ephKey.PublicKey.Y),
+	}
+
+	serialized := Marshal(&kexInit)
+	if err := c.writePacket(serialized); err != nil {
+		return nil, err
+	}
+
+	packet, err := c.readPacket()
+	if err != nil {
+		return nil, err
+	}
+
+	var reply kexECDHReplyMsg
+	if err = Unmarshal(packet, &reply); err != nil {
+		return nil, err
+	}
+
+	x, y, err := unmarshalECKey(kex.curve, reply.EphemeralPubKey)
+	if err != nil {
+		return nil, err
+	}
+
+	// generate shared secret
+	secret, _ := kex.curve.ScalarMult(x, y, ephKey.D.Bytes())
+
+	h := ecHash(kex.curve).New()
+	magics.write(h)
+	writeString(h, reply.HostKey)
+	writeString(h, kexInit.ClientPubKey)
+	writeString(h, reply.EphemeralPubKey)
+	K := make([]byte, intLength(secret))
+	marshalInt(K, secret)
+	h.Write(K)
+
+	return &kexResult{
+		H:         h.Sum(nil),
+		K:         K,
+		HostKey:   reply.HostKey,
+		Signature: reply.Signature,
+		Hash:      ecHash(kex.curve),
+	}, nil
+}
+
+// unmarshalECKey parses and checks an EC key.
+func unmarshalECKey(curve elliptic.Curve, pubkey []byte) (x, y *big.Int, err error) {
+	x, y = elliptic.Unmarshal(curve, pubkey)
+	if x == nil {
+		return nil, nil, errors.New("ssh: elliptic.Unmarshal failure")
+	}
+	if !validateECPublicKey(curve, x, y) {
+		return nil, nil, errors.New("ssh: public key not on curve")
+	}
+	return x, y, nil
+}
+
+// validateECPublicKey checks that the point is a valid public key for
+// the given curve. See [SEC1], 3.2.2
+func validateECPublicKey(curve elliptic.Curve, x, y *big.Int) bool {
+	if x.Sign() == 0 && y.Sign() == 0 {
+		return false
+	}
+
+	if x.Cmp(curve.Params().P) >= 0 {
+		return false
+	}
+
+	if y.Cmp(curve.Params().P) >= 0 {
+		return false
+	}
+
+	if !curve.IsOnCurve(x, y) {
+		return false
+	}
+
+	// We don't check if N * PubKey == 0, since
+	//
+	// - the NIST curves have cofactor = 1, so this is implicit.
+	// (We don't foresee an implementation that supports non NIST
+	// curves)
+	//
+	// - for ephemeral keys, we don't need to worry about small
+	// subgroup attacks.
+	return true
+}
+
+func (kex *ecdh) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
+	packet, err := c.readPacket()
+	if err != nil {
+		return nil, err
+	}
+
+	var kexECDHInit kexECDHInitMsg
+	if err = Unmarshal(packet, &kexECDHInit); err != nil {
+		return nil, err
+	}
+
+	clientX, clientY, err := unmarshalECKey(kex.curve, kexECDHInit.ClientPubKey)
+	if err != nil {
+		return nil, err
+	}
+
+	// We could cache this key across multiple users/multiple
+	// connection attempts, but the benefit is small. OpenSSH
+	// generates a new key for each incoming connection.
+	ephKey, err := ecdsa.GenerateKey(kex.curve, rand)
+	if err != nil {
+		return nil, err
+	}
+
+	hostKeyBytes := priv.PublicKey().Marshal()
+
+	serializedEphKey := elliptic.Marshal(kex.curve, ephKey.PublicKey.X, ephKey.PublicKey.Y)
+
+	// generate shared secret
+	secret, _ := kex.curve.ScalarMult(clientX, clientY, ephKey.D.Bytes())
+
+	h := ecHash(kex.curve).New()
+	magics.write(h)
+	writeString(h, hostKeyBytes)
+	writeString(h, kexECDHInit.ClientPubKey)
+	writeString(h, serializedEphKey)
+
+	K := make([]byte, intLength(secret))
+	marshalInt(K, secret)
+	h.Write(K)
+
+	H := h.Sum(nil)
+
+	// H is already a hash, but the hostkey signing will apply its
+	// own key-specific hash algorithm.
+	sig, err := signAndMarshal(priv, rand, H)
+	if err != nil {
+		return nil, err
+	}
+
+	reply := kexECDHReplyMsg{
+		EphemeralPubKey: serializedEphKey,
+		HostKey:         hostKeyBytes,
+		Signature:       sig,
+	}
+
+	serialized := Marshal(&reply)
+	if err := c.writePacket(serialized); err != nil {
+		return nil, err
+	}
+
+	return &kexResult{
+		H:         H,
+		K:         K,
+		HostKey:   reply.HostKey,
+		Signature: sig,
+		Hash:      ecHash(kex.curve),
+	}, nil
+}
+
+var kexAlgoMap = map[string]kexAlgorithm{}
+
+func init() {
+	// This is the group called diffie-hellman-group1-sha1 in RFC
+	// 4253 and Oakley Group 2 in RFC 2409.
+	p, _ := new(big.Int).SetString("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF", 16)
+	kexAlgoMap[kexAlgoDH1SHA1] = &dhGroup{
+		g:       new(big.Int).SetInt64(2),
+		p:       p,
+		pMinus1: new(big.Int).Sub(p, bigOne),
+	}
+
+	// This is the group called diffie-hellman-group14-sha1 in RFC
+	// 4253 and Oakley Group 14 in RFC 3526.
+	p, _ = new(big.Int).SetString("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF", 16)
+
+	kexAlgoMap[kexAlgoDH14SHA1] = &dhGroup{
+		g:       new(big.Int).SetInt64(2),
+		p:       p,
+		pMinus1: new(big.Int).Sub(p, bigOne),
+	}
+
+	kexAlgoMap[kexAlgoECDH521] = &ecdh{elliptic.P521()}
+	kexAlgoMap[kexAlgoECDH384] = &ecdh{elliptic.P384()}
+	kexAlgoMap[kexAlgoECDH256] = &ecdh{elliptic.P256()}
+	kexAlgoMap[kexAlgoCurve25519SHA256] = &curve25519sha256{}
+}
+
+// curve25519sha256 implements the curve25519-sha256@libssh.org key
+// agreement protocol, as described in
+// https://git.libssh.org/projects/libssh.git/tree/doc/curve25519-sha256@libssh.org.txt
+type curve25519sha256 struct{}
+
+type curve25519KeyPair struct {
+	priv [32]byte
+	pub  [32]byte
+}
+
+func (kp *curve25519KeyPair) generate(rand io.Reader) error {
+	if _, err := io.ReadFull(rand, kp.priv[:]); err != nil {
+		return err
+	}
+	curve25519.ScalarBaseMult(&kp.pub, &kp.priv)
+	return nil
+}
+
+// curve25519Zeros is just an array of 32 zero bytes so that we have something
+// convenient to compare against in order to reject curve25519 points with the
+// wrong order.
+var curve25519Zeros [32]byte
+
+func (kex *curve25519sha256) Client(c packetConn, rand io.Reader, magics *handshakeMagics) (*kexResult, error) {
+	var kp curve25519KeyPair
+	if err := kp.generate(rand); err != nil {
+		return nil, err
+	}
+	if err := c.writePacket(Marshal(&kexECDHInitMsg{kp.pub[:]})); err != nil {
+		return nil, err
+	}
+
+	packet, err := c.readPacket()
+	if err != nil {
+		return nil, err
+	}
+
+	var reply kexECDHReplyMsg
+	if err = Unmarshal(packet, &reply); err != nil {
+		return nil, err
+	}
+	if len(reply.EphemeralPubKey) != 32 {
+		return nil, errors.New("ssh: peer's curve25519 public value has wrong length")
+	}
+
+	var servPub, secret [32]byte
+	copy(servPub[:], reply.EphemeralPubKey)
+	curve25519.ScalarMult(&secret, &kp.priv, &servPub)
+	if subtle.ConstantTimeCompare(secret[:], curve25519Zeros[:]) == 1 {
+		return nil, errors.New("ssh: peer's curve25519 public value has wrong order")
+	}
+
+	h := crypto.SHA256.New()
+	magics.write(h)
+	writeString(h, reply.HostKey)
+	writeString(h, kp.pub[:])
+	writeString(h, reply.EphemeralPubKey)
+
+	kInt := new(big.Int).SetBytes(secret[:])
+	K := make([]byte, intLength(kInt))
+	marshalInt(K, kInt)
+	h.Write(K)
+
+	return &kexResult{
+		H:         h.Sum(nil),
+		K:         K,
+		HostKey:   reply.HostKey,
+		Signature: reply.Signature,
+		Hash:      crypto.SHA256,
+	}, nil
+}
+
+func (kex *curve25519sha256) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
+	packet, err := c.readPacket()
+	if err != nil {
+		return
+	}
+	var kexInit kexECDHInitMsg
+	if err = Unmarshal(packet, &kexInit); err != nil {
+		return
+	}
+
+	if len(kexInit.ClientPubKey) != 32 {
+		return nil, errors.New("ssh: peer's curve25519 public value has wrong length")
+	}
+
+	var kp curve25519KeyPair
+	if err := kp.generate(rand); err != nil {
+		return nil, err
+	}
+
+	var clientPub, secret [32]byte
+	copy(clientPub[:], kexInit.ClientPubKey)
+	curve25519.ScalarMult(&secret, &kp.priv, &clientPub)
+	if subtle.ConstantTimeCompare(secret[:], curve25519Zeros[:]) == 1 {
+		return nil, errors.New("ssh: peer's curve25519 public value has wrong order")
+	}
+
+	hostKeyBytes := priv.PublicKey().Marshal()
+
+	h := crypto.SHA256.New()
+	magics.write(h)
+	writeString(h, hostKeyBytes)
+	writeString(h, kexInit.ClientPubKey)
+	writeString(h, kp.pub[:])
+
+	kInt := new(big.Int).SetBytes(secret[:])
+	K := make([]byte, intLength(kInt))
+	marshalInt(K, kInt)
+	h.Write(K)
+
+	H := h.Sum(nil)
+
+	sig, err := signAndMarshal(priv, rand, H)
+	if err != nil {
+		return nil, err
+	}
+
+	reply := kexECDHReplyMsg{
+		EphemeralPubKey: kp.pub[:],
+		HostKey:         hostKeyBytes,
+		Signature:       sig,
+	}
+	if err := c.writePacket(Marshal(&reply)); err != nil {
+		return nil, err
+	}
+	return &kexResult{
+		H:         H,
+		K:         K,
+		HostKey:   hostKeyBytes,
+		Signature: sig,
+		Hash:      crypto.SHA256,
+	}, nil
+}
diff --git a/vendor/golang.org/x/crypto/ssh/keys.go b/vendor/golang.org/x/crypto/ssh/keys.go
new file mode 100644
index 0000000..b682c17
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/keys.go
@@ -0,0 +1,1031 @@
+// Copyright 2012 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"bytes"
+	"crypto"
+	"crypto/dsa"
+	"crypto/ecdsa"
+	"crypto/elliptic"
+	"crypto/md5"
+	"crypto/rsa"
+	"crypto/sha256"
+	"crypto/x509"
+	"encoding/asn1"
+	"encoding/base64"
+	"encoding/hex"
+	"encoding/pem"
+	"errors"
+	"fmt"
+	"io"
+	"math/big"
+	"strings"
+
+	"golang.org/x/crypto/ed25519"
+)
+
+// These constants represent the algorithm names for key types supported by this
+// package.
+const (
+	KeyAlgoRSA      = "ssh-rsa"
+	KeyAlgoDSA      = "ssh-dss"
+	KeyAlgoECDSA256 = "ecdsa-sha2-nistp256"
+	KeyAlgoECDSA384 = "ecdsa-sha2-nistp384"
+	KeyAlgoECDSA521 = "ecdsa-sha2-nistp521"
+	KeyAlgoED25519  = "ssh-ed25519"
+)
+
+// parsePubKey parses a public key of the given algorithm.
+// Use ParsePublicKey for keys with prepended algorithm.
+func parsePubKey(in []byte, algo string) (pubKey PublicKey, rest []byte, err error) {
+	switch algo {
+	case KeyAlgoRSA:
+		return parseRSA(in)
+	case KeyAlgoDSA:
+		return parseDSA(in)
+	case KeyAlgoECDSA256, KeyAlgoECDSA384, KeyAlgoECDSA521:
+		return parseECDSA(in)
+	case KeyAlgoED25519:
+		return parseED25519(in)
+	case CertAlgoRSAv01, CertAlgoDSAv01, CertAlgoECDSA256v01, CertAlgoECDSA384v01, CertAlgoECDSA521v01, CertAlgoED25519v01:
+		cert, err := parseCert(in, certToPrivAlgo(algo))
+		if err != nil {
+			return nil, nil, err
+		}
+		return cert, nil, nil
+	}
+	return nil, nil, fmt.Errorf("ssh: unknown key algorithm: %v", algo)
+}
+
+// parseAuthorizedKey parses a public key in OpenSSH authorized_keys format
+// (see sshd(8) manual page) once the options and key type fields have been
+// removed.
+func parseAuthorizedKey(in []byte) (out PublicKey, comment string, err error) {
+	in = bytes.TrimSpace(in)
+
+	i := bytes.IndexAny(in, " \t")
+	if i == -1 {
+		i = len(in)
+	}
+	base64Key := in[:i]
+
+	key := make([]byte, base64.StdEncoding.DecodedLen(len(base64Key)))
+	n, err := base64.StdEncoding.Decode(key, base64Key)
+	if err != nil {
+		return nil, "", err
+	}
+	key = key[:n]
+	out, err = ParsePublicKey(key)
+	if err != nil {
+		return nil, "", err
+	}
+	comment = string(bytes.TrimSpace(in[i:]))
+	return out, comment, nil
+}
+
+// ParseKnownHosts parses an entry in the format of the known_hosts file.
+//
+// The known_hosts format is documented in the sshd(8) manual page. This
+// function will parse a single entry from in. On successful return, marker
+// will contain the optional marker value (i.e. "cert-authority" or "revoked")
+// or else be empty, hosts will contain the hosts that this entry matches,
+// pubKey will contain the public key and comment will contain any trailing
+// comment at the end of the line. See the sshd(8) manual page for the various
+// forms that a host string can take.
+//
+// The unparsed remainder of the input will be returned in rest. This function
+// can be called repeatedly to parse multiple entries.
+//
+// If no entries were found in the input then err will be io.EOF. Otherwise a
+// non-nil err value indicates a parse error.
+func ParseKnownHosts(in []byte) (marker string, hosts []string, pubKey PublicKey, comment string, rest []byte, err error) {
+	for len(in) > 0 {
+		end := bytes.IndexByte(in, '\n')
+		if end != -1 {
+			rest = in[end+1:]
+			in = in[:end]
+		} else {
+			rest = nil
+		}
+
+		end = bytes.IndexByte(in, '\r')
+		if end != -1 {
+			in = in[:end]
+		}
+
+		in = bytes.TrimSpace(in)
+		if len(in) == 0 || in[0] == '#' {
+			in = rest
+			continue
+		}
+
+		i := bytes.IndexAny(in, " \t")
+		if i == -1 {
+			in = rest
+			continue
+		}
+
+		// Strip out the beginning of the known_host key.
+		// This is either an optional marker or a (set of) hostname(s).
+		keyFields := bytes.Fields(in)
+		if len(keyFields) < 3 || len(keyFields) > 5 {
+			return "", nil, nil, "", nil, errors.New("ssh: invalid entry in known_hosts data")
+		}
+
+		// keyFields[0] is either "@cert-authority", "@revoked" or a comma separated
+		// list of hosts
+		marker := ""
+		if keyFields[0][0] == '@' {
+			marker = string(keyFields[0][1:])
+			keyFields = keyFields[1:]
+		}
+
+		hosts := string(keyFields[0])
+		// keyFields[1] contains the key type (e.g. ssh-rsa).
+		// However, that information is duplicated inside the
+		// base64-encoded key and so is ignored here.
+
+		key := bytes.Join(keyFields[2:], []byte(" "))
+		if pubKey, comment, err = parseAuthorizedKey(key); err != nil {
+			return "", nil, nil, "", nil, err
+		}
+
+		return marker, strings.Split(hosts, ","), pubKey, comment, rest, nil
+	}
+
+	return "", nil, nil, "", nil, io.EOF
+}
+
+// ParseAuthorizedKeys parses a public key from an authorized_keys
+// file used in OpenSSH according to the sshd(8) manual page.
+func ParseAuthorizedKey(in []byte) (out PublicKey, comment string, options []string, rest []byte, err error) {
+	for len(in) > 0 {
+		end := bytes.IndexByte(in, '\n')
+		if end != -1 {
+			rest = in[end+1:]
+			in = in[:end]
+		} else {
+			rest = nil
+		}
+
+		end = bytes.IndexByte(in, '\r')
+		if end != -1 {
+			in = in[:end]
+		}
+
+		in = bytes.TrimSpace(in)
+		if len(in) == 0 || in[0] == '#' {
+			in = rest
+			continue
+		}
+
+		i := bytes.IndexAny(in, " \t")
+		if i == -1 {
+			in = rest
+			continue
+		}
+
+		if out, comment, err = parseAuthorizedKey(in[i:]); err == nil {
+			return out, comment, options, rest, nil
+		}
+
+		// No key type recognised. Maybe there's an options field at
+		// the beginning.
+		var b byte
+		inQuote := false
+		var candidateOptions []string
+		optionStart := 0
+		for i, b = range in {
+			isEnd := !inQuote && (b == ' ' || b == '\t')
+			if (b == ',' && !inQuote) || isEnd {
+				if i-optionStart > 0 {
+					candidateOptions = append(candidateOptions, string(in[optionStart:i]))
+				}
+				optionStart = i + 1
+			}
+			if isEnd {
+				break
+			}
+			if b == '"' && (i == 0 || (i > 0 && in[i-1] != '\\')) {
+				inQuote = !inQuote
+			}
+		}
+		for i < len(in) && (in[i] == ' ' || in[i] == '\t') {
+			i++
+		}
+		if i == len(in) {
+			// Invalid line: unmatched quote
+			in = rest
+			continue
+		}
+
+		in = in[i:]
+		i = bytes.IndexAny(in, " \t")
+		if i == -1 {
+			in = rest
+			continue
+		}
+
+		if out, comment, err = parseAuthorizedKey(in[i:]); err == nil {
+			options = candidateOptions
+			return out, comment, options, rest, nil
+		}
+
+		in = rest
+		continue
+	}
+
+	return nil, "", nil, nil, errors.New("ssh: no key found")
+}
+
+// ParsePublicKey parses an SSH public key formatted for use in
+// the SSH wire protocol according to RFC 4253, section 6.6.
+func ParsePublicKey(in []byte) (out PublicKey, err error) {
+	algo, in, ok := parseString(in)
+	if !ok {
+		return nil, errShortRead
+	}
+	var rest []byte
+	out, rest, err = parsePubKey(in, string(algo))
+	if len(rest) > 0 {
+		return nil, errors.New("ssh: trailing junk in public key")
+	}
+
+	return out, err
+}
+
+// MarshalAuthorizedKey serializes key for inclusion in an OpenSSH
+// authorized_keys file. The return value ends with newline.
+func MarshalAuthorizedKey(key PublicKey) []byte {
+	b := &bytes.Buffer{}
+	b.WriteString(key.Type())
+	b.WriteByte(' ')
+	e := base64.NewEncoder(base64.StdEncoding, b)
+	e.Write(key.Marshal())
+	e.Close()
+	b.WriteByte('\n')
+	return b.Bytes()
+}
+
+// PublicKey is an abstraction of different types of public keys.
+type PublicKey interface {
+	// Type returns the key's type, e.g. "ssh-rsa".
+	Type() string
+
+	// Marshal returns the serialized key data in SSH wire format,
+	// with the name prefix.
+	Marshal() []byte
+
+	// Verify that sig is a signature on the given data using this
+	// key. This function will hash the data appropriately first.
+	Verify(data []byte, sig *Signature) error
+}
+
+// CryptoPublicKey, if implemented by a PublicKey,
+// returns the underlying crypto.PublicKey form of the key.
+type CryptoPublicKey interface {
+	CryptoPublicKey() crypto.PublicKey
+}
+
+// A Signer can create signatures that verify against a public key.
+type Signer interface {
+	// PublicKey returns an associated PublicKey instance.
+	PublicKey() PublicKey
+
+	// Sign returns raw signature for the given data. This method
+	// will apply the hash specified for the keytype to the data.
+	Sign(rand io.Reader, data []byte) (*Signature, error)
+}
+
+type rsaPublicKey rsa.PublicKey
+
+func (r *rsaPublicKey) Type() string {
+	return "ssh-rsa"
+}
+
+// parseRSA parses an RSA key according to RFC 4253, section 6.6.
+func parseRSA(in []byte) (out PublicKey, rest []byte, err error) {
+	var w struct {
+		E    *big.Int
+		N    *big.Int
+		Rest []byte `ssh:"rest"`
+	}
+	if err := Unmarshal(in, &w); err != nil {
+		return nil, nil, err
+	}
+
+	if w.E.BitLen() > 24 {
+		return nil, nil, errors.New("ssh: exponent too large")
+	}
+	e := w.E.Int64()
+	if e < 3 || e&1 == 0 {
+		return nil, nil, errors.New("ssh: incorrect exponent")
+	}
+
+	var key rsa.PublicKey
+	key.E = int(e)
+	key.N = w.N
+	return (*rsaPublicKey)(&key), w.Rest, nil
+}
+
+func (r *rsaPublicKey) Marshal() []byte {
+	e := new(big.Int).SetInt64(int64(r.E))
+	// RSA publickey struct layout should match the struct used by
+	// parseRSACert in the x/crypto/ssh/agent package.
+	wirekey := struct {
+		Name string
+		E    *big.Int
+		N    *big.Int
+	}{
+		KeyAlgoRSA,
+		e,
+		r.N,
+	}
+	return Marshal(&wirekey)
+}
+
+func (r *rsaPublicKey) Verify(data []byte, sig *Signature) error {
+	if sig.Format != r.Type() {
+		return fmt.Errorf("ssh: signature type %s for key type %s", sig.Format, r.Type())
+	}
+	h := crypto.SHA1.New()
+	h.Write(data)
+	digest := h.Sum(nil)
+	return rsa.VerifyPKCS1v15((*rsa.PublicKey)(r), crypto.SHA1, digest, sig.Blob)
+}
+
+func (r *rsaPublicKey) CryptoPublicKey() crypto.PublicKey {
+	return (*rsa.PublicKey)(r)
+}
+
+type dsaPublicKey dsa.PublicKey
+
+func (r *dsaPublicKey) Type() string {
+	return "ssh-dss"
+}
+
+func checkDSAParams(param *dsa.Parameters) error {
+	// SSH specifies FIPS 186-2, which only provided a single size
+	// (1024 bits) DSA key. FIPS 186-3 allows for larger key
+	// sizes, which would confuse SSH.
+	if l := param.P.BitLen(); l != 1024 {
+		return fmt.Errorf("ssh: unsupported DSA key size %d", l)
+	}
+
+	return nil
+}
+
+// parseDSA parses an DSA key according to RFC 4253, section 6.6.
+func parseDSA(in []byte) (out PublicKey, rest []byte, err error) {
+	var w struct {
+		P, Q, G, Y *big.Int
+		Rest       []byte `ssh:"rest"`
+	}
+	if err := Unmarshal(in, &w); err != nil {
+		return nil, nil, err
+	}
+
+	param := dsa.Parameters{
+		P: w.P,
+		Q: w.Q,
+		G: w.G,
+	}
+	if err := checkDSAParams(&param); err != nil {
+		return nil, nil, err
+	}
+
+	key := &dsaPublicKey{
+		Parameters: param,
+		Y:          w.Y,
+	}
+	return key, w.Rest, nil
+}
+
+func (k *dsaPublicKey) Marshal() []byte {
+	// DSA publickey struct layout should match the struct used by
+	// parseDSACert in the x/crypto/ssh/agent package.
+	w := struct {
+		Name       string
+		P, Q, G, Y *big.Int
+	}{
+		k.Type(),
+		k.P,
+		k.Q,
+		k.G,
+		k.Y,
+	}
+
+	return Marshal(&w)
+}
+
+func (k *dsaPublicKey) Verify(data []byte, sig *Signature) error {
+	if sig.Format != k.Type() {
+		return fmt.Errorf("ssh: signature type %s for key type %s", sig.Format, k.Type())
+	}
+	h := crypto.SHA1.New()
+	h.Write(data)
+	digest := h.Sum(nil)
+
+	// Per RFC 4253, section 6.6,
+	// The value for 'dss_signature_blob' is encoded as a string containing
+	// r, followed by s (which are 160-bit integers, without lengths or
+	// padding, unsigned, and in network byte order).
+	// For DSS purposes, sig.Blob should be exactly 40 bytes in length.
+	if len(sig.Blob) != 40 {
+		return errors.New("ssh: DSA signature parse error")
+	}
+	r := new(big.Int).SetBytes(sig.Blob[:20])
+	s := new(big.Int).SetBytes(sig.Blob[20:])
+	if dsa.Verify((*dsa.PublicKey)(k), digest, r, s) {
+		return nil
+	}
+	return errors.New("ssh: signature did not verify")
+}
+
+func (k *dsaPublicKey) CryptoPublicKey() crypto.PublicKey {
+	return (*dsa.PublicKey)(k)
+}
+
+type dsaPrivateKey struct {
+	*dsa.PrivateKey
+}
+
+func (k *dsaPrivateKey) PublicKey() PublicKey {
+	return (*dsaPublicKey)(&k.PrivateKey.PublicKey)
+}
+
+func (k *dsaPrivateKey) Sign(rand io.Reader, data []byte) (*Signature, error) {
+	h := crypto.SHA1.New()
+	h.Write(data)
+	digest := h.Sum(nil)
+	r, s, err := dsa.Sign(rand, k.PrivateKey, digest)
+	if err != nil {
+		return nil, err
+	}
+
+	sig := make([]byte, 40)
+	rb := r.Bytes()
+	sb := s.Bytes()
+
+	copy(sig[20-len(rb):20], rb)
+	copy(sig[40-len(sb):], sb)
+
+	return &Signature{
+		Format: k.PublicKey().Type(),
+		Blob:   sig,
+	}, nil
+}
+
+type ecdsaPublicKey ecdsa.PublicKey
+
+func (key *ecdsaPublicKey) Type() string {
+	return "ecdsa-sha2-" + key.nistID()
+}
+
+func (key *ecdsaPublicKey) nistID() string {
+	switch key.Params().BitSize {
+	case 256:
+		return "nistp256"
+	case 384:
+		return "nistp384"
+	case 521:
+		return "nistp521"
+	}
+	panic("ssh: unsupported ecdsa key size")
+}
+
+type ed25519PublicKey ed25519.PublicKey
+
+func (key ed25519PublicKey) Type() string {
+	return KeyAlgoED25519
+}
+
+func parseED25519(in []byte) (out PublicKey, rest []byte, err error) {
+	var w struct {
+		KeyBytes []byte
+		Rest     []byte `ssh:"rest"`
+	}
+
+	if err := Unmarshal(in, &w); err != nil {
+		return nil, nil, err
+	}
+
+	key := ed25519.PublicKey(w.KeyBytes)
+
+	return (ed25519PublicKey)(key), w.Rest, nil
+}
+
+func (key ed25519PublicKey) Marshal() []byte {
+	w := struct {
+		Name     string
+		KeyBytes []byte
+	}{
+		KeyAlgoED25519,
+		[]byte(key),
+	}
+	return Marshal(&w)
+}
+
+func (key ed25519PublicKey) Verify(b []byte, sig *Signature) error {
+	if sig.Format != key.Type() {
+		return fmt.Errorf("ssh: signature type %s for key type %s", sig.Format, key.Type())
+	}
+
+	edKey := (ed25519.PublicKey)(key)
+	if ok := ed25519.Verify(edKey, b, sig.Blob); !ok {
+		return errors.New("ssh: signature did not verify")
+	}
+
+	return nil
+}
+
+func (k ed25519PublicKey) CryptoPublicKey() crypto.PublicKey {
+	return ed25519.PublicKey(k)
+}
+
+func supportedEllipticCurve(curve elliptic.Curve) bool {
+	return curve == elliptic.P256() || curve == elliptic.P384() || curve == elliptic.P521()
+}
+
+// ecHash returns the hash to match the given elliptic curve, see RFC
+// 5656, section 6.2.1
+func ecHash(curve elliptic.Curve) crypto.Hash {
+	bitSize := curve.Params().BitSize
+	switch {
+	case bitSize <= 256:
+		return crypto.SHA256
+	case bitSize <= 384:
+		return crypto.SHA384
+	}
+	return crypto.SHA512
+}
+
+// parseECDSA parses an ECDSA key according to RFC 5656, section 3.1.
+func parseECDSA(in []byte) (out PublicKey, rest []byte, err error) {
+	var w struct {
+		Curve    string
+		KeyBytes []byte
+		Rest     []byte `ssh:"rest"`
+	}
+
+	if err := Unmarshal(in, &w); err != nil {
+		return nil, nil, err
+	}
+
+	key := new(ecdsa.PublicKey)
+
+	switch w.Curve {
+	case "nistp256":
+		key.Curve = elliptic.P256()
+	case "nistp384":
+		key.Curve = elliptic.P384()
+	case "nistp521":
+		key.Curve = elliptic.P521()
+	default:
+		return nil, nil, errors.New("ssh: unsupported curve")
+	}
+
+	key.X, key.Y = elliptic.Unmarshal(key.Curve, w.KeyBytes)
+	if key.X == nil || key.Y == nil {
+		return nil, nil, errors.New("ssh: invalid curve point")
+	}
+	return (*ecdsaPublicKey)(key), w.Rest, nil
+}
+
+func (key *ecdsaPublicKey) Marshal() []byte {
+	// See RFC 5656, section 3.1.
+	keyBytes := elliptic.Marshal(key.Curve, key.X, key.Y)
+	// ECDSA publickey struct layout should match the struct used by
+	// parseECDSACert in the x/crypto/ssh/agent package.
+	w := struct {
+		Name string
+		ID   string
+		Key  []byte
+	}{
+		key.Type(),
+		key.nistID(),
+		keyBytes,
+	}
+
+	return Marshal(&w)
+}
+
+func (key *ecdsaPublicKey) Verify(data []byte, sig *Signature) error {
+	if sig.Format != key.Type() {
+		return fmt.Errorf("ssh: signature type %s for key type %s", sig.Format, key.Type())
+	}
+
+	h := ecHash(key.Curve).New()
+	h.Write(data)
+	digest := h.Sum(nil)
+
+	// Per RFC 5656, section 3.1.2,
+	// The ecdsa_signature_blob value has the following specific encoding:
+	//    mpint    r
+	//    mpint    s
+	var ecSig struct {
+		R *big.Int
+		S *big.Int
+	}
+
+	if err := Unmarshal(sig.Blob, &ecSig); err != nil {
+		return err
+	}
+
+	if ecdsa.Verify((*ecdsa.PublicKey)(key), digest, ecSig.R, ecSig.S) {
+		return nil
+	}
+	return errors.New("ssh: signature did not verify")
+}
+
+func (k *ecdsaPublicKey) CryptoPublicKey() crypto.PublicKey {
+	return (*ecdsa.PublicKey)(k)
+}
+
+// NewSignerFromKey takes an *rsa.PrivateKey, *dsa.PrivateKey,
+// *ecdsa.PrivateKey or any other crypto.Signer and returns a
+// corresponding Signer instance. ECDSA keys must use P-256, P-384 or
+// P-521. DSA keys must use parameter size L1024N160.
+func NewSignerFromKey(key interface{}) (Signer, error) {
+	switch key := key.(type) {
+	case crypto.Signer:
+		return NewSignerFromSigner(key)
+	case *dsa.PrivateKey:
+		return newDSAPrivateKey(key)
+	default:
+		return nil, fmt.Errorf("ssh: unsupported key type %T", key)
+	}
+}
+
+func newDSAPrivateKey(key *dsa.PrivateKey) (Signer, error) {
+	if err := checkDSAParams(&key.PublicKey.Parameters); err != nil {
+		return nil, err
+	}
+
+	return &dsaPrivateKey{key}, nil
+}
+
+type wrappedSigner struct {
+	signer crypto.Signer
+	pubKey PublicKey
+}
+
+// NewSignerFromSigner takes any crypto.Signer implementation and
+// returns a corresponding Signer interface. This can be used, for
+// example, with keys kept in hardware modules.
+func NewSignerFromSigner(signer crypto.Signer) (Signer, error) {
+	pubKey, err := NewPublicKey(signer.Public())
+	if err != nil {
+		return nil, err
+	}
+
+	return &wrappedSigner{signer, pubKey}, nil
+}
+
+func (s *wrappedSigner) PublicKey() PublicKey {
+	return s.pubKey
+}
+
+func (s *wrappedSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {
+	var hashFunc crypto.Hash
+
+	switch key := s.pubKey.(type) {
+	case *rsaPublicKey, *dsaPublicKey:
+		hashFunc = crypto.SHA1
+	case *ecdsaPublicKey:
+		hashFunc = ecHash(key.Curve)
+	case ed25519PublicKey:
+	default:
+		return nil, fmt.Errorf("ssh: unsupported key type %T", key)
+	}
+
+	var digest []byte
+	if hashFunc != 0 {
+		h := hashFunc.New()
+		h.Write(data)
+		digest = h.Sum(nil)
+	} else {
+		digest = data
+	}
+
+	signature, err := s.signer.Sign(rand, digest, hashFunc)
+	if err != nil {
+		return nil, err
+	}
+
+	// crypto.Signer.Sign is expected to return an ASN.1-encoded signature
+	// for ECDSA and DSA, but that's not the encoding expected by SSH, so
+	// re-encode.
+	switch s.pubKey.(type) {
+	case *ecdsaPublicKey, *dsaPublicKey:
+		type asn1Signature struct {
+			R, S *big.Int
+		}
+		asn1Sig := new(asn1Signature)
+		_, err := asn1.Unmarshal(signature, asn1Sig)
+		if err != nil {
+			return nil, err
+		}
+
+		switch s.pubKey.(type) {
+		case *ecdsaPublicKey:
+			signature = Marshal(asn1Sig)
+
+		case *dsaPublicKey:
+			signature = make([]byte, 40)
+			r := asn1Sig.R.Bytes()
+			s := asn1Sig.S.Bytes()
+			copy(signature[20-len(r):20], r)
+			copy(signature[40-len(s):40], s)
+		}
+	}
+
+	return &Signature{
+		Format: s.pubKey.Type(),
+		Blob:   signature,
+	}, nil
+}
+
+// NewPublicKey takes an *rsa.PublicKey, *dsa.PublicKey, *ecdsa.PublicKey,
+// or ed25519.PublicKey returns a corresponding PublicKey instance.
+// ECDSA keys must use P-256, P-384 or P-521.
+func NewPublicKey(key interface{}) (PublicKey, error) {
+	switch key := key.(type) {
+	case *rsa.PublicKey:
+		return (*rsaPublicKey)(key), nil
+	case *ecdsa.PublicKey:
+		if !supportedEllipticCurve(key.Curve) {
+			return nil, errors.New("ssh: only P-256, P-384 and P-521 EC keys are supported.")
+		}
+		return (*ecdsaPublicKey)(key), nil
+	case *dsa.PublicKey:
+		return (*dsaPublicKey)(key), nil
+	case ed25519.PublicKey:
+		return (ed25519PublicKey)(key), nil
+	default:
+		return nil, fmt.Errorf("ssh: unsupported key type %T", key)
+	}
+}
+
+// ParsePrivateKey returns a Signer from a PEM encoded private key. It supports
+// the same keys as ParseRawPrivateKey.
+func ParsePrivateKey(pemBytes []byte) (Signer, error) {
+	key, err := ParseRawPrivateKey(pemBytes)
+	if err != nil {
+		return nil, err
+	}
+
+	return NewSignerFromKey(key)
+}
+
+// ParsePrivateKeyWithPassphrase returns a Signer from a PEM encoded private
+// key and passphrase. It supports the same keys as
+// ParseRawPrivateKeyWithPassphrase.
+func ParsePrivateKeyWithPassphrase(pemBytes, passPhrase []byte) (Signer, error) {
+	key, err := ParseRawPrivateKeyWithPassphrase(pemBytes, passPhrase)
+	if err != nil {
+		return nil, err
+	}
+
+	return NewSignerFromKey(key)
+}
+
+// encryptedBlock tells whether a private key is
+// encrypted by examining its Proc-Type header
+// for a mention of ENCRYPTED
+// according to RFC 1421 Section 4.6.1.1.
+func encryptedBlock(block *pem.Block) bool {
+	return strings.Contains(block.Headers["Proc-Type"], "ENCRYPTED")
+}
+
+// ParseRawPrivateKey returns a private key from a PEM encoded private key. It
+// supports RSA (PKCS#1), DSA (OpenSSL), and ECDSA private keys.
+func ParseRawPrivateKey(pemBytes []byte) (interface{}, error) {
+	block, _ := pem.Decode(pemBytes)
+	if block == nil {
+		return nil, errors.New("ssh: no key found")
+	}
+
+	if encryptedBlock(block) {
+		return nil, errors.New("ssh: cannot decode encrypted private keys")
+	}
+
+	switch block.Type {
+	case "RSA PRIVATE KEY":
+		return x509.ParsePKCS1PrivateKey(block.Bytes)
+	case "EC PRIVATE KEY":
+		return x509.ParseECPrivateKey(block.Bytes)
+	case "DSA PRIVATE KEY":
+		return ParseDSAPrivateKey(block.Bytes)
+	case "OPENSSH PRIVATE KEY":
+		return parseOpenSSHPrivateKey(block.Bytes)
+	default:
+		return nil, fmt.Errorf("ssh: unsupported key type %q", block.Type)
+	}
+}
+
+// ParseRawPrivateKeyWithPassphrase returns a private key decrypted with
+// passphrase from a PEM encoded private key. If wrong passphrase, return
+// x509.IncorrectPasswordError.
+func ParseRawPrivateKeyWithPassphrase(pemBytes, passPhrase []byte) (interface{}, error) {
+	block, _ := pem.Decode(pemBytes)
+	if block == nil {
+		return nil, errors.New("ssh: no key found")
+	}
+	buf := block.Bytes
+
+	if encryptedBlock(block) {
+		if x509.IsEncryptedPEMBlock(block) {
+			var err error
+			buf, err = x509.DecryptPEMBlock(block, passPhrase)
+			if err != nil {
+				if err == x509.IncorrectPasswordError {
+					return nil, err
+				}
+				return nil, fmt.Errorf("ssh: cannot decode encrypted private keys: %v", err)
+			}
+		}
+	}
+
+	switch block.Type {
+	case "RSA PRIVATE KEY":
+		return x509.ParsePKCS1PrivateKey(buf)
+	case "EC PRIVATE KEY":
+		return x509.ParseECPrivateKey(buf)
+	case "DSA PRIVATE KEY":
+		return ParseDSAPrivateKey(buf)
+	case "OPENSSH PRIVATE KEY":
+		return parseOpenSSHPrivateKey(buf)
+	default:
+		return nil, fmt.Errorf("ssh: unsupported key type %q", block.Type)
+	}
+}
+
+// ParseDSAPrivateKey returns a DSA private key from its ASN.1 DER encoding, as
+// specified by the OpenSSL DSA man page.
+func ParseDSAPrivateKey(der []byte) (*dsa.PrivateKey, error) {
+	var k struct {
+		Version int
+		P       *big.Int
+		Q       *big.Int
+		G       *big.Int
+		Pub     *big.Int
+		Priv    *big.Int
+	}
+	rest, err := asn1.Unmarshal(der, &k)
+	if err != nil {
+		return nil, errors.New("ssh: failed to parse DSA key: " + err.Error())
+	}
+	if len(rest) > 0 {
+		return nil, errors.New("ssh: garbage after DSA key")
+	}
+
+	return &dsa.PrivateKey{
+		PublicKey: dsa.PublicKey{
+			Parameters: dsa.Parameters{
+				P: k.P,
+				Q: k.Q,
+				G: k.G,
+			},
+			Y: k.Pub,
+		},
+		X: k.Priv,
+	}, nil
+}
+
+// Implemented based on the documentation at
+// https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.key
+func parseOpenSSHPrivateKey(key []byte) (crypto.PrivateKey, error) {
+	magic := append([]byte("openssh-key-v1"), 0)
+	if !bytes.Equal(magic, key[0:len(magic)]) {
+		return nil, errors.New("ssh: invalid openssh private key format")
+	}
+	remaining := key[len(magic):]
+
+	var w struct {
+		CipherName   string
+		KdfName      string
+		KdfOpts      string
+		NumKeys      uint32
+		PubKey       []byte
+		PrivKeyBlock []byte
+	}
+
+	if err := Unmarshal(remaining, &w); err != nil {
+		return nil, err
+	}
+
+	if w.KdfName != "none" || w.CipherName != "none" {
+		return nil, errors.New("ssh: cannot decode encrypted private keys")
+	}
+
+	pk1 := struct {
+		Check1  uint32
+		Check2  uint32
+		Keytype string
+		Rest    []byte `ssh:"rest"`
+	}{}
+
+	if err := Unmarshal(w.PrivKeyBlock, &pk1); err != nil {
+		return nil, err
+	}
+
+	if pk1.Check1 != pk1.Check2 {
+		return nil, errors.New("ssh: checkint mismatch")
+	}
+
+	// we only handle ed25519 and rsa keys currently
+	switch pk1.Keytype {
+	case KeyAlgoRSA:
+		// https://github.com/openssh/openssh-portable/blob/master/sshkey.c#L2760-L2773
+		key := struct {
+			N       *big.Int
+			E       *big.Int
+			D       *big.Int
+			Iqmp    *big.Int
+			P       *big.Int
+			Q       *big.Int
+			Comment string
+			Pad     []byte `ssh:"rest"`
+		}{}
+
+		if err := Unmarshal(pk1.Rest, &key); err != nil {
+			return nil, err
+		}
+
+		for i, b := range key.Pad {
+			if int(b) != i+1 {
+				return nil, errors.New("ssh: padding not as expected")
+			}
+		}
+
+		pk := &rsa.PrivateKey{
+			PublicKey: rsa.PublicKey{
+				N: key.N,
+				E: int(key.E.Int64()),
+			},
+			D:      key.D,
+			Primes: []*big.Int{key.P, key.Q},
+		}
+
+		if err := pk.Validate(); err != nil {
+			return nil, err
+		}
+
+		pk.Precompute()
+
+		return pk, nil
+	case KeyAlgoED25519:
+		key := struct {
+			Pub     []byte
+			Priv    []byte
+			Comment string
+			Pad     []byte `ssh:"rest"`
+		}{}
+
+		if err := Unmarshal(pk1.Rest, &key); err != nil {
+			return nil, err
+		}
+
+		if len(key.Priv) != ed25519.PrivateKeySize {
+			return nil, errors.New("ssh: private key unexpected length")
+		}
+
+		for i, b := range key.Pad {
+			if int(b) != i+1 {
+				return nil, errors.New("ssh: padding not as expected")
+			}
+		}
+
+		pk := ed25519.PrivateKey(make([]byte, ed25519.PrivateKeySize))
+		copy(pk, key.Priv)
+		return &pk, nil
+	default:
+		return nil, errors.New("ssh: unhandled key type")
+	}
+}
+
+// FingerprintLegacyMD5 returns the user presentation of the key's
+// fingerprint as described by RFC 4716 section 4.
+func FingerprintLegacyMD5(pubKey PublicKey) string {
+	md5sum := md5.Sum(pubKey.Marshal())
+	hexarray := make([]string, len(md5sum))
+	for i, c := range md5sum {
+		hexarray[i] = hex.EncodeToString([]byte{c})
+	}
+	return strings.Join(hexarray, ":")
+}
+
+// FingerprintSHA256 returns the user presentation of the key's
+// fingerprint as unpadded base64 encoded sha256 hash.
+// This format was introduced from OpenSSH 6.8.
+// https://www.openssh.com/txt/release-6.8
+// https://tools.ietf.org/html/rfc4648#section-3.2 (unpadded base64 encoding)
+func FingerprintSHA256(pubKey PublicKey) string {
+	sha256sum := sha256.Sum256(pubKey.Marshal())
+	hash := base64.RawStdEncoding.EncodeToString(sha256sum[:])
+	return "SHA256:" + hash
+}
diff --git a/vendor/golang.org/x/crypto/ssh/mac.go b/vendor/golang.org/x/crypto/ssh/mac.go
new file mode 100644
index 0000000..c07a062
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/mac.go
@@ -0,0 +1,61 @@
+// Copyright 2012 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+// Message authentication support
+
+import (
+	"crypto/hmac"
+	"crypto/sha1"
+	"crypto/sha256"
+	"hash"
+)
+
+type macMode struct {
+	keySize int
+	etm     bool
+	new     func(key []byte) hash.Hash
+}
+
+// truncatingMAC wraps around a hash.Hash and truncates the output digest to
+// a given size.
+type truncatingMAC struct {
+	length int
+	hmac   hash.Hash
+}
+
+func (t truncatingMAC) Write(data []byte) (int, error) {
+	return t.hmac.Write(data)
+}
+
+func (t truncatingMAC) Sum(in []byte) []byte {
+	out := t.hmac.Sum(in)
+	return out[:len(in)+t.length]
+}
+
+func (t truncatingMAC) Reset() {
+	t.hmac.Reset()
+}
+
+func (t truncatingMAC) Size() int {
+	return t.length
+}
+
+func (t truncatingMAC) BlockSize() int { return t.hmac.BlockSize() }
+
+var macModes = map[string]*macMode{
+	"hmac-sha2-256-etm@openssh.com": {32, true, func(key []byte) hash.Hash {
+		return hmac.New(sha256.New, key)
+	}},
+	"hmac-sha2-256": {32, false, func(key []byte) hash.Hash {
+		return hmac.New(sha256.New, key)
+	}},
+	"hmac-sha1": {20, false, func(key []byte) hash.Hash {
+		return hmac.New(sha1.New, key)
+	}},
+	"hmac-sha1-96": {20, false, func(key []byte) hash.Hash {
+		return truncatingMAC{12, hmac.New(sha1.New, key)}
+	}},
+}
diff --git a/vendor/golang.org/x/crypto/ssh/messages.go b/vendor/golang.org/x/crypto/ssh/messages.go
new file mode 100644
index 0000000..e6ecd3a
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/messages.go
@@ -0,0 +1,758 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"bytes"
+	"encoding/binary"
+	"errors"
+	"fmt"
+	"io"
+	"math/big"
+	"reflect"
+	"strconv"
+	"strings"
+)
+
+// These are SSH message type numbers. They are scattered around several
+// documents but many were taken from [SSH-PARAMETERS].
+const (
+	msgIgnore        = 2
+	msgUnimplemented = 3
+	msgDebug         = 4
+	msgNewKeys       = 21
+
+	// Standard authentication messages
+	msgUserAuthSuccess = 52
+	msgUserAuthBanner  = 53
+)
+
+// SSH messages:
+//
+// These structures mirror the wire format of the corresponding SSH messages.
+// They are marshaled using reflection with the marshal and unmarshal functions
+// in this file. The only wrinkle is that a final member of type []byte with a
+// ssh tag of "rest" receives the remainder of a packet when unmarshaling.
+
+// See RFC 4253, section 11.1.
+const msgDisconnect = 1
+
+// disconnectMsg is the message that signals a disconnect. It is also
+// the error type returned from mux.Wait()
+type disconnectMsg struct {
+	Reason   uint32 `sshtype:"1"`
+	Message  string
+	Language string
+}
+
+func (d *disconnectMsg) Error() string {
+	return fmt.Sprintf("ssh: disconnect, reason %d: %s", d.Reason, d.Message)
+}
+
+// See RFC 4253, section 7.1.
+const msgKexInit = 20
+
+type kexInitMsg struct {
+	Cookie                  [16]byte `sshtype:"20"`
+	KexAlgos                []string
+	ServerHostKeyAlgos      []string
+	CiphersClientServer     []string
+	CiphersServerClient     []string
+	MACsClientServer        []string
+	MACsServerClient        []string
+	CompressionClientServer []string
+	CompressionServerClient []string
+	LanguagesClientServer   []string
+	LanguagesServerClient   []string
+	FirstKexFollows         bool
+	Reserved                uint32
+}
+
+// See RFC 4253, section 8.
+
+// Diffie-Helman
+const msgKexDHInit = 30
+
+type kexDHInitMsg struct {
+	X *big.Int `sshtype:"30"`
+}
+
+const msgKexECDHInit = 30
+
+type kexECDHInitMsg struct {
+	ClientPubKey []byte `sshtype:"30"`
+}
+
+const msgKexECDHReply = 31
+
+type kexECDHReplyMsg struct {
+	HostKey         []byte `sshtype:"31"`
+	EphemeralPubKey []byte
+	Signature       []byte
+}
+
+const msgKexDHReply = 31
+
+type kexDHReplyMsg struct {
+	HostKey   []byte `sshtype:"31"`
+	Y         *big.Int
+	Signature []byte
+}
+
+// See RFC 4253, section 10.
+const msgServiceRequest = 5
+
+type serviceRequestMsg struct {
+	Service string `sshtype:"5"`
+}
+
+// See RFC 4253, section 10.
+const msgServiceAccept = 6
+
+type serviceAcceptMsg struct {
+	Service string `sshtype:"6"`
+}
+
+// See RFC 4252, section 5.
+const msgUserAuthRequest = 50
+
+type userAuthRequestMsg struct {
+	User    string `sshtype:"50"`
+	Service string
+	Method  string
+	Payload []byte `ssh:"rest"`
+}
+
+// Used for debug printouts of packets.
+type userAuthSuccessMsg struct {
+}
+
+// See RFC 4252, section 5.1
+const msgUserAuthFailure = 51
+
+type userAuthFailureMsg struct {
+	Methods        []string `sshtype:"51"`
+	PartialSuccess bool
+}
+
+// See RFC 4256, section 3.2
+const msgUserAuthInfoRequest = 60
+const msgUserAuthInfoResponse = 61
+
+type userAuthInfoRequestMsg struct {
+	User               string `sshtype:"60"`
+	Instruction        string
+	DeprecatedLanguage string
+	NumPrompts         uint32
+	Prompts            []byte `ssh:"rest"`
+}
+
+// See RFC 4254, section 5.1.
+const msgChannelOpen = 90
+
+type channelOpenMsg struct {
+	ChanType         string `sshtype:"90"`
+	PeersId          uint32
+	PeersWindow      uint32
+	MaxPacketSize    uint32
+	TypeSpecificData []byte `ssh:"rest"`
+}
+
+const msgChannelExtendedData = 95
+const msgChannelData = 94
+
+// Used for debug print outs of packets.
+type channelDataMsg struct {
+	PeersId uint32 `sshtype:"94"`
+	Length  uint32
+	Rest    []byte `ssh:"rest"`
+}
+
+// See RFC 4254, section 5.1.
+const msgChannelOpenConfirm = 91
+
+type channelOpenConfirmMsg struct {
+	PeersId          uint32 `sshtype:"91"`
+	MyId             uint32
+	MyWindow         uint32
+	MaxPacketSize    uint32
+	TypeSpecificData []byte `ssh:"rest"`
+}
+
+// See RFC 4254, section 5.1.
+const msgChannelOpenFailure = 92
+
+type channelOpenFailureMsg struct {
+	PeersId  uint32 `sshtype:"92"`
+	Reason   RejectionReason
+	Message  string
+	Language string
+}
+
+const msgChannelRequest = 98
+
+type channelRequestMsg struct {
+	PeersId             uint32 `sshtype:"98"`
+	Request             string
+	WantReply           bool
+	RequestSpecificData []byte `ssh:"rest"`
+}
+
+// See RFC 4254, section 5.4.
+const msgChannelSuccess = 99
+
+type channelRequestSuccessMsg struct {
+	PeersId uint32 `sshtype:"99"`
+}
+
+// See RFC 4254, section 5.4.
+const msgChannelFailure = 100
+
+type channelRequestFailureMsg struct {
+	PeersId uint32 `sshtype:"100"`
+}
+
+// See RFC 4254, section 5.3
+const msgChannelClose = 97
+
+type channelCloseMsg struct {
+	PeersId uint32 `sshtype:"97"`
+}
+
+// See RFC 4254, section 5.3
+const msgChannelEOF = 96
+
+type channelEOFMsg struct {
+	PeersId uint32 `sshtype:"96"`
+}
+
+// See RFC 4254, section 4
+const msgGlobalRequest = 80
+
+type globalRequestMsg struct {
+	Type      string `sshtype:"80"`
+	WantReply bool
+	Data      []byte `ssh:"rest"`
+}
+
+// See RFC 4254, section 4
+const msgRequestSuccess = 81
+
+type globalRequestSuccessMsg struct {
+	Data []byte `ssh:"rest" sshtype:"81"`
+}
+
+// See RFC 4254, section 4
+const msgRequestFailure = 82
+
+type globalRequestFailureMsg struct {
+	Data []byte `ssh:"rest" sshtype:"82"`
+}
+
+// See RFC 4254, section 5.2
+const msgChannelWindowAdjust = 93
+
+type windowAdjustMsg struct {
+	PeersId         uint32 `sshtype:"93"`
+	AdditionalBytes uint32
+}
+
+// See RFC 4252, section 7
+const msgUserAuthPubKeyOk = 60
+
+type userAuthPubKeyOkMsg struct {
+	Algo   string `sshtype:"60"`
+	PubKey []byte
+}
+
+// typeTags returns the possible type bytes for the given reflect.Type, which
+// should be a struct. The possible values are separated by a '|' character.
+func typeTags(structType reflect.Type) (tags []byte) {
+	tagStr := structType.Field(0).Tag.Get("sshtype")
+
+	for _, tag := range strings.Split(tagStr, "|") {
+		i, err := strconv.Atoi(tag)
+		if err == nil {
+			tags = append(tags, byte(i))
+		}
+	}
+
+	return tags
+}
+
+func fieldError(t reflect.Type, field int, problem string) error {
+	if problem != "" {
+		problem = ": " + problem
+	}
+	return fmt.Errorf("ssh: unmarshal error for field %s of type %s%s", t.Field(field).Name, t.Name(), problem)
+}
+
+var errShortRead = errors.New("ssh: short read")
+
+// Unmarshal parses data in SSH wire format into a structure. The out
+// argument should be a pointer to struct. If the first member of the
+// struct has the "sshtype" tag set to a '|'-separated set of numbers
+// in decimal, the packet must start with one of those numbers. In
+// case of error, Unmarshal returns a ParseError or
+// UnexpectedMessageError.
+func Unmarshal(data []byte, out interface{}) error {
+	v := reflect.ValueOf(out).Elem()
+	structType := v.Type()
+	expectedTypes := typeTags(structType)
+
+	var expectedType byte
+	if len(expectedTypes) > 0 {
+		expectedType = expectedTypes[0]
+	}
+
+	if len(data) == 0 {
+		return parseError(expectedType)
+	}
+
+	if len(expectedTypes) > 0 {
+		goodType := false
+		for _, e := range expectedTypes {
+			if e > 0 && data[0] == e {
+				goodType = true
+				break
+			}
+		}
+		if !goodType {
+			return fmt.Errorf("ssh: unexpected message type %d (expected one of %v)", data[0], expectedTypes)
+		}
+		data = data[1:]
+	}
+
+	var ok bool
+	for i := 0; i < v.NumField(); i++ {
+		field := v.Field(i)
+		t := field.Type()
+		switch t.Kind() {
+		case reflect.Bool:
+			if len(data) < 1 {
+				return errShortRead
+			}
+			field.SetBool(data[0] != 0)
+			data = data[1:]
+		case reflect.Array:
+			if t.Elem().Kind() != reflect.Uint8 {
+				return fieldError(structType, i, "array of unsupported type")
+			}
+			if len(data) < t.Len() {
+				return errShortRead
+			}
+			for j, n := 0, t.Len(); j < n; j++ {
+				field.Index(j).Set(reflect.ValueOf(data[j]))
+			}
+			data = data[t.Len():]
+		case reflect.Uint64:
+			var u64 uint64
+			if u64, data, ok = parseUint64(data); !ok {
+				return errShortRead
+			}
+			field.SetUint(u64)
+		case reflect.Uint32:
+			var u32 uint32
+			if u32, data, ok = parseUint32(data); !ok {
+				return errShortRead
+			}
+			field.SetUint(uint64(u32))
+		case reflect.Uint8:
+			if len(data) < 1 {
+				return errShortRead
+			}
+			field.SetUint(uint64(data[0]))
+			data = data[1:]
+		case reflect.String:
+			var s []byte
+			if s, data, ok = parseString(data); !ok {
+				return fieldError(structType, i, "")
+			}
+			field.SetString(string(s))
+		case reflect.Slice:
+			switch t.Elem().Kind() {
+			case reflect.Uint8:
+				if structType.Field(i).Tag.Get("ssh") == "rest" {
+					field.Set(reflect.ValueOf(data))
+					data = nil
+				} else {
+					var s []byte
+					if s, data, ok = parseString(data); !ok {
+						return errShortRead
+					}
+					field.Set(reflect.ValueOf(s))
+				}
+			case reflect.String:
+				var nl []string
+				if nl, data, ok = parseNameList(data); !ok {
+					return errShortRead
+				}
+				field.Set(reflect.ValueOf(nl))
+			default:
+				return fieldError(structType, i, "slice of unsupported type")
+			}
+		case reflect.Ptr:
+			if t == bigIntType {
+				var n *big.Int
+				if n, data, ok = parseInt(data); !ok {
+					return errShortRead
+				}
+				field.Set(reflect.ValueOf(n))
+			} else {
+				return fieldError(structType, i, "pointer to unsupported type")
+			}
+		default:
+			return fieldError(structType, i, fmt.Sprintf("unsupported type: %v", t))
+		}
+	}
+
+	if len(data) != 0 {
+		return parseError(expectedType)
+	}
+
+	return nil
+}
+
+// Marshal serializes the message in msg to SSH wire format.  The msg
+// argument should be a struct or pointer to struct. If the first
+// member has the "sshtype" tag set to a number in decimal, that
+// number is prepended to the result. If the last of member has the
+// "ssh" tag set to "rest", its contents are appended to the output.
+func Marshal(msg interface{}) []byte {
+	out := make([]byte, 0, 64)
+	return marshalStruct(out, msg)
+}
+
+func marshalStruct(out []byte, msg interface{}) []byte {
+	v := reflect.Indirect(reflect.ValueOf(msg))
+	msgTypes := typeTags(v.Type())
+	if len(msgTypes) > 0 {
+		out = append(out, msgTypes[0])
+	}
+
+	for i, n := 0, v.NumField(); i < n; i++ {
+		field := v.Field(i)
+		switch t := field.Type(); t.Kind() {
+		case reflect.Bool:
+			var v uint8
+			if field.Bool() {
+				v = 1
+			}
+			out = append(out, v)
+		case reflect.Array:
+			if t.Elem().Kind() != reflect.Uint8 {
+				panic(fmt.Sprintf("array of non-uint8 in field %d: %T", i, field.Interface()))
+			}
+			for j, l := 0, t.Len(); j < l; j++ {
+				out = append(out, uint8(field.Index(j).Uint()))
+			}
+		case reflect.Uint32:
+			out = appendU32(out, uint32(field.Uint()))
+		case reflect.Uint64:
+			out = appendU64(out, uint64(field.Uint()))
+		case reflect.Uint8:
+			out = append(out, uint8(field.Uint()))
+		case reflect.String:
+			s := field.String()
+			out = appendInt(out, len(s))
+			out = append(out, s...)
+		case reflect.Slice:
+			switch t.Elem().Kind() {
+			case reflect.Uint8:
+				if v.Type().Field(i).Tag.Get("ssh") != "rest" {
+					out = appendInt(out, field.Len())
+				}
+				out = append(out, field.Bytes()...)
+			case reflect.String:
+				offset := len(out)
+				out = appendU32(out, 0)
+				if n := field.Len(); n > 0 {
+					for j := 0; j < n; j++ {
+						f := field.Index(j)
+						if j != 0 {
+							out = append(out, ',')
+						}
+						out = append(out, f.String()...)
+					}
+					// overwrite length value
+					binary.BigEndian.PutUint32(out[offset:], uint32(len(out)-offset-4))
+				}
+			default:
+				panic(fmt.Sprintf("slice of unknown type in field %d: %T", i, field.Interface()))
+			}
+		case reflect.Ptr:
+			if t == bigIntType {
+				var n *big.Int
+				nValue := reflect.ValueOf(&n)
+				nValue.Elem().Set(field)
+				needed := intLength(n)
+				oldLength := len(out)
+
+				if cap(out)-len(out) < needed {
+					newOut := make([]byte, len(out), 2*(len(out)+needed))
+					copy(newOut, out)
+					out = newOut
+				}
+				out = out[:oldLength+needed]
+				marshalInt(out[oldLength:], n)
+			} else {
+				panic(fmt.Sprintf("pointer to unknown type in field %d: %T", i, field.Interface()))
+			}
+		}
+	}
+
+	return out
+}
+
+var bigOne = big.NewInt(1)
+
+func parseString(in []byte) (out, rest []byte, ok bool) {
+	if len(in) < 4 {
+		return
+	}
+	length := binary.BigEndian.Uint32(in)
+	in = in[4:]
+	if uint32(len(in)) < length {
+		return
+	}
+	out = in[:length]
+	rest = in[length:]
+	ok = true
+	return
+}
+
+var (
+	comma         = []byte{','}
+	emptyNameList = []string{}
+)
+
+func parseNameList(in []byte) (out []string, rest []byte, ok bool) {
+	contents, rest, ok := parseString(in)
+	if !ok {
+		return
+	}
+	if len(contents) == 0 {
+		out = emptyNameList
+		return
+	}
+	parts := bytes.Split(contents, comma)
+	out = make([]string, len(parts))
+	for i, part := range parts {
+		out[i] = string(part)
+	}
+	return
+}
+
+func parseInt(in []byte) (out *big.Int, rest []byte, ok bool) {
+	contents, rest, ok := parseString(in)
+	if !ok {
+		return
+	}
+	out = new(big.Int)
+
+	if len(contents) > 0 && contents[0]&0x80 == 0x80 {
+		// This is a negative number
+		notBytes := make([]byte, len(contents))
+		for i := range notBytes {
+			notBytes[i] = ^contents[i]
+		}
+		out.SetBytes(notBytes)
+		out.Add(out, bigOne)
+		out.Neg(out)
+	} else {
+		// Positive number
+		out.SetBytes(contents)
+	}
+	ok = true
+	return
+}
+
+func parseUint32(in []byte) (uint32, []byte, bool) {
+	if len(in) < 4 {
+		return 0, nil, false
+	}
+	return binary.BigEndian.Uint32(in), in[4:], true
+}
+
+func parseUint64(in []byte) (uint64, []byte, bool) {
+	if len(in) < 8 {
+		return 0, nil, false
+	}
+	return binary.BigEndian.Uint64(in), in[8:], true
+}
+
+func intLength(n *big.Int) int {
+	length := 4 /* length bytes */
+	if n.Sign() < 0 {
+		nMinus1 := new(big.Int).Neg(n)
+		nMinus1.Sub(nMinus1, bigOne)
+		bitLen := nMinus1.BitLen()
+		if bitLen%8 == 0 {
+			// The number will need 0xff padding
+			length++
+		}
+		length += (bitLen + 7) / 8
+	} else if n.Sign() == 0 {
+		// A zero is the zero length string
+	} else {
+		bitLen := n.BitLen()
+		if bitLen%8 == 0 {
+			// The number will need 0x00 padding
+			length++
+		}
+		length += (bitLen + 7) / 8
+	}
+
+	return length
+}
+
+func marshalUint32(to []byte, n uint32) []byte {
+	binary.BigEndian.PutUint32(to, n)
+	return to[4:]
+}
+
+func marshalUint64(to []byte, n uint64) []byte {
+	binary.BigEndian.PutUint64(to, n)
+	return to[8:]
+}
+
+func marshalInt(to []byte, n *big.Int) []byte {
+	lengthBytes := to
+	to = to[4:]
+	length := 0
+
+	if n.Sign() < 0 {
+		// A negative number has to be converted to two's-complement
+		// form. So we'll subtract 1 and invert. If the
+		// most-significant-bit isn't set then we'll need to pad the
+		// beginning with 0xff in order to keep the number negative.
+		nMinus1 := new(big.Int).Neg(n)
+		nMinus1.Sub(nMinus1, bigOne)
+		bytes := nMinus1.Bytes()
+		for i := range bytes {
+			bytes[i] ^= 0xff
+		}
+		if len(bytes) == 0 || bytes[0]&0x80 == 0 {
+			to[0] = 0xff
+			to = to[1:]
+			length++
+		}
+		nBytes := copy(to, bytes)
+		to = to[nBytes:]
+		length += nBytes
+	} else if n.Sign() == 0 {
+		// A zero is the zero length string
+	} else {
+		bytes := n.Bytes()
+		if len(bytes) > 0 && bytes[0]&0x80 != 0 {
+			// We'll have to pad this with a 0x00 in order to
+			// stop it looking like a negative number.
+			to[0] = 0
+			to = to[1:]
+			length++
+		}
+		nBytes := copy(to, bytes)
+		to = to[nBytes:]
+		length += nBytes
+	}
+
+	lengthBytes[0] = byte(length >> 24)
+	lengthBytes[1] = byte(length >> 16)
+	lengthBytes[2] = byte(length >> 8)
+	lengthBytes[3] = byte(length)
+	return to
+}
+
+func writeInt(w io.Writer, n *big.Int) {
+	length := intLength(n)
+	buf := make([]byte, length)
+	marshalInt(buf, n)
+	w.Write(buf)
+}
+
+func writeString(w io.Writer, s []byte) {
+	var lengthBytes [4]byte
+	lengthBytes[0] = byte(len(s) >> 24)
+	lengthBytes[1] = byte(len(s) >> 16)
+	lengthBytes[2] = byte(len(s) >> 8)
+	lengthBytes[3] = byte(len(s))
+	w.Write(lengthBytes[:])
+	w.Write(s)
+}
+
+func stringLength(n int) int {
+	return 4 + n
+}
+
+func marshalString(to []byte, s []byte) []byte {
+	to[0] = byte(len(s) >> 24)
+	to[1] = byte(len(s) >> 16)
+	to[2] = byte(len(s) >> 8)
+	to[3] = byte(len(s))
+	to = to[4:]
+	copy(to, s)
+	return to[len(s):]
+}
+
+var bigIntType = reflect.TypeOf((*big.Int)(nil))
+
+// Decode a packet into its corresponding message.
+func decode(packet []byte) (interface{}, error) {
+	var msg interface{}
+	switch packet[0] {
+	case msgDisconnect:
+		msg = new(disconnectMsg)
+	case msgServiceRequest:
+		msg = new(serviceRequestMsg)
+	case msgServiceAccept:
+		msg = new(serviceAcceptMsg)
+	case msgKexInit:
+		msg = new(kexInitMsg)
+	case msgKexDHInit:
+		msg = new(kexDHInitMsg)
+	case msgKexDHReply:
+		msg = new(kexDHReplyMsg)
+	case msgUserAuthRequest:
+		msg = new(userAuthRequestMsg)
+	case msgUserAuthSuccess:
+		return new(userAuthSuccessMsg), nil
+	case msgUserAuthFailure:
+		msg = new(userAuthFailureMsg)
+	case msgUserAuthPubKeyOk:
+		msg = new(userAuthPubKeyOkMsg)
+	case msgGlobalRequest:
+		msg = new(globalRequestMsg)
+	case msgRequestSuccess:
+		msg = new(globalRequestSuccessMsg)
+	case msgRequestFailure:
+		msg = new(globalRequestFailureMsg)
+	case msgChannelOpen:
+		msg = new(channelOpenMsg)
+	case msgChannelData:
+		msg = new(channelDataMsg)
+	case msgChannelOpenConfirm:
+		msg = new(channelOpenConfirmMsg)
+	case msgChannelOpenFailure:
+		msg = new(channelOpenFailureMsg)
+	case msgChannelWindowAdjust:
+		msg = new(windowAdjustMsg)
+	case msgChannelEOF:
+		msg = new(channelEOFMsg)
+	case msgChannelClose:
+		msg = new(channelCloseMsg)
+	case msgChannelRequest:
+		msg = new(channelRequestMsg)
+	case msgChannelSuccess:
+		msg = new(channelRequestSuccessMsg)
+	case msgChannelFailure:
+		msg = new(channelRequestFailureMsg)
+	default:
+		return nil, unexpectedMessageError(0, packet[0])
+	}
+	if err := Unmarshal(packet, msg); err != nil {
+		return nil, err
+	}
+	return msg, nil
+}
diff --git a/vendor/golang.org/x/crypto/ssh/mux.go b/vendor/golang.org/x/crypto/ssh/mux.go
new file mode 100644
index 0000000..27a527c
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/mux.go
@@ -0,0 +1,330 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"encoding/binary"
+	"fmt"
+	"io"
+	"log"
+	"sync"
+	"sync/atomic"
+)
+
+// debugMux, if set, causes messages in the connection protocol to be
+// logged.
+const debugMux = false
+
+// chanList is a thread safe channel list.
+type chanList struct {
+	// protects concurrent access to chans
+	sync.Mutex
+
+	// chans are indexed by the local id of the channel, which the
+	// other side should send in the PeersId field.
+	chans []*channel
+
+	// This is a debugging aid: it offsets all IDs by this
+	// amount. This helps distinguish otherwise identical
+	// server/client muxes
+	offset uint32
+}
+
+// Assigns a channel ID to the given channel.
+func (c *chanList) add(ch *channel) uint32 {
+	c.Lock()
+	defer c.Unlock()
+	for i := range c.chans {
+		if c.chans[i] == nil {
+			c.chans[i] = ch
+			return uint32(i) + c.offset
+		}
+	}
+	c.chans = append(c.chans, ch)
+	return uint32(len(c.chans)-1) + c.offset
+}
+
+// getChan returns the channel for the given ID.
+func (c *chanList) getChan(id uint32) *channel {
+	id -= c.offset
+
+	c.Lock()
+	defer c.Unlock()
+	if id < uint32(len(c.chans)) {
+		return c.chans[id]
+	}
+	return nil
+}
+
+func (c *chanList) remove(id uint32) {
+	id -= c.offset
+	c.Lock()
+	if id < uint32(len(c.chans)) {
+		c.chans[id] = nil
+	}
+	c.Unlock()
+}
+
+// dropAll forgets all channels it knows, returning them in a slice.
+func (c *chanList) dropAll() []*channel {
+	c.Lock()
+	defer c.Unlock()
+	var r []*channel
+
+	for _, ch := range c.chans {
+		if ch == nil {
+			continue
+		}
+		r = append(r, ch)
+	}
+	c.chans = nil
+	return r
+}
+
+// mux represents the state for the SSH connection protocol, which
+// multiplexes many channels onto a single packet transport.
+type mux struct {
+	conn     packetConn
+	chanList chanList
+
+	incomingChannels chan NewChannel
+
+	globalSentMu     sync.Mutex
+	globalResponses  chan interface{}
+	incomingRequests chan *Request
+
+	errCond *sync.Cond
+	err     error
+}
+
+// When debugging, each new chanList instantiation has a different
+// offset.
+var globalOff uint32
+
+func (m *mux) Wait() error {
+	m.errCond.L.Lock()
+	defer m.errCond.L.Unlock()
+	for m.err == nil {
+		m.errCond.Wait()
+	}
+	return m.err
+}
+
+// newMux returns a mux that runs over the given connection.
+func newMux(p packetConn) *mux {
+	m := &mux{
+		conn:             p,
+		incomingChannels: make(chan NewChannel, chanSize),
+		globalResponses:  make(chan interface{}, 1),
+		incomingRequests: make(chan *Request, chanSize),
+		errCond:          newCond(),
+	}
+	if debugMux {
+		m.chanList.offset = atomic.AddUint32(&globalOff, 1)
+	}
+
+	go m.loop()
+	return m
+}
+
+func (m *mux) sendMessage(msg interface{}) error {
+	p := Marshal(msg)
+	if debugMux {
+		log.Printf("send global(%d): %#v", m.chanList.offset, msg)
+	}
+	return m.conn.writePacket(p)
+}
+
+func (m *mux) SendRequest(name string, wantReply bool, payload []byte) (bool, []byte, error) {
+	if wantReply {
+		m.globalSentMu.Lock()
+		defer m.globalSentMu.Unlock()
+	}
+
+	if err := m.sendMessage(globalRequestMsg{
+		Type:      name,
+		WantReply: wantReply,
+		Data:      payload,
+	}); err != nil {
+		return false, nil, err
+	}
+
+	if !wantReply {
+		return false, nil, nil
+	}
+
+	msg, ok := <-m.globalResponses
+	if !ok {
+		return false, nil, io.EOF
+	}
+	switch msg := msg.(type) {
+	case *globalRequestFailureMsg:
+		return false, msg.Data, nil
+	case *globalRequestSuccessMsg:
+		return true, msg.Data, nil
+	default:
+		return false, nil, fmt.Errorf("ssh: unexpected response to request: %#v", msg)
+	}
+}
+
+// ackRequest must be called after processing a global request that
+// has WantReply set.
+func (m *mux) ackRequest(ok bool, data []byte) error {
+	if ok {
+		return m.sendMessage(globalRequestSuccessMsg{Data: data})
+	}
+	return m.sendMessage(globalRequestFailureMsg{Data: data})
+}
+
+func (m *mux) Close() error {
+	return m.conn.Close()
+}
+
+// loop runs the connection machine. It will process packets until an
+// error is encountered. To synchronize on loop exit, use mux.Wait.
+func (m *mux) loop() {
+	var err error
+	for err == nil {
+		err = m.onePacket()
+	}
+
+	for _, ch := range m.chanList.dropAll() {
+		ch.close()
+	}
+
+	close(m.incomingChannels)
+	close(m.incomingRequests)
+	close(m.globalResponses)
+
+	m.conn.Close()
+
+	m.errCond.L.Lock()
+	m.err = err
+	m.errCond.Broadcast()
+	m.errCond.L.Unlock()
+
+	if debugMux {
+		log.Println("loop exit", err)
+	}
+}
+
+// onePacket reads and processes one packet.
+func (m *mux) onePacket() error {
+	packet, err := m.conn.readPacket()
+	if err != nil {
+		return err
+	}
+
+	if debugMux {
+		if packet[0] == msgChannelData || packet[0] == msgChannelExtendedData {
+			log.Printf("decoding(%d): data packet - %d bytes", m.chanList.offset, len(packet))
+		} else {
+			p, _ := decode(packet)
+			log.Printf("decoding(%d): %d %#v - %d bytes", m.chanList.offset, packet[0], p, len(packet))
+		}
+	}
+
+	switch packet[0] {
+	case msgChannelOpen:
+		return m.handleChannelOpen(packet)
+	case msgGlobalRequest, msgRequestSuccess, msgRequestFailure:
+		return m.handleGlobalPacket(packet)
+	}
+
+	// assume a channel packet.
+	if len(packet) < 5 {
+		return parseError(packet[0])
+	}
+	id := binary.BigEndian.Uint32(packet[1:])
+	ch := m.chanList.getChan(id)
+	if ch == nil {
+		return fmt.Errorf("ssh: invalid channel %d", id)
+	}
+
+	return ch.handlePacket(packet)
+}
+
+func (m *mux) handleGlobalPacket(packet []byte) error {
+	msg, err := decode(packet)
+	if err != nil {
+		return err
+	}
+
+	switch msg := msg.(type) {
+	case *globalRequestMsg:
+		m.incomingRequests <- &Request{
+			Type:      msg.Type,
+			WantReply: msg.WantReply,
+			Payload:   msg.Data,
+			mux:       m,
+		}
+	case *globalRequestSuccessMsg, *globalRequestFailureMsg:
+		m.globalResponses <- msg
+	default:
+		panic(fmt.Sprintf("not a global message %#v", msg))
+	}
+
+	return nil
+}
+
+// handleChannelOpen schedules a channel to be Accept()ed.
+func (m *mux) handleChannelOpen(packet []byte) error {
+	var msg channelOpenMsg
+	if err := Unmarshal(packet, &msg); err != nil {
+		return err
+	}
+
+	if msg.MaxPacketSize < minPacketLength || msg.MaxPacketSize > 1<<31 {
+		failMsg := channelOpenFailureMsg{
+			PeersId:  msg.PeersId,
+			Reason:   ConnectionFailed,
+			Message:  "invalid request",
+			Language: "en_US.UTF-8",
+		}
+		return m.sendMessage(failMsg)
+	}
+
+	c := m.newChannel(msg.ChanType, channelInbound, msg.TypeSpecificData)
+	c.remoteId = msg.PeersId
+	c.maxRemotePayload = msg.MaxPacketSize
+	c.remoteWin.add(msg.PeersWindow)
+	m.incomingChannels <- c
+	return nil
+}
+
+func (m *mux) OpenChannel(chanType string, extra []byte) (Channel, <-chan *Request, error) {
+	ch, err := m.openChannel(chanType, extra)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	return ch, ch.incomingRequests, nil
+}
+
+func (m *mux) openChannel(chanType string, extra []byte) (*channel, error) {
+	ch := m.newChannel(chanType, channelOutbound, extra)
+
+	ch.maxIncomingPayload = channelMaxPacket
+
+	open := channelOpenMsg{
+		ChanType:         chanType,
+		PeersWindow:      ch.myWindow,
+		MaxPacketSize:    ch.maxIncomingPayload,
+		TypeSpecificData: extra,
+		PeersId:          ch.localId,
+	}
+	if err := m.sendMessage(open); err != nil {
+		return nil, err
+	}
+
+	switch msg := (<-ch.msg).(type) {
+	case *channelOpenConfirmMsg:
+		return ch, nil
+	case *channelOpenFailureMsg:
+		return nil, &OpenChannelError{msg.Reason, msg.Message}
+	default:
+		return nil, fmt.Errorf("ssh: unexpected packet in response to channel open: %T", msg)
+	}
+}
diff --git a/vendor/golang.org/x/crypto/ssh/server.go b/vendor/golang.org/x/crypto/ssh/server.go
new file mode 100644
index 0000000..8a78b7c
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/server.go
@@ -0,0 +1,563 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"bytes"
+	"errors"
+	"fmt"
+	"io"
+	"net"
+	"strings"
+)
+
+// The Permissions type holds fine-grained permissions that are
+// specific to a user or a specific authentication method for a user.
+// The Permissions value for a successful authentication attempt is
+// available in ServerConn, so it can be used to pass information from
+// the user-authentication phase to the application layer.
+type Permissions struct {
+	// CriticalOptions indicate restrictions to the default
+	// permissions, and are typically used in conjunction with
+	// user certificates. The standard for SSH certificates
+	// defines "force-command" (only allow the given command to
+	// execute) and "source-address" (only allow connections from
+	// the given address). The SSH package currently only enforces
+	// the "source-address" critical option. It is up to server
+	// implementations to enforce other critical options, such as
+	// "force-command", by checking them after the SSH handshake
+	// is successful. In general, SSH servers should reject
+	// connections that specify critical options that are unknown
+	// or not supported.
+	CriticalOptions map[string]string
+
+	// Extensions are extra functionality that the server may
+	// offer on authenticated connections. Lack of support for an
+	// extension does not preclude authenticating a user. Common
+	// extensions are "permit-agent-forwarding",
+	// "permit-X11-forwarding". The Go SSH library currently does
+	// not act on any extension, and it is up to server
+	// implementations to honor them. Extensions can be used to
+	// pass data from the authentication callbacks to the server
+	// application layer.
+	Extensions map[string]string
+}
+
+// ServerConfig holds server specific configuration data.
+type ServerConfig struct {
+	// Config contains configuration shared between client and server.
+	Config
+
+	hostKeys []Signer
+
+	// NoClientAuth is true if clients are allowed to connect without
+	// authenticating.
+	NoClientAuth bool
+
+	// MaxAuthTries specifies the maximum number of authentication attempts
+	// permitted per connection. If set to a negative number, the number of
+	// attempts are unlimited. If set to zero, the number of attempts are limited
+	// to 6.
+	MaxAuthTries int
+
+	// PasswordCallback, if non-nil, is called when a user
+	// attempts to authenticate using a password.
+	PasswordCallback func(conn ConnMetadata, password []byte) (*Permissions, error)
+
+	// PublicKeyCallback, if non-nil, is called when a client
+	// offers a public key for authentication. It must return a nil error
+	// if the given public key can be used to authenticate the
+	// given user. For example, see CertChecker.Authenticate. A
+	// call to this function does not guarantee that the key
+	// offered is in fact used to authenticate. To record any data
+	// depending on the public key, store it inside a
+	// Permissions.Extensions entry.
+	PublicKeyCallback func(conn ConnMetadata, key PublicKey) (*Permissions, error)
+
+	// KeyboardInteractiveCallback, if non-nil, is called when
+	// keyboard-interactive authentication is selected (RFC
+	// 4256). The client object's Challenge function should be
+	// used to query the user. The callback may offer multiple
+	// Challenge rounds. To avoid information leaks, the client
+	// should be presented a challenge even if the user is
+	// unknown.
+	KeyboardInteractiveCallback func(conn ConnMetadata, client KeyboardInteractiveChallenge) (*Permissions, error)
+
+	// AuthLogCallback, if non-nil, is called to log all authentication
+	// attempts.
+	AuthLogCallback func(conn ConnMetadata, method string, err error)
+
+	// ServerVersion is the version identification string to announce in
+	// the public handshake.
+	// If empty, a reasonable default is used.
+	// Note that RFC 4253 section 4.2 requires that this string start with
+	// "SSH-2.0-".
+	ServerVersion string
+}
+
+// AddHostKey adds a private key as a host key. If an existing host
+// key exists with the same algorithm, it is overwritten. Each server
+// config must have at least one host key.
+func (s *ServerConfig) AddHostKey(key Signer) {
+	for i, k := range s.hostKeys {
+		if k.PublicKey().Type() == key.PublicKey().Type() {
+			s.hostKeys[i] = key
+			return
+		}
+	}
+
+	s.hostKeys = append(s.hostKeys, key)
+}
+
+// cachedPubKey contains the results of querying whether a public key is
+// acceptable for a user.
+type cachedPubKey struct {
+	user       string
+	pubKeyData []byte
+	result     error
+	perms      *Permissions
+}
+
+const maxCachedPubKeys = 16
+
+// pubKeyCache caches tests for public keys.  Since SSH clients
+// will query whether a public key is acceptable before attempting to
+// authenticate with it, we end up with duplicate queries for public
+// key validity.  The cache only applies to a single ServerConn.
+type pubKeyCache struct {
+	keys []cachedPubKey
+}
+
+// get returns the result for a given user/algo/key tuple.
+func (c *pubKeyCache) get(user string, pubKeyData []byte) (cachedPubKey, bool) {
+	for _, k := range c.keys {
+		if k.user == user && bytes.Equal(k.pubKeyData, pubKeyData) {
+			return k, true
+		}
+	}
+	return cachedPubKey{}, false
+}
+
+// add adds the given tuple to the cache.
+func (c *pubKeyCache) add(candidate cachedPubKey) {
+	if len(c.keys) < maxCachedPubKeys {
+		c.keys = append(c.keys, candidate)
+	}
+}
+
+// ServerConn is an authenticated SSH connection, as seen from the
+// server
+type ServerConn struct {
+	Conn
+
+	// If the succeeding authentication callback returned a
+	// non-nil Permissions pointer, it is stored here.
+	Permissions *Permissions
+}
+
+// NewServerConn starts a new SSH server with c as the underlying
+// transport.  It starts with a handshake and, if the handshake is
+// unsuccessful, it closes the connection and returns an error.  The
+// Request and NewChannel channels must be serviced, or the connection
+// will hang.
+func NewServerConn(c net.Conn, config *ServerConfig) (*ServerConn, <-chan NewChannel, <-chan *Request, error) {
+	fullConf := *config
+	fullConf.SetDefaults()
+	if fullConf.MaxAuthTries == 0 {
+		fullConf.MaxAuthTries = 6
+	}
+
+	s := &connection{
+		sshConn: sshConn{conn: c},
+	}
+	perms, err := s.serverHandshake(&fullConf)
+	if err != nil {
+		c.Close()
+		return nil, nil, nil, err
+	}
+	return &ServerConn{s, perms}, s.mux.incomingChannels, s.mux.incomingRequests, nil
+}
+
+// signAndMarshal signs the data with the appropriate algorithm,
+// and serializes the result in SSH wire format.
+func signAndMarshal(k Signer, rand io.Reader, data []byte) ([]byte, error) {
+	sig, err := k.Sign(rand, data)
+	if err != nil {
+		return nil, err
+	}
+
+	return Marshal(sig), nil
+}
+
+// handshake performs key exchange and user authentication.
+func (s *connection) serverHandshake(config *ServerConfig) (*Permissions, error) {
+	if len(config.hostKeys) == 0 {
+		return nil, errors.New("ssh: server has no host keys")
+	}
+
+	if !config.NoClientAuth && config.PasswordCallback == nil && config.PublicKeyCallback == nil && config.KeyboardInteractiveCallback == nil {
+		return nil, errors.New("ssh: no authentication methods configured but NoClientAuth is also false")
+	}
+
+	if config.ServerVersion != "" {
+		s.serverVersion = []byte(config.ServerVersion)
+	} else {
+		s.serverVersion = []byte(packageVersion)
+	}
+	var err error
+	s.clientVersion, err = exchangeVersions(s.sshConn.conn, s.serverVersion)
+	if err != nil {
+		return nil, err
+	}
+
+	tr := newTransport(s.sshConn.conn, config.Rand, false /* not client */)
+	s.transport = newServerTransport(tr, s.clientVersion, s.serverVersion, config)
+
+	if err := s.transport.waitSession(); err != nil {
+		return nil, err
+	}
+
+	// We just did the key change, so the session ID is established.
+	s.sessionID = s.transport.getSessionID()
+
+	var packet []byte
+	if packet, err = s.transport.readPacket(); err != nil {
+		return nil, err
+	}
+
+	var serviceRequest serviceRequestMsg
+	if err = Unmarshal(packet, &serviceRequest); err != nil {
+		return nil, err
+	}
+	if serviceRequest.Service != serviceUserAuth {
+		return nil, errors.New("ssh: requested service '" + serviceRequest.Service + "' before authenticating")
+	}
+	serviceAccept := serviceAcceptMsg{
+		Service: serviceUserAuth,
+	}
+	if err := s.transport.writePacket(Marshal(&serviceAccept)); err != nil {
+		return nil, err
+	}
+
+	perms, err := s.serverAuthenticate(config)
+	if err != nil {
+		return nil, err
+	}
+	s.mux = newMux(s.transport)
+	return perms, err
+}
+
+func isAcceptableAlgo(algo string) bool {
+	switch algo {
+	case KeyAlgoRSA, KeyAlgoDSA, KeyAlgoECDSA256, KeyAlgoECDSA384, KeyAlgoECDSA521, KeyAlgoED25519,
+		CertAlgoRSAv01, CertAlgoDSAv01, CertAlgoECDSA256v01, CertAlgoECDSA384v01, CertAlgoECDSA521v01:
+		return true
+	}
+	return false
+}
+
+func checkSourceAddress(addr net.Addr, sourceAddrs string) error {
+	if addr == nil {
+		return errors.New("ssh: no address known for client, but source-address match required")
+	}
+
+	tcpAddr, ok := addr.(*net.TCPAddr)
+	if !ok {
+		return fmt.Errorf("ssh: remote address %v is not an TCP address when checking source-address match", addr)
+	}
+
+	for _, sourceAddr := range strings.Split(sourceAddrs, ",") {
+		if allowedIP := net.ParseIP(sourceAddr); allowedIP != nil {
+			if allowedIP.Equal(tcpAddr.IP) {
+				return nil
+			}
+		} else {
+			_, ipNet, err := net.ParseCIDR(sourceAddr)
+			if err != nil {
+				return fmt.Errorf("ssh: error parsing source-address restriction %q: %v", sourceAddr, err)
+			}
+
+			if ipNet.Contains(tcpAddr.IP) {
+				return nil
+			}
+		}
+	}
+
+	return fmt.Errorf("ssh: remote address %v is not allowed because of source-address restriction", addr)
+}
+
+// ServerAuthError implements the error interface. It appends any authentication
+// errors that may occur, and is returned if all of the authentication methods
+// provided by the user failed to authenticate.
+type ServerAuthError struct {
+	// Errors contains authentication errors returned by the authentication
+	// callback methods.
+	Errors []error
+}
+
+func (l ServerAuthError) Error() string {
+	var errs []string
+	for _, err := range l.Errors {
+		errs = append(errs, err.Error())
+	}
+	return "[" + strings.Join(errs, ", ") + "]"
+}
+
+func (s *connection) serverAuthenticate(config *ServerConfig) (*Permissions, error) {
+	sessionID := s.transport.getSessionID()
+	var cache pubKeyCache
+	var perms *Permissions
+
+	authFailures := 0
+	var authErrs []error
+
+userAuthLoop:
+	for {
+		if authFailures >= config.MaxAuthTries && config.MaxAuthTries > 0 {
+			discMsg := &disconnectMsg{
+				Reason:  2,
+				Message: "too many authentication failures",
+			}
+
+			if err := s.transport.writePacket(Marshal(discMsg)); err != nil {
+				return nil, err
+			}
+
+			return nil, discMsg
+		}
+
+		var userAuthReq userAuthRequestMsg
+		if packet, err := s.transport.readPacket(); err != nil {
+			if err == io.EOF {
+				return nil, &ServerAuthError{Errors: authErrs}
+			}
+			return nil, err
+		} else if err = Unmarshal(packet, &userAuthReq); err != nil {
+			return nil, err
+		}
+
+		if userAuthReq.Service != serviceSSH {
+			return nil, errors.New("ssh: client attempted to negotiate for unknown service: " + userAuthReq.Service)
+		}
+
+		s.user = userAuthReq.User
+		perms = nil
+		authErr := errors.New("no auth passed yet")
+
+		switch userAuthReq.Method {
+		case "none":
+			if config.NoClientAuth {
+				authErr = nil
+			}
+
+			// allow initial attempt of 'none' without penalty
+			if authFailures == 0 {
+				authFailures--
+			}
+		case "password":
+			if config.PasswordCallback == nil {
+				authErr = errors.New("ssh: password auth not configured")
+				break
+			}
+			payload := userAuthReq.Payload
+			if len(payload) < 1 || payload[0] != 0 {
+				return nil, parseError(msgUserAuthRequest)
+			}
+			payload = payload[1:]
+			password, payload, ok := parseString(payload)
+			if !ok || len(payload) > 0 {
+				return nil, parseError(msgUserAuthRequest)
+			}
+
+			perms, authErr = config.PasswordCallback(s, password)
+		case "keyboard-interactive":
+			if config.KeyboardInteractiveCallback == nil {
+				authErr = errors.New("ssh: keyboard-interactive auth not configubred")
+				break
+			}
+
+			prompter := &sshClientKeyboardInteractive{s}
+			perms, authErr = config.KeyboardInteractiveCallback(s, prompter.Challenge)
+		case "publickey":
+			if config.PublicKeyCallback == nil {
+				authErr = errors.New("ssh: publickey auth not configured")
+				break
+			}
+			payload := userAuthReq.Payload
+			if len(payload) < 1 {
+				return nil, parseError(msgUserAuthRequest)
+			}
+			isQuery := payload[0] == 0
+			payload = payload[1:]
+			algoBytes, payload, ok := parseString(payload)
+			if !ok {
+				return nil, parseError(msgUserAuthRequest)
+			}
+			algo := string(algoBytes)
+			if !isAcceptableAlgo(algo) {
+				authErr = fmt.Errorf("ssh: algorithm %q not accepted", algo)
+				break
+			}
+
+			pubKeyData, payload, ok := parseString(payload)
+			if !ok {
+				return nil, parseError(msgUserAuthRequest)
+			}
+
+			pubKey, err := ParsePublicKey(pubKeyData)
+			if err != nil {
+				return nil, err
+			}
+
+			candidate, ok := cache.get(s.user, pubKeyData)
+			if !ok {
+				candidate.user = s.user
+				candidate.pubKeyData = pubKeyData
+				candidate.perms, candidate.result = config.PublicKeyCallback(s, pubKey)
+				if candidate.result == nil && candidate.perms != nil && candidate.perms.CriticalOptions != nil && candidate.perms.CriticalOptions[sourceAddressCriticalOption] != "" {
+					candidate.result = checkSourceAddress(
+						s.RemoteAddr(),
+						candidate.perms.CriticalOptions[sourceAddressCriticalOption])
+				}
+				cache.add(candidate)
+			}
+
+			if isQuery {
+				// The client can query if the given public key
+				// would be okay.
+
+				if len(payload) > 0 {
+					return nil, parseError(msgUserAuthRequest)
+				}
+
+				if candidate.result == nil {
+					okMsg := userAuthPubKeyOkMsg{
+						Algo:   algo,
+						PubKey: pubKeyData,
+					}
+					if err = s.transport.writePacket(Marshal(&okMsg)); err != nil {
+						return nil, err
+					}
+					continue userAuthLoop
+				}
+				authErr = candidate.result
+			} else {
+				sig, payload, ok := parseSignature(payload)
+				if !ok || len(payload) > 0 {
+					return nil, parseError(msgUserAuthRequest)
+				}
+				// Ensure the public key algo and signature algo
+				// are supported.  Compare the private key
+				// algorithm name that corresponds to algo with
+				// sig.Format.  This is usually the same, but
+				// for certs, the names differ.
+				if !isAcceptableAlgo(sig.Format) {
+					break
+				}
+				signedData := buildDataSignedForAuth(sessionID, userAuthReq, algoBytes, pubKeyData)
+
+				if err := pubKey.Verify(signedData, sig); err != nil {
+					return nil, err
+				}
+
+				authErr = candidate.result
+				perms = candidate.perms
+			}
+		default:
+			authErr = fmt.Errorf("ssh: unknown method %q", userAuthReq.Method)
+		}
+
+		authErrs = append(authErrs, authErr)
+
+		if config.AuthLogCallback != nil {
+			config.AuthLogCallback(s, userAuthReq.Method, authErr)
+		}
+
+		if authErr == nil {
+			break userAuthLoop
+		}
+
+		authFailures++
+
+		var failureMsg userAuthFailureMsg
+		if config.PasswordCallback != nil {
+			failureMsg.Methods = append(failureMsg.Methods, "password")
+		}
+		if config.PublicKeyCallback != nil {
+			failureMsg.Methods = append(failureMsg.Methods, "publickey")
+		}
+		if config.KeyboardInteractiveCallback != nil {
+			failureMsg.Methods = append(failureMsg.Methods, "keyboard-interactive")
+		}
+
+		if len(failureMsg.Methods) == 0 {
+			return nil, errors.New("ssh: no authentication methods configured but NoClientAuth is also false")
+		}
+
+		if err := s.transport.writePacket(Marshal(&failureMsg)); err != nil {
+			return nil, err
+		}
+	}
+
+	if err := s.transport.writePacket([]byte{msgUserAuthSuccess}); err != nil {
+		return nil, err
+	}
+	return perms, nil
+}
+
+// sshClientKeyboardInteractive implements a ClientKeyboardInteractive by
+// asking the client on the other side of a ServerConn.
+type sshClientKeyboardInteractive struct {
+	*connection
+}
+
+func (c *sshClientKeyboardInteractive) Challenge(user, instruction string, questions []string, echos []bool) (answers []string, err error) {
+	if len(questions) != len(echos) {
+		return nil, errors.New("ssh: echos and questions must have equal length")
+	}
+
+	var prompts []byte
+	for i := range questions {
+		prompts = appendString(prompts, questions[i])
+		prompts = appendBool(prompts, echos[i])
+	}
+
+	if err := c.transport.writePacket(Marshal(&userAuthInfoRequestMsg{
+		Instruction: instruction,
+		NumPrompts:  uint32(len(questions)),
+		Prompts:     prompts,
+	})); err != nil {
+		return nil, err
+	}
+
+	packet, err := c.transport.readPacket()
+	if err != nil {
+		return nil, err
+	}
+	if packet[0] != msgUserAuthInfoResponse {
+		return nil, unexpectedMessageError(msgUserAuthInfoResponse, packet[0])
+	}
+	packet = packet[1:]
+
+	n, packet, ok := parseUint32(packet)
+	if !ok || int(n) != len(questions) {
+		return nil, parseError(msgUserAuthInfoResponse)
+	}
+
+	for i := uint32(0); i < n; i++ {
+		ans, rest, ok := parseString(packet)
+		if !ok {
+			return nil, parseError(msgUserAuthInfoResponse)
+		}
+
+		answers = append(answers, string(ans))
+		packet = rest
+	}
+	if len(packet) != 0 {
+		return nil, errors.New("ssh: junk at end of message")
+	}
+
+	return answers, nil
+}
diff --git a/vendor/golang.org/x/crypto/ssh/session.go b/vendor/golang.org/x/crypto/ssh/session.go
new file mode 100644
index 0000000..cc06e03
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/session.go
@@ -0,0 +1,647 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+// Session implements an interactive session described in
+// "RFC 4254, section 6".
+
+import (
+	"bytes"
+	"encoding/binary"
+	"errors"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"sync"
+)
+
+type Signal string
+
+// POSIX signals as listed in RFC 4254 Section 6.10.
+const (
+	SIGABRT Signal = "ABRT"
+	SIGALRM Signal = "ALRM"
+	SIGFPE  Signal = "FPE"
+	SIGHUP  Signal = "HUP"
+	SIGILL  Signal = "ILL"
+	SIGINT  Signal = "INT"
+	SIGKILL Signal = "KILL"
+	SIGPIPE Signal = "PIPE"
+	SIGQUIT Signal = "QUIT"
+	SIGSEGV Signal = "SEGV"
+	SIGTERM Signal = "TERM"
+	SIGUSR1 Signal = "USR1"
+	SIGUSR2 Signal = "USR2"
+)
+
+var signals = map[Signal]int{
+	SIGABRT: 6,
+	SIGALRM: 14,
+	SIGFPE:  8,
+	SIGHUP:  1,
+	SIGILL:  4,
+	SIGINT:  2,
+	SIGKILL: 9,
+	SIGPIPE: 13,
+	SIGQUIT: 3,
+	SIGSEGV: 11,
+	SIGTERM: 15,
+}
+
+type TerminalModes map[uint8]uint32
+
+// POSIX terminal mode flags as listed in RFC 4254 Section 8.
+const (
+	tty_OP_END    = 0
+	VINTR         = 1
+	VQUIT         = 2
+	VERASE        = 3
+	VKILL         = 4
+	VEOF          = 5
+	VEOL          = 6
+	VEOL2         = 7
+	VSTART        = 8
+	VSTOP         = 9
+	VSUSP         = 10
+	VDSUSP        = 11
+	VREPRINT      = 12
+	VWERASE       = 13
+	VLNEXT        = 14
+	VFLUSH        = 15
+	VSWTCH        = 16
+	VSTATUS       = 17
+	VDISCARD      = 18
+	IGNPAR        = 30
+	PARMRK        = 31
+	INPCK         = 32
+	ISTRIP        = 33
+	INLCR         = 34
+	IGNCR         = 35
+	ICRNL         = 36
+	IUCLC         = 37
+	IXON          = 38
+	IXANY         = 39
+	IXOFF         = 40
+	IMAXBEL       = 41
+	ISIG          = 50
+	ICANON        = 51
+	XCASE         = 52
+	ECHO          = 53
+	ECHOE         = 54
+	ECHOK         = 55
+	ECHONL        = 56
+	NOFLSH        = 57
+	TOSTOP        = 58
+	IEXTEN        = 59
+	ECHOCTL       = 60
+	ECHOKE        = 61
+	PENDIN        = 62
+	OPOST         = 70
+	OLCUC         = 71
+	ONLCR         = 72
+	OCRNL         = 73
+	ONOCR         = 74
+	ONLRET        = 75
+	CS7           = 90
+	CS8           = 91
+	PARENB        = 92
+	PARODD        = 93
+	TTY_OP_ISPEED = 128
+	TTY_OP_OSPEED = 129
+)
+
+// A Session represents a connection to a remote command or shell.
+type Session struct {
+	// Stdin specifies the remote process's standard input.
+	// If Stdin is nil, the remote process reads from an empty
+	// bytes.Buffer.
+	Stdin io.Reader
+
+	// Stdout and Stderr specify the remote process's standard
+	// output and error.
+	//
+	// If either is nil, Run connects the corresponding file
+	// descriptor to an instance of ioutil.Discard. There is a
+	// fixed amount of buffering that is shared for the two streams.
+	// If either blocks it may eventually cause the remote
+	// command to block.
+	Stdout io.Writer
+	Stderr io.Writer
+
+	ch        Channel // the channel backing this session
+	started   bool    // true once Start, Run or Shell is invoked.
+	copyFuncs []func() error
+	errors    chan error // one send per copyFunc
+
+	// true if pipe method is active
+	stdinpipe, stdoutpipe, stderrpipe bool
+
+	// stdinPipeWriter is non-nil if StdinPipe has not been called
+	// and Stdin was specified by the user; it is the write end of
+	// a pipe connecting Session.Stdin to the stdin channel.
+	stdinPipeWriter io.WriteCloser
+
+	exitStatus chan error
+}
+
+// SendRequest sends an out-of-band channel request on the SSH channel
+// underlying the session.
+func (s *Session) SendRequest(name string, wantReply bool, payload []byte) (bool, error) {
+	return s.ch.SendRequest(name, wantReply, payload)
+}
+
+func (s *Session) Close() error {
+	return s.ch.Close()
+}
+
+// RFC 4254 Section 6.4.
+type setenvRequest struct {
+	Name  string
+	Value string
+}
+
+// Setenv sets an environment variable that will be applied to any
+// command executed by Shell or Run.
+func (s *Session) Setenv(name, value string) error {
+	msg := setenvRequest{
+		Name:  name,
+		Value: value,
+	}
+	ok, err := s.ch.SendRequest("env", true, Marshal(&msg))
+	if err == nil && !ok {
+		err = errors.New("ssh: setenv failed")
+	}
+	return err
+}
+
+// RFC 4254 Section 6.2.
+type ptyRequestMsg struct {
+	Term     string
+	Columns  uint32
+	Rows     uint32
+	Width    uint32
+	Height   uint32
+	Modelist string
+}
+
+// RequestPty requests the association of a pty with the session on the remote host.
+func (s *Session) RequestPty(term string, h, w int, termmodes TerminalModes) error {
+	var tm []byte
+	for k, v := range termmodes {
+		kv := struct {
+			Key byte
+			Val uint32
+		}{k, v}
+
+		tm = append(tm, Marshal(&kv)...)
+	}
+	tm = append(tm, tty_OP_END)
+	req := ptyRequestMsg{
+		Term:     term,
+		Columns:  uint32(w),
+		Rows:     uint32(h),
+		Width:    uint32(w * 8),
+		Height:   uint32(h * 8),
+		Modelist: string(tm),
+	}
+	ok, err := s.ch.SendRequest("pty-req", true, Marshal(&req))
+	if err == nil && !ok {
+		err = errors.New("ssh: pty-req failed")
+	}
+	return err
+}
+
+// RFC 4254 Section 6.5.
+type subsystemRequestMsg struct {
+	Subsystem string
+}
+
+// RequestSubsystem requests the association of a subsystem with the session on the remote host.
+// A subsystem is a predefined command that runs in the background when the ssh session is initiated
+func (s *Session) RequestSubsystem(subsystem string) error {
+	msg := subsystemRequestMsg{
+		Subsystem: subsystem,
+	}
+	ok, err := s.ch.SendRequest("subsystem", true, Marshal(&msg))
+	if err == nil && !ok {
+		err = errors.New("ssh: subsystem request failed")
+	}
+	return err
+}
+
+// RFC 4254 Section 6.7.
+type ptyWindowChangeMsg struct {
+	Columns uint32
+	Rows    uint32
+	Width   uint32
+	Height  uint32
+}
+
+// WindowChange informs the remote host about a terminal window dimension change to h rows and w columns.
+func (s *Session) WindowChange(h, w int) error {
+	req := ptyWindowChangeMsg{
+		Columns: uint32(w),
+		Rows:    uint32(h),
+		Width:   uint32(w * 8),
+		Height:  uint32(h * 8),
+	}
+	_, err := s.ch.SendRequest("window-change", false, Marshal(&req))
+	return err
+}
+
+// RFC 4254 Section 6.9.
+type signalMsg struct {
+	Signal string
+}
+
+// Signal sends the given signal to the remote process.
+// sig is one of the SIG* constants.
+func (s *Session) Signal(sig Signal) error {
+	msg := signalMsg{
+		Signal: string(sig),
+	}
+
+	_, err := s.ch.SendRequest("signal", false, Marshal(&msg))
+	return err
+}
+
+// RFC 4254 Section 6.5.
+type execMsg struct {
+	Command string
+}
+
+// Start runs cmd on the remote host. Typically, the remote
+// server passes cmd to the shell for interpretation.
+// A Session only accepts one call to Run, Start or Shell.
+func (s *Session) Start(cmd string) error {
+	if s.started {
+		return errors.New("ssh: session already started")
+	}
+	req := execMsg{
+		Command: cmd,
+	}
+
+	ok, err := s.ch.SendRequest("exec", true, Marshal(&req))
+	if err == nil && !ok {
+		err = fmt.Errorf("ssh: command %v failed", cmd)
+	}
+	if err != nil {
+		return err
+	}
+	return s.start()
+}
+
+// Run runs cmd on the remote host. Typically, the remote
+// server passes cmd to the shell for interpretation.
+// A Session only accepts one call to Run, Start, Shell, Output,
+// or CombinedOutput.
+//
+// The returned error is nil if the command runs, has no problems
+// copying stdin, stdout, and stderr, and exits with a zero exit
+// status.
+//
+// If the remote server does not send an exit status, an error of type
+// *ExitMissingError is returned. If the command completes
+// unsuccessfully or is interrupted by a signal, the error is of type
+// *ExitError. Other error types may be returned for I/O problems.
+func (s *Session) Run(cmd string) error {
+	err := s.Start(cmd)
+	if err != nil {
+		return err
+	}
+	return s.Wait()
+}
+
+// Output runs cmd on the remote host and returns its standard output.
+func (s *Session) Output(cmd string) ([]byte, error) {
+	if s.Stdout != nil {
+		return nil, errors.New("ssh: Stdout already set")
+	}
+	var b bytes.Buffer
+	s.Stdout = &b
+	err := s.Run(cmd)
+	return b.Bytes(), err
+}
+
+type singleWriter struct {
+	b  bytes.Buffer
+	mu sync.Mutex
+}
+
+func (w *singleWriter) Write(p []byte) (int, error) {
+	w.mu.Lock()
+	defer w.mu.Unlock()
+	return w.b.Write(p)
+}
+
+// CombinedOutput runs cmd on the remote host and returns its combined
+// standard output and standard error.
+func (s *Session) CombinedOutput(cmd string) ([]byte, error) {
+	if s.Stdout != nil {
+		return nil, errors.New("ssh: Stdout already set")
+	}
+	if s.Stderr != nil {
+		return nil, errors.New("ssh: Stderr already set")
+	}
+	var b singleWriter
+	s.Stdout = &b
+	s.Stderr = &b
+	err := s.Run(cmd)
+	return b.b.Bytes(), err
+}
+
+// Shell starts a login shell on the remote host. A Session only
+// accepts one call to Run, Start, Shell, Output, or CombinedOutput.
+func (s *Session) Shell() error {
+	if s.started {
+		return errors.New("ssh: session already started")
+	}
+
+	ok, err := s.ch.SendRequest("shell", true, nil)
+	if err == nil && !ok {
+		return errors.New("ssh: could not start shell")
+	}
+	if err != nil {
+		return err
+	}
+	return s.start()
+}
+
+func (s *Session) start() error {
+	s.started = true
+
+	type F func(*Session)
+	for _, setupFd := range []F{(*Session).stdin, (*Session).stdout, (*Session).stderr} {
+		setupFd(s)
+	}
+
+	s.errors = make(chan error, len(s.copyFuncs))
+	for _, fn := range s.copyFuncs {
+		go func(fn func() error) {
+			s.errors <- fn()
+		}(fn)
+	}
+	return nil
+}
+
+// Wait waits for the remote command to exit.
+//
+// The returned error is nil if the command runs, has no problems
+// copying stdin, stdout, and stderr, and exits with a zero exit
+// status.
+//
+// If the remote server does not send an exit status, an error of type
+// *ExitMissingError is returned. If the command completes
+// unsuccessfully or is interrupted by a signal, the error is of type
+// *ExitError. Other error types may be returned for I/O problems.
+func (s *Session) Wait() error {
+	if !s.started {
+		return errors.New("ssh: session not started")
+	}
+	waitErr := <-s.exitStatus
+
+	if s.stdinPipeWriter != nil {
+		s.stdinPipeWriter.Close()
+	}
+	var copyError error
+	for _ = range s.copyFuncs {
+		if err := <-s.errors; err != nil && copyError == nil {
+			copyError = err
+		}
+	}
+	if waitErr != nil {
+		return waitErr
+	}
+	return copyError
+}
+
+func (s *Session) wait(reqs <-chan *Request) error {
+	wm := Waitmsg{status: -1}
+	// Wait for msg channel to be closed before returning.
+	for msg := range reqs {
+		switch msg.Type {
+		case "exit-status":
+			wm.status = int(binary.BigEndian.Uint32(msg.Payload))
+		case "exit-signal":
+			var sigval struct {
+				Signal     string
+				CoreDumped bool
+				Error      string
+				Lang       string
+			}
+			if err := Unmarshal(msg.Payload, &sigval); err != nil {
+				return err
+			}
+
+			// Must sanitize strings?
+			wm.signal = sigval.Signal
+			wm.msg = sigval.Error
+			wm.lang = sigval.Lang
+		default:
+			// This handles keepalives and matches
+			// OpenSSH's behaviour.
+			if msg.WantReply {
+				msg.Reply(false, nil)
+			}
+		}
+	}
+	if wm.status == 0 {
+		return nil
+	}
+	if wm.status == -1 {
+		// exit-status was never sent from server
+		if wm.signal == "" {
+			// signal was not sent either.  RFC 4254
+			// section 6.10 recommends against this
+			// behavior, but it is allowed, so we let
+			// clients handle it.
+			return &ExitMissingError{}
+		}
+		wm.status = 128
+		if _, ok := signals[Signal(wm.signal)]; ok {
+			wm.status += signals[Signal(wm.signal)]
+		}
+	}
+
+	return &ExitError{wm}
+}
+
+// ExitMissingError is returned if a session is torn down cleanly, but
+// the server sends no confirmation of the exit status.
+type ExitMissingError struct{}
+
+func (e *ExitMissingError) Error() string {
+	return "wait: remote command exited without exit status or exit signal"
+}
+
+func (s *Session) stdin() {
+	if s.stdinpipe {
+		return
+	}
+	var stdin io.Reader
+	if s.Stdin == nil {
+		stdin = new(bytes.Buffer)
+	} else {
+		r, w := io.Pipe()
+		go func() {
+			_, err := io.Copy(w, s.Stdin)
+			w.CloseWithError(err)
+		}()
+		stdin, s.stdinPipeWriter = r, w
+	}
+	s.copyFuncs = append(s.copyFuncs, func() error {
+		_, err := io.Copy(s.ch, stdin)
+		if err1 := s.ch.CloseWrite(); err == nil && err1 != io.EOF {
+			err = err1
+		}
+		return err
+	})
+}
+
+func (s *Session) stdout() {
+	if s.stdoutpipe {
+		return
+	}
+	if s.Stdout == nil {
+		s.Stdout = ioutil.Discard
+	}
+	s.copyFuncs = append(s.copyFuncs, func() error {
+		_, err := io.Copy(s.Stdout, s.ch)
+		return err
+	})
+}
+
+func (s *Session) stderr() {
+	if s.stderrpipe {
+		return
+	}
+	if s.Stderr == nil {
+		s.Stderr = ioutil.Discard
+	}
+	s.copyFuncs = append(s.copyFuncs, func() error {
+		_, err := io.Copy(s.Stderr, s.ch.Stderr())
+		return err
+	})
+}
+
+// sessionStdin reroutes Close to CloseWrite.
+type sessionStdin struct {
+	io.Writer
+	ch Channel
+}
+
+func (s *sessionStdin) Close() error {
+	return s.ch.CloseWrite()
+}
+
+// StdinPipe returns a pipe that will be connected to the
+// remote command's standard input when the command starts.
+func (s *Session) StdinPipe() (io.WriteCloser, error) {
+	if s.Stdin != nil {
+		return nil, errors.New("ssh: Stdin already set")
+	}
+	if s.started {
+		return nil, errors.New("ssh: StdinPipe after process started")
+	}
+	s.stdinpipe = true
+	return &sessionStdin{s.ch, s.ch}, nil
+}
+
+// StdoutPipe returns a pipe that will be connected to the
+// remote command's standard output when the command starts.
+// There is a fixed amount of buffering that is shared between
+// stdout and stderr streams. If the StdoutPipe reader is
+// not serviced fast enough it may eventually cause the
+// remote command to block.
+func (s *Session) StdoutPipe() (io.Reader, error) {
+	if s.Stdout != nil {
+		return nil, errors.New("ssh: Stdout already set")
+	}
+	if s.started {
+		return nil, errors.New("ssh: StdoutPipe after process started")
+	}
+	s.stdoutpipe = true
+	return s.ch, nil
+}
+
+// StderrPipe returns a pipe that will be connected to the
+// remote command's standard error when the command starts.
+// There is a fixed amount of buffering that is shared between
+// stdout and stderr streams. If the StderrPipe reader is
+// not serviced fast enough it may eventually cause the
+// remote command to block.
+func (s *Session) StderrPipe() (io.Reader, error) {
+	if s.Stderr != nil {
+		return nil, errors.New("ssh: Stderr already set")
+	}
+	if s.started {
+		return nil, errors.New("ssh: StderrPipe after process started")
+	}
+	s.stderrpipe = true
+	return s.ch.Stderr(), nil
+}
+
+// newSession returns a new interactive session on the remote host.
+func newSession(ch Channel, reqs <-chan *Request) (*Session, error) {
+	s := &Session{
+		ch: ch,
+	}
+	s.exitStatus = make(chan error, 1)
+	go func() {
+		s.exitStatus <- s.wait(reqs)
+	}()
+
+	return s, nil
+}
+
+// An ExitError reports unsuccessful completion of a remote command.
+type ExitError struct {
+	Waitmsg
+}
+
+func (e *ExitError) Error() string {
+	return e.Waitmsg.String()
+}
+
+// Waitmsg stores the information about an exited remote command
+// as reported by Wait.
+type Waitmsg struct {
+	status int
+	signal string
+	msg    string
+	lang   string
+}
+
+// ExitStatus returns the exit status of the remote command.
+func (w Waitmsg) ExitStatus() int {
+	return w.status
+}
+
+// Signal returns the exit signal of the remote command if
+// it was terminated violently.
+func (w Waitmsg) Signal() string {
+	return w.signal
+}
+
+// Msg returns the exit message given by the remote command
+func (w Waitmsg) Msg() string {
+	return w.msg
+}
+
+// Lang returns the language tag. See RFC 3066
+func (w Waitmsg) Lang() string {
+	return w.lang
+}
+
+func (w Waitmsg) String() string {
+	str := fmt.Sprintf("Process exited with status %v", w.status)
+	if w.signal != "" {
+		str += fmt.Sprintf(" from signal %v", w.signal)
+	}
+	if w.msg != "" {
+		str += fmt.Sprintf(". Reason was: %v", w.msg)
+	}
+	return str
+}
diff --git a/vendor/golang.org/x/crypto/ssh/streamlocal.go b/vendor/golang.org/x/crypto/ssh/streamlocal.go
new file mode 100644
index 0000000..a2dccc6
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/streamlocal.go
@@ -0,0 +1,115 @@
+package ssh
+
+import (
+	"errors"
+	"io"
+	"net"
+)
+
+// streamLocalChannelOpenDirectMsg is a struct used for SSH_MSG_CHANNEL_OPEN message
+// with "direct-streamlocal@openssh.com" string.
+//
+// See openssh-portable/PROTOCOL, section 2.4. connection: Unix domain socket forwarding
+// https://github.com/openssh/openssh-portable/blob/master/PROTOCOL#L235
+type streamLocalChannelOpenDirectMsg struct {
+	socketPath string
+	reserved0  string
+	reserved1  uint32
+}
+
+// forwardedStreamLocalPayload is a struct used for SSH_MSG_CHANNEL_OPEN message
+// with "forwarded-streamlocal@openssh.com" string.
+type forwardedStreamLocalPayload struct {
+	SocketPath string
+	Reserved0  string
+}
+
+// streamLocalChannelForwardMsg is a struct used for SSH2_MSG_GLOBAL_REQUEST message
+// with "streamlocal-forward@openssh.com"/"cancel-streamlocal-forward@openssh.com" string.
+type streamLocalChannelForwardMsg struct {
+	socketPath string
+}
+
+// ListenUnix is similar to ListenTCP but uses a Unix domain socket.
+func (c *Client) ListenUnix(socketPath string) (net.Listener, error) {
+	m := streamLocalChannelForwardMsg{
+		socketPath,
+	}
+	// send message
+	ok, _, err := c.SendRequest("streamlocal-forward@openssh.com", true, Marshal(&m))
+	if err != nil {
+		return nil, err
+	}
+	if !ok {
+		return nil, errors.New("ssh: streamlocal-forward@openssh.com request denied by peer")
+	}
+	ch := c.forwards.add(&net.UnixAddr{Name: socketPath, Net: "unix"})
+
+	return &unixListener{socketPath, c, ch}, nil
+}
+
+func (c *Client) dialStreamLocal(socketPath string) (Channel, error) {
+	msg := streamLocalChannelOpenDirectMsg{
+		socketPath: socketPath,
+	}
+	ch, in, err := c.OpenChannel("direct-streamlocal@openssh.com", Marshal(&msg))
+	if err != nil {
+		return nil, err
+	}
+	go DiscardRequests(in)
+	return ch, err
+}
+
+type unixListener struct {
+	socketPath string
+
+	conn *Client
+	in   <-chan forward
+}
+
+// Accept waits for and returns the next connection to the listener.
+func (l *unixListener) Accept() (net.Conn, error) {
+	s, ok := <-l.in
+	if !ok {
+		return nil, io.EOF
+	}
+	ch, incoming, err := s.newCh.Accept()
+	if err != nil {
+		return nil, err
+	}
+	go DiscardRequests(incoming)
+
+	return &chanConn{
+		Channel: ch,
+		laddr: &net.UnixAddr{
+			Name: l.socketPath,
+			Net:  "unix",
+		},
+		raddr: &net.UnixAddr{
+			Name: "@",
+			Net:  "unix",
+		},
+	}, nil
+}
+
+// Close closes the listener.
+func (l *unixListener) Close() error {
+	// this also closes the listener.
+	l.conn.forwards.remove(&net.UnixAddr{Name: l.socketPath, Net: "unix"})
+	m := streamLocalChannelForwardMsg{
+		l.socketPath,
+	}
+	ok, _, err := l.conn.SendRequest("cancel-streamlocal-forward@openssh.com", true, Marshal(&m))
+	if err == nil && !ok {
+		err = errors.New("ssh: cancel-streamlocal-forward@openssh.com failed")
+	}
+	return err
+}
+
+// Addr returns the listener's network address.
+func (l *unixListener) Addr() net.Addr {
+	return &net.UnixAddr{
+		Name: l.socketPath,
+		Net:  "unix",
+	}
+}
diff --git a/vendor/golang.org/x/crypto/ssh/tcpip.go b/vendor/golang.org/x/crypto/ssh/tcpip.go
new file mode 100644
index 0000000..acf1717
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/tcpip.go
@@ -0,0 +1,465 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"errors"
+	"fmt"
+	"io"
+	"math/rand"
+	"net"
+	"strconv"
+	"strings"
+	"sync"
+	"time"
+)
+
+// Listen requests the remote peer open a listening socket on
+// addr. Incoming connections will be available by calling Accept on
+// the returned net.Listener. The listener must be serviced, or the
+// SSH connection may hang.
+// N must be "tcp", "tcp4", "tcp6", or "unix".
+func (c *Client) Listen(n, addr string) (net.Listener, error) {
+	switch n {
+	case "tcp", "tcp4", "tcp6":
+		laddr, err := net.ResolveTCPAddr(n, addr)
+		if err != nil {
+			return nil, err
+		}
+		return c.ListenTCP(laddr)
+	case "unix":
+		return c.ListenUnix(addr)
+	default:
+		return nil, fmt.Errorf("ssh: unsupported protocol: %s", n)
+	}
+}
+
+// Automatic port allocation is broken with OpenSSH before 6.0. See
+// also https://bugzilla.mindrot.org/show_bug.cgi?id=2017.  In
+// particular, OpenSSH 5.9 sends a channelOpenMsg with port number 0,
+// rather than the actual port number. This means you can never open
+// two different listeners with auto allocated ports. We work around
+// this by trying explicit ports until we succeed.
+
+const openSSHPrefix = "OpenSSH_"
+
+var portRandomizer = rand.New(rand.NewSource(time.Now().UnixNano()))
+
+// isBrokenOpenSSHVersion returns true if the given version string
+// specifies a version of OpenSSH that is known to have a bug in port
+// forwarding.
+func isBrokenOpenSSHVersion(versionStr string) bool {
+	i := strings.Index(versionStr, openSSHPrefix)
+	if i < 0 {
+		return false
+	}
+	i += len(openSSHPrefix)
+	j := i
+	for ; j < len(versionStr); j++ {
+		if versionStr[j] < '0' || versionStr[j] > '9' {
+			break
+		}
+	}
+	version, _ := strconv.Atoi(versionStr[i:j])
+	return version < 6
+}
+
+// autoPortListenWorkaround simulates automatic port allocation by
+// trying random ports repeatedly.
+func (c *Client) autoPortListenWorkaround(laddr *net.TCPAddr) (net.Listener, error) {
+	var sshListener net.Listener
+	var err error
+	const tries = 10
+	for i := 0; i < tries; i++ {
+		addr := *laddr
+		addr.Port = 1024 + portRandomizer.Intn(60000)
+		sshListener, err = c.ListenTCP(&addr)
+		if err == nil {
+			laddr.Port = addr.Port
+			return sshListener, err
+		}
+	}
+	return nil, fmt.Errorf("ssh: listen on random port failed after %d tries: %v", tries, err)
+}
+
+// RFC 4254 7.1
+type channelForwardMsg struct {
+	addr  string
+	rport uint32
+}
+
+// ListenTCP requests the remote peer open a listening socket
+// on laddr. Incoming connections will be available by calling
+// Accept on the returned net.Listener.
+func (c *Client) ListenTCP(laddr *net.TCPAddr) (net.Listener, error) {
+	if laddr.Port == 0 && isBrokenOpenSSHVersion(string(c.ServerVersion())) {
+		return c.autoPortListenWorkaround(laddr)
+	}
+
+	m := channelForwardMsg{
+		laddr.IP.String(),
+		uint32(laddr.Port),
+	}
+	// send message
+	ok, resp, err := c.SendRequest("tcpip-forward", true, Marshal(&m))
+	if err != nil {
+		return nil, err
+	}
+	if !ok {
+		return nil, errors.New("ssh: tcpip-forward request denied by peer")
+	}
+
+	// If the original port was 0, then the remote side will
+	// supply a real port number in the response.
+	if laddr.Port == 0 {
+		var p struct {
+			Port uint32
+		}
+		if err := Unmarshal(resp, &p); err != nil {
+			return nil, err
+		}
+		laddr.Port = int(p.Port)
+	}
+
+	// Register this forward, using the port number we obtained.
+	ch := c.forwards.add(laddr)
+
+	return &tcpListener{laddr, c, ch}, nil
+}
+
+// forwardList stores a mapping between remote
+// forward requests and the tcpListeners.
+type forwardList struct {
+	sync.Mutex
+	entries []forwardEntry
+}
+
+// forwardEntry represents an established mapping of a laddr on a
+// remote ssh server to a channel connected to a tcpListener.
+type forwardEntry struct {
+	laddr net.Addr
+	c     chan forward
+}
+
+// forward represents an incoming forwarded tcpip connection. The
+// arguments to add/remove/lookup should be address as specified in
+// the original forward-request.
+type forward struct {
+	newCh NewChannel // the ssh client channel underlying this forward
+	raddr net.Addr   // the raddr of the incoming connection
+}
+
+func (l *forwardList) add(addr net.Addr) chan forward {
+	l.Lock()
+	defer l.Unlock()
+	f := forwardEntry{
+		laddr: addr,
+		c:     make(chan forward, 1),
+	}
+	l.entries = append(l.entries, f)
+	return f.c
+}
+
+// See RFC 4254, section 7.2
+type forwardedTCPPayload struct {
+	Addr       string
+	Port       uint32
+	OriginAddr string
+	OriginPort uint32
+}
+
+// parseTCPAddr parses the originating address from the remote into a *net.TCPAddr.
+func parseTCPAddr(addr string, port uint32) (*net.TCPAddr, error) {
+	if port == 0 || port > 65535 {
+		return nil, fmt.Errorf("ssh: port number out of range: %d", port)
+	}
+	ip := net.ParseIP(string(addr))
+	if ip == nil {
+		return nil, fmt.Errorf("ssh: cannot parse IP address %q", addr)
+	}
+	return &net.TCPAddr{IP: ip, Port: int(port)}, nil
+}
+
+func (l *forwardList) handleChannels(in <-chan NewChannel) {
+	for ch := range in {
+		var (
+			laddr net.Addr
+			raddr net.Addr
+			err   error
+		)
+		switch channelType := ch.ChannelType(); channelType {
+		case "forwarded-tcpip":
+			var payload forwardedTCPPayload
+			if err = Unmarshal(ch.ExtraData(), &payload); err != nil {
+				ch.Reject(ConnectionFailed, "could not parse forwarded-tcpip payload: "+err.Error())
+				continue
+			}
+
+			// RFC 4254 section 7.2 specifies that incoming
+			// addresses should list the address, in string
+			// format. It is implied that this should be an IP
+			// address, as it would be impossible to connect to it
+			// otherwise.
+			laddr, err = parseTCPAddr(payload.Addr, payload.Port)
+			if err != nil {
+				ch.Reject(ConnectionFailed, err.Error())
+				continue
+			}
+			raddr, err = parseTCPAddr(payload.OriginAddr, payload.OriginPort)
+			if err != nil {
+				ch.Reject(ConnectionFailed, err.Error())
+				continue
+			}
+
+		case "forwarded-streamlocal@openssh.com":
+			var payload forwardedStreamLocalPayload
+			if err = Unmarshal(ch.ExtraData(), &payload); err != nil {
+				ch.Reject(ConnectionFailed, "could not parse forwarded-streamlocal@openssh.com payload: "+err.Error())
+				continue
+			}
+			laddr = &net.UnixAddr{
+				Name: payload.SocketPath,
+				Net:  "unix",
+			}
+			raddr = &net.UnixAddr{
+				Name: "@",
+				Net:  "unix",
+			}
+		default:
+			panic(fmt.Errorf("ssh: unknown channel type %s", channelType))
+		}
+		if ok := l.forward(laddr, raddr, ch); !ok {
+			// Section 7.2, implementations MUST reject spurious incoming
+			// connections.
+			ch.Reject(Prohibited, "no forward for address")
+			continue
+		}
+
+	}
+}
+
+// remove removes the forward entry, and the channel feeding its
+// listener.
+func (l *forwardList) remove(addr net.Addr) {
+	l.Lock()
+	defer l.Unlock()
+	for i, f := range l.entries {
+		if addr.Network() == f.laddr.Network() && addr.String() == f.laddr.String() {
+			l.entries = append(l.entries[:i], l.entries[i+1:]...)
+			close(f.c)
+			return
+		}
+	}
+}
+
+// closeAll closes and clears all forwards.
+func (l *forwardList) closeAll() {
+	l.Lock()
+	defer l.Unlock()
+	for _, f := range l.entries {
+		close(f.c)
+	}
+	l.entries = nil
+}
+
+func (l *forwardList) forward(laddr, raddr net.Addr, ch NewChannel) bool {
+	l.Lock()
+	defer l.Unlock()
+	for _, f := range l.entries {
+		if laddr.Network() == f.laddr.Network() && laddr.String() == f.laddr.String() {
+			f.c <- forward{newCh: ch, raddr: raddr}
+			return true
+		}
+	}
+	return false
+}
+
+type tcpListener struct {
+	laddr *net.TCPAddr
+
+	conn *Client
+	in   <-chan forward
+}
+
+// Accept waits for and returns the next connection to the listener.
+func (l *tcpListener) Accept() (net.Conn, error) {
+	s, ok := <-l.in
+	if !ok {
+		return nil, io.EOF
+	}
+	ch, incoming, err := s.newCh.Accept()
+	if err != nil {
+		return nil, err
+	}
+	go DiscardRequests(incoming)
+
+	return &chanConn{
+		Channel: ch,
+		laddr:   l.laddr,
+		raddr:   s.raddr,
+	}, nil
+}
+
+// Close closes the listener.
+func (l *tcpListener) Close() error {
+	m := channelForwardMsg{
+		l.laddr.IP.String(),
+		uint32(l.laddr.Port),
+	}
+
+	// this also closes the listener.
+	l.conn.forwards.remove(l.laddr)
+	ok, _, err := l.conn.SendRequest("cancel-tcpip-forward", true, Marshal(&m))
+	if err == nil && !ok {
+		err = errors.New("ssh: cancel-tcpip-forward failed")
+	}
+	return err
+}
+
+// Addr returns the listener's network address.
+func (l *tcpListener) Addr() net.Addr {
+	return l.laddr
+}
+
+// Dial initiates a connection to the addr from the remote host.
+// The resulting connection has a zero LocalAddr() and RemoteAddr().
+func (c *Client) Dial(n, addr string) (net.Conn, error) {
+	var ch Channel
+	switch n {
+	case "tcp", "tcp4", "tcp6":
+		// Parse the address into host and numeric port.
+		host, portString, err := net.SplitHostPort(addr)
+		if err != nil {
+			return nil, err
+		}
+		port, err := strconv.ParseUint(portString, 10, 16)
+		if err != nil {
+			return nil, err
+		}
+		ch, err = c.dial(net.IPv4zero.String(), 0, host, int(port))
+		if err != nil {
+			return nil, err
+		}
+		// Use a zero address for local and remote address.
+		zeroAddr := &net.TCPAddr{
+			IP:   net.IPv4zero,
+			Port: 0,
+		}
+		return &chanConn{
+			Channel: ch,
+			laddr:   zeroAddr,
+			raddr:   zeroAddr,
+		}, nil
+	case "unix":
+		var err error
+		ch, err = c.dialStreamLocal(addr)
+		if err != nil {
+			return nil, err
+		}
+		return &chanConn{
+			Channel: ch,
+			laddr: &net.UnixAddr{
+				Name: "@",
+				Net:  "unix",
+			},
+			raddr: &net.UnixAddr{
+				Name: addr,
+				Net:  "unix",
+			},
+		}, nil
+	default:
+		return nil, fmt.Errorf("ssh: unsupported protocol: %s", n)
+	}
+}
+
+// DialTCP connects to the remote address raddr on the network net,
+// which must be "tcp", "tcp4", or "tcp6".  If laddr is not nil, it is used
+// as the local address for the connection.
+func (c *Client) DialTCP(n string, laddr, raddr *net.TCPAddr) (net.Conn, error) {
+	if laddr == nil {
+		laddr = &net.TCPAddr{
+			IP:   net.IPv4zero,
+			Port: 0,
+		}
+	}
+	ch, err := c.dial(laddr.IP.String(), laddr.Port, raddr.IP.String(), raddr.Port)
+	if err != nil {
+		return nil, err
+	}
+	return &chanConn{
+		Channel: ch,
+		laddr:   laddr,
+		raddr:   raddr,
+	}, nil
+}
+
+// RFC 4254 7.2
+type channelOpenDirectMsg struct {
+	raddr string
+	rport uint32
+	laddr string
+	lport uint32
+}
+
+func (c *Client) dial(laddr string, lport int, raddr string, rport int) (Channel, error) {
+	msg := channelOpenDirectMsg{
+		raddr: raddr,
+		rport: uint32(rport),
+		laddr: laddr,
+		lport: uint32(lport),
+	}
+	ch, in, err := c.OpenChannel("direct-tcpip", Marshal(&msg))
+	if err != nil {
+		return nil, err
+	}
+	go DiscardRequests(in)
+	return ch, err
+}
+
+type tcpChan struct {
+	Channel // the backing channel
+}
+
+// chanConn fulfills the net.Conn interface without
+// the tcpChan having to hold laddr or raddr directly.
+type chanConn struct {
+	Channel
+	laddr, raddr net.Addr
+}
+
+// LocalAddr returns the local network address.
+func (t *chanConn) LocalAddr() net.Addr {
+	return t.laddr
+}
+
+// RemoteAddr returns the remote network address.
+func (t *chanConn) RemoteAddr() net.Addr {
+	return t.raddr
+}
+
+// SetDeadline sets the read and write deadlines associated
+// with the connection.
+func (t *chanConn) SetDeadline(deadline time.Time) error {
+	if err := t.SetReadDeadline(deadline); err != nil {
+		return err
+	}
+	return t.SetWriteDeadline(deadline)
+}
+
+// SetReadDeadline sets the read deadline.
+// A zero value for t means Read will not time out.
+// After the deadline, the error from Read will implement net.Error
+// with Timeout() == true.
+func (t *chanConn) SetReadDeadline(deadline time.Time) error {
+	// for compatibility with previous version,
+	// the error message contains "tcpChan"
+	return errors.New("ssh: tcpChan: deadline not supported")
+}
+
+// SetWriteDeadline exists to satisfy the net.Conn interface
+// but is not implemented by this type.  It always returns an error.
+func (t *chanConn) SetWriteDeadline(deadline time.Time) error {
+	return errors.New("ssh: tcpChan: deadline not supported")
+}
diff --git a/vendor/golang.org/x/crypto/ssh/transport.go b/vendor/golang.org/x/crypto/ssh/transport.go
new file mode 100644
index 0000000..f9780e0
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/transport.go
@@ -0,0 +1,375 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ssh
+
+import (
+	"bufio"
+	"errors"
+	"io"
+	"log"
+)
+
+// debugTransport if set, will print packet types as they go over the
+// wire. No message decoding is done, to minimize the impact on timing.
+const debugTransport = false
+
+const (
+	gcmCipherID    = "aes128-gcm@openssh.com"
+	aes128cbcID    = "aes128-cbc"
+	tripledescbcID = "3des-cbc"
+)
+
+// packetConn represents a transport that implements packet based
+// operations.
+type packetConn interface {
+	// Encrypt and send a packet of data to the remote peer.
+	writePacket(packet []byte) error
+
+	// Read a packet from the connection. The read is blocking,
+	// i.e. if error is nil, then the returned byte slice is
+	// always non-empty.
+	readPacket() ([]byte, error)
+
+	// Close closes the write-side of the connection.
+	Close() error
+}
+
+// transport is the keyingTransport that implements the SSH packet
+// protocol.
+type transport struct {
+	reader connectionState
+	writer connectionState
+
+	bufReader *bufio.Reader
+	bufWriter *bufio.Writer
+	rand      io.Reader
+	isClient  bool
+	io.Closer
+}
+
+// packetCipher represents a combination of SSH encryption/MAC
+// protocol.  A single instance should be used for one direction only.
+type packetCipher interface {
+	// writePacket encrypts the packet and writes it to w. The
+	// contents of the packet are generally scrambled.
+	writePacket(seqnum uint32, w io.Writer, rand io.Reader, packet []byte) error
+
+	// readPacket reads and decrypts a packet of data. The
+	// returned packet may be overwritten by future calls of
+	// readPacket.
+	readPacket(seqnum uint32, r io.Reader) ([]byte, error)
+}
+
+// connectionState represents one side (read or write) of the
+// connection. This is necessary because each direction has its own
+// keys, and can even have its own algorithms
+type connectionState struct {
+	packetCipher
+	seqNum           uint32
+	dir              direction
+	pendingKeyChange chan packetCipher
+}
+
+// prepareKeyChange sets up key material for a keychange. The key changes in
+// both directions are triggered by reading and writing a msgNewKey packet
+// respectively.
+func (t *transport) prepareKeyChange(algs *algorithms, kexResult *kexResult) error {
+	if ciph, err := newPacketCipher(t.reader.dir, algs.r, kexResult); err != nil {
+		return err
+	} else {
+		t.reader.pendingKeyChange <- ciph
+	}
+
+	if ciph, err := newPacketCipher(t.writer.dir, algs.w, kexResult); err != nil {
+		return err
+	} else {
+		t.writer.pendingKeyChange <- ciph
+	}
+
+	return nil
+}
+
+func (t *transport) printPacket(p []byte, write bool) {
+	if len(p) == 0 {
+		return
+	}
+	who := "server"
+	if t.isClient {
+		who = "client"
+	}
+	what := "read"
+	if write {
+		what = "write"
+	}
+
+	log.Println(what, who, p[0])
+}
+
+// Read and decrypt next packet.
+func (t *transport) readPacket() (p []byte, err error) {
+	for {
+		p, err = t.reader.readPacket(t.bufReader)
+		if err != nil {
+			break
+		}
+		if len(p) == 0 || (p[0] != msgIgnore && p[0] != msgDebug) {
+			break
+		}
+	}
+	if debugTransport {
+		t.printPacket(p, false)
+	}
+
+	return p, err
+}
+
+func (s *connectionState) readPacket(r *bufio.Reader) ([]byte, error) {
+	packet, err := s.packetCipher.readPacket(s.seqNum, r)
+	s.seqNum++
+	if err == nil && len(packet) == 0 {
+		err = errors.New("ssh: zero length packet")
+	}
+
+	if len(packet) > 0 {
+		switch packet[0] {
+		case msgNewKeys:
+			select {
+			case cipher := <-s.pendingKeyChange:
+				s.packetCipher = cipher
+			default:
+				return nil, errors.New("ssh: got bogus newkeys message.")
+			}
+
+		case msgDisconnect:
+			// Transform a disconnect message into an
+			// error. Since this is lowest level at which
+			// we interpret message types, doing it here
+			// ensures that we don't have to handle it
+			// elsewhere.
+			var msg disconnectMsg
+			if err := Unmarshal(packet, &msg); err != nil {
+				return nil, err
+			}
+			return nil, &msg
+		}
+	}
+
+	// The packet may point to an internal buffer, so copy the
+	// packet out here.
+	fresh := make([]byte, len(packet))
+	copy(fresh, packet)
+
+	return fresh, err
+}
+
+func (t *transport) writePacket(packet []byte) error {
+	if debugTransport {
+		t.printPacket(packet, true)
+	}
+	return t.writer.writePacket(t.bufWriter, t.rand, packet)
+}
+
+func (s *connectionState) writePacket(w *bufio.Writer, rand io.Reader, packet []byte) error {
+	changeKeys := len(packet) > 0 && packet[0] == msgNewKeys
+
+	err := s.packetCipher.writePacket(s.seqNum, w, rand, packet)
+	if err != nil {
+		return err
+	}
+	if err = w.Flush(); err != nil {
+		return err
+	}
+	s.seqNum++
+	if changeKeys {
+		select {
+		case cipher := <-s.pendingKeyChange:
+			s.packetCipher = cipher
+		default:
+			panic("ssh: no key material for msgNewKeys")
+		}
+	}
+	return err
+}
+
+func newTransport(rwc io.ReadWriteCloser, rand io.Reader, isClient bool) *transport {
+	t := &transport{
+		bufReader: bufio.NewReader(rwc),
+		bufWriter: bufio.NewWriter(rwc),
+		rand:      rand,
+		reader: connectionState{
+			packetCipher:     &streamPacketCipher{cipher: noneCipher{}},
+			pendingKeyChange: make(chan packetCipher, 1),
+		},
+		writer: connectionState{
+			packetCipher:     &streamPacketCipher{cipher: noneCipher{}},
+			pendingKeyChange: make(chan packetCipher, 1),
+		},
+		Closer: rwc,
+	}
+	t.isClient = isClient
+
+	if isClient {
+		t.reader.dir = serverKeys
+		t.writer.dir = clientKeys
+	} else {
+		t.reader.dir = clientKeys
+		t.writer.dir = serverKeys
+	}
+
+	return t
+}
+
+type direction struct {
+	ivTag     []byte
+	keyTag    []byte
+	macKeyTag []byte
+}
+
+var (
+	serverKeys = direction{[]byte{'B'}, []byte{'D'}, []byte{'F'}}
+	clientKeys = direction{[]byte{'A'}, []byte{'C'}, []byte{'E'}}
+)
+
+// generateKeys generates key material for IV, MAC and encryption.
+func generateKeys(d direction, algs directionAlgorithms, kex *kexResult) (iv, key, macKey []byte) {
+	cipherMode := cipherModes[algs.Cipher]
+	macMode := macModes[algs.MAC]
+
+	iv = make([]byte, cipherMode.ivSize)
+	key = make([]byte, cipherMode.keySize)
+	macKey = make([]byte, macMode.keySize)
+
+	generateKeyMaterial(iv, d.ivTag, kex)
+	generateKeyMaterial(key, d.keyTag, kex)
+	generateKeyMaterial(macKey, d.macKeyTag, kex)
+	return
+}
+
+// setupKeys sets the cipher and MAC keys from kex.K, kex.H and sessionId, as
+// described in RFC 4253, section 6.4. direction should either be serverKeys
+// (to setup server->client keys) or clientKeys (for client->server keys).
+func newPacketCipher(d direction, algs directionAlgorithms, kex *kexResult) (packetCipher, error) {
+	iv, key, macKey := generateKeys(d, algs, kex)
+
+	if algs.Cipher == gcmCipherID {
+		return newGCMCipher(iv, key, macKey)
+	}
+
+	if algs.Cipher == aes128cbcID {
+		return newAESCBCCipher(iv, key, macKey, algs)
+	}
+
+	if algs.Cipher == tripledescbcID {
+		return newTripleDESCBCCipher(iv, key, macKey, algs)
+	}
+
+	c := &streamPacketCipher{
+		mac: macModes[algs.MAC].new(macKey),
+		etm: macModes[algs.MAC].etm,
+	}
+	c.macResult = make([]byte, c.mac.Size())
+
+	var err error
+	c.cipher, err = cipherModes[algs.Cipher].createStream(key, iv)
+	if err != nil {
+		return nil, err
+	}
+
+	return c, nil
+}
+
+// generateKeyMaterial fills out with key material generated from tag, K, H
+// and sessionId, as specified in RFC 4253, section 7.2.
+func generateKeyMaterial(out, tag []byte, r *kexResult) {
+	var digestsSoFar []byte
+
+	h := r.Hash.New()
+	for len(out) > 0 {
+		h.Reset()
+		h.Write(r.K)
+		h.Write(r.H)
+
+		if len(digestsSoFar) == 0 {
+			h.Write(tag)
+			h.Write(r.SessionID)
+		} else {
+			h.Write(digestsSoFar)
+		}
+
+		digest := h.Sum(nil)
+		n := copy(out, digest)
+		out = out[n:]
+		if len(out) > 0 {
+			digestsSoFar = append(digestsSoFar, digest...)
+		}
+	}
+}
+
+const packageVersion = "SSH-2.0-Go"
+
+// Sends and receives a version line.  The versionLine string should
+// be US ASCII, start with "SSH-2.0-", and should not include a
+// newline. exchangeVersions returns the other side's version line.
+func exchangeVersions(rw io.ReadWriter, versionLine []byte) (them []byte, err error) {
+	// Contrary to the RFC, we do not ignore lines that don't
+	// start with "SSH-2.0-" to make the library usable with
+	// nonconforming servers.
+	for _, c := range versionLine {
+		// The spec disallows non US-ASCII chars, and
+		// specifically forbids null chars.
+		if c < 32 {
+			return nil, errors.New("ssh: junk character in version line")
+		}
+	}
+	if _, err = rw.Write(append(versionLine, '\r', '\n')); err != nil {
+		return
+	}
+
+	them, err = readVersion(rw)
+	return them, err
+}
+
+// maxVersionStringBytes is the maximum number of bytes that we'll
+// accept as a version string. RFC 4253 section 4.2 limits this at 255
+// chars
+const maxVersionStringBytes = 255
+
+// Read version string as specified by RFC 4253, section 4.2.
+func readVersion(r io.Reader) ([]byte, error) {
+	versionString := make([]byte, 0, 64)
+	var ok bool
+	var buf [1]byte
+
+	for len(versionString) < maxVersionStringBytes {
+		_, err := io.ReadFull(r, buf[:])
+		if err != nil {
+			return nil, err
+		}
+		// The RFC says that the version should be terminated with \r\n
+		// but several SSH servers actually only send a \n.
+		if buf[0] == '\n' {
+			ok = true
+			break
+		}
+
+		// non ASCII chars are disallowed, but we are lenient,
+		// since Go doesn't use null-terminated strings.
+
+		// The RFC allows a comment after a space, however,
+		// all of it (version and comments) goes into the
+		// session hash.
+		versionString = append(versionString, buf[0])
+	}
+
+	if !ok {
+		return nil, errors.New("ssh: overflow reading version string")
+	}
+
+	// There might be a '\r' on the end which we should remove.
+	if len(versionString) > 0 && versionString[len(versionString)-1] == '\r' {
+		versionString = versionString[:len(versionString)-1]
+	}
+	return versionString, nil
+}
diff --git a/vendor/golang.org/x/text/doc.go b/vendor/golang.org/x/text/doc.go
new file mode 100644
index 0000000..a48e284
--- /dev/null
+++ b/vendor/golang.org/x/text/doc.go
@@ -0,0 +1,13 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:generate go run gen.go
+
+// text is a repository of text-related packages related to internationalization
+// (i18n) and localization (l10n), such as character encodings, text
+// transformations, and locale-specific text handling.
+package text
+
+// TODO: more documentation on general concepts, such as Transformers, use
+// of normalization, etc.
diff --git a/vendor/golang.org/x/text/gen.go b/vendor/golang.org/x/text/gen.go
new file mode 100644
index 0000000..79af97e
--- /dev/null
+++ b/vendor/golang.org/x/text/gen.go
@@ -0,0 +1,292 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build ignore
+
+// gen runs go generate on Unicode- and CLDR-related package in the text
+// repositories, taking into account dependencies and versions.
+package main
+
+import (
+	"bytes"
+	"flag"
+	"fmt"
+	"go/build"
+	"go/format"
+	"io/ioutil"
+	"os"
+	"os/exec"
+	"path"
+	"path/filepath"
+	"regexp"
+	"runtime"
+	"strings"
+	"sync"
+	"unicode"
+
+	"golang.org/x/text/internal/gen"
+)
+
+var (
+	verbose     = flag.Bool("v", false, "verbose output")
+	force       = flag.Bool("force", false, "ignore failing dependencies")
+	doCore      = flag.Bool("core", false, "force an update to core")
+	excludeList = flag.String("exclude", "",
+		"comma-separated list of packages to exclude")
+
+	// The user can specify a selection of packages to build on the command line.
+	args []string
+)
+
+func exclude(pkg string) bool {
+	if len(args) > 0 {
+		return !contains(args, pkg)
+	}
+	return contains(strings.Split(*excludeList, ","), pkg)
+}
+
+// TODO:
+// - Better version handling.
+// - Generate tables for the core unicode package?
+// - Add generation for encodings. This requires some retooling here and there.
+// - Running repo-wide "long" tests.
+
+var vprintf = fmt.Printf
+
+func main() {
+	gen.Init()
+	args = flag.Args()
+	if !*verbose {
+		// Set vprintf to a no-op.
+		vprintf = func(string, ...interface{}) (int, error) { return 0, nil }
+	}
+
+	// TODO: create temporary cache directory to load files and create and set
+	// a "cache" option if the user did not specify the UNICODE_DIR environment
+	// variable. This will prevent duplicate downloads and also will enable long
+	// tests, which really need to be run after each generated package.
+
+	updateCore := *doCore
+	if gen.UnicodeVersion() != unicode.Version {
+		fmt.Printf("Requested Unicode version %s; core unicode version is %s.\n",
+			gen.UnicodeVersion(),
+			unicode.Version)
+		// TODO: use collate to compare. Simple comparison will work, though,
+		// until Unicode reaches version 10. To avoid circular dependencies, we
+		// could use the NumericWeighter without using package collate using a
+		// trivial Weighter implementation.
+		if gen.UnicodeVersion() < unicode.Version && !*force {
+			os.Exit(2)
+		}
+		updateCore = true
+	}
+
+	var unicode = &dependency{}
+	if updateCore {
+		fmt.Printf("Updating core to version %s...\n", gen.UnicodeVersion())
+		unicode = generate("unicode")
+
+		// Test some users of the unicode packages, especially the ones that
+		// keep a mirrored table. These may need to be corrected by hand.
+		generate("regexp", unicode)
+		generate("strconv", unicode) // mimics Unicode table
+		generate("strings", unicode)
+		generate("testing", unicode) // mimics Unicode table
+	}
+
+	var (
+		cldr       = generate("./unicode/cldr", unicode)
+		language   = generate("./language", cldr)
+		internal   = generate("./internal", unicode, language)
+		norm       = generate("./unicode/norm", unicode)
+		rangetable = generate("./unicode/rangetable", unicode)
+		cases      = generate("./cases", unicode, norm, language, rangetable)
+		width      = generate("./width", unicode)
+		bidi       = generate("./unicode/bidi", unicode, norm, rangetable)
+		mib        = generate("./encoding/internal/identifier", unicode)
+		_          = generate("./encoding/htmlindex", unicode, language, mib)
+		_          = generate("./encoding/ianaindex", unicode, language, mib)
+		_          = generate("./secure/precis", unicode, norm, rangetable, cases, width, bidi)
+		_          = generate("./currency", unicode, cldr, language, internal)
+		_          = generate("./internal/number", unicode, cldr, language, internal)
+		_          = generate("./feature/plural", unicode, cldr, language, internal)
+		_          = generate("./internal/export/idna", unicode, bidi, norm)
+		_          = generate("./language/display", unicode, cldr, language, internal)
+		_          = generate("./collate", unicode, norm, cldr, language, rangetable)
+		_          = generate("./search", unicode, norm, cldr, language, rangetable)
+	)
+	all.Wait()
+
+	// Copy exported packages to the destination golang.org repo.
+	copyExported("golang.org/x/net/idna")
+
+	if updateCore {
+		copyVendored()
+	}
+
+	if hasErrors {
+		fmt.Println("FAIL")
+		os.Exit(1)
+	}
+	vprintf("SUCCESS\n")
+}
+
+var (
+	all       sync.WaitGroup
+	hasErrors bool
+)
+
+type dependency struct {
+	sync.WaitGroup
+	hasErrors bool
+}
+
+func generate(pkg string, deps ...*dependency) *dependency {
+	var wg dependency
+	if exclude(pkg) {
+		return &wg
+	}
+	wg.Add(1)
+	all.Add(1)
+	go func() {
+		defer wg.Done()
+		defer all.Done()
+		// Wait for dependencies to finish.
+		for _, d := range deps {
+			d.Wait()
+			if d.hasErrors && !*force {
+				fmt.Printf("--- ABORT: %s\n", pkg)
+				wg.hasErrors = true
+				return
+			}
+		}
+		vprintf("=== GENERATE %s\n", pkg)
+		args := []string{"generate"}
+		if *verbose {
+			args = append(args, "-v")
+		}
+		args = append(args, pkg)
+		cmd := exec.Command(filepath.Join(runtime.GOROOT(), "bin", "go"), args...)
+		w := &bytes.Buffer{}
+		cmd.Stderr = w
+		cmd.Stdout = w
+		if err := cmd.Run(); err != nil {
+			fmt.Printf("--- FAIL: %s:\n\t%v\n\tError: %v\n", pkg, indent(w), err)
+			hasErrors = true
+			wg.hasErrors = true
+			return
+		}
+
+		vprintf("=== TEST %s\n", pkg)
+		args[0] = "test"
+		cmd = exec.Command(filepath.Join(runtime.GOROOT(), "bin", "go"), args...)
+		wt := &bytes.Buffer{}
+		cmd.Stderr = wt
+		cmd.Stdout = wt
+		if err := cmd.Run(); err != nil {
+			fmt.Printf("--- FAIL: %s:\n\t%v\n\tError: %v\n", pkg, indent(wt), err)
+			hasErrors = true
+			wg.hasErrors = true
+			return
+		}
+		vprintf("--- SUCCESS: %s\n\t%v\n", pkg, indent(w))
+		fmt.Print(wt.String())
+	}()
+	return &wg
+}
+
+// copyExported copies a package in x/text/internal/export to the
+// destination repository.
+func copyExported(p string) {
+	copyPackage(
+		filepath.Join("internal", "export", path.Base(p)),
+		filepath.Join("..", filepath.FromSlash(p[len("golang.org/x"):])),
+		"golang.org/x/text/internal/export/"+path.Base(p),
+		p)
+}
+
+// copyVendored copies packages used by Go core into the vendored directory.
+func copyVendored() {
+	root := filepath.Join(build.Default.GOROOT, filepath.FromSlash("src/vendor/golang_org/x"))
+
+	err := filepath.Walk(root, func(dir string, info os.FileInfo, err error) error {
+		if err != nil || !info.IsDir() || root == dir {
+			return err
+		}
+		src := dir[len(root)+1:]
+		const slash = string(filepath.Separator)
+		if c := strings.Split(src, slash); c[0] == "text" {
+			// Copy a text repo package from its normal location.
+			src = strings.Join(c[1:], slash)
+		} else {
+			// Copy the vendored package if it exists in the export directory.
+			src = filepath.Join("internal", "export", filepath.Base(src))
+		}
+		copyPackage(src, dir, "golang.org", "golang_org")
+		return nil
+	})
+	if err != nil {
+		fmt.Printf("Seeding directory %s has failed %v:", root, err)
+		os.Exit(1)
+	}
+}
+
+// goGenRE is used to remove go:generate lines.
+var goGenRE = regexp.MustCompile("//go:generate[^\n]*\n")
+
+// copyPackage copies relevant files from a directory in x/text to the
+// destination package directory. The destination package is assumed to have
+// the same name. For each copied file go:generate lines are removed and
+// and package comments are rewritten to the new path.
+func copyPackage(dirSrc, dirDst, search, replace string) {
+	err := filepath.Walk(dirSrc, func(file string, info os.FileInfo, err error) error {
+		base := filepath.Base(file)
+		if err != nil || info.IsDir() ||
+			!strings.HasSuffix(base, ".go") ||
+			strings.HasSuffix(base, "_test.go") && !strings.HasPrefix(base, "example") ||
+			// Don't process subdirectories.
+			filepath.Dir(file) != dirSrc {
+			return nil
+		}
+		b, err := ioutil.ReadFile(file)
+		if err != nil || bytes.Contains(b, []byte("\n// +build ignore")) {
+			return err
+		}
+		// Fix paths.
+		b = bytes.Replace(b, []byte(search), []byte(replace), -1)
+		// Remove go:generate lines.
+		b = goGenRE.ReplaceAllLiteral(b, nil)
+		comment := "// Code generated by running \"go generate\" in golang.org/x/text. DO NOT EDIT.\n\n"
+		if *doCore {
+			comment = "// Code generated by running \"go run gen.go -core\" in golang.org/x/text. DO NOT EDIT.\n\n"
+		}
+		if !bytes.HasPrefix(b, []byte(comment)) {
+			b = append([]byte(comment), b...)
+		}
+		if b, err = format.Source(b); err != nil {
+			fmt.Println("Failed to format file:", err)
+			os.Exit(1)
+		}
+		file = filepath.Join(dirDst, base)
+		vprintf("=== COPY %s\n", file)
+		return ioutil.WriteFile(file, b, 0666)
+	})
+	if err != nil {
+		fmt.Println("Copying exported files failed:", err)
+		os.Exit(1)
+	}
+}
+
+func contains(a []string, s string) bool {
+	for _, e := range a {
+		if s == e {
+			return true
+		}
+	}
+	return false
+}
+
+func indent(b *bytes.Buffer) string {
+	return strings.Replace(strings.TrimSpace(b.String()), "\n", "\n\t", -1)
+}
diff --git a/vendor/golang.org/x/text/internal/gen.go b/vendor/golang.org/x/text/internal/gen.go
new file mode 100644
index 0000000..1d678af
--- /dev/null
+++ b/vendor/golang.org/x/text/internal/gen.go
@@ -0,0 +1,52 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build ignore
+
+package main
+
+import (
+	"log"
+
+	"golang.org/x/text/internal/gen"
+	"golang.org/x/text/language"
+	"golang.org/x/text/unicode/cldr"
+)
+
+func main() {
+	r := gen.OpenCLDRCoreZip()
+	defer r.Close()
+
+	d := &cldr.Decoder{}
+	data, err := d.DecodeZip(r)
+	if err != nil {
+		log.Fatalf("DecodeZip: %v", err)
+	}
+
+	w := gen.NewCodeWriter()
+	defer w.WriteGoFile("tables.go", "internal")
+
+	// Create parents table.
+	parents := make([]uint16, language.NumCompactTags)
+	for _, loc := range data.Locales() {
+		tag := language.MustParse(loc)
+		index, ok := language.CompactIndex(tag)
+		if !ok {
+			continue
+		}
+		parentIndex := 0 // und
+		for p := tag.Parent(); p != language.Und; p = p.Parent() {
+			if x, ok := language.CompactIndex(p); ok {
+				parentIndex = x
+				break
+			}
+		}
+		parents[index] = uint16(parentIndex)
+	}
+
+	w.WriteComment(`
+	Parent maps a compact index of a tag to the compact index of the parent of
+	this tag.`)
+	w.WriteVar("Parent", parents)
+}
diff --git a/vendor/golang.org/x/text/internal/gen/code.go b/vendor/golang.org/x/text/internal/gen/code.go
new file mode 100644
index 0000000..d7031b6
--- /dev/null
+++ b/vendor/golang.org/x/text/internal/gen/code.go
@@ -0,0 +1,351 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package gen
+
+import (
+	"bytes"
+	"encoding/gob"
+	"fmt"
+	"hash"
+	"hash/fnv"
+	"io"
+	"log"
+	"os"
+	"reflect"
+	"strings"
+	"unicode"
+	"unicode/utf8"
+)
+
+// This file contains utilities for generating code.
+
+// TODO: other write methods like:
+// - slices, maps, types, etc.
+
+// CodeWriter is a utility for writing structured code. It computes the content
+// hash and size of written content. It ensures there are newlines between
+// written code blocks.
+type CodeWriter struct {
+	buf  bytes.Buffer
+	Size int
+	Hash hash.Hash32 // content hash
+	gob  *gob.Encoder
+	// For comments we skip the usual one-line separator if they are followed by
+	// a code block.
+	skipSep bool
+}
+
+func (w *CodeWriter) Write(p []byte) (n int, err error) {
+	return w.buf.Write(p)
+}
+
+// NewCodeWriter returns a new CodeWriter.
+func NewCodeWriter() *CodeWriter {
+	h := fnv.New32()
+	return &CodeWriter{Hash: h, gob: gob.NewEncoder(h)}
+}
+
+// WriteGoFile appends the buffer with the total size of all created structures
+// and writes it as a Go file to the the given file with the given package name.
+func (w *CodeWriter) WriteGoFile(filename, pkg string) {
+	f, err := os.Create(filename)
+	if err != nil {
+		log.Fatalf("Could not create file %s: %v", filename, err)
+	}
+	defer f.Close()
+	if _, err = w.WriteGo(f, pkg); err != nil {
+		log.Fatalf("Error writing file %s: %v", filename, err)
+	}
+}
+
+// WriteGo appends the buffer with the total size of all created structures and
+// writes it as a Go file to the the given writer with the given package name.
+func (w *CodeWriter) WriteGo(out io.Writer, pkg string) (n int, err error) {
+	sz := w.Size
+	w.WriteComment("Total table size %d bytes (%dKiB); checksum: %X\n", sz, sz/1024, w.Hash.Sum32())
+	defer w.buf.Reset()
+	return WriteGo(out, pkg, w.buf.Bytes())
+}
+
+func (w *CodeWriter) printf(f string, x ...interface{}) {
+	fmt.Fprintf(w, f, x...)
+}
+
+func (w *CodeWriter) insertSep() {
+	if w.skipSep {
+		w.skipSep = false
+		return
+	}
+	// Use at least two newlines to ensure a blank space between the previous
+	// block. WriteGoFile will remove extraneous newlines.
+	w.printf("\n\n")
+}
+
+// WriteComment writes a comment block. All line starts are prefixed with "//".
+// Initial empty lines are gobbled. The indentation for the first line is
+// stripped from consecutive lines.
+func (w *CodeWriter) WriteComment(comment string, args ...interface{}) {
+	s := fmt.Sprintf(comment, args...)
+	s = strings.Trim(s, "\n")
+
+	// Use at least two newlines to ensure a blank space between the previous
+	// block. WriteGoFile will remove extraneous newlines.
+	w.printf("\n\n// ")
+	w.skipSep = true
+
+	// strip first indent level.
+	sep := "\n"
+	for ; len(s) > 0 && (s[0] == '\t' || s[0] == ' '); s = s[1:] {
+		sep += s[:1]
+	}
+
+	strings.NewReplacer(sep, "\n// ", "\n", "\n// ").WriteString(w, s)
+
+	w.printf("\n")
+}
+
+func (w *CodeWriter) writeSizeInfo(size int) {
+	w.printf("// Size: %d bytes\n", size)
+}
+
+// WriteConst writes a constant of the given name and value.
+func (w *CodeWriter) WriteConst(name string, x interface{}) {
+	w.insertSep()
+	v := reflect.ValueOf(x)
+
+	switch v.Type().Kind() {
+	case reflect.String:
+		w.printf("const %s %s = ", name, typeName(x))
+		w.WriteString(v.String())
+		w.printf("\n")
+	default:
+		w.printf("const %s = %#v\n", name, x)
+	}
+}
+
+// WriteVar writes a variable of the given name and value.
+func (w *CodeWriter) WriteVar(name string, x interface{}) {
+	w.insertSep()
+	v := reflect.ValueOf(x)
+	oldSize := w.Size
+	sz := int(v.Type().Size())
+	w.Size += sz
+
+	switch v.Type().Kind() {
+	case reflect.String:
+		w.printf("var %s %s = ", name, typeName(x))
+		w.WriteString(v.String())
+	case reflect.Struct:
+		w.gob.Encode(x)
+		fallthrough
+	case reflect.Slice, reflect.Array:
+		w.printf("var %s = ", name)
+		w.writeValue(v)
+		w.writeSizeInfo(w.Size - oldSize)
+	default:
+		w.printf("var %s %s = ", name, typeName(x))
+		w.gob.Encode(x)
+		w.writeValue(v)
+		w.writeSizeInfo(w.Size - oldSize)
+	}
+	w.printf("\n")
+}
+
+func (w *CodeWriter) writeValue(v reflect.Value) {
+	x := v.Interface()
+	switch v.Kind() {
+	case reflect.String:
+		w.WriteString(v.String())
+	case reflect.Array:
+		// Don't double count: callers of WriteArray count on the size being
+		// added, so we need to discount it here.
+		w.Size -= int(v.Type().Size())
+		w.writeSlice(x, true)
+	case reflect.Slice:
+		w.writeSlice(x, false)
+	case reflect.Struct:
+		w.printf("%s{\n", typeName(v.Interface()))
+		t := v.Type()
+		for i := 0; i < v.NumField(); i++ {
+			w.printf("%s: ", t.Field(i).Name)
+			w.writeValue(v.Field(i))
+			w.printf(",\n")
+		}
+		w.printf("}")
+	default:
+		w.printf("%#v", x)
+	}
+}
+
+// WriteString writes a string literal.
+func (w *CodeWriter) WriteString(s string) {
+	s = strings.Replace(s, `\`, `\\`, -1)
+	io.WriteString(w.Hash, s) // content hash
+	w.Size += len(s)
+
+	const maxInline = 40
+	if len(s) <= maxInline {
+		w.printf("%q", s)
+		return
+	}
+
+	// We will render the string as a multi-line string.
+	const maxWidth = 80 - 4 - len(`"`) - len(`" +`)
+
+	// When starting on its own line, go fmt indents line 2+ an extra level.
+	n, max := maxWidth, maxWidth-4
+
+	// As per https://golang.org/issue/18078, the compiler has trouble
+	// compiling the concatenation of many strings, s0 + s1 + s2 + ... + sN,
+	// for large N. We insert redundant, explicit parentheses to work around
+	// that, lowering the N at any given step: (s0 + s1 + ... + s63) + (s64 +
+	// ... + s127) + etc + (etc + ... + sN).
+	explicitParens, extraComment := len(s) > 128*1024, ""
+	if explicitParens {
+		w.printf(`(`)
+		extraComment = "; the redundant, explicit parens are for https://golang.org/issue/18078"
+	}
+
+	// Print "" +\n, if a string does not start on its own line.
+	b := w.buf.Bytes()
+	if p := len(bytes.TrimRight(b, " \t")); p > 0 && b[p-1] != '\n' {
+		w.printf("\"\" + // Size: %d bytes%s\n", len(s), extraComment)
+		n, max = maxWidth, maxWidth
+	}
+
+	w.printf(`"`)
+
+	for sz, p, nLines := 0, 0, 0; p < len(s); {
+		var r rune
+		r, sz = utf8.DecodeRuneInString(s[p:])
+		out := s[p : p+sz]
+		chars := 1
+		if !unicode.IsPrint(r) || r == utf8.RuneError || r == '"' {
+			switch sz {
+			case 1:
+				out = fmt.Sprintf("\\x%02x", s[p])
+			case 2, 3:
+				out = fmt.Sprintf("\\u%04x", r)
+			case 4:
+				out = fmt.Sprintf("\\U%08x", r)
+			}
+			chars = len(out)
+		}
+		if n -= chars; n < 0 {
+			nLines++
+			if explicitParens && nLines&63 == 63 {
+				w.printf("\") + (\"")
+			}
+			w.printf("\" +\n\"")
+			n = max - len(out)
+		}
+		w.printf("%s", out)
+		p += sz
+	}
+	w.printf(`"`)
+	if explicitParens {
+		w.printf(`)`)
+	}
+}
+
+// WriteSlice writes a slice value.
+func (w *CodeWriter) WriteSlice(x interface{}) {
+	w.writeSlice(x, false)
+}
+
+// WriteArray writes an array value.
+func (w *CodeWriter) WriteArray(x interface{}) {
+	w.writeSlice(x, true)
+}
+
+func (w *CodeWriter) writeSlice(x interface{}, isArray bool) {
+	v := reflect.ValueOf(x)
+	w.gob.Encode(v.Len())
+	w.Size += v.Len() * int(v.Type().Elem().Size())
+	name := typeName(x)
+	if isArray {
+		name = fmt.Sprintf("[%d]%s", v.Len(), name[strings.Index(name, "]")+1:])
+	}
+	if isArray {
+		w.printf("%s{\n", name)
+	} else {
+		w.printf("%s{ // %d elements\n", name, v.Len())
+	}
+
+	switch kind := v.Type().Elem().Kind(); kind {
+	case reflect.String:
+		for _, s := range x.([]string) {
+			w.WriteString(s)
+			w.printf(",\n")
+		}
+	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
+		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
+		// nLine and nBlock are the number of elements per line and block.
+		nLine, nBlock, format := 8, 64, "%d,"
+		switch kind {
+		case reflect.Uint8:
+			format = "%#02x,"
+		case reflect.Uint16:
+			format = "%#04x,"
+		case reflect.Uint32:
+			nLine, nBlock, format = 4, 32, "%#08x,"
+		case reflect.Uint, reflect.Uint64:
+			nLine, nBlock, format = 4, 32, "%#016x,"
+		case reflect.Int8:
+			nLine = 16
+		}
+		n := nLine
+		for i := 0; i < v.Len(); i++ {
+			if i%nBlock == 0 && v.Len() > nBlock {
+				w.printf("// Entry %X - %X\n", i, i+nBlock-1)
+			}
+			x := v.Index(i).Interface()
+			w.gob.Encode(x)
+			w.printf(format, x)
+			if n--; n == 0 {
+				n = nLine
+				w.printf("\n")
+			}
+		}
+		w.printf("\n")
+	case reflect.Struct:
+		zero := reflect.Zero(v.Type().Elem()).Interface()
+		for i := 0; i < v.Len(); i++ {
+			x := v.Index(i).Interface()
+			w.gob.EncodeValue(v)
+			if !reflect.DeepEqual(zero, x) {
+				line := fmt.Sprintf("%#v,\n", x)
+				line = line[strings.IndexByte(line, '{'):]
+				w.printf("%d: ", i)
+				w.printf(line)
+			}
+		}
+	case reflect.Array:
+		for i := 0; i < v.Len(); i++ {
+			w.printf("%d: %#v,\n", i, v.Index(i).Interface())
+		}
+	default:
+		panic("gen: slice elem type not supported")
+	}
+	w.printf("}")
+}
+
+// WriteType writes a definition of the type of the given value and returns the
+// type name.
+func (w *CodeWriter) WriteType(x interface{}) string {
+	t := reflect.TypeOf(x)
+	w.printf("type %s struct {\n", t.Name())
+	for i := 0; i < t.NumField(); i++ {
+		w.printf("\t%s %s\n", t.Field(i).Name, t.Field(i).Type)
+	}
+	w.printf("}\n")
+	return t.Name()
+}
+
+// typeName returns the name of the go type of x.
+func typeName(x interface{}) string {
+	t := reflect.ValueOf(x).Type()
+	return strings.Replace(fmt.Sprint(t), "main.", "", 1)
+}
diff --git a/vendor/golang.org/x/text/internal/gen/gen.go b/vendor/golang.org/x/text/internal/gen/gen.go
new file mode 100644
index 0000000..2acb035
--- /dev/null
+++ b/vendor/golang.org/x/text/internal/gen/gen.go
@@ -0,0 +1,281 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package gen contains common code for the various code generation tools in the
+// text repository. Its usage ensures consistency between tools.
+//
+// This package defines command line flags that are common to most generation
+// tools. The flags allow for specifying specific Unicode and CLDR versions
+// in the public Unicode data repository (http://www.unicode.org/Public).
+//
+// A local Unicode data mirror can be set through the flag -local or the
+// environment variable UNICODE_DIR. The former takes precedence. The local
+// directory should follow the same structure as the public repository.
+//
+// IANA data can also optionally be mirrored by putting it in the iana directory
+// rooted at the top of the local mirror. Beware, though, that IANA data is not
+// versioned. So it is up to the developer to use the right version.
+package gen // import "golang.org/x/text/internal/gen"
+
+import (
+	"bytes"
+	"flag"
+	"fmt"
+	"go/build"
+	"go/format"
+	"io"
+	"io/ioutil"
+	"log"
+	"net/http"
+	"os"
+	"path"
+	"path/filepath"
+	"sync"
+	"unicode"
+
+	"golang.org/x/text/unicode/cldr"
+)
+
+var (
+	url = flag.String("url",
+		"http://www.unicode.org/Public",
+		"URL of Unicode database directory")
+	iana = flag.String("iana",
+		"http://www.iana.org",
+		"URL of the IANA repository")
+	unicodeVersion = flag.String("unicode",
+		getEnv("UNICODE_VERSION", unicode.Version),
+		"unicode version to use")
+	cldrVersion = flag.String("cldr",
+		getEnv("CLDR_VERSION", cldr.Version),
+		"cldr version to use")
+)
+
+func getEnv(name, def string) string {
+	if v := os.Getenv(name); v != "" {
+		return v
+	}
+	return def
+}
+
+// Init performs common initialization for a gen command. It parses the flags
+// and sets up the standard logging parameters.
+func Init() {
+	log.SetPrefix("")
+	log.SetFlags(log.Lshortfile)
+	flag.Parse()
+}
+
+const header = `// Code generated by running "go generate" in golang.org/x/text. DO NOT EDIT.
+
+package %s
+
+`
+
+// UnicodeVersion reports the requested Unicode version.
+func UnicodeVersion() string {
+	return *unicodeVersion
+}
+
+// UnicodeVersion reports the requested CLDR version.
+func CLDRVersion() string {
+	return *cldrVersion
+}
+
+// IsLocal reports whether data files are available locally.
+func IsLocal() bool {
+	dir, err := localReadmeFile()
+	if err != nil {
+		return false
+	}
+	if _, err = os.Stat(dir); err != nil {
+		return false
+	}
+	return true
+}
+
+// OpenUCDFile opens the requested UCD file. The file is specified relative to
+// the public Unicode root directory. It will call log.Fatal if there are any
+// errors.
+func OpenUCDFile(file string) io.ReadCloser {
+	return openUnicode(path.Join(*unicodeVersion, "ucd", file))
+}
+
+// OpenCLDRCoreZip opens the CLDR core zip file. It will call log.Fatal if there
+// are any errors.
+func OpenCLDRCoreZip() io.ReadCloser {
+	return OpenUnicodeFile("cldr", *cldrVersion, "core.zip")
+}
+
+// OpenUnicodeFile opens the requested file of the requested category from the
+// root of the Unicode data archive. The file is specified relative to the
+// public Unicode root directory. If version is "", it will use the default
+// Unicode version. It will call log.Fatal if there are any errors.
+func OpenUnicodeFile(category, version, file string) io.ReadCloser {
+	if version == "" {
+		version = UnicodeVersion()
+	}
+	return openUnicode(path.Join(category, version, file))
+}
+
+// OpenIANAFile opens the requested IANA file. The file is specified relative
+// to the IANA root, which is typically either http://www.iana.org or the
+// iana directory in the local mirror. It will call log.Fatal if there are any
+// errors.
+func OpenIANAFile(path string) io.ReadCloser {
+	return Open(*iana, "iana", path)
+}
+
+var (
+	dirMutex sync.Mutex
+	localDir string
+)
+
+const permissions = 0755
+
+func localReadmeFile() (string, error) {
+	p, err := build.Import("golang.org/x/text", "", build.FindOnly)
+	if err != nil {
+		return "", fmt.Errorf("Could not locate package: %v", err)
+	}
+	return filepath.Join(p.Dir, "DATA", "README"), nil
+}
+
+func getLocalDir() string {
+	dirMutex.Lock()
+	defer dirMutex.Unlock()
+
+	readme, err := localReadmeFile()
+	if err != nil {
+		log.Fatal(err)
+	}
+	dir := filepath.Dir(readme)
+	if _, err := os.Stat(readme); err != nil {
+		if err := os.MkdirAll(dir, permissions); err != nil {
+			log.Fatalf("Could not create directory: %v", err)
+		}
+		ioutil.WriteFile(readme, []byte(readmeTxt), permissions)
+	}
+	return dir
+}
+
+const readmeTxt = `Generated by golang.org/x/text/internal/gen. DO NOT EDIT.
+
+This directory contains downloaded files used to generate the various tables
+in the golang.org/x/text subrepo.
+
+Note that the language subtag repo (iana/assignments/language-subtag-registry)
+and all other times in the iana subdirectory are not versioned and will need
+to be periodically manually updated. The easiest way to do this is to remove
+the entire iana directory. This is mostly of concern when updating the language
+package.
+`
+
+// Open opens subdir/path if a local directory is specified and the file exists,
+// where subdir is a directory relative to the local root, or fetches it from
+// urlRoot/path otherwise. It will call log.Fatal if there are any errors.
+func Open(urlRoot, subdir, path string) io.ReadCloser {
+	file := filepath.Join(getLocalDir(), subdir, filepath.FromSlash(path))
+	return open(file, urlRoot, path)
+}
+
+func openUnicode(path string) io.ReadCloser {
+	file := filepath.Join(getLocalDir(), filepath.FromSlash(path))
+	return open(file, *url, path)
+}
+
+// TODO: automatically periodically update non-versioned files.
+
+func open(file, urlRoot, path string) io.ReadCloser {
+	if f, err := os.Open(file); err == nil {
+		return f
+	}
+	r := get(urlRoot, path)
+	defer r.Close()
+	b, err := ioutil.ReadAll(r)
+	if err != nil {
+		log.Fatalf("Could not download file: %v", err)
+	}
+	os.MkdirAll(filepath.Dir(file), permissions)
+	if err := ioutil.WriteFile(file, b, permissions); err != nil {
+		log.Fatalf("Could not create file: %v", err)
+	}
+	return ioutil.NopCloser(bytes.NewReader(b))
+}
+
+func get(root, path string) io.ReadCloser {
+	url := root + "/" + path
+	fmt.Printf("Fetching %s...", url)
+	defer fmt.Println(" done.")
+	resp, err := http.Get(url)
+	if err != nil {
+		log.Fatalf("HTTP GET: %v", err)
+	}
+	if resp.StatusCode != 200 {
+		log.Fatalf("Bad GET status for %q: %q", url, resp.Status)
+	}
+	return resp.Body
+}
+
+// TODO: use Write*Version in all applicable packages.
+
+// WriteUnicodeVersion writes a constant for the Unicode version from which the
+// tables are generated.
+func WriteUnicodeVersion(w io.Writer) {
+	fmt.Fprintf(w, "// UnicodeVersion is the Unicode version from which the tables in this package are derived.\n")
+	fmt.Fprintf(w, "const UnicodeVersion = %q\n\n", UnicodeVersion())
+}
+
+// WriteCLDRVersion writes a constant for the CLDR version from which the
+// tables are generated.
+func WriteCLDRVersion(w io.Writer) {
+	fmt.Fprintf(w, "// CLDRVersion is the CLDR version from which the tables in this package are derived.\n")
+	fmt.Fprintf(w, "const CLDRVersion = %q\n\n", CLDRVersion())
+}
+
+// WriteGoFile prepends a standard file comment and package statement to the
+// given bytes, applies gofmt, and writes them to a file with the given name.
+// It will call log.Fatal if there are any errors.
+func WriteGoFile(filename, pkg string, b []byte) {
+	w, err := os.Create(filename)
+	if err != nil {
+		log.Fatalf("Could not create file %s: %v", filename, err)
+	}
+	defer w.Close()
+	if _, err = WriteGo(w, pkg, b); err != nil {
+		log.Fatalf("Error writing file %s: %v", filename, err)
+	}
+}
+
+// WriteGo prepends a standard file comment and package statement to the given
+// bytes, applies gofmt, and writes them to w.
+func WriteGo(w io.Writer, pkg string, b []byte) (n int, err error) {
+	src := []byte(fmt.Sprintf(header, pkg))
+	src = append(src, b...)
+	formatted, err := format.Source(src)
+	if err != nil {
+		// Print the generated code even in case of an error so that the
+		// returned error can be meaningfully interpreted.
+		n, _ = w.Write(src)
+		return n, err
+	}
+	return w.Write(formatted)
+}
+
+// Repackage rewrites a Go file from belonging to package main to belonging to
+// the given package.
+func Repackage(inFile, outFile, pkg string) {
+	src, err := ioutil.ReadFile(inFile)
+	if err != nil {
+		log.Fatalf("reading %s: %v", inFile, err)
+	}
+	const toDelete = "package main\n\n"
+	i := bytes.Index(src, []byte(toDelete))
+	if i < 0 {
+		log.Fatalf("Could not find %q in %s.", toDelete, inFile)
+	}
+	w := &bytes.Buffer{}
+	w.Write(src[i+len(toDelete):])
+	WriteGoFile(outFile, pkg, w.Bytes())
+}
diff --git a/vendor/golang.org/x/text/internal/internal.go b/vendor/golang.org/x/text/internal/internal.go
new file mode 100644
index 0000000..eac8328
--- /dev/null
+++ b/vendor/golang.org/x/text/internal/internal.go
@@ -0,0 +1,51 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:generate go run gen.go
+
+// Package internal contains non-exported functionality that are used by
+// packages in the text repository.
+package internal // import "golang.org/x/text/internal"
+
+import (
+	"sort"
+
+	"golang.org/x/text/language"
+)
+
+// SortTags sorts tags in place.
+func SortTags(tags []language.Tag) {
+	sort.Sort(sorter(tags))
+}
+
+type sorter []language.Tag
+
+func (s sorter) Len() int {
+	return len(s)
+}
+
+func (s sorter) Swap(i, j int) {
+	s[i], s[j] = s[j], s[i]
+}
+
+func (s sorter) Less(i, j int) bool {
+	return s[i].String() < s[j].String()
+}
+
+// UniqueTags sorts and filters duplicate tags in place and returns a slice with
+// only unique tags.
+func UniqueTags(tags []language.Tag) []language.Tag {
+	if len(tags) <= 1 {
+		return tags
+	}
+	SortTags(tags)
+	k := 0
+	for i := 1; i < len(tags); i++ {
+		if tags[k].String() < tags[i].String() {
+			k++
+			tags[k] = tags[i]
+		}
+	}
+	return tags[:k+1]
+}
diff --git a/vendor/golang.org/x/text/internal/match.go b/vendor/golang.org/x/text/internal/match.go
new file mode 100644
index 0000000..a67fcac
--- /dev/null
+++ b/vendor/golang.org/x/text/internal/match.go
@@ -0,0 +1,67 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package internal
+
+// This file contains matchers that implement CLDR inheritance.
+//
+//     See http://unicode.org/reports/tr35/#Locale_Inheritance.
+//
+// Some of the inheritance described in this document is already handled by
+// the cldr package.
+
+import (
+	"golang.org/x/text/language"
+)
+
+// TODO: consider if (some of the) matching algorithm needs to be public after
+// getting some feel about what is generic and what is specific.
+
+// NewInheritanceMatcher returns a matcher that matches based on the inheritance
+// chain.
+//
+// The matcher uses canonicalization and the parent relationship to find a
+// match. The resulting match will always be either Und or a language with the
+// same language and script as the requested language. It will not match
+// languages for which there is understood to be mutual or one-directional
+// intelligibility.
+//
+// A Match will indicate an Exact match if the language matches after
+// canonicalization and High if the matched tag is a parent.
+func NewInheritanceMatcher(t []language.Tag) *InheritanceMatcher {
+	tags := &InheritanceMatcher{make(map[language.Tag]int)}
+	for i, tag := range t {
+		ct, err := language.All.Canonicalize(tag)
+		if err != nil {
+			ct = tag
+		}
+		tags.index[ct] = i
+	}
+	return tags
+}
+
+type InheritanceMatcher struct {
+	index map[language.Tag]int
+}
+
+func (m InheritanceMatcher) Match(want ...language.Tag) (language.Tag, int, language.Confidence) {
+	for _, t := range want {
+		ct, err := language.All.Canonicalize(t)
+		if err != nil {
+			ct = t
+		}
+		conf := language.Exact
+		for {
+			if index, ok := m.index[ct]; ok {
+				return ct, index, conf
+			}
+			if ct == language.Und {
+				break
+			}
+			ct = ct.Parent()
+			conf = language.High
+		}
+	}
+	return language.Und, 0, language.No
+}
diff --git a/vendor/golang.org/x/text/internal/tables.go b/vendor/golang.org/x/text/internal/tables.go
new file mode 100644
index 0000000..a53042a
--- /dev/null
+++ b/vendor/golang.org/x/text/internal/tables.go
@@ -0,0 +1,117 @@
+// Code generated by running "go generate" in golang.org/x/text. DO NOT EDIT.
+
+package internal
+
+// Parent maps a compact index of a tag to the compact index of the parent of
+// this tag.
+var Parent = []uint16{ // 754 elements
+	// Entry 0 - 3F
+	0x0000, 0x0053, 0x00e5, 0x0000, 0x0003, 0x0003, 0x0000, 0x0006,
+	0x0000, 0x0008, 0x0000, 0x000a, 0x0000, 0x000c, 0x000c, 0x000c,
+	0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c,
+	0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c,
+	0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c,
+	0x000c, 0x0000, 0x0000, 0x002a, 0x0000, 0x002c, 0x0000, 0x002e,
+	0x0000, 0x0000, 0x0031, 0x0030, 0x0030, 0x0000, 0x0035, 0x0000,
+	0x0037, 0x0000, 0x0039, 0x0000, 0x003b, 0x0000, 0x003d, 0x0000,
+	// Entry 40 - 7F
+	0x0000, 0x0040, 0x0000, 0x0042, 0x0042, 0x0000, 0x0045, 0x0045,
+	0x0000, 0x0048, 0x0000, 0x004a, 0x0000, 0x0000, 0x004d, 0x004c,
+	0x004c, 0x0000, 0x0051, 0x0051, 0x0051, 0x0051, 0x0000, 0x0056,
+	0x0000, 0x0058, 0x0000, 0x005a, 0x0000, 0x005c, 0x005c, 0x0000,
+	0x005f, 0x0000, 0x0061, 0x0000, 0x0063, 0x0000, 0x0065, 0x0065,
+	0x0000, 0x0068, 0x0000, 0x006a, 0x006a, 0x006a, 0x006a, 0x006a,
+	0x006a, 0x006a, 0x0000, 0x0072, 0x0000, 0x0074, 0x0000, 0x0076,
+	0x0000, 0x0000, 0x0079, 0x0000, 0x007b, 0x0000, 0x007d, 0x0000,
+	// Entry 80 - BF
+	0x007f, 0x007f, 0x0000, 0x0082, 0x0082, 0x0000, 0x0085, 0x0086,
+	0x0086, 0x0086, 0x0085, 0x0087, 0x0086, 0x0086, 0x0086, 0x0085,
+	0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0087, 0x0086,
+	0x0086, 0x0086, 0x0086, 0x0087, 0x0086, 0x0087, 0x0086, 0x0086,
+	0x0087, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086,
+	0x0086, 0x0086, 0x0085, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086,
+	0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086,
+	0x0086, 0x0086, 0x0086, 0x0086, 0x0085, 0x0086, 0x0085, 0x0086,
+	// Entry C0 - FF
+	0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0087,
+	0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0085,
+	0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0087, 0x0086, 0x0086,
+	0x0087, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086,
+	0x0086, 0x0086, 0x0086, 0x0086, 0x0085, 0x0085, 0x0086, 0x0086,
+	0x0085, 0x0086, 0x0086, 0x0086, 0x0086, 0x0086, 0x0000, 0x00ee,
+	0x0000, 0x00f0, 0x00f1, 0x00f1, 0x00f1, 0x00f1, 0x00f1, 0x00f1,
+	0x00f1, 0x00f1, 0x00f1, 0x00f0, 0x00f1, 0x00f0, 0x00f0, 0x00f1,
+	// Entry 100 - 13F
+	0x00f1, 0x00f0, 0x00f1, 0x00f1, 0x00f1, 0x00f1, 0x00f0, 0x00f1,
+	0x00f1, 0x00f1, 0x00f1, 0x00f1, 0x00f1, 0x0000, 0x010d, 0x0000,
+	0x010f, 0x0000, 0x0111, 0x0000, 0x0113, 0x0113, 0x0000, 0x0116,
+	0x0116, 0x0116, 0x0116, 0x0000, 0x011b, 0x0000, 0x011d, 0x0000,
+	0x011f, 0x011f, 0x0000, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122,
+	0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122,
+	0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122,
+	0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122,
+	// Entry 140 - 17F
+	0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122,
+	0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122, 0x0122,
+	0x0122, 0x0000, 0x0151, 0x0000, 0x0153, 0x0000, 0x0155, 0x0000,
+	0x0157, 0x0000, 0x0159, 0x0000, 0x015b, 0x015b, 0x015b, 0x0000,
+	0x015f, 0x0000, 0x0000, 0x0162, 0x0000, 0x0164, 0x0000, 0x0166,
+	0x0166, 0x0166, 0x0000, 0x016a, 0x0000, 0x016c, 0x0000, 0x016e,
+	0x0000, 0x0170, 0x0170, 0x0000, 0x0173, 0x0000, 0x0175, 0x0000,
+	0x0177, 0x0000, 0x0179, 0x0000, 0x017b, 0x0000, 0x017d, 0x0000,
+	// Entry 180 - 1BF
+	0x017f, 0x0000, 0x0181, 0x0181, 0x0181, 0x0181, 0x0000, 0x0000,
+	0x0187, 0x0000, 0x0000, 0x018a, 0x0000, 0x018c, 0x0000, 0x0000,
+	0x018f, 0x0000, 0x0191, 0x0000, 0x0000, 0x0194, 0x0000, 0x0000,
+	0x0197, 0x0000, 0x0199, 0x0000, 0x019b, 0x0000, 0x019d, 0x0000,
+	0x019f, 0x0000, 0x01a1, 0x0000, 0x01a3, 0x0000, 0x01a5, 0x0000,
+	0x01a7, 0x0000, 0x01a9, 0x0000, 0x01ab, 0x01ab, 0x0000, 0x01ae,
+	0x0000, 0x01b0, 0x0000, 0x01b2, 0x0000, 0x01b4, 0x0000, 0x01b6,
+	0x0000, 0x0000, 0x01b9, 0x0000, 0x01bb, 0x0000, 0x01bd, 0x0000,
+	// Entry 1C0 - 1FF
+	0x01bf, 0x0000, 0x01c1, 0x0000, 0x01c3, 0x0000, 0x01c5, 0x01c5,
+	0x01c5, 0x01c5, 0x0000, 0x01ca, 0x0000, 0x01cc, 0x01cc, 0x0000,
+	0x01cf, 0x0000, 0x01d1, 0x0000, 0x01d3, 0x0000, 0x01d5, 0x0000,
+	0x01d7, 0x0000, 0x01d9, 0x01d9, 0x0000, 0x01dc, 0x0000, 0x01de,
+	0x0000, 0x01e0, 0x0000, 0x01e2, 0x0000, 0x01e4, 0x0000, 0x01e6,
+	0x0000, 0x01e8, 0x0000, 0x01ea, 0x0000, 0x01ec, 0x0000, 0x01ee,
+	0x01ee, 0x01ee, 0x0000, 0x01f2, 0x0000, 0x01f4, 0x0000, 0x01f6,
+	0x0000, 0x01f8, 0x0000, 0x0000, 0x01fb, 0x0000, 0x01fd, 0x01fd,
+	// Entry 200 - 23F
+	0x0000, 0x0200, 0x0000, 0x0202, 0x0202, 0x0000, 0x0205, 0x0205,
+	0x0000, 0x0208, 0x0208, 0x0208, 0x0208, 0x0208, 0x0208, 0x0208,
+	0x0000, 0x0210, 0x0000, 0x0212, 0x0000, 0x0214, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x021a, 0x0000, 0x0000, 0x021d, 0x0000,
+	0x021f, 0x021f, 0x0000, 0x0222, 0x0000, 0x0224, 0x0224, 0x0000,
+	0x0000, 0x0228, 0x0227, 0x0227, 0x0000, 0x0000, 0x022d, 0x0000,
+	0x022f, 0x0000, 0x0231, 0x0000, 0x023d, 0x0233, 0x023d, 0x023d,
+	0x023d, 0x023d, 0x023d, 0x023d, 0x023d, 0x0233, 0x023d, 0x023d,
+	// Entry 240 - 27F
+	0x0000, 0x0240, 0x0240, 0x0240, 0x0000, 0x0244, 0x0000, 0x0246,
+	0x0000, 0x0248, 0x0248, 0x0000, 0x024b, 0x0000, 0x024d, 0x024d,
+	0x024d, 0x024d, 0x024d, 0x024d, 0x0000, 0x0254, 0x0000, 0x0256,
+	0x0000, 0x0258, 0x0000, 0x025a, 0x0000, 0x025c, 0x0000, 0x0000,
+	0x025f, 0x025f, 0x025f, 0x0000, 0x0263, 0x0000, 0x0265, 0x0000,
+	0x0267, 0x0000, 0x0000, 0x026a, 0x0269, 0x0269, 0x0000, 0x026e,
+	0x0000, 0x0270, 0x0000, 0x0272, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0277, 0x0000, 0x0000, 0x027a, 0x0000, 0x027c, 0x027c, 0x027c,
+	// Entry 280 - 2BF
+	0x027c, 0x0000, 0x0281, 0x0281, 0x0281, 0x0000, 0x0285, 0x0285,
+	0x0285, 0x0285, 0x0285, 0x0000, 0x028b, 0x028b, 0x028b, 0x028b,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0293, 0x0293, 0x0293, 0x0000,
+	0x0297, 0x0297, 0x0297, 0x0297, 0x0000, 0x0000, 0x029d, 0x029d,
+	0x029d, 0x029d, 0x0000, 0x02a2, 0x0000, 0x02a4, 0x02a4, 0x0000,
+	0x02a7, 0x0000, 0x02a9, 0x02a9, 0x0000, 0x0000, 0x02ad, 0x0000,
+	0x0000, 0x02b0, 0x0000, 0x02b2, 0x02b2, 0x0000, 0x0000, 0x02b6,
+	0x0000, 0x02b8, 0x0000, 0x02ba, 0x0000, 0x02bc, 0x0000, 0x02be,
+	// Entry 2C0 - 2FF
+	0x02be, 0x0000, 0x0000, 0x02c2, 0x0000, 0x02c4, 0x02c1, 0x02c1,
+	0x0000, 0x0000, 0x02c9, 0x02c8, 0x02c8, 0x0000, 0x0000, 0x02ce,
+	0x0000, 0x02d0, 0x0000, 0x02d2, 0x0000, 0x0000, 0x02d5, 0x0000,
+	0x0000, 0x0000, 0x02d9, 0x0000, 0x02db, 0x0000, 0x02dd, 0x0000,
+	0x02df, 0x02df, 0x0000, 0x02e2, 0x0000, 0x02e4, 0x0000, 0x02e6,
+	0x02e6, 0x02e6, 0x02e6, 0x02e6, 0x0000, 0x02ec, 0x02ed, 0x02ec,
+	0x0000, 0x02f0,
+} // Size: 1532 bytes
+
+// Total table size 1532 bytes (1KiB); checksum: 90718A2
diff --git a/vendor/golang.org/x/text/internal/triegen/compact.go b/vendor/golang.org/x/text/internal/triegen/compact.go
new file mode 100644
index 0000000..397b975
--- /dev/null
+++ b/vendor/golang.org/x/text/internal/triegen/compact.go
@@ -0,0 +1,58 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package triegen
+
+// This file defines Compacter and its implementations.
+
+import "io"
+
+// A Compacter generates an alternative, more space-efficient way to store a
+// trie value block. A trie value block holds all possible values for the last
+// byte of a UTF-8 encoded rune. Excluding ASCII characters, a trie value block
+// always has 64 values, as a UTF-8 encoding ends with a byte in [0x80, 0xC0).
+type Compacter interface {
+	// Size returns whether the Compacter could encode the given block as well
+	// as its size in case it can. len(v) is always 64.
+	Size(v []uint64) (sz int, ok bool)
+
+	// Store stores the block using the Compacter's compression method.
+	// It returns a handle with which the block can be retrieved.
+	// len(v) is always 64.
+	Store(v []uint64) uint32
+
+	// Print writes the data structures associated to the given store to w.
+	Print(w io.Writer) error
+
+	// Handler returns the name of a function that gets called during trie
+	// lookup for blocks generated by the Compacter. The function should be of
+	// the form func (n uint32, b byte) uint64, where n is the index returned by
+	// the Compacter's Store method and b is the last byte of the UTF-8
+	// encoding, where 0x80 <= b < 0xC0, for which to do the lookup in the
+	// block.
+	Handler() string
+}
+
+// simpleCompacter is the default Compacter used by builder. It implements a
+// normal trie block.
+type simpleCompacter builder
+
+func (b *simpleCompacter) Size([]uint64) (sz int, ok bool) {
+	return blockSize * b.ValueSize, true
+}
+
+func (b *simpleCompacter) Store(v []uint64) uint32 {
+	h := uint32(len(b.ValueBlocks) - blockOffset)
+	b.ValueBlocks = append(b.ValueBlocks, v)
+	return h
+}
+
+func (b *simpleCompacter) Print(io.Writer) error {
+	// Structures are printed in print.go.
+	return nil
+}
+
+func (b *simpleCompacter) Handler() string {
+	panic("Handler should be special-cased for this Compacter")
+}
diff --git a/vendor/golang.org/x/text/internal/triegen/print.go b/vendor/golang.org/x/text/internal/triegen/print.go
new file mode 100644
index 0000000..8d9f120
--- /dev/null
+++ b/vendor/golang.org/x/text/internal/triegen/print.go
@@ -0,0 +1,251 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package triegen
+
+import (
+	"bytes"
+	"fmt"
+	"io"
+	"strings"
+	"text/template"
+)
+
+// print writes all the data structures as well as the code necessary to use the
+// trie to w.
+func (b *builder) print(w io.Writer) error {
+	b.Stats.NValueEntries = len(b.ValueBlocks) * blockSize
+	b.Stats.NValueBytes = len(b.ValueBlocks) * blockSize * b.ValueSize
+	b.Stats.NIndexEntries = len(b.IndexBlocks) * blockSize
+	b.Stats.NIndexBytes = len(b.IndexBlocks) * blockSize * b.IndexSize
+	b.Stats.NHandleBytes = len(b.Trie) * 2 * b.IndexSize
+
+	// If we only have one root trie, all starter blocks are at position 0 and
+	// we can access the arrays directly.
+	if len(b.Trie) == 1 {
+		// At this point we cannot refer to the generated tables directly.
+		b.ASCIIBlock = b.Name + "Values"
+		b.StarterBlock = b.Name + "Index"
+	} else {
+		// Otherwise we need to have explicit starter indexes in the trie
+		// structure.
+		b.ASCIIBlock = "t.ascii"
+		b.StarterBlock = "t.utf8Start"
+	}
+
+	b.SourceType = "[]byte"
+	if err := lookupGen.Execute(w, b); err != nil {
+		return err
+	}
+
+	b.SourceType = "string"
+	if err := lookupGen.Execute(w, b); err != nil {
+		return err
+	}
+
+	if err := trieGen.Execute(w, b); err != nil {
+		return err
+	}
+
+	for _, c := range b.Compactions {
+		if err := c.c.Print(w); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func printValues(n int, values []uint64) string {
+	w := &bytes.Buffer{}
+	boff := n * blockSize
+	fmt.Fprintf(w, "\t// Block %#x, offset %#x", n, boff)
+	var newline bool
+	for i, v := range values {
+		if i%6 == 0 {
+			newline = true
+		}
+		if v != 0 {
+			if newline {
+				fmt.Fprintf(w, "\n")
+				newline = false
+			}
+			fmt.Fprintf(w, "\t%#02x:%#04x, ", boff+i, v)
+		}
+	}
+	return w.String()
+}
+
+func printIndex(b *builder, nr int, n *node) string {
+	w := &bytes.Buffer{}
+	boff := nr * blockSize
+	fmt.Fprintf(w, "\t// Block %#x, offset %#x", nr, boff)
+	var newline bool
+	for i, c := range n.children {
+		if i%8 == 0 {
+			newline = true
+		}
+		if c != nil {
+			v := b.Compactions[c.index.compaction].Offset + uint32(c.index.index)
+			if v != 0 {
+				if newline {
+					fmt.Fprintf(w, "\n")
+					newline = false
+				}
+				fmt.Fprintf(w, "\t%#02x:%#02x, ", boff+i, v)
+			}
+		}
+	}
+	return w.String()
+}
+
+var (
+	trieGen = template.Must(template.New("trie").Funcs(template.FuncMap{
+		"printValues": printValues,
+		"printIndex":  printIndex,
+		"title":       strings.Title,
+		"dec":         func(x int) int { return x - 1 },
+		"psize": func(n int) string {
+			return fmt.Sprintf("%d bytes (%.2f KiB)", n, float64(n)/1024)
+		},
+	}).Parse(trieTemplate))
+	lookupGen = template.Must(template.New("lookup").Parse(lookupTemplate))
+)
+
+// TODO: consider the return type of lookup. It could be uint64, even if the
+// internal value type is smaller. We will have to verify this with the
+// performance of unicode/norm, which is very sensitive to such changes.
+const trieTemplate = `{{$b := .}}{{$multi := gt (len .Trie) 1}}
+// {{.Name}}Trie. Total size: {{psize .Size}}. Checksum: {{printf "%08x" .Checksum}}.
+type {{.Name}}Trie struct { {{if $multi}}
+	ascii []{{.ValueType}} // index for ASCII bytes
+	utf8Start  []{{.IndexType}} // index for UTF-8 bytes >= 0xC0
+{{end}}}
+
+func new{{title .Name}}Trie(i int) *{{.Name}}Trie { {{if $multi}}
+	h := {{.Name}}TrieHandles[i]
+	return &{{.Name}}Trie{ {{.Name}}Values[uint32(h.ascii)<<6:], {{.Name}}Index[uint32(h.multi)<<6:] }
+}
+
+type {{.Name}}TrieHandle struct {
+	ascii, multi {{.IndexType}}
+}
+
+// {{.Name}}TrieHandles: {{len .Trie}} handles, {{.Stats.NHandleBytes}} bytes
+var {{.Name}}TrieHandles = [{{len .Trie}}]{{.Name}}TrieHandle{
+{{range .Trie}}	{ {{.ASCIIIndex}}, {{.StarterIndex}} }, // {{printf "%08x" .Checksum}}: {{.Name}}
+{{end}}}{{else}}
+	return &{{.Name}}Trie{}
+}
+{{end}}
+// lookupValue determines the type of block n and looks up the value for b.
+func (t *{{.Name}}Trie) lookupValue(n uint32, b byte) {{.ValueType}}{{$last := dec (len .Compactions)}} {
+	switch { {{range $i, $c := .Compactions}}
+		{{if eq $i $last}}default{{else}}case n < {{$c.Cutoff}}{{end}}:{{if ne $i 0}}
+			n -= {{$c.Offset}}{{end}}
+			return {{print $b.ValueType}}({{$c.Handler}}){{end}}
+	}
+}
+
+// {{.Name}}Values: {{len .ValueBlocks}} blocks, {{.Stats.NValueEntries}} entries, {{.Stats.NValueBytes}} bytes
+// The third block is the zero block.
+var {{.Name}}Values = [{{.Stats.NValueEntries}}]{{.ValueType}} {
+{{range $i, $v := .ValueBlocks}}{{printValues $i $v}}
+{{end}}}
+
+// {{.Name}}Index: {{len .IndexBlocks}} blocks, {{.Stats.NIndexEntries}} entries, {{.Stats.NIndexBytes}} bytes
+// Block 0 is the zero block.
+var {{.Name}}Index = [{{.Stats.NIndexEntries}}]{{.IndexType}} {
+{{range $i, $v := .IndexBlocks}}{{printIndex $b $i $v}}
+{{end}}}
+`
+
+// TODO: consider allowing zero-length strings after evaluating performance with
+// unicode/norm.
+const lookupTemplate = `
+// lookup{{if eq .SourceType "string"}}String{{end}} returns the trie value for the first UTF-8 encoding in s and
+// the width in bytes of this encoding. The size will be 0 if s does not
+// hold enough bytes to complete the encoding. len(s) must be greater than 0.
+func (t *{{.Name}}Trie) lookup{{if eq .SourceType "string"}}String{{end}}(s {{.SourceType}}) (v {{.ValueType}}, sz int) {
+	c0 := s[0]
+	switch {
+	case c0 < 0x80: // is ASCII
+		return {{.ASCIIBlock}}[c0], 1
+	case c0 < 0xC2:
+		return 0, 1  // Illegal UTF-8: not a starter, not ASCII.
+	case c0 < 0xE0: // 2-byte UTF-8
+		if len(s) < 2 {
+			return 0, 0
+		}
+		i := {{.StarterBlock}}[c0]
+		c1 := s[1]
+		if c1 < 0x80 || 0xC0 <= c1 {
+			return 0, 1 // Illegal UTF-8: not a continuation byte.
+		}
+		return t.lookupValue(uint32(i), c1), 2
+	case c0 < 0xF0: // 3-byte UTF-8
+		if len(s) < 3 {
+			return 0, 0
+		}
+		i := {{.StarterBlock}}[c0]
+		c1 := s[1]
+		if c1 < 0x80 || 0xC0 <= c1 {
+			return 0, 1 // Illegal UTF-8: not a continuation byte.
+		}
+		o := uint32(i)<<6 + uint32(c1)
+		i = {{.Name}}Index[o]
+		c2 := s[2]
+		if c2 < 0x80 || 0xC0 <= c2 {
+			return 0, 2 // Illegal UTF-8: not a continuation byte.
+		}
+		return t.lookupValue(uint32(i), c2), 3
+	case c0 < 0xF8: // 4-byte UTF-8
+		if len(s) < 4 {
+			return 0, 0
+		}
+		i := {{.StarterBlock}}[c0]
+		c1 := s[1]
+		if c1 < 0x80 || 0xC0 <= c1 {
+			return 0, 1 // Illegal UTF-8: not a continuation byte.
+		}
+		o := uint32(i)<<6 + uint32(c1)
+		i = {{.Name}}Index[o]
+		c2 := s[2]
+		if c2 < 0x80 || 0xC0 <= c2 {
+			return 0, 2 // Illegal UTF-8: not a continuation byte.
+		}
+		o = uint32(i)<<6 + uint32(c2)
+		i = {{.Name}}Index[o]
+		c3 := s[3]
+		if c3 < 0x80 || 0xC0 <= c3 {
+			return 0, 3 // Illegal UTF-8: not a continuation byte.
+		}
+		return t.lookupValue(uint32(i), c3), 4
+	}
+	// Illegal rune
+	return 0, 1
+}
+
+// lookup{{if eq .SourceType "string"}}String{{end}}Unsafe returns the trie value for the first UTF-8 encoding in s.
+// s must start with a full and valid UTF-8 encoded rune.
+func (t *{{.Name}}Trie) lookup{{if eq .SourceType "string"}}String{{end}}Unsafe(s {{.SourceType}}) {{.ValueType}} {
+	c0 := s[0]
+	if c0 < 0x80 { // is ASCII
+		return {{.ASCIIBlock}}[c0]
+	}
+	i := {{.StarterBlock}}[c0]
+	if c0 < 0xE0 { // 2-byte UTF-8
+		return t.lookupValue(uint32(i), s[1])
+	}
+	i = {{.Name}}Index[uint32(i)<<6+uint32(s[1])]
+	if c0 < 0xF0 { // 3-byte UTF-8
+		return t.lookupValue(uint32(i), s[2])
+	}
+	i = {{.Name}}Index[uint32(i)<<6+uint32(s[2])]
+	if c0 < 0xF8 { // 4-byte UTF-8
+		return t.lookupValue(uint32(i), s[3])
+	}
+	return 0
+}
+`
diff --git a/vendor/golang.org/x/text/internal/triegen/triegen.go b/vendor/golang.org/x/text/internal/triegen/triegen.go
new file mode 100644
index 0000000..adb0108
--- /dev/null
+++ b/vendor/golang.org/x/text/internal/triegen/triegen.go
@@ -0,0 +1,494 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package triegen implements a code generator for a trie for associating
+// unsigned integer values with UTF-8 encoded runes.
+//
+// Many of the go.text packages use tries for storing per-rune information.  A
+// trie is especially useful if many of the runes have the same value. If this
+// is the case, many blocks can be expected to be shared allowing for
+// information on many runes to be stored in little space.
+//
+// As most of the lookups are done directly on []byte slices, the tries use the
+// UTF-8 bytes directly for the lookup. This saves a conversion from UTF-8 to
+// runes and contributes a little bit to better performance. It also naturally
+// provides a fast path for ASCII.
+//
+// Space is also an issue. There are many code points defined in Unicode and as
+// a result tables can get quite large. So every byte counts. The triegen
+// package automatically chooses the smallest integer values to represent the
+// tables. Compacters allow further compression of the trie by allowing for
+// alternative representations of individual trie blocks.
+//
+// triegen allows generating multiple tries as a single structure. This is
+// useful when, for example, one wants to generate tries for several languages
+// that have a lot of values in common. Some existing libraries for
+// internationalization store all per-language data as a dynamically loadable
+// chunk. The go.text packages are designed with the assumption that the user
+// typically wants to compile in support for all supported languages, in line
+// with the approach common to Go to create a single standalone binary. The
+// multi-root trie approach can give significant storage savings in this
+// scenario.
+//
+// triegen generates both tables and code. The code is optimized to use the
+// automatically chosen data types. The following code is generated for a Trie
+// or multiple Tries named "foo":
+//	- type fooTrie
+//		The trie type.
+//
+//	- func newFooTrie(x int) *fooTrie
+//		Trie constructor, where x is the index of the trie passed to Gen.
+//
+//	- func (t *fooTrie) lookup(s []byte) (v uintX, sz int)
+//		The lookup method, where uintX is automatically chosen.
+//
+//	- func lookupString, lookupUnsafe and lookupStringUnsafe
+//		Variants of the above.
+//
+//	- var fooValues and fooIndex and any tables generated by Compacters.
+//		The core trie data.
+//
+//	- var fooTrieHandles
+//		Indexes of starter blocks in case of multiple trie roots.
+//
+// It is recommended that users test the generated trie by checking the returned
+// value for every rune. Such exhaustive tests are possible as the the number of
+// runes in Unicode is limited.
+package triegen // import "golang.org/x/text/internal/triegen"
+
+// TODO: Arguably, the internally optimized data types would not have to be
+// exposed in the generated API. We could also investigate not generating the
+// code, but using it through a package. We would have to investigate the impact
+// on performance of making such change, though. For packages like unicode/norm,
+// small changes like this could tank performance.
+
+import (
+	"encoding/binary"
+	"fmt"
+	"hash/crc64"
+	"io"
+	"log"
+	"unicode/utf8"
+)
+
+// builder builds a set of tries for associating values with runes. The set of
+// tries can share common index and value blocks.
+type builder struct {
+	Name string
+
+	// ValueType is the type of the trie values looked up.
+	ValueType string
+
+	// ValueSize is the byte size of the ValueType.
+	ValueSize int
+
+	// IndexType is the type of trie index values used for all UTF-8 bytes of
+	// a rune except the last one.
+	IndexType string
+
+	// IndexSize is the byte size of the IndexType.
+	IndexSize int
+
+	// SourceType is used when generating the lookup functions. If the user
+	// requests StringSupport, all lookup functions will be generated for
+	// string input as well.
+	SourceType string
+
+	Trie []*Trie
+
+	IndexBlocks []*node
+	ValueBlocks [][]uint64
+	Compactions []compaction
+	Checksum    uint64
+
+	ASCIIBlock   string
+	StarterBlock string
+
+	indexBlockIdx map[uint64]int
+	valueBlockIdx map[uint64]nodeIndex
+	asciiBlockIdx map[uint64]int
+
+	// Stats are used to fill out the template.
+	Stats struct {
+		NValueEntries int
+		NValueBytes   int
+		NIndexEntries int
+		NIndexBytes   int
+		NHandleBytes  int
+	}
+
+	err error
+}
+
+// A nodeIndex encodes the index of a node, which is defined by the compaction
+// which stores it and an index within the compaction. For internal nodes, the
+// compaction is always 0.
+type nodeIndex struct {
+	compaction int
+	index      int
+}
+
+// compaction keeps track of stats used for the compaction.
+type compaction struct {
+	c         Compacter
+	blocks    []*node
+	maxHandle uint32
+	totalSize int
+
+	// Used by template-based generator and thus exported.
+	Cutoff  uint32
+	Offset  uint32
+	Handler string
+}
+
+func (b *builder) setError(err error) {
+	if b.err == nil {
+		b.err = err
+	}
+}
+
+// An Option can be passed to Gen.
+type Option func(b *builder) error
+
+// Compact configures the trie generator to use the given Compacter.
+func Compact(c Compacter) Option {
+	return func(b *builder) error {
+		b.Compactions = append(b.Compactions, compaction{
+			c:       c,
+			Handler: c.Handler() + "(n, b)"})
+		return nil
+	}
+}
+
+// Gen writes Go code for a shared trie lookup structure to w for the given
+// Tries. The generated trie type will be called nameTrie. newNameTrie(x) will
+// return the *nameTrie for tries[x]. A value can be looked up by using one of
+// the various lookup methods defined on nameTrie. It returns the table size of
+// the generated trie.
+func Gen(w io.Writer, name string, tries []*Trie, opts ...Option) (sz int, err error) {
+	// The index contains two dummy blocks, followed by the zero block. The zero
+	// block is at offset 0x80, so that the offset for the zero block for
+	// continuation bytes is 0.
+	b := &builder{
+		Name:        name,
+		Trie:        tries,
+		IndexBlocks: []*node{{}, {}, {}},
+		Compactions: []compaction{{
+			Handler: name + "Values[n<<6+uint32(b)]",
+		}},
+		// The 0 key in indexBlockIdx and valueBlockIdx is the hash of the zero
+		// block.
+		indexBlockIdx: map[uint64]int{0: 0},
+		valueBlockIdx: map[uint64]nodeIndex{0: {}},
+		asciiBlockIdx: map[uint64]int{},
+	}
+	b.Compactions[0].c = (*simpleCompacter)(b)
+
+	for _, f := range opts {
+		if err := f(b); err != nil {
+			return 0, err
+		}
+	}
+	b.build()
+	if b.err != nil {
+		return 0, b.err
+	}
+	if err = b.print(w); err != nil {
+		return 0, err
+	}
+	return b.Size(), nil
+}
+
+// A Trie represents a single root node of a trie. A builder may build several
+// overlapping tries at once.
+type Trie struct {
+	root *node
+
+	hiddenTrie
+}
+
+// hiddenTrie contains values we want to be visible to the template generator,
+// but hidden from the API documentation.
+type hiddenTrie struct {
+	Name         string
+	Checksum     uint64
+	ASCIIIndex   int
+	StarterIndex int
+}
+
+// NewTrie returns a new trie root.
+func NewTrie(name string) *Trie {
+	return &Trie{
+		&node{
+			children: make([]*node, blockSize),
+			values:   make([]uint64, utf8.RuneSelf),
+		},
+		hiddenTrie{Name: name},
+	}
+}
+
+// Gen is a convenience wrapper around the Gen func passing t as the only trie
+// and uses the name passed to NewTrie. It returns the size of the generated
+// tables.
+func (t *Trie) Gen(w io.Writer, opts ...Option) (sz int, err error) {
+	return Gen(w, t.Name, []*Trie{t}, opts...)
+}
+
+// node is a node of the intermediate trie structure.
+type node struct {
+	// children holds this node's children. It is always of length 64.
+	// A child node may be nil.
+	children []*node
+
+	// values contains the values of this node. If it is non-nil, this node is
+	// either a root or leaf node:
+	// For root nodes, len(values) == 128 and it maps the bytes in [0x00, 0x7F].
+	// For leaf nodes, len(values) ==  64 and it maps the bytes in [0x80, 0xBF].
+	values []uint64
+
+	index nodeIndex
+}
+
+// Insert associates value with the given rune. Insert will panic if a non-zero
+// value is passed for an invalid rune.
+func (t *Trie) Insert(r rune, value uint64) {
+	if value == 0 {
+		return
+	}
+	s := string(r)
+	if []rune(s)[0] != r && value != 0 {
+		// Note: The UCD tables will always assign what amounts to a zero value
+		// to a surrogate. Allowing a zero value for an illegal rune allows
+		// users to iterate over [0..MaxRune] without having to explicitly
+		// exclude surrogates, which would be tedious.
+		panic(fmt.Sprintf("triegen: non-zero value for invalid rune %U", r))
+	}
+	if len(s) == 1 {
+		// It is a root node value (ASCII).
+		t.root.values[s[0]] = value
+		return
+	}
+
+	n := t.root
+	for ; len(s) > 1; s = s[1:] {
+		if n.children == nil {
+			n.children = make([]*node, blockSize)
+		}
+		p := s[0] % blockSize
+		c := n.children[p]
+		if c == nil {
+			c = &node{}
+			n.children[p] = c
+		}
+		if len(s) > 2 && c.values != nil {
+			log.Fatalf("triegen: insert(%U): found internal node with values", r)
+		}
+		n = c
+	}
+	if n.values == nil {
+		n.values = make([]uint64, blockSize)
+	}
+	if n.children != nil {
+		log.Fatalf("triegen: insert(%U): found leaf node that also has child nodes", r)
+	}
+	n.values[s[0]-0x80] = value
+}
+
+// Size returns the number of bytes the generated trie will take to store. It
+// needs to be exported as it is used in the templates.
+func (b *builder) Size() int {
+	// Index blocks.
+	sz := len(b.IndexBlocks) * blockSize * b.IndexSize
+
+	// Skip the first compaction, which represents the normal value blocks, as
+	// its totalSize does not account for the ASCII blocks, which are managed
+	// separately.
+	sz += len(b.ValueBlocks) * blockSize * b.ValueSize
+	for _, c := range b.Compactions[1:] {
+		sz += c.totalSize
+	}
+
+	// TODO: this computation does not account for the fixed overhead of a using
+	// a compaction, either code or data. As for data, though, the typical
+	// overhead of data is in the order of bytes (2 bytes for cases). Further,
+	// the savings of using a compaction should anyway be substantial for it to
+	// be worth it.
+
+	// For multi-root tries, we also need to account for the handles.
+	if len(b.Trie) > 1 {
+		sz += 2 * b.IndexSize * len(b.Trie)
+	}
+	return sz
+}
+
+func (b *builder) build() {
+	// Compute the sizes of the values.
+	var vmax uint64
+	for _, t := range b.Trie {
+		vmax = maxValue(t.root, vmax)
+	}
+	b.ValueType, b.ValueSize = getIntType(vmax)
+
+	// Compute all block allocations.
+	// TODO: first compute the ASCII blocks for all tries and then the other
+	// nodes. ASCII blocks are more restricted in placement, as they require two
+	// blocks to be placed consecutively. Processing them first may improve
+	// sharing (at least one zero block can be expected to be saved.)
+	for _, t := range b.Trie {
+		b.Checksum += b.buildTrie(t)
+	}
+
+	// Compute the offsets for all the Compacters.
+	offset := uint32(0)
+	for i := range b.Compactions {
+		c := &b.Compactions[i]
+		c.Offset = offset
+		offset += c.maxHandle + 1
+		c.Cutoff = offset
+	}
+
+	// Compute the sizes of indexes.
+	// TODO: different byte positions could have different sizes. So far we have
+	// not found a case where this is beneficial.
+	imax := uint64(b.Compactions[len(b.Compactions)-1].Cutoff)
+	for _, ib := range b.IndexBlocks {
+		if x := uint64(ib.index.index); x > imax {
+			imax = x
+		}
+	}
+	b.IndexType, b.IndexSize = getIntType(imax)
+}
+
+func maxValue(n *node, max uint64) uint64 {
+	if n == nil {
+		return max
+	}
+	for _, c := range n.children {
+		max = maxValue(c, max)
+	}
+	for _, v := range n.values {
+		if max < v {
+			max = v
+		}
+	}
+	return max
+}
+
+func getIntType(v uint64) (string, int) {
+	switch {
+	case v < 1<<8:
+		return "uint8", 1
+	case v < 1<<16:
+		return "uint16", 2
+	case v < 1<<32:
+		return "uint32", 4
+	}
+	return "uint64", 8
+}
+
+const (
+	blockSize = 64
+
+	// Subtract two blocks to offset 0x80, the first continuation byte.
+	blockOffset = 2
+
+	// Subtract three blocks to offset 0xC0, the first non-ASCII starter.
+	rootBlockOffset = 3
+)
+
+var crcTable = crc64.MakeTable(crc64.ISO)
+
+func (b *builder) buildTrie(t *Trie) uint64 {
+	n := t.root
+
+	// Get the ASCII offset. For the first trie, the ASCII block will be at
+	// position 0.
+	hasher := crc64.New(crcTable)
+	binary.Write(hasher, binary.BigEndian, n.values)
+	hash := hasher.Sum64()
+
+	v, ok := b.asciiBlockIdx[hash]
+	if !ok {
+		v = len(b.ValueBlocks)
+		b.asciiBlockIdx[hash] = v
+
+		b.ValueBlocks = append(b.ValueBlocks, n.values[:blockSize], n.values[blockSize:])
+		if v == 0 {
+			// Add the zero block at position 2 so that it will be assigned a
+			// zero reference in the lookup blocks.
+			// TODO: always do this? This would allow us to remove a check from
+			// the trie lookup, but at the expense of extra space. Analyze
+			// performance for unicode/norm.
+			b.ValueBlocks = append(b.ValueBlocks, make([]uint64, blockSize))
+		}
+	}
+	t.ASCIIIndex = v
+
+	// Compute remaining offsets.
+	t.Checksum = b.computeOffsets(n, true)
+	// We already subtracted the normal blockOffset from the index. Subtract the
+	// difference for starter bytes.
+	t.StarterIndex = n.index.index - (rootBlockOffset - blockOffset)
+	return t.Checksum
+}
+
+func (b *builder) computeOffsets(n *node, root bool) uint64 {
+	// For the first trie, the root lookup block will be at position 3, which is
+	// the offset for UTF-8 non-ASCII starter bytes.
+	first := len(b.IndexBlocks) == rootBlockOffset
+	if first {
+		b.IndexBlocks = append(b.IndexBlocks, n)
+	}
+
+	// We special-case the cases where all values recursively are 0. This allows
+	// for the use of a zero block to which all such values can be directed.
+	hash := uint64(0)
+	if n.children != nil || n.values != nil {
+		hasher := crc64.New(crcTable)
+		for _, c := range n.children {
+			var v uint64
+			if c != nil {
+				v = b.computeOffsets(c, false)
+			}
+			binary.Write(hasher, binary.BigEndian, v)
+		}
+		binary.Write(hasher, binary.BigEndian, n.values)
+		hash = hasher.Sum64()
+	}
+
+	if first {
+		b.indexBlockIdx[hash] = rootBlockOffset - blockOffset
+	}
+
+	// Compacters don't apply to internal nodes.
+	if n.children != nil {
+		v, ok := b.indexBlockIdx[hash]
+		if !ok {
+			v = len(b.IndexBlocks) - blockOffset
+			b.IndexBlocks = append(b.IndexBlocks, n)
+			b.indexBlockIdx[hash] = v
+		}
+		n.index = nodeIndex{0, v}
+	} else {
+		h, ok := b.valueBlockIdx[hash]
+		if !ok {
+			bestI, bestSize := 0, blockSize*b.ValueSize
+			for i, c := range b.Compactions[1:] {
+				if sz, ok := c.c.Size(n.values); ok && bestSize > sz {
+					bestI, bestSize = i+1, sz
+				}
+			}
+			c := &b.Compactions[bestI]
+			c.totalSize += bestSize
+			v := c.c.Store(n.values)
+			if c.maxHandle < v {
+				c.maxHandle = v
+			}
+			h = nodeIndex{bestI, int(v)}
+			b.valueBlockIdx[hash] = h
+		}
+		n.index = h
+	}
+	return hash
+}
diff --git a/vendor/golang.org/x/text/internal/ucd/ucd.go b/vendor/golang.org/x/text/internal/ucd/ucd.go
new file mode 100644
index 0000000..309e8d8
--- /dev/null
+++ b/vendor/golang.org/x/text/internal/ucd/ucd.go
@@ -0,0 +1,376 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package ucd provides a parser for Unicode Character Database files, the
+// format of which is defined in http://www.unicode.org/reports/tr44/. See
+// http://www.unicode.org/Public/UCD/latest/ucd/ for example files.
+//
+// It currently does not support substitutions of missing fields.
+package ucd // import "golang.org/x/text/internal/ucd"
+
+import (
+	"bufio"
+	"bytes"
+	"errors"
+	"io"
+	"log"
+	"regexp"
+	"strconv"
+	"strings"
+)
+
+// UnicodeData.txt fields.
+const (
+	CodePoint = iota
+	Name
+	GeneralCategory
+	CanonicalCombiningClass
+	BidiClass
+	DecompMapping
+	DecimalValue
+	DigitValue
+	NumericValue
+	BidiMirrored
+	Unicode1Name
+	ISOComment
+	SimpleUppercaseMapping
+	SimpleLowercaseMapping
+	SimpleTitlecaseMapping
+)
+
+// Parse calls f for each entry in the given reader of a UCD file. It will close
+// the reader upon return. It will call log.Fatal if any error occurred.
+//
+// This implements the most common usage pattern of using Parser.
+func Parse(r io.ReadCloser, f func(p *Parser)) {
+	defer r.Close()
+
+	p := New(r)
+	for p.Next() {
+		f(p)
+	}
+	if err := p.Err(); err != nil {
+		r.Close() // os.Exit will cause defers not to be called.
+		log.Fatal(err)
+	}
+}
+
+// An Option is used to configure a Parser.
+type Option func(p *Parser)
+
+func keepRanges(p *Parser) {
+	p.keepRanges = true
+}
+
+var (
+	// KeepRanges prevents the expansion of ranges. The raw ranges can be
+	// obtained by calling Range(0) on the parser.
+	KeepRanges Option = keepRanges
+)
+
+// The Part option register a handler for lines starting with a '@'. The text
+// after a '@' is available as the first field. Comments are handled as usual.
+func Part(f func(p *Parser)) Option {
+	return func(p *Parser) {
+		p.partHandler = f
+	}
+}
+
+// The CommentHandler option passes comments that are on a line by itself to
+// a given handler.
+func CommentHandler(f func(s string)) Option {
+	return func(p *Parser) {
+		p.commentHandler = f
+	}
+}
+
+// A Parser parses Unicode Character Database (UCD) files.
+type Parser struct {
+	scanner *bufio.Scanner
+
+	keepRanges bool // Don't expand rune ranges in field 0.
+
+	err     error
+	comment []byte
+	field   [][]byte
+	// parsedRange is needed in case Range(0) is called more than once for one
+	// field. In some cases this requires scanning ahead.
+	parsedRange          bool
+	rangeStart, rangeEnd rune
+
+	partHandler    func(p *Parser)
+	commentHandler func(s string)
+}
+
+func (p *Parser) setError(err error) {
+	if p.err == nil {
+		p.err = err
+	}
+}
+
+func (p *Parser) getField(i int) []byte {
+	if i >= len(p.field) {
+		return nil
+	}
+	return p.field[i]
+}
+
+// Err returns a non-nil error if any error occurred during parsing.
+func (p *Parser) Err() error {
+	return p.err
+}
+
+// New returns a Parser for the given Reader.
+func New(r io.Reader, o ...Option) *Parser {
+	p := &Parser{
+		scanner: bufio.NewScanner(r),
+	}
+	for _, f := range o {
+		f(p)
+	}
+	return p
+}
+
+// Next parses the next line in the file. It returns true if a line was parsed
+// and false if it reached the end of the file.
+func (p *Parser) Next() bool {
+	if !p.keepRanges && p.rangeStart < p.rangeEnd {
+		p.rangeStart++
+		return true
+	}
+	p.comment = nil
+	p.field = p.field[:0]
+	p.parsedRange = false
+
+	for p.scanner.Scan() {
+		b := p.scanner.Bytes()
+		if len(b) == 0 {
+			continue
+		}
+		if b[0] == '#' {
+			if p.commentHandler != nil {
+				p.commentHandler(strings.TrimSpace(string(b[1:])))
+			}
+			continue
+		}
+
+		// Parse line
+		if i := bytes.IndexByte(b, '#'); i != -1 {
+			p.comment = bytes.TrimSpace(b[i+1:])
+			b = b[:i]
+		}
+		if b[0] == '@' {
+			if p.partHandler != nil {
+				p.field = append(p.field, bytes.TrimSpace(b[1:]))
+				p.partHandler(p)
+				p.field = p.field[:0]
+			}
+			p.comment = nil
+			continue
+		}
+		for {
+			i := bytes.IndexByte(b, ';')
+			if i == -1 {
+				p.field = append(p.field, bytes.TrimSpace(b))
+				break
+			}
+			p.field = append(p.field, bytes.TrimSpace(b[:i]))
+			b = b[i+1:]
+		}
+		if !p.keepRanges {
+			p.rangeStart, p.rangeEnd = p.getRange(0)
+		}
+		return true
+	}
+	p.setError(p.scanner.Err())
+	return false
+}
+
+func parseRune(b []byte) (rune, error) {
+	if len(b) > 2 && b[0] == 'U' && b[1] == '+' {
+		b = b[2:]
+	}
+	x, err := strconv.ParseUint(string(b), 16, 32)
+	return rune(x), err
+}
+
+func (p *Parser) parseRune(b []byte) rune {
+	x, err := parseRune(b)
+	p.setError(err)
+	return x
+}
+
+// Rune parses and returns field i as a rune.
+func (p *Parser) Rune(i int) rune {
+	if i > 0 || p.keepRanges {
+		return p.parseRune(p.getField(i))
+	}
+	return p.rangeStart
+}
+
+// Runes interprets and returns field i as a sequence of runes.
+func (p *Parser) Runes(i int) (runes []rune) {
+	add := func(b []byte) {
+		if b = bytes.TrimSpace(b); len(b) > 0 {
+			runes = append(runes, p.parseRune(b))
+		}
+	}
+	for b := p.getField(i); ; {
+		i := bytes.IndexByte(b, ' ')
+		if i == -1 {
+			add(b)
+			break
+		}
+		add(b[:i])
+		b = b[i+1:]
+	}
+	return
+}
+
+var (
+	errIncorrectLegacyRange = errors.New("ucd: unmatched <* First>")
+
+	// reRange matches one line of a legacy rune range.
+	reRange = regexp.MustCompile("^([0-9A-F]*);<([^,]*), ([^>]*)>(.*)$")
+)
+
+// Range parses and returns field i as a rune range. A range is inclusive at
+// both ends. If the field only has one rune, first and last will be identical.
+// It supports the legacy format for ranges used in UnicodeData.txt.
+func (p *Parser) Range(i int) (first, last rune) {
+	if !p.keepRanges {
+		return p.rangeStart, p.rangeStart
+	}
+	return p.getRange(i)
+}
+
+func (p *Parser) getRange(i int) (first, last rune) {
+	b := p.getField(i)
+	if k := bytes.Index(b, []byte("..")); k != -1 {
+		return p.parseRune(b[:k]), p.parseRune(b[k+2:])
+	}
+	// The first field may not be a rune, in which case we may ignore any error
+	// and set the range as 0..0.
+	x, err := parseRune(b)
+	if err != nil {
+		// Disable range parsing henceforth. This ensures that an error will be
+		// returned if the user subsequently will try to parse this field as
+		// a Rune.
+		p.keepRanges = true
+	}
+	// Special case for UnicodeData that was retained for backwards compatibility.
+	if i == 0 && len(p.field) > 1 && bytes.HasSuffix(p.field[1], []byte("First>")) {
+		if p.parsedRange {
+			return p.rangeStart, p.rangeEnd
+		}
+		mf := reRange.FindStringSubmatch(p.scanner.Text())
+		if mf == nil || !p.scanner.Scan() {
+			p.setError(errIncorrectLegacyRange)
+			return x, x
+		}
+		// Using Bytes would be more efficient here, but Text is a lot easier
+		// and this is not a frequent case.
+		ml := reRange.FindStringSubmatch(p.scanner.Text())
+		if ml == nil || mf[2] != ml[2] || ml[3] != "Last" || mf[4] != ml[4] {
+			p.setError(errIncorrectLegacyRange)
+			return x, x
+		}
+		p.rangeStart, p.rangeEnd = x, p.parseRune(p.scanner.Bytes()[:len(ml[1])])
+		p.parsedRange = true
+		return p.rangeStart, p.rangeEnd
+	}
+	return x, x
+}
+
+// bools recognizes all valid UCD boolean values.
+var bools = map[string]bool{
+	"":      false,
+	"N":     false,
+	"No":    false,
+	"F":     false,
+	"False": false,
+	"Y":     true,
+	"Yes":   true,
+	"T":     true,
+	"True":  true,
+}
+
+// Bool parses and returns field i as a boolean value.
+func (p *Parser) Bool(i int) bool {
+	b := p.getField(i)
+	for s, v := range bools {
+		if bstrEq(b, s) {
+			return v
+		}
+	}
+	p.setError(strconv.ErrSyntax)
+	return false
+}
+
+// Int parses and returns field i as an integer value.
+func (p *Parser) Int(i int) int {
+	x, err := strconv.ParseInt(string(p.getField(i)), 10, 64)
+	p.setError(err)
+	return int(x)
+}
+
+// Uint parses and returns field i as an unsigned integer value.
+func (p *Parser) Uint(i int) uint {
+	x, err := strconv.ParseUint(string(p.getField(i)), 10, 64)
+	p.setError(err)
+	return uint(x)
+}
+
+// Float parses and returns field i as a decimal value.
+func (p *Parser) Float(i int) float64 {
+	x, err := strconv.ParseFloat(string(p.getField(i)), 64)
+	p.setError(err)
+	return x
+}
+
+// String parses and returns field i as a string value.
+func (p *Parser) String(i int) string {
+	return string(p.getField(i))
+}
+
+// Strings parses and returns field i as a space-separated list of strings.
+func (p *Parser) Strings(i int) []string {
+	ss := strings.Split(string(p.getField(i)), " ")
+	for i, s := range ss {
+		ss[i] = strings.TrimSpace(s)
+	}
+	return ss
+}
+
+// Comment returns the comments for the current line.
+func (p *Parser) Comment() string {
+	return string(p.comment)
+}
+
+var errUndefinedEnum = errors.New("ucd: undefined enum value")
+
+// Enum interprets and returns field i as a value that must be one of the values
+// in enum.
+func (p *Parser) Enum(i int, enum ...string) string {
+	b := p.getField(i)
+	for _, s := range enum {
+		if bstrEq(b, s) {
+			return s
+		}
+	}
+	p.setError(errUndefinedEnum)
+	return ""
+}
+
+func bstrEq(b []byte, s string) bool {
+	if len(b) != len(s) {
+		return false
+	}
+	for i, c := range b {
+		if c != s[i] {
+			return false
+		}
+	}
+	return true
+}
diff --git a/vendor/golang.org/x/text/secure/doc.go b/vendor/golang.org/x/text/secure/doc.go
new file mode 100644
index 0000000..e531c35
--- /dev/null
+++ b/vendor/golang.org/x/text/secure/doc.go
@@ -0,0 +1,6 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// secure is a repository of text security related packages.
+package secure // import "golang.org/x/text/secure"
diff --git a/vendor/golang.org/x/text/unicode/cldr/base.go b/vendor/golang.org/x/text/unicode/cldr/base.go
new file mode 100644
index 0000000..2382f4d
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/cldr/base.go
@@ -0,0 +1,100 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package cldr
+
+import (
+	"encoding/xml"
+	"regexp"
+	"strconv"
+)
+
+// Elem is implemented by every XML element.
+type Elem interface {
+	setEnclosing(Elem)
+	setName(string)
+	enclosing() Elem
+
+	GetCommon() *Common
+}
+
+type hidden struct {
+	CharData string `xml:",chardata"`
+	Alias    *struct {
+		Common
+		Source string `xml:"source,attr"`
+		Path   string `xml:"path,attr"`
+	} `xml:"alias"`
+	Def *struct {
+		Common
+		Choice string `xml:"choice,attr,omitempty"`
+		Type   string `xml:"type,attr,omitempty"`
+	} `xml:"default"`
+}
+
+// Common holds several of the most common attributes and sub elements
+// of an XML element.
+type Common struct {
+	XMLName         xml.Name
+	name            string
+	enclElem        Elem
+	Type            string `xml:"type,attr,omitempty"`
+	Reference       string `xml:"reference,attr,omitempty"`
+	Alt             string `xml:"alt,attr,omitempty"`
+	ValidSubLocales string `xml:"validSubLocales,attr,omitempty"`
+	Draft           string `xml:"draft,attr,omitempty"`
+	hidden
+}
+
+// Default returns the default type to select from the enclosed list
+// or "" if no default value is specified.
+func (e *Common) Default() string {
+	if e.Def == nil {
+		return ""
+	}
+	if e.Def.Choice != "" {
+		return e.Def.Choice
+	} else if e.Def.Type != "" {
+		// Type is still used by the default element in collation.
+		return e.Def.Type
+	}
+	return ""
+}
+
+// GetCommon returns e. It is provided such that Common implements Elem.
+func (e *Common) GetCommon() *Common {
+	return e
+}
+
+// Data returns the character data accumulated for this element.
+func (e *Common) Data() string {
+	e.CharData = charRe.ReplaceAllStringFunc(e.CharData, replaceUnicode)
+	return e.CharData
+}
+
+func (e *Common) setName(s string) {
+	e.name = s
+}
+
+func (e *Common) enclosing() Elem {
+	return e.enclElem
+}
+
+func (e *Common) setEnclosing(en Elem) {
+	e.enclElem = en
+}
+
+// Escape characters that can be escaped without further escaping the string.
+var charRe = regexp.MustCompile(`&#x[0-9a-fA-F]*;|\\u[0-9a-fA-F]{4}|\\U[0-9a-fA-F]{8}|\\x[0-9a-fA-F]{2}|\\[0-7]{3}|\\[abtnvfr]`)
+
+// replaceUnicode converts hexadecimal Unicode codepoint notations to a one-rune string.
+// It assumes the input string is correctly formatted.
+func replaceUnicode(s string) string {
+	if s[1] == '#' {
+		r, _ := strconv.ParseInt(s[3:len(s)-1], 16, 32)
+		return string(r)
+	}
+	r, _, _, _ := strconv.UnquoteChar(s, 0)
+	return string(r)
+}
diff --git a/vendor/golang.org/x/text/unicode/cldr/cldr.go b/vendor/golang.org/x/text/unicode/cldr/cldr.go
new file mode 100644
index 0000000..2197f8a
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/cldr/cldr.go
@@ -0,0 +1,130 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:generate go run makexml.go -output xml.go
+
+// Package cldr provides a parser for LDML and related XML formats.
+// This package is intended to be used by the table generation tools
+// for the various internationalization-related packages.
+// As the XML types are generated from the CLDR DTD, and as the CLDR standard
+// is periodically amended, this package may change considerably over time.
+// This mostly means that data may appear and disappear between versions.
+// That is, old code should keep compiling for newer versions, but data
+// may have moved or changed.
+// CLDR version 22 is the first version supported by this package.
+// Older versions may not work.
+package cldr // import "golang.org/x/text/unicode/cldr"
+
+import (
+	"fmt"
+	"sort"
+)
+
+// CLDR provides access to parsed data of the Unicode Common Locale Data Repository.
+type CLDR struct {
+	parent   map[string][]string
+	locale   map[string]*LDML
+	resolved map[string]*LDML
+	bcp47    *LDMLBCP47
+	supp     *SupplementalData
+}
+
+func makeCLDR() *CLDR {
+	return &CLDR{
+		parent:   make(map[string][]string),
+		locale:   make(map[string]*LDML),
+		resolved: make(map[string]*LDML),
+		bcp47:    &LDMLBCP47{},
+		supp:     &SupplementalData{},
+	}
+}
+
+// BCP47 returns the parsed BCP47 LDML data. If no such data was parsed, nil is returned.
+func (cldr *CLDR) BCP47() *LDMLBCP47 {
+	return nil
+}
+
+// Draft indicates the draft level of an element.
+type Draft int
+
+const (
+	Approved Draft = iota
+	Contributed
+	Provisional
+	Unconfirmed
+)
+
+var drafts = []string{"unconfirmed", "provisional", "contributed", "approved", ""}
+
+// ParseDraft returns the Draft value corresponding to the given string. The
+// empty string corresponds to Approved.
+func ParseDraft(level string) (Draft, error) {
+	if level == "" {
+		return Approved, nil
+	}
+	for i, s := range drafts {
+		if level == s {
+			return Unconfirmed - Draft(i), nil
+		}
+	}
+	return Approved, fmt.Errorf("cldr: unknown draft level %q", level)
+}
+
+func (d Draft) String() string {
+	return drafts[len(drafts)-1-int(d)]
+}
+
+// SetDraftLevel sets which draft levels to include in the evaluated LDML.
+// Any draft element for which the draft level is higher than lev will be excluded.
+// If multiple draft levels are available for a single element, the one with the
+// lowest draft level will be selected, unless preferDraft is true, in which case
+// the highest draft will be chosen.
+// It is assumed that the underlying LDML is canonicalized.
+func (cldr *CLDR) SetDraftLevel(lev Draft, preferDraft bool) {
+	// TODO: implement
+	cldr.resolved = make(map[string]*LDML)
+}
+
+// RawLDML returns the LDML XML for id in unresolved form.
+// id must be one of the strings returned by Locales.
+func (cldr *CLDR) RawLDML(loc string) *LDML {
+	return cldr.locale[loc]
+}
+
+// LDML returns the fully resolved LDML XML for loc, which must be one of
+// the strings returned by Locales.
+func (cldr *CLDR) LDML(loc string) (*LDML, error) {
+	return cldr.resolve(loc)
+}
+
+// Supplemental returns the parsed supplemental data. If no such data was parsed,
+// nil is returned.
+func (cldr *CLDR) Supplemental() *SupplementalData {
+	return cldr.supp
+}
+
+// Locales returns the locales for which there exist files.
+// Valid sublocales for which there is no file are not included.
+// The root locale is always sorted first.
+func (cldr *CLDR) Locales() []string {
+	loc := []string{"root"}
+	hasRoot := false
+	for l, _ := range cldr.locale {
+		if l == "root" {
+			hasRoot = true
+			continue
+		}
+		loc = append(loc, l)
+	}
+	sort.Strings(loc[1:])
+	if !hasRoot {
+		return loc[1:]
+	}
+	return loc
+}
+
+// Get fills in the fields of x based on the XPath path.
+func Get(e Elem, path string) (res Elem, err error) {
+	return walkXPath(e, path)
+}
diff --git a/vendor/golang.org/x/text/unicode/cldr/collate.go b/vendor/golang.org/x/text/unicode/cldr/collate.go
new file mode 100644
index 0000000..80ee28d
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/cldr/collate.go
@@ -0,0 +1,359 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package cldr
+
+import (
+	"bufio"
+	"encoding/xml"
+	"errors"
+	"fmt"
+	"strconv"
+	"strings"
+	"unicode"
+	"unicode/utf8"
+)
+
+// RuleProcessor can be passed to Collator's Process method, which
+// parses the rules and calls the respective method for each rule found.
+type RuleProcessor interface {
+	Reset(anchor string, before int) error
+	Insert(level int, str, context, extend string) error
+	Index(id string)
+}
+
+const (
+	// cldrIndex is a Unicode-reserved sentinel value used to mark the start
+	// of a grouping within an index.
+	// We ignore any rule that starts with this rune.
+	// See http://unicode.org/reports/tr35/#Collation_Elements for details.
+	cldrIndex = "\uFDD0"
+
+	// specialAnchor is the format in which to represent logical reset positions,
+	// such as "first tertiary ignorable".
+	specialAnchor = "<%s/>"
+)
+
+// Process parses the rules for the tailorings of this collation
+// and calls the respective methods of p for each rule found.
+func (c Collation) Process(p RuleProcessor) (err error) {
+	if len(c.Cr) > 0 {
+		if len(c.Cr) > 1 {
+			return fmt.Errorf("multiple cr elements, want 0 or 1")
+		}
+		return processRules(p, c.Cr[0].Data())
+	}
+	if c.Rules.Any != nil {
+		return c.processXML(p)
+	}
+	return errors.New("no tailoring data")
+}
+
+// processRules parses rules in the Collation Rule Syntax defined in
+// http://www.unicode.org/reports/tr35/tr35-collation.html#Collation_Tailorings.
+func processRules(p RuleProcessor, s string) (err error) {
+	chk := func(s string, e error) string {
+		if err == nil {
+			err = e
+		}
+		return s
+	}
+	i := 0 // Save the line number for use after the loop.
+	scanner := bufio.NewScanner(strings.NewReader(s))
+	for ; scanner.Scan() && err == nil; i++ {
+		for s := skipSpace(scanner.Text()); s != "" && s[0] != '#'; s = skipSpace(s) {
+			level := 5
+			var ch byte
+			switch ch, s = s[0], s[1:]; ch {
+			case '&': // followed by <anchor> or '[' <key> ']'
+				if s = skipSpace(s); consume(&s, '[') {
+					s = chk(parseSpecialAnchor(p, s))
+				} else {
+					s = chk(parseAnchor(p, 0, s))
+				}
+			case '<': // sort relation '<'{1,4}, optionally followed by '*'.
+				for level = 1; consume(&s, '<'); level++ {
+				}
+				if level > 4 {
+					err = fmt.Errorf("level %d > 4", level)
+				}
+				fallthrough
+			case '=': // identity relation, optionally followed by *.
+				if consume(&s, '*') {
+					s = chk(parseSequence(p, level, s))
+				} else {
+					s = chk(parseOrder(p, level, s))
+				}
+			default:
+				chk("", fmt.Errorf("illegal operator %q", ch))
+				break
+			}
+		}
+	}
+	if chk("", scanner.Err()); err != nil {
+		return fmt.Errorf("%d: %v", i, err)
+	}
+	return nil
+}
+
+// parseSpecialAnchor parses the anchor syntax which is either of the form
+//    ['before' <level>] <anchor>
+// or
+//    [<label>]
+// The starting should already be consumed.
+func parseSpecialAnchor(p RuleProcessor, s string) (tail string, err error) {
+	i := strings.IndexByte(s, ']')
+	if i == -1 {
+		return "", errors.New("unmatched bracket")
+	}
+	a := strings.TrimSpace(s[:i])
+	s = s[i+1:]
+	if strings.HasPrefix(a, "before ") {
+		l, err := strconv.ParseUint(skipSpace(a[len("before "):]), 10, 3)
+		if err != nil {
+			return s, err
+		}
+		return parseAnchor(p, int(l), s)
+	}
+	return s, p.Reset(fmt.Sprintf(specialAnchor, a), 0)
+}
+
+func parseAnchor(p RuleProcessor, level int, s string) (tail string, err error) {
+	anchor, s, err := scanString(s)
+	if err != nil {
+		return s, err
+	}
+	return s, p.Reset(anchor, level)
+}
+
+func parseOrder(p RuleProcessor, level int, s string) (tail string, err error) {
+	var value, context, extend string
+	if value, s, err = scanString(s); err != nil {
+		return s, err
+	}
+	if strings.HasPrefix(value, cldrIndex) {
+		p.Index(value[len(cldrIndex):])
+		return
+	}
+	if consume(&s, '|') {
+		if context, s, err = scanString(s); err != nil {
+			return s, errors.New("missing string after context")
+		}
+	}
+	if consume(&s, '/') {
+		if extend, s, err = scanString(s); err != nil {
+			return s, errors.New("missing string after extension")
+		}
+	}
+	return s, p.Insert(level, value, context, extend)
+}
+
+// scanString scans a single input string.
+func scanString(s string) (str, tail string, err error) {
+	if s = skipSpace(s); s == "" {
+		return s, s, errors.New("missing string")
+	}
+	buf := [16]byte{} // small but enough to hold most cases.
+	value := buf[:0]
+	for s != "" {
+		if consume(&s, '\'') {
+			i := strings.IndexByte(s, '\'')
+			if i == -1 {
+				return "", "", errors.New(`unmatched single quote`)
+			}
+			if i == 0 {
+				value = append(value, '\'')
+			} else {
+				value = append(value, s[:i]...)
+			}
+			s = s[i+1:]
+			continue
+		}
+		r, sz := utf8.DecodeRuneInString(s)
+		if unicode.IsSpace(r) || strings.ContainsRune("&<=#", r) {
+			break
+		}
+		value = append(value, s[:sz]...)
+		s = s[sz:]
+	}
+	return string(value), skipSpace(s), nil
+}
+
+func parseSequence(p RuleProcessor, level int, s string) (tail string, err error) {
+	if s = skipSpace(s); s == "" {
+		return s, errors.New("empty sequence")
+	}
+	last := rune(0)
+	for s != "" {
+		r, sz := utf8.DecodeRuneInString(s)
+		s = s[sz:]
+
+		if r == '-' {
+			// We have a range. The first element was already written.
+			if last == 0 {
+				return s, errors.New("range without starter value")
+			}
+			r, sz = utf8.DecodeRuneInString(s)
+			s = s[sz:]
+			if r == utf8.RuneError || r < last {
+				return s, fmt.Errorf("invalid range %q-%q", last, r)
+			}
+			for i := last + 1; i <= r; i++ {
+				if err := p.Insert(level, string(i), "", ""); err != nil {
+					return s, err
+				}
+			}
+			last = 0
+			continue
+		}
+
+		if unicode.IsSpace(r) || unicode.IsPunct(r) {
+			break
+		}
+
+		// normal case
+		if err := p.Insert(level, string(r), "", ""); err != nil {
+			return s, err
+		}
+		last = r
+	}
+	return s, nil
+}
+
+func skipSpace(s string) string {
+	return strings.TrimLeftFunc(s, unicode.IsSpace)
+}
+
+// consumes returns whether the next byte is ch. If so, it gobbles it by
+// updating s.
+func consume(s *string, ch byte) (ok bool) {
+	if *s == "" || (*s)[0] != ch {
+		return false
+	}
+	*s = (*s)[1:]
+	return true
+}
+
+// The following code parses Collation rules of CLDR version 24 and before.
+
+var lmap = map[byte]int{
+	'p': 1,
+	's': 2,
+	't': 3,
+	'i': 5,
+}
+
+type rulesElem struct {
+	Rules struct {
+		Common
+		Any []*struct {
+			XMLName xml.Name
+			rule
+		} `xml:",any"`
+	} `xml:"rules"`
+}
+
+type rule struct {
+	Value  string `xml:",chardata"`
+	Before string `xml:"before,attr"`
+	Any    []*struct {
+		XMLName xml.Name
+		rule
+	} `xml:",any"`
+}
+
+var emptyValueError = errors.New("cldr: empty rule value")
+
+func (r *rule) value() (string, error) {
+	// Convert hexadecimal Unicode codepoint notation to a string.
+	s := charRe.ReplaceAllStringFunc(r.Value, replaceUnicode)
+	r.Value = s
+	if s == "" {
+		if len(r.Any) != 1 {
+			return "", emptyValueError
+		}
+		r.Value = fmt.Sprintf(specialAnchor, r.Any[0].XMLName.Local)
+		r.Any = nil
+	} else if len(r.Any) != 0 {
+		return "", fmt.Errorf("cldr: XML elements found in collation rule: %v", r.Any)
+	}
+	return r.Value, nil
+}
+
+func (r rule) process(p RuleProcessor, name, context, extend string) error {
+	v, err := r.value()
+	if err != nil {
+		return err
+	}
+	switch name {
+	case "p", "s", "t", "i":
+		if strings.HasPrefix(v, cldrIndex) {
+			p.Index(v[len(cldrIndex):])
+			return nil
+		}
+		if err := p.Insert(lmap[name[0]], v, context, extend); err != nil {
+			return err
+		}
+	case "pc", "sc", "tc", "ic":
+		level := lmap[name[0]]
+		for _, s := range v {
+			if err := p.Insert(level, string(s), context, extend); err != nil {
+				return err
+			}
+		}
+	default:
+		return fmt.Errorf("cldr: unsupported tag: %q", name)
+	}
+	return nil
+}
+
+// processXML parses the format of CLDR versions 24 and older.
+func (c Collation) processXML(p RuleProcessor) (err error) {
+	// Collation is generated and defined in xml.go.
+	var v string
+	for _, r := range c.Rules.Any {
+		switch r.XMLName.Local {
+		case "reset":
+			level := 0
+			switch r.Before {
+			case "primary", "1":
+				level = 1
+			case "secondary", "2":
+				level = 2
+			case "tertiary", "3":
+				level = 3
+			case "":
+			default:
+				return fmt.Errorf("cldr: unknown level %q", r.Before)
+			}
+			v, err = r.value()
+			if err == nil {
+				err = p.Reset(v, level)
+			}
+		case "x":
+			var context, extend string
+			for _, r1 := range r.Any {
+				v, err = r1.value()
+				switch r1.XMLName.Local {
+				case "context":
+					context = v
+				case "extend":
+					extend = v
+				}
+			}
+			for _, r1 := range r.Any {
+				if t := r1.XMLName.Local; t == "context" || t == "extend" {
+					continue
+				}
+				r1.rule.process(p, r1.XMLName.Local, context, extend)
+			}
+		default:
+			err = r.rule.process(p, r.XMLName.Local, "", "")
+		}
+		if err != nil {
+			return err
+		}
+	}
+	return nil
+}
diff --git a/vendor/golang.org/x/text/unicode/cldr/decode.go b/vendor/golang.org/x/text/unicode/cldr/decode.go
new file mode 100644
index 0000000..e5ee4ae
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/cldr/decode.go
@@ -0,0 +1,171 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package cldr
+
+import (
+	"archive/zip"
+	"bytes"
+	"encoding/xml"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"log"
+	"os"
+	"path/filepath"
+	"regexp"
+)
+
+// A Decoder loads an archive of CLDR data.
+type Decoder struct {
+	dirFilter     []string
+	sectionFilter []string
+	loader        Loader
+	cldr          *CLDR
+	curLocale     string
+}
+
+// SetSectionFilter takes a list top-level LDML element names to which
+// evaluation of LDML should be limited.  It automatically calls SetDirFilter.
+func (d *Decoder) SetSectionFilter(filter ...string) {
+	d.sectionFilter = filter
+	// TODO: automatically set dir filter
+}
+
+// SetDirFilter limits the loading of LDML XML files of the specied directories.
+// Note that sections may be split across directories differently for different CLDR versions.
+// For more robust code, use SetSectionFilter.
+func (d *Decoder) SetDirFilter(dir ...string) {
+	d.dirFilter = dir
+}
+
+// A Loader provides access to the files of a CLDR archive.
+type Loader interface {
+	Len() int
+	Path(i int) string
+	Reader(i int) (io.ReadCloser, error)
+}
+
+var fileRe = regexp.MustCompile(".*/(.*)/(.*)\\.xml")
+
+// Decode loads and decodes the files represented by l.
+func (d *Decoder) Decode(l Loader) (cldr *CLDR, err error) {
+	d.cldr = makeCLDR()
+	for i := 0; i < l.Len(); i++ {
+		fname := l.Path(i)
+		if m := fileRe.FindStringSubmatch(fname); m != nil {
+			if len(d.dirFilter) > 0 && !in(d.dirFilter, m[1]) {
+				continue
+			}
+			var r io.Reader
+			if r, err = l.Reader(i); err == nil {
+				err = d.decode(m[1], m[2], r)
+			}
+			if err != nil {
+				return nil, err
+			}
+		}
+	}
+	d.cldr.finalize(d.sectionFilter)
+	return d.cldr, nil
+}
+
+func (d *Decoder) decode(dir, id string, r io.Reader) error {
+	var v interface{}
+	var l *LDML
+	cldr := d.cldr
+	switch {
+	case dir == "supplemental":
+		v = cldr.supp
+	case dir == "transforms":
+		return nil
+	case dir == "bcp47":
+		v = cldr.bcp47
+	case dir == "validity":
+		return nil
+	default:
+		ok := false
+		if v, ok = cldr.locale[id]; !ok {
+			l = &LDML{}
+			v, cldr.locale[id] = l, l
+		}
+	}
+	x := xml.NewDecoder(r)
+	if err := x.Decode(v); err != nil {
+		log.Printf("%s/%s: %v", dir, id, err)
+		return err
+	}
+	if l != nil {
+		if l.Identity == nil {
+			return fmt.Errorf("%s/%s: missing identity element", dir, id)
+		}
+		// TODO: verify when CLDR bug http://unicode.org/cldr/trac/ticket/8970
+		// is resolved.
+		// path := strings.Split(id, "_")
+		// if lang := l.Identity.Language.Type; lang != path[0] {
+		// 	return fmt.Errorf("%s/%s: language was %s; want %s", dir, id, lang, path[0])
+		// }
+	}
+	return nil
+}
+
+type pathLoader []string
+
+func makePathLoader(path string) (pl pathLoader, err error) {
+	err = filepath.Walk(path, func(path string, _ os.FileInfo, err error) error {
+		pl = append(pl, path)
+		return err
+	})
+	return pl, err
+}
+
+func (pl pathLoader) Len() int {
+	return len(pl)
+}
+
+func (pl pathLoader) Path(i int) string {
+	return pl[i]
+}
+
+func (pl pathLoader) Reader(i int) (io.ReadCloser, error) {
+	return os.Open(pl[i])
+}
+
+// DecodePath loads CLDR data from the given path.
+func (d *Decoder) DecodePath(path string) (cldr *CLDR, err error) {
+	loader, err := makePathLoader(path)
+	if err != nil {
+		return nil, err
+	}
+	return d.Decode(loader)
+}
+
+type zipLoader struct {
+	r *zip.Reader
+}
+
+func (zl zipLoader) Len() int {
+	return len(zl.r.File)
+}
+
+func (zl zipLoader) Path(i int) string {
+	return zl.r.File[i].Name
+}
+
+func (zl zipLoader) Reader(i int) (io.ReadCloser, error) {
+	return zl.r.File[i].Open()
+}
+
+// DecodeZip loads CLDR data from the zip archive for which r is the source.
+func (d *Decoder) DecodeZip(r io.Reader) (cldr *CLDR, err error) {
+	buffer, err := ioutil.ReadAll(r)
+	if err != nil {
+		return nil, err
+	}
+	archive, err := zip.NewReader(bytes.NewReader(buffer), int64(len(buffer)))
+	if err != nil {
+		return nil, err
+	}
+	return d.Decode(zipLoader{archive})
+}
diff --git a/vendor/golang.org/x/text/unicode/cldr/makexml.go b/vendor/golang.org/x/text/unicode/cldr/makexml.go
new file mode 100644
index 0000000..6114d01
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/cldr/makexml.go
@@ -0,0 +1,400 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build ignore
+
+// This tool generates types for the various XML formats of CLDR.
+package main
+
+import (
+	"archive/zip"
+	"bytes"
+	"encoding/xml"
+	"flag"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"log"
+	"os"
+	"regexp"
+	"strings"
+
+	"golang.org/x/text/internal/gen"
+)
+
+var outputFile = flag.String("output", "xml.go", "output file name")
+
+func main() {
+	flag.Parse()
+
+	r := gen.OpenCLDRCoreZip()
+	buffer, err := ioutil.ReadAll(r)
+	if err != nil {
+		log.Fatal("Could not read zip file")
+	}
+	r.Close()
+	z, err := zip.NewReader(bytes.NewReader(buffer), int64(len(buffer)))
+	if err != nil {
+		log.Fatalf("Could not read zip archive: %v", err)
+	}
+
+	var buf bytes.Buffer
+
+	version := gen.CLDRVersion()
+
+	for _, dtd := range files {
+		for _, f := range z.File {
+			if strings.HasSuffix(f.Name, dtd.file+".dtd") {
+				r, err := f.Open()
+				failOnError(err)
+
+				b := makeBuilder(&buf, dtd)
+				b.parseDTD(r)
+				b.resolve(b.index[dtd.top[0]])
+				b.write()
+				if b.version != "" && version != b.version {
+					println(f.Name)
+					log.Fatalf("main: inconsistent versions: found %s; want %s", b.version, version)
+				}
+				break
+			}
+		}
+	}
+	fmt.Fprintln(&buf, "// Version is the version of CLDR from which the XML definitions are generated.")
+	fmt.Fprintf(&buf, "const Version = %q\n", version)
+
+	gen.WriteGoFile(*outputFile, "cldr", buf.Bytes())
+}
+
+func failOnError(err error) {
+	if err != nil {
+		log.New(os.Stderr, "", log.Lshortfile).Output(2, err.Error())
+		os.Exit(1)
+	}
+}
+
+// configuration data per DTD type
+type dtd struct {
+	file string   // base file name
+	root string   // Go name of the root XML element
+	top  []string // create a different type for this section
+
+	skipElem    []string // hard-coded or deprecated elements
+	skipAttr    []string // attributes to exclude
+	predefined  []string // hard-coded elements exist of the form <name>Elem
+	forceRepeat []string // elements to make slices despite DTD
+}
+
+var files = []dtd{
+	{
+		file: "ldmlBCP47",
+		root: "LDMLBCP47",
+		top:  []string{"ldmlBCP47"},
+		skipElem: []string{
+			"cldrVersion", // deprecated, not used
+		},
+	},
+	{
+		file: "ldmlSupplemental",
+		root: "SupplementalData",
+		top:  []string{"supplementalData"},
+		skipElem: []string{
+			"cldrVersion", // deprecated, not used
+		},
+		forceRepeat: []string{
+			"plurals", // data defined in plurals.xml and ordinals.xml
+		},
+	},
+	{
+		file: "ldml",
+		root: "LDML",
+		top: []string{
+			"ldml", "collation", "calendar", "timeZoneNames", "localeDisplayNames", "numbers",
+		},
+		skipElem: []string{
+			"cp",       // not used anywhere
+			"special",  // not used anywhere
+			"fallback", // deprecated, not used
+			"alias",    // in Common
+			"default",  // in Common
+		},
+		skipAttr: []string{
+			"hiraganaQuarternary", // typo in DTD, correct version included as well
+		},
+		predefined: []string{"rules"},
+	},
+}
+
+var comments = map[string]string{
+	"ldmlBCP47": `
+// LDMLBCP47 holds information on allowable values for various variables in LDML.
+`,
+	"supplementalData": `
+// SupplementalData holds information relevant for internationalization
+// and proper use of CLDR, but that is not contained in the locale hierarchy.
+`,
+	"ldml": `
+// LDML is the top-level type for locale-specific data.
+`,
+	"collation": `
+// Collation contains rules that specify a certain sort-order,
+// as a tailoring of the root order. 
+// The parsed rules are obtained by passing a RuleProcessor to Collation's
+// Process method.
+`,
+	"calendar": `
+// Calendar specifies the fields used for formatting and parsing dates and times.
+// The month and quarter names are identified numerically, starting at 1.
+// The day (of the week) names are identified with short strings, since there is
+// no universally-accepted numeric designation.
+`,
+	"dates": `
+// Dates contains information regarding the format and parsing of dates and times.
+`,
+	"localeDisplayNames": `
+// LocaleDisplayNames specifies localized display names for for scripts, languages,
+// countries, currencies, and variants.
+`,
+	"numbers": `
+// Numbers supplies information for formatting and parsing numbers and currencies.
+`,
+}
+
+type element struct {
+	name      string // XML element name
+	category  string // elements contained by this element
+	signature string // category + attrKey*
+
+	attr []*attribute // attributes supported by this element.
+	sub  []struct {   // parsed and evaluated sub elements of this element.
+		e      *element
+		repeat bool // true if the element needs to be a slice
+	}
+
+	resolved bool // prevent multiple resolutions of this element.
+}
+
+type attribute struct {
+	name string
+	key  string
+	list []string
+
+	tag string // Go tag
+}
+
+var (
+	reHead  = regexp.MustCompile(` *(\w+) +([\w\-]+)`)
+	reAttr  = regexp.MustCompile(` *(\w+) *(?:(\w+)|\(([\w\- \|]+)\)) *(?:#([A-Z]*) *(?:\"([\.\d+])\")?)? *("[\w\-:]*")?`)
+	reElem  = regexp.MustCompile(`^ *(EMPTY|ANY|\(.*\)[\*\+\?]?) *$`)
+	reToken = regexp.MustCompile(`\w\-`)
+)
+
+// builder is used to read in the DTD files from CLDR and generate Go code
+// to be used with the encoding/xml package.
+type builder struct {
+	w       io.Writer
+	index   map[string]*element
+	elem    []*element
+	info    dtd
+	version string
+}
+
+func makeBuilder(w io.Writer, d dtd) builder {
+	return builder{
+		w:     w,
+		index: make(map[string]*element),
+		elem:  []*element{},
+		info:  d,
+	}
+}
+
+// parseDTD parses a DTD file.
+func (b *builder) parseDTD(r io.Reader) {
+	for d := xml.NewDecoder(r); ; {
+		t, err := d.Token()
+		if t == nil {
+			break
+		}
+		failOnError(err)
+		dir, ok := t.(xml.Directive)
+		if !ok {
+			continue
+		}
+		m := reHead.FindSubmatch(dir)
+		dir = dir[len(m[0]):]
+		ename := string(m[2])
+		el, elementFound := b.index[ename]
+		switch string(m[1]) {
+		case "ELEMENT":
+			if elementFound {
+				log.Fatal("parseDTD: duplicate entry for element %q", ename)
+			}
+			m := reElem.FindSubmatch(dir)
+			if m == nil {
+				log.Fatalf("parseDTD: invalid element %q", string(dir))
+			}
+			if len(m[0]) != len(dir) {
+				log.Fatal("parseDTD: invalid element %q", string(dir), len(dir), len(m[0]), string(m[0]))
+			}
+			s := string(m[1])
+			el = &element{
+				name:     ename,
+				category: s,
+			}
+			b.index[ename] = el
+		case "ATTLIST":
+			if !elementFound {
+				log.Fatalf("parseDTD: unknown element %q", ename)
+			}
+			s := string(dir)
+			m := reAttr.FindStringSubmatch(s)
+			if m == nil {
+				log.Fatal(fmt.Errorf("parseDTD: invalid attribute %q", string(dir)))
+			}
+			if m[4] == "FIXED" {
+				b.version = m[5]
+			} else {
+				switch m[1] {
+				case "draft", "references", "alt", "validSubLocales", "standard" /* in Common */ :
+				case "type", "choice":
+				default:
+					el.attr = append(el.attr, &attribute{
+						name: m[1],
+						key:  s,
+						list: reToken.FindAllString(m[3], -1),
+					})
+					el.signature = fmt.Sprintf("%s=%s+%s", el.signature, m[1], m[2])
+				}
+			}
+		}
+	}
+}
+
+var reCat = regexp.MustCompile(`[ ,\|]*(?:(\(|\)|\#?[\w_-]+)([\*\+\?]?))?`)
+
+// resolve takes a parsed element and converts it into structured data
+// that can be used to generate the XML code.
+func (b *builder) resolve(e *element) {
+	if e.resolved {
+		return
+	}
+	b.elem = append(b.elem, e)
+	e.resolved = true
+	s := e.category
+	found := make(map[string]bool)
+	sequenceStart := []int{}
+	for len(s) > 0 {
+		m := reCat.FindStringSubmatch(s)
+		if m == nil {
+			log.Fatalf("%s: invalid category string %q", e.name, s)
+		}
+		repeat := m[2] == "*" || m[2] == "+" || in(b.info.forceRepeat, m[1])
+		switch m[1] {
+		case "":
+		case "(":
+			sequenceStart = append(sequenceStart, len(e.sub))
+		case ")":
+			if len(sequenceStart) == 0 {
+				log.Fatalf("%s: unmatched closing parenthesis", e.name)
+			}
+			for i := sequenceStart[len(sequenceStart)-1]; i < len(e.sub); i++ {
+				e.sub[i].repeat = e.sub[i].repeat || repeat
+			}
+			sequenceStart = sequenceStart[:len(sequenceStart)-1]
+		default:
+			if in(b.info.skipElem, m[1]) {
+			} else if sub, ok := b.index[m[1]]; ok {
+				if !found[sub.name] {
+					e.sub = append(e.sub, struct {
+						e      *element
+						repeat bool
+					}{sub, repeat})
+					found[sub.name] = true
+					b.resolve(sub)
+				}
+			} else if m[1] == "#PCDATA" || m[1] == "ANY" {
+			} else if m[1] != "EMPTY" {
+				log.Fatalf("resolve:%s: element %q not found", e.name, m[1])
+			}
+		}
+		s = s[len(m[0]):]
+	}
+}
+
+// return true if s is contained in set.
+func in(set []string, s string) bool {
+	for _, v := range set {
+		if v == s {
+			return true
+		}
+	}
+	return false
+}
+
+var repl = strings.NewReplacer("-", " ", "_", " ")
+
+// title puts the first character or each character following '_' in title case and
+// removes all occurrences of '_'.
+func title(s string) string {
+	return strings.Replace(strings.Title(repl.Replace(s)), " ", "", -1)
+}
+
+// writeElem generates Go code for a single element, recursively.
+func (b *builder) writeElem(tab int, e *element) {
+	p := func(f string, x ...interface{}) {
+		f = strings.Replace(f, "\n", "\n"+strings.Repeat("\t", tab), -1)
+		fmt.Fprintf(b.w, f, x...)
+	}
+	if len(e.sub) == 0 && len(e.attr) == 0 {
+		p("Common")
+		return
+	}
+	p("struct {")
+	tab++
+	p("\nCommon")
+	for _, attr := range e.attr {
+		if !in(b.info.skipAttr, attr.name) {
+			p("\n%s string `xml:\"%s,attr\"`", title(attr.name), attr.name)
+		}
+	}
+	for _, sub := range e.sub {
+		if in(b.info.predefined, sub.e.name) {
+			p("\n%sElem", sub.e.name)
+			continue
+		}
+		if in(b.info.skipElem, sub.e.name) {
+			continue
+		}
+		p("\n%s ", title(sub.e.name))
+		if sub.repeat {
+			p("[]")
+		}
+		p("*")
+		if in(b.info.top, sub.e.name) {
+			p(title(sub.e.name))
+		} else {
+			b.writeElem(tab, sub.e)
+		}
+		p(" `xml:\"%s\"`", sub.e.name)
+	}
+	tab--
+	p("\n}")
+}
+
+// write generates the Go XML code.
+func (b *builder) write() {
+	for i, name := range b.info.top {
+		e := b.index[name]
+		if e != nil {
+			fmt.Fprintf(b.w, comments[name])
+			name := title(e.name)
+			if i == 0 {
+				name = b.info.root
+			}
+			fmt.Fprintf(b.w, "type %s ", name)
+			b.writeElem(0, e)
+			fmt.Fprint(b.w, "\n")
+		}
+	}
+}
diff --git a/vendor/golang.org/x/text/unicode/cldr/resolve.go b/vendor/golang.org/x/text/unicode/cldr/resolve.go
new file mode 100644
index 0000000..691b590
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/cldr/resolve.go
@@ -0,0 +1,602 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package cldr
+
+// This file implements the various inheritance constructs defined by LDML.
+// See http://www.unicode.org/reports/tr35/#Inheritance_and_Validity
+// for more details.
+
+import (
+	"fmt"
+	"log"
+	"reflect"
+	"regexp"
+	"sort"
+	"strings"
+)
+
+// fieldIter iterates over fields in a struct. It includes
+// fields of embedded structs.
+type fieldIter struct {
+	v        reflect.Value
+	index, n []int
+}
+
+func iter(v reflect.Value) fieldIter {
+	if v.Kind() != reflect.Struct {
+		log.Panicf("value %v must be a struct", v)
+	}
+	i := fieldIter{
+		v:     v,
+		index: []int{0},
+		n:     []int{v.NumField()},
+	}
+	i.descent()
+	return i
+}
+
+func (i *fieldIter) descent() {
+	for f := i.field(); f.Anonymous && f.Type.NumField() > 0; f = i.field() {
+		i.index = append(i.index, 0)
+		i.n = append(i.n, f.Type.NumField())
+	}
+}
+
+func (i *fieldIter) done() bool {
+	return len(i.index) == 1 && i.index[0] >= i.n[0]
+}
+
+func skip(f reflect.StructField) bool {
+	return !f.Anonymous && (f.Name[0] < 'A' || f.Name[0] > 'Z')
+}
+
+func (i *fieldIter) next() {
+	for {
+		k := len(i.index) - 1
+		i.index[k]++
+		if i.index[k] < i.n[k] {
+			if !skip(i.field()) {
+				break
+			}
+		} else {
+			if k == 0 {
+				return
+			}
+			i.index = i.index[:k]
+			i.n = i.n[:k]
+		}
+	}
+	i.descent()
+}
+
+func (i *fieldIter) value() reflect.Value {
+	return i.v.FieldByIndex(i.index)
+}
+
+func (i *fieldIter) field() reflect.StructField {
+	return i.v.Type().FieldByIndex(i.index)
+}
+
+type visitor func(v reflect.Value) error
+
+var stopDescent = fmt.Errorf("do not recurse")
+
+func (f visitor) visit(x interface{}) error {
+	return f.visitRec(reflect.ValueOf(x))
+}
+
+// visit recursively calls f on all nodes in v.
+func (f visitor) visitRec(v reflect.Value) error {
+	if v.Kind() == reflect.Ptr {
+		if v.IsNil() {
+			return nil
+		}
+		return f.visitRec(v.Elem())
+	}
+	if err := f(v); err != nil {
+		if err == stopDescent {
+			return nil
+		}
+		return err
+	}
+	switch v.Kind() {
+	case reflect.Struct:
+		for i := iter(v); !i.done(); i.next() {
+			if err := f.visitRec(i.value()); err != nil {
+				return err
+			}
+		}
+	case reflect.Slice:
+		for i := 0; i < v.Len(); i++ {
+			if err := f.visitRec(v.Index(i)); err != nil {
+				return err
+			}
+		}
+	}
+	return nil
+}
+
+// getPath is used for error reporting purposes only.
+func getPath(e Elem) string {
+	if e == nil {
+		return "<nil>"
+	}
+	if e.enclosing() == nil {
+		return e.GetCommon().name
+	}
+	if e.GetCommon().Type == "" {
+		return fmt.Sprintf("%s.%s", getPath(e.enclosing()), e.GetCommon().name)
+	}
+	return fmt.Sprintf("%s.%s[type=%s]", getPath(e.enclosing()), e.GetCommon().name, e.GetCommon().Type)
+}
+
+// xmlName returns the xml name of the element or attribute
+func xmlName(f reflect.StructField) (name string, attr bool) {
+	tags := strings.Split(f.Tag.Get("xml"), ",")
+	for _, s := range tags {
+		attr = attr || s == "attr"
+	}
+	return tags[0], attr
+}
+
+func findField(v reflect.Value, key string) (reflect.Value, error) {
+	v = reflect.Indirect(v)
+	for i := iter(v); !i.done(); i.next() {
+		if n, _ := xmlName(i.field()); n == key {
+			return i.value(), nil
+		}
+	}
+	return reflect.Value{}, fmt.Errorf("cldr: no field %q in element %#v", key, v.Interface())
+}
+
+var xpathPart = regexp.MustCompile(`(\pL+)(?:\[@(\pL+)='([\w-]+)'\])?`)
+
+func walkXPath(e Elem, path string) (res Elem, err error) {
+	for _, c := range strings.Split(path, "/") {
+		if c == ".." {
+			if e = e.enclosing(); e == nil {
+				panic("path ..")
+				return nil, fmt.Errorf(`cldr: ".." moves past root in path %q`, path)
+			}
+			continue
+		} else if c == "" {
+			continue
+		}
+		m := xpathPart.FindStringSubmatch(c)
+		if len(m) == 0 || len(m[0]) != len(c) {
+			return nil, fmt.Errorf("cldr: syntax error in path component %q", c)
+		}
+		v, err := findField(reflect.ValueOf(e), m[1])
+		if err != nil {
+			return nil, err
+		}
+		switch v.Kind() {
+		case reflect.Slice:
+			i := 0
+			if m[2] != "" || v.Len() > 1 {
+				if m[2] == "" {
+					m[2] = "type"
+					if m[3] = e.GetCommon().Default(); m[3] == "" {
+						return nil, fmt.Errorf("cldr: type selector or default value needed for element %s", m[1])
+					}
+				}
+				for ; i < v.Len(); i++ {
+					vi := v.Index(i)
+					key, err := findField(vi.Elem(), m[2])
+					if err != nil {
+						return nil, err
+					}
+					key = reflect.Indirect(key)
+					if key.Kind() == reflect.String && key.String() == m[3] {
+						break
+					}
+				}
+			}
+			if i == v.Len() || v.Index(i).IsNil() {
+				return nil, fmt.Errorf("no %s found with %s==%s", m[1], m[2], m[3])
+			}
+			e = v.Index(i).Interface().(Elem)
+		case reflect.Ptr:
+			if v.IsNil() {
+				return nil, fmt.Errorf("cldr: element %q not found within element %q", m[1], e.GetCommon().name)
+			}
+			var ok bool
+			if e, ok = v.Interface().(Elem); !ok {
+				return nil, fmt.Errorf("cldr: %q is not an XML element", m[1])
+			} else if m[2] != "" || m[3] != "" {
+				return nil, fmt.Errorf("cldr: no type selector allowed for element %s", m[1])
+			}
+		default:
+			return nil, fmt.Errorf("cldr: %q is not an XML element", m[1])
+		}
+	}
+	return e, nil
+}
+
+const absPrefix = "//ldml/"
+
+func (cldr *CLDR) resolveAlias(e Elem, src, path string) (res Elem, err error) {
+	if src != "locale" {
+		if !strings.HasPrefix(path, absPrefix) {
+			return nil, fmt.Errorf("cldr: expected absolute path, found %q", path)
+		}
+		path = path[len(absPrefix):]
+		if e, err = cldr.resolve(src); err != nil {
+			return nil, err
+		}
+	}
+	return walkXPath(e, path)
+}
+
+func (cldr *CLDR) resolveAndMergeAlias(e Elem) error {
+	alias := e.GetCommon().Alias
+	if alias == nil {
+		return nil
+	}
+	a, err := cldr.resolveAlias(e, alias.Source, alias.Path)
+	if err != nil {
+		return fmt.Errorf("%v: error evaluating path %q: %v", getPath(e), alias.Path, err)
+	}
+	// Ensure alias node was already evaluated. TODO: avoid double evaluation.
+	err = cldr.resolveAndMergeAlias(a)
+	v := reflect.ValueOf(e).Elem()
+	for i := iter(reflect.ValueOf(a).Elem()); !i.done(); i.next() {
+		if vv := i.value(); vv.Kind() != reflect.Ptr || !vv.IsNil() {
+			if _, attr := xmlName(i.field()); !attr {
+				v.FieldByIndex(i.index).Set(vv)
+			}
+		}
+	}
+	return err
+}
+
+func (cldr *CLDR) aliasResolver() visitor {
+	return func(v reflect.Value) (err error) {
+		if e, ok := v.Addr().Interface().(Elem); ok {
+			err = cldr.resolveAndMergeAlias(e)
+			if err == nil && blocking[e.GetCommon().name] {
+				return stopDescent
+			}
+		}
+		return err
+	}
+}
+
+// elements within blocking elements do not inherit.
+// Taken from CLDR's supplementalMetaData.xml.
+var blocking = map[string]bool{
+	"identity":         true,
+	"supplementalData": true,
+	"cldrTest":         true,
+	"collation":        true,
+	"transform":        true,
+}
+
+// Distinguishing attributes affect inheritance; two elements with different
+// distinguishing attributes are treated as different for purposes of inheritance,
+// except when such attributes occur in the indicated elements.
+// Taken from CLDR's supplementalMetaData.xml.
+var distinguishing = map[string][]string{
+	"key":        nil,
+	"request_id": nil,
+	"id":         nil,
+	"registry":   nil,
+	"alt":        nil,
+	"iso4217":    nil,
+	"iso3166":    nil,
+	"mzone":      nil,
+	"from":       nil,
+	"to":         nil,
+	"type": []string{
+		"abbreviationFallback",
+		"default",
+		"mapping",
+		"measurementSystem",
+		"preferenceOrdering",
+	},
+	"numberSystem": nil,
+}
+
+func in(set []string, s string) bool {
+	for _, v := range set {
+		if v == s {
+			return true
+		}
+	}
+	return false
+}
+
+// attrKey computes a key based on the distinguishable attributes of
+// an element and it's values.
+func attrKey(v reflect.Value, exclude ...string) string {
+	parts := []string{}
+	ename := v.Interface().(Elem).GetCommon().name
+	v = v.Elem()
+	for i := iter(v); !i.done(); i.next() {
+		if name, attr := xmlName(i.field()); attr {
+			if except, ok := distinguishing[name]; ok && !in(exclude, name) && !in(except, ename) {
+				v := i.value()
+				if v.Kind() == reflect.Ptr {
+					v = v.Elem()
+				}
+				if v.IsValid() {
+					parts = append(parts, fmt.Sprintf("%s=%s", name, v.String()))
+				}
+			}
+		}
+	}
+	sort.Strings(parts)
+	return strings.Join(parts, ";")
+}
+
+// Key returns a key for e derived from all distinguishing attributes
+// except those specified by exclude.
+func Key(e Elem, exclude ...string) string {
+	return attrKey(reflect.ValueOf(e), exclude...)
+}
+
+// linkEnclosing sets the enclosing element as well as the name
+// for all sub-elements of child, recursively.
+func linkEnclosing(parent, child Elem) {
+	child.setEnclosing(parent)
+	v := reflect.ValueOf(child).Elem()
+	for i := iter(v); !i.done(); i.next() {
+		vf := i.value()
+		if vf.Kind() == reflect.Slice {
+			for j := 0; j < vf.Len(); j++ {
+				linkEnclosing(child, vf.Index(j).Interface().(Elem))
+			}
+		} else if vf.Kind() == reflect.Ptr && !vf.IsNil() && vf.Elem().Kind() == reflect.Struct {
+			linkEnclosing(child, vf.Interface().(Elem))
+		}
+	}
+}
+
+func setNames(e Elem, name string) {
+	e.setName(name)
+	v := reflect.ValueOf(e).Elem()
+	for i := iter(v); !i.done(); i.next() {
+		vf := i.value()
+		name, _ = xmlName(i.field())
+		if vf.Kind() == reflect.Slice {
+			for j := 0; j < vf.Len(); j++ {
+				setNames(vf.Index(j).Interface().(Elem), name)
+			}
+		} else if vf.Kind() == reflect.Ptr && !vf.IsNil() && vf.Elem().Kind() == reflect.Struct {
+			setNames(vf.Interface().(Elem), name)
+		}
+	}
+}
+
+// deepCopy copies elements of v recursively.  All elements of v that may
+// be modified by inheritance are explicitly copied.
+func deepCopy(v reflect.Value) reflect.Value {
+	switch v.Kind() {
+	case reflect.Ptr:
+		if v.IsNil() || v.Elem().Kind() != reflect.Struct {
+			return v
+		}
+		nv := reflect.New(v.Elem().Type())
+		nv.Elem().Set(v.Elem())
+		deepCopyRec(nv.Elem(), v.Elem())
+		return nv
+	case reflect.Slice:
+		nv := reflect.MakeSlice(v.Type(), v.Len(), v.Len())
+		for i := 0; i < v.Len(); i++ {
+			deepCopyRec(nv.Index(i), v.Index(i))
+		}
+		return nv
+	}
+	panic("deepCopy: must be called with pointer or slice")
+}
+
+// deepCopyRec is only called by deepCopy.
+func deepCopyRec(nv, v reflect.Value) {
+	if v.Kind() == reflect.Struct {
+		t := v.Type()
+		for i := 0; i < v.NumField(); i++ {
+			if name, attr := xmlName(t.Field(i)); name != "" && !attr {
+				deepCopyRec(nv.Field(i), v.Field(i))
+			}
+		}
+	} else {
+		nv.Set(deepCopy(v))
+	}
+}
+
+// newNode is used to insert a missing node during inheritance.
+func (cldr *CLDR) newNode(v, enc reflect.Value) reflect.Value {
+	n := reflect.New(v.Type())
+	for i := iter(v); !i.done(); i.next() {
+		if name, attr := xmlName(i.field()); name == "" || attr {
+			n.Elem().FieldByIndex(i.index).Set(i.value())
+		}
+	}
+	n.Interface().(Elem).GetCommon().setEnclosing(enc.Addr().Interface().(Elem))
+	return n
+}
+
+// v, parent must be pointers to struct
+func (cldr *CLDR) inheritFields(v, parent reflect.Value) (res reflect.Value, err error) {
+	t := v.Type()
+	nv := reflect.New(t)
+	nv.Elem().Set(v)
+	for i := iter(v); !i.done(); i.next() {
+		vf := i.value()
+		f := i.field()
+		name, attr := xmlName(f)
+		if name == "" || attr {
+			continue
+		}
+		pf := parent.FieldByIndex(i.index)
+		if blocking[name] {
+			if vf.IsNil() {
+				vf = pf
+			}
+			nv.Elem().FieldByIndex(i.index).Set(deepCopy(vf))
+			continue
+		}
+		switch f.Type.Kind() {
+		case reflect.Ptr:
+			if f.Type.Elem().Kind() == reflect.Struct {
+				if !vf.IsNil() {
+					if vf, err = cldr.inheritStructPtr(vf, pf); err != nil {
+						return reflect.Value{}, err
+					}
+					vf.Interface().(Elem).setEnclosing(nv.Interface().(Elem))
+					nv.Elem().FieldByIndex(i.index).Set(vf)
+				} else if !pf.IsNil() {
+					n := cldr.newNode(pf.Elem(), v)
+					if vf, err = cldr.inheritStructPtr(n, pf); err != nil {
+						return reflect.Value{}, err
+					}
+					vf.Interface().(Elem).setEnclosing(nv.Interface().(Elem))
+					nv.Elem().FieldByIndex(i.index).Set(vf)
+				}
+			}
+		case reflect.Slice:
+			vf, err := cldr.inheritSlice(nv.Elem(), vf, pf)
+			if err != nil {
+				return reflect.Zero(t), err
+			}
+			nv.Elem().FieldByIndex(i.index).Set(vf)
+		}
+	}
+	return nv, nil
+}
+
+func root(e Elem) *LDML {
+	for ; e.enclosing() != nil; e = e.enclosing() {
+	}
+	return e.(*LDML)
+}
+
+// inheritStructPtr first merges possible aliases in with v and then inherits
+// any underspecified elements from parent.
+func (cldr *CLDR) inheritStructPtr(v, parent reflect.Value) (r reflect.Value, err error) {
+	if !v.IsNil() {
+		e := v.Interface().(Elem).GetCommon()
+		alias := e.Alias
+		if alias == nil && !parent.IsNil() {
+			alias = parent.Interface().(Elem).GetCommon().Alias
+		}
+		if alias != nil {
+			a, err := cldr.resolveAlias(v.Interface().(Elem), alias.Source, alias.Path)
+			if a != nil {
+				if v, err = cldr.inheritFields(v.Elem(), reflect.ValueOf(a).Elem()); err != nil {
+					return reflect.Value{}, err
+				}
+			}
+		}
+		if !parent.IsNil() {
+			return cldr.inheritFields(v.Elem(), parent.Elem())
+		}
+	} else if parent.IsNil() {
+		panic("should not reach here")
+	}
+	return v, nil
+}
+
+// Must be slice of struct pointers.
+func (cldr *CLDR) inheritSlice(enc, v, parent reflect.Value) (res reflect.Value, err error) {
+	t := v.Type()
+	index := make(map[string]reflect.Value)
+	if !v.IsNil() {
+		for i := 0; i < v.Len(); i++ {
+			vi := v.Index(i)
+			key := attrKey(vi)
+			index[key] = vi
+		}
+	}
+	if !parent.IsNil() {
+		for i := 0; i < parent.Len(); i++ {
+			vi := parent.Index(i)
+			key := attrKey(vi)
+			if w, ok := index[key]; ok {
+				index[key], err = cldr.inheritStructPtr(w, vi)
+			} else {
+				n := cldr.newNode(vi.Elem(), enc)
+				index[key], err = cldr.inheritStructPtr(n, vi)
+			}
+			index[key].Interface().(Elem).setEnclosing(enc.Addr().Interface().(Elem))
+			if err != nil {
+				return v, err
+			}
+		}
+	}
+	keys := make([]string, 0, len(index))
+	for k, _ := range index {
+		keys = append(keys, k)
+	}
+	sort.Strings(keys)
+	sl := reflect.MakeSlice(t, len(index), len(index))
+	for i, k := range keys {
+		sl.Index(i).Set(index[k])
+	}
+	return sl, nil
+}
+
+func parentLocale(loc string) string {
+	parts := strings.Split(loc, "_")
+	if len(parts) == 1 {
+		return "root"
+	}
+	parts = parts[:len(parts)-1]
+	key := strings.Join(parts, "_")
+	return key
+}
+
+func (cldr *CLDR) resolve(loc string) (res *LDML, err error) {
+	if r := cldr.resolved[loc]; r != nil {
+		return r, nil
+	}
+	x := cldr.RawLDML(loc)
+	if x == nil {
+		return nil, fmt.Errorf("cldr: unknown locale %q", loc)
+	}
+	var v reflect.Value
+	if loc == "root" {
+		x = deepCopy(reflect.ValueOf(x)).Interface().(*LDML)
+		linkEnclosing(nil, x)
+		err = cldr.aliasResolver().visit(x)
+	} else {
+		key := parentLocale(loc)
+		var parent *LDML
+		for ; cldr.locale[key] == nil; key = parentLocale(key) {
+		}
+		if parent, err = cldr.resolve(key); err != nil {
+			return nil, err
+		}
+		v, err = cldr.inheritFields(reflect.ValueOf(x).Elem(), reflect.ValueOf(parent).Elem())
+		x = v.Interface().(*LDML)
+		linkEnclosing(nil, x)
+	}
+	if err != nil {
+		return nil, err
+	}
+	cldr.resolved[loc] = x
+	return x, err
+}
+
+// finalize finalizes the initialization of the raw LDML structs.  It also
+// removed unwanted fields, as specified by filter, so that they will not
+// be unnecessarily evaluated.
+func (cldr *CLDR) finalize(filter []string) {
+	for _, x := range cldr.locale {
+		if filter != nil {
+			v := reflect.ValueOf(x).Elem()
+			t := v.Type()
+			for i := 0; i < v.NumField(); i++ {
+				f := t.Field(i)
+				name, _ := xmlName(f)
+				if name != "" && name != "identity" && !in(filter, name) {
+					v.Field(i).Set(reflect.Zero(f.Type))
+				}
+			}
+		}
+		linkEnclosing(nil, x) // for resolving aliases and paths
+		setNames(x, "ldml")
+	}
+}
diff --git a/vendor/golang.org/x/text/unicode/cldr/slice.go b/vendor/golang.org/x/text/unicode/cldr/slice.go
new file mode 100644
index 0000000..388c983
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/cldr/slice.go
@@ -0,0 +1,144 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package cldr
+
+import (
+	"fmt"
+	"reflect"
+	"sort"
+)
+
+// Slice provides utilities for modifying slices of elements.
+// It can be wrapped around any slice of which the element type implements
+// interface Elem.
+type Slice struct {
+	ptr reflect.Value
+	typ reflect.Type
+}
+
+// Value returns the reflect.Value of the underlying slice.
+func (s *Slice) Value() reflect.Value {
+	return s.ptr.Elem()
+}
+
+// MakeSlice wraps a pointer to a slice of Elems.
+// It replaces the array pointed to by the slice so that subsequent modifications
+// do not alter the data in a CLDR type.
+// It panics if an incorrect type is passed.
+func MakeSlice(slicePtr interface{}) Slice {
+	ptr := reflect.ValueOf(slicePtr)
+	if ptr.Kind() != reflect.Ptr {
+		panic(fmt.Sprintf("MakeSlice: argument must be pointer to slice, found %v", ptr.Type()))
+	}
+	sl := ptr.Elem()
+	if sl.Kind() != reflect.Slice {
+		panic(fmt.Sprintf("MakeSlice: argument must point to a slice, found %v", sl.Type()))
+	}
+	intf := reflect.TypeOf((*Elem)(nil)).Elem()
+	if !sl.Type().Elem().Implements(intf) {
+		panic(fmt.Sprintf("MakeSlice: element type of slice (%v) does not implement Elem", sl.Type().Elem()))
+	}
+	nsl := reflect.MakeSlice(sl.Type(), sl.Len(), sl.Len())
+	reflect.Copy(nsl, sl)
+	sl.Set(nsl)
+	return Slice{
+		ptr: ptr,
+		typ: sl.Type().Elem().Elem(),
+	}
+}
+
+func (s Slice) indexForAttr(a string) []int {
+	for i := iter(reflect.Zero(s.typ)); !i.done(); i.next() {
+		if n, _ := xmlName(i.field()); n == a {
+			return i.index
+		}
+	}
+	panic(fmt.Sprintf("MakeSlice: no attribute %q for type %v", a, s.typ))
+}
+
+// Filter filters s to only include elements for which fn returns true.
+func (s Slice) Filter(fn func(e Elem) bool) {
+	k := 0
+	sl := s.Value()
+	for i := 0; i < sl.Len(); i++ {
+		vi := sl.Index(i)
+		if fn(vi.Interface().(Elem)) {
+			sl.Index(k).Set(vi)
+			k++
+		}
+	}
+	sl.Set(sl.Slice(0, k))
+}
+
+// Group finds elements in s for which fn returns the same value and groups
+// them in a new Slice.
+func (s Slice) Group(fn func(e Elem) string) []Slice {
+	m := make(map[string][]reflect.Value)
+	sl := s.Value()
+	for i := 0; i < sl.Len(); i++ {
+		vi := sl.Index(i)
+		key := fn(vi.Interface().(Elem))
+		m[key] = append(m[key], vi)
+	}
+	keys := []string{}
+	for k, _ := range m {
+		keys = append(keys, k)
+	}
+	sort.Strings(keys)
+	res := []Slice{}
+	for _, k := range keys {
+		nsl := reflect.New(sl.Type())
+		nsl.Elem().Set(reflect.Append(nsl.Elem(), m[k]...))
+		res = append(res, MakeSlice(nsl.Interface()))
+	}
+	return res
+}
+
+// SelectAnyOf filters s to contain only elements for which attr matches
+// any of the values.
+func (s Slice) SelectAnyOf(attr string, values ...string) {
+	index := s.indexForAttr(attr)
+	s.Filter(func(e Elem) bool {
+		vf := reflect.ValueOf(e).Elem().FieldByIndex(index)
+		return in(values, vf.String())
+	})
+}
+
+// SelectOnePerGroup filters s to include at most one element e per group of
+// elements matching Key(attr), where e has an attribute a that matches any
+// the values in v.
+// If more than one element in a group matches a value in v preference
+// is given to the element that matches the first value in v.
+func (s Slice) SelectOnePerGroup(a string, v []string) {
+	index := s.indexForAttr(a)
+	grouped := s.Group(func(e Elem) string { return Key(e, a) })
+	sl := s.Value()
+	sl.Set(sl.Slice(0, 0))
+	for _, g := range grouped {
+		e := reflect.Value{}
+		found := len(v)
+		gsl := g.Value()
+		for i := 0; i < gsl.Len(); i++ {
+			vi := gsl.Index(i).Elem().FieldByIndex(index)
+			j := 0
+			for ; j < len(v) && v[j] != vi.String(); j++ {
+			}
+			if j < found {
+				found = j
+				e = gsl.Index(i)
+			}
+		}
+		if found < len(v) {
+			sl.Set(reflect.Append(sl, e))
+		}
+	}
+}
+
+// SelectDraft drops all elements from the list with a draft level smaller than d
+// and selects the highest draft level of the remaining.
+// This method assumes that the input CLDR is canonicalized.
+func (s Slice) SelectDraft(d Draft) {
+	s.SelectOnePerGroup("draft", drafts[len(drafts)-2-int(d):])
+}
diff --git a/vendor/golang.org/x/text/unicode/cldr/xml.go b/vendor/golang.org/x/text/unicode/cldr/xml.go
new file mode 100644
index 0000000..ce32038
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/cldr/xml.go
@@ -0,0 +1,1487 @@
+// Code generated by running "go generate" in golang.org/x/text. DO NOT EDIT.
+
+package cldr
+
+// LDMLBCP47 holds information on allowable values for various variables in LDML.
+type LDMLBCP47 struct {
+	Common
+	Version *struct {
+		Common
+		Number string `xml:"number,attr"`
+	} `xml:"version"`
+	Generation *struct {
+		Common
+		Date string `xml:"date,attr"`
+	} `xml:"generation"`
+	Keyword []*struct {
+		Common
+		Key []*struct {
+			Common
+			Extension   string `xml:"extension,attr"`
+			Name        string `xml:"name,attr"`
+			Description string `xml:"description,attr"`
+			Deprecated  string `xml:"deprecated,attr"`
+			Preferred   string `xml:"preferred,attr"`
+			Alias       string `xml:"alias,attr"`
+			ValueType   string `xml:"valueType,attr"`
+			Since       string `xml:"since,attr"`
+			Type        []*struct {
+				Common
+				Name        string `xml:"name,attr"`
+				Description string `xml:"description,attr"`
+				Deprecated  string `xml:"deprecated,attr"`
+				Preferred   string `xml:"preferred,attr"`
+				Alias       string `xml:"alias,attr"`
+				Since       string `xml:"since,attr"`
+			} `xml:"type"`
+		} `xml:"key"`
+	} `xml:"keyword"`
+	Attribute []*struct {
+		Common
+		Name        string `xml:"name,attr"`
+		Description string `xml:"description,attr"`
+		Deprecated  string `xml:"deprecated,attr"`
+		Preferred   string `xml:"preferred,attr"`
+		Since       string `xml:"since,attr"`
+	} `xml:"attribute"`
+}
+
+// SupplementalData holds information relevant for internationalization
+// and proper use of CLDR, but that is not contained in the locale hierarchy.
+type SupplementalData struct {
+	Common
+	Version *struct {
+		Common
+		Number string `xml:"number,attr"`
+	} `xml:"version"`
+	Generation *struct {
+		Common
+		Date string `xml:"date,attr"`
+	} `xml:"generation"`
+	CurrencyData *struct {
+		Common
+		Fractions []*struct {
+			Common
+			Info []*struct {
+				Common
+				Iso4217      string `xml:"iso4217,attr"`
+				Digits       string `xml:"digits,attr"`
+				Rounding     string `xml:"rounding,attr"`
+				CashDigits   string `xml:"cashDigits,attr"`
+				CashRounding string `xml:"cashRounding,attr"`
+			} `xml:"info"`
+		} `xml:"fractions"`
+		Region []*struct {
+			Common
+			Iso3166  string `xml:"iso3166,attr"`
+			Currency []*struct {
+				Common
+				Before       string `xml:"before,attr"`
+				From         string `xml:"from,attr"`
+				To           string `xml:"to,attr"`
+				Iso4217      string `xml:"iso4217,attr"`
+				Digits       string `xml:"digits,attr"`
+				Rounding     string `xml:"rounding,attr"`
+				CashRounding string `xml:"cashRounding,attr"`
+				Tender       string `xml:"tender,attr"`
+				Alternate    []*struct {
+					Common
+					Iso4217 string `xml:"iso4217,attr"`
+				} `xml:"alternate"`
+			} `xml:"currency"`
+		} `xml:"region"`
+	} `xml:"currencyData"`
+	TerritoryContainment *struct {
+		Common
+		Group []*struct {
+			Common
+			Contains string `xml:"contains,attr"`
+			Grouping string `xml:"grouping,attr"`
+			Status   string `xml:"status,attr"`
+		} `xml:"group"`
+	} `xml:"territoryContainment"`
+	SubdivisionContainment *struct {
+		Common
+		Subgroup []*struct {
+			Common
+			Subtype  string `xml:"subtype,attr"`
+			Contains string `xml:"contains,attr"`
+		} `xml:"subgroup"`
+	} `xml:"subdivisionContainment"`
+	LanguageData *struct {
+		Common
+		Language []*struct {
+			Common
+			Scripts     string `xml:"scripts,attr"`
+			Territories string `xml:"territories,attr"`
+			Variants    string `xml:"variants,attr"`
+		} `xml:"language"`
+	} `xml:"languageData"`
+	TerritoryInfo *struct {
+		Common
+		Territory []*struct {
+			Common
+			Gdp                string `xml:"gdp,attr"`
+			LiteracyPercent    string `xml:"literacyPercent,attr"`
+			Population         string `xml:"population,attr"`
+			LanguagePopulation []*struct {
+				Common
+				LiteracyPercent   string `xml:"literacyPercent,attr"`
+				WritingPercent    string `xml:"writingPercent,attr"`
+				PopulationPercent string `xml:"populationPercent,attr"`
+				OfficialStatus    string `xml:"officialStatus,attr"`
+			} `xml:"languagePopulation"`
+		} `xml:"territory"`
+	} `xml:"territoryInfo"`
+	PostalCodeData *struct {
+		Common
+		PostCodeRegex []*struct {
+			Common
+			TerritoryId string `xml:"territoryId,attr"`
+		} `xml:"postCodeRegex"`
+	} `xml:"postalCodeData"`
+	CalendarData *struct {
+		Common
+		Calendar []*struct {
+			Common
+			Territories    string  `xml:"territories,attr"`
+			CalendarSystem *Common `xml:"calendarSystem"`
+			Eras           *struct {
+				Common
+				Era []*struct {
+					Common
+					Start string `xml:"start,attr"`
+					End   string `xml:"end,attr"`
+				} `xml:"era"`
+			} `xml:"eras"`
+		} `xml:"calendar"`
+	} `xml:"calendarData"`
+	CalendarPreferenceData *struct {
+		Common
+		CalendarPreference []*struct {
+			Common
+			Territories string `xml:"territories,attr"`
+			Ordering    string `xml:"ordering,attr"`
+		} `xml:"calendarPreference"`
+	} `xml:"calendarPreferenceData"`
+	WeekData *struct {
+		Common
+		MinDays []*struct {
+			Common
+			Count       string `xml:"count,attr"`
+			Territories string `xml:"territories,attr"`
+		} `xml:"minDays"`
+		FirstDay []*struct {
+			Common
+			Day         string `xml:"day,attr"`
+			Territories string `xml:"territories,attr"`
+		} `xml:"firstDay"`
+		WeekendStart []*struct {
+			Common
+			Day         string `xml:"day,attr"`
+			Territories string `xml:"territories,attr"`
+		} `xml:"weekendStart"`
+		WeekendEnd []*struct {
+			Common
+			Day         string `xml:"day,attr"`
+			Territories string `xml:"territories,attr"`
+		} `xml:"weekendEnd"`
+		WeekOfPreference []*struct {
+			Common
+			Locales  string `xml:"locales,attr"`
+			Ordering string `xml:"ordering,attr"`
+		} `xml:"weekOfPreference"`
+	} `xml:"weekData"`
+	TimeData *struct {
+		Common
+		Hours []*struct {
+			Common
+			Allowed   string `xml:"allowed,attr"`
+			Preferred string `xml:"preferred,attr"`
+			Regions   string `xml:"regions,attr"`
+		} `xml:"hours"`
+	} `xml:"timeData"`
+	MeasurementData *struct {
+		Common
+		MeasurementSystem []*struct {
+			Common
+			Category    string `xml:"category,attr"`
+			Territories string `xml:"territories,attr"`
+		} `xml:"measurementSystem"`
+		PaperSize []*struct {
+			Common
+			Territories string `xml:"territories,attr"`
+		} `xml:"paperSize"`
+	} `xml:"measurementData"`
+	UnitPreferenceData *struct {
+		Common
+		UnitPreferences []*struct {
+			Common
+			Category       string `xml:"category,attr"`
+			Usage          string `xml:"usage,attr"`
+			Scope          string `xml:"scope,attr"`
+			UnitPreference []*struct {
+				Common
+				Regions string `xml:"regions,attr"`
+			} `xml:"unitPreference"`
+		} `xml:"unitPreferences"`
+	} `xml:"unitPreferenceData"`
+	TimezoneData *struct {
+		Common
+		MapTimezones []*struct {
+			Common
+			OtherVersion string `xml:"otherVersion,attr"`
+			TypeVersion  string `xml:"typeVersion,attr"`
+			MapZone      []*struct {
+				Common
+				Other     string `xml:"other,attr"`
+				Territory string `xml:"territory,attr"`
+			} `xml:"mapZone"`
+		} `xml:"mapTimezones"`
+		ZoneFormatting []*struct {
+			Common
+			Multizone   string `xml:"multizone,attr"`
+			TzidVersion string `xml:"tzidVersion,attr"`
+			ZoneItem    []*struct {
+				Common
+				Territory string `xml:"territory,attr"`
+				Aliases   string `xml:"aliases,attr"`
+			} `xml:"zoneItem"`
+		} `xml:"zoneFormatting"`
+	} `xml:"timezoneData"`
+	Characters *struct {
+		Common
+		CharacterFallback []*struct {
+			Common
+			Character []*struct {
+				Common
+				Value      string    `xml:"value,attr"`
+				Substitute []*Common `xml:"substitute"`
+			} `xml:"character"`
+		} `xml:"character-fallback"`
+	} `xml:"characters"`
+	Transforms *struct {
+		Common
+		Transform []*struct {
+			Common
+			Source        string    `xml:"source,attr"`
+			Target        string    `xml:"target,attr"`
+			Variant       string    `xml:"variant,attr"`
+			Direction     string    `xml:"direction,attr"`
+			Alias         string    `xml:"alias,attr"`
+			BackwardAlias string    `xml:"backwardAlias,attr"`
+			Visibility    string    `xml:"visibility,attr"`
+			Comment       []*Common `xml:"comment"`
+			TRule         []*Common `xml:"tRule"`
+		} `xml:"transform"`
+	} `xml:"transforms"`
+	Metadata *struct {
+		Common
+		AttributeOrder *Common `xml:"attributeOrder"`
+		ElementOrder   *Common `xml:"elementOrder"`
+		SerialElements *Common `xml:"serialElements"`
+		Suppress       *struct {
+			Common
+			Attributes []*struct {
+				Common
+				Element        string `xml:"element,attr"`
+				Attribute      string `xml:"attribute,attr"`
+				AttributeValue string `xml:"attributeValue,attr"`
+			} `xml:"attributes"`
+		} `xml:"suppress"`
+		Validity *struct {
+			Common
+			Variable []*struct {
+				Common
+				Id string `xml:"id,attr"`
+			} `xml:"variable"`
+			AttributeValues []*struct {
+				Common
+				Dtds       string `xml:"dtds,attr"`
+				Elements   string `xml:"elements,attr"`
+				Attributes string `xml:"attributes,attr"`
+				Order      string `xml:"order,attr"`
+			} `xml:"attributeValues"`
+		} `xml:"validity"`
+		Alias *struct {
+			Common
+			LanguageAlias []*struct {
+				Common
+				Replacement string `xml:"replacement,attr"`
+				Reason      string `xml:"reason,attr"`
+			} `xml:"languageAlias"`
+			ScriptAlias []*struct {
+				Common
+				Replacement string `xml:"replacement,attr"`
+				Reason      string `xml:"reason,attr"`
+			} `xml:"scriptAlias"`
+			TerritoryAlias []*struct {
+				Common
+				Replacement string `xml:"replacement,attr"`
+				Reason      string `xml:"reason,attr"`
+			} `xml:"territoryAlias"`
+			SubdivisionAlias []*struct {
+				Common
+				Replacement string `xml:"replacement,attr"`
+				Reason      string `xml:"reason,attr"`
+			} `xml:"subdivisionAlias"`
+			VariantAlias []*struct {
+				Common
+				Replacement string `xml:"replacement,attr"`
+				Reason      string `xml:"reason,attr"`
+			} `xml:"variantAlias"`
+			ZoneAlias []*struct {
+				Common
+				Replacement string `xml:"replacement,attr"`
+				Reason      string `xml:"reason,attr"`
+			} `xml:"zoneAlias"`
+		} `xml:"alias"`
+		Deprecated *struct {
+			Common
+			DeprecatedItems []*struct {
+				Common
+				Elements   string `xml:"elements,attr"`
+				Attributes string `xml:"attributes,attr"`
+				Values     string `xml:"values,attr"`
+			} `xml:"deprecatedItems"`
+		} `xml:"deprecated"`
+		Distinguishing *struct {
+			Common
+			DistinguishingItems []*struct {
+				Common
+				Exclude    string `xml:"exclude,attr"`
+				Elements   string `xml:"elements,attr"`
+				Attributes string `xml:"attributes,attr"`
+			} `xml:"distinguishingItems"`
+		} `xml:"distinguishing"`
+		Blocking *struct {
+			Common
+			BlockingItems []*struct {
+				Common
+				Elements string `xml:"elements,attr"`
+			} `xml:"blockingItems"`
+		} `xml:"blocking"`
+		CoverageAdditions *struct {
+			Common
+			LanguageCoverage []*struct {
+				Common
+				Values string `xml:"values,attr"`
+			} `xml:"languageCoverage"`
+			ScriptCoverage []*struct {
+				Common
+				Values string `xml:"values,attr"`
+			} `xml:"scriptCoverage"`
+			TerritoryCoverage []*struct {
+				Common
+				Values string `xml:"values,attr"`
+			} `xml:"territoryCoverage"`
+			CurrencyCoverage []*struct {
+				Common
+				Values string `xml:"values,attr"`
+			} `xml:"currencyCoverage"`
+			TimezoneCoverage []*struct {
+				Common
+				Values string `xml:"values,attr"`
+			} `xml:"timezoneCoverage"`
+		} `xml:"coverageAdditions"`
+		SkipDefaultLocale *struct {
+			Common
+			Services string `xml:"services,attr"`
+		} `xml:"skipDefaultLocale"`
+		DefaultContent *struct {
+			Common
+			Locales string `xml:"locales,attr"`
+		} `xml:"defaultContent"`
+	} `xml:"metadata"`
+	CodeMappings *struct {
+		Common
+		LanguageCodes []*struct {
+			Common
+			Alpha3 string `xml:"alpha3,attr"`
+		} `xml:"languageCodes"`
+		TerritoryCodes []*struct {
+			Common
+			Numeric  string `xml:"numeric,attr"`
+			Alpha3   string `xml:"alpha3,attr"`
+			Fips10   string `xml:"fips10,attr"`
+			Internet string `xml:"internet,attr"`
+		} `xml:"territoryCodes"`
+		CurrencyCodes []*struct {
+			Common
+			Numeric string `xml:"numeric,attr"`
+		} `xml:"currencyCodes"`
+	} `xml:"codeMappings"`
+	ParentLocales *struct {
+		Common
+		ParentLocale []*struct {
+			Common
+			Parent  string `xml:"parent,attr"`
+			Locales string `xml:"locales,attr"`
+		} `xml:"parentLocale"`
+	} `xml:"parentLocales"`
+	LikelySubtags *struct {
+		Common
+		LikelySubtag []*struct {
+			Common
+			From string `xml:"from,attr"`
+			To   string `xml:"to,attr"`
+		} `xml:"likelySubtag"`
+	} `xml:"likelySubtags"`
+	MetazoneInfo *struct {
+		Common
+		Timezone []*struct {
+			Common
+			UsesMetazone []*struct {
+				Common
+				From  string `xml:"from,attr"`
+				To    string `xml:"to,attr"`
+				Mzone string `xml:"mzone,attr"`
+			} `xml:"usesMetazone"`
+		} `xml:"timezone"`
+	} `xml:"metazoneInfo"`
+	Plurals []*struct {
+		Common
+		PluralRules []*struct {
+			Common
+			Locales    string `xml:"locales,attr"`
+			PluralRule []*struct {
+				Common
+				Count string `xml:"count,attr"`
+			} `xml:"pluralRule"`
+		} `xml:"pluralRules"`
+		PluralRanges []*struct {
+			Common
+			Locales     string `xml:"locales,attr"`
+			PluralRange []*struct {
+				Common
+				Start  string `xml:"start,attr"`
+				End    string `xml:"end,attr"`
+				Result string `xml:"result,attr"`
+			} `xml:"pluralRange"`
+		} `xml:"pluralRanges"`
+	} `xml:"plurals"`
+	TelephoneCodeData *struct {
+		Common
+		CodesByTerritory []*struct {
+			Common
+			Territory            string `xml:"territory,attr"`
+			TelephoneCountryCode []*struct {
+				Common
+				Code string `xml:"code,attr"`
+				From string `xml:"from,attr"`
+				To   string `xml:"to,attr"`
+			} `xml:"telephoneCountryCode"`
+		} `xml:"codesByTerritory"`
+	} `xml:"telephoneCodeData"`
+	NumberingSystems *struct {
+		Common
+		NumberingSystem []*struct {
+			Common
+			Id     string `xml:"id,attr"`
+			Radix  string `xml:"radix,attr"`
+			Digits string `xml:"digits,attr"`
+			Rules  string `xml:"rules,attr"`
+		} `xml:"numberingSystem"`
+	} `xml:"numberingSystems"`
+	Bcp47KeywordMappings *struct {
+		Common
+		MapKeys *struct {
+			Common
+			KeyMap []*struct {
+				Common
+				Bcp47 string `xml:"bcp47,attr"`
+			} `xml:"keyMap"`
+		} `xml:"mapKeys"`
+		MapTypes []*struct {
+			Common
+			TypeMap []*struct {
+				Common
+				Bcp47 string `xml:"bcp47,attr"`
+			} `xml:"typeMap"`
+		} `xml:"mapTypes"`
+	} `xml:"bcp47KeywordMappings"`
+	Gender *struct {
+		Common
+		PersonList []*struct {
+			Common
+			Locales string `xml:"locales,attr"`
+		} `xml:"personList"`
+	} `xml:"gender"`
+	References *struct {
+		Common
+		Reference []*struct {
+			Common
+			Uri string `xml:"uri,attr"`
+		} `xml:"reference"`
+	} `xml:"references"`
+	LanguageMatching *struct {
+		Common
+		LanguageMatches []*struct {
+			Common
+			ParadigmLocales []*struct {
+				Common
+				Locales string `xml:"locales,attr"`
+			} `xml:"paradigmLocales"`
+			MatchVariable []*struct {
+				Common
+				Id    string `xml:"id,attr"`
+				Value string `xml:"value,attr"`
+			} `xml:"matchVariable"`
+			LanguageMatch []*struct {
+				Common
+				Desired   string `xml:"desired,attr"`
+				Supported string `xml:"supported,attr"`
+				Percent   string `xml:"percent,attr"`
+				Distance  string `xml:"distance,attr"`
+				Oneway    string `xml:"oneway,attr"`
+			} `xml:"languageMatch"`
+		} `xml:"languageMatches"`
+	} `xml:"languageMatching"`
+	DayPeriodRuleSet []*struct {
+		Common
+		DayPeriodRules []*struct {
+			Common
+			Locales       string `xml:"locales,attr"`
+			DayPeriodRule []*struct {
+				Common
+				At     string `xml:"at,attr"`
+				After  string `xml:"after,attr"`
+				Before string `xml:"before,attr"`
+				From   string `xml:"from,attr"`
+				To     string `xml:"to,attr"`
+			} `xml:"dayPeriodRule"`
+		} `xml:"dayPeriodRules"`
+	} `xml:"dayPeriodRuleSet"`
+	MetaZones *struct {
+		Common
+		MetazoneInfo *struct {
+			Common
+			Timezone []*struct {
+				Common
+				UsesMetazone []*struct {
+					Common
+					From  string `xml:"from,attr"`
+					To    string `xml:"to,attr"`
+					Mzone string `xml:"mzone,attr"`
+				} `xml:"usesMetazone"`
+			} `xml:"timezone"`
+		} `xml:"metazoneInfo"`
+		MapTimezones *struct {
+			Common
+			OtherVersion string `xml:"otherVersion,attr"`
+			TypeVersion  string `xml:"typeVersion,attr"`
+			MapZone      []*struct {
+				Common
+				Other     string `xml:"other,attr"`
+				Territory string `xml:"territory,attr"`
+			} `xml:"mapZone"`
+		} `xml:"mapTimezones"`
+	} `xml:"metaZones"`
+	PrimaryZones *struct {
+		Common
+		PrimaryZone []*struct {
+			Common
+			Iso3166 string `xml:"iso3166,attr"`
+		} `xml:"primaryZone"`
+	} `xml:"primaryZones"`
+	WindowsZones *struct {
+		Common
+		MapTimezones *struct {
+			Common
+			OtherVersion string `xml:"otherVersion,attr"`
+			TypeVersion  string `xml:"typeVersion,attr"`
+			MapZone      []*struct {
+				Common
+				Other     string `xml:"other,attr"`
+				Territory string `xml:"territory,attr"`
+			} `xml:"mapZone"`
+		} `xml:"mapTimezones"`
+	} `xml:"windowsZones"`
+	CoverageLevels *struct {
+		Common
+		ApprovalRequirements *struct {
+			Common
+			ApprovalRequirement []*struct {
+				Common
+				Votes   string `xml:"votes,attr"`
+				Locales string `xml:"locales,attr"`
+				Paths   string `xml:"paths,attr"`
+			} `xml:"approvalRequirement"`
+		} `xml:"approvalRequirements"`
+		CoverageVariable []*struct {
+			Common
+			Key   string `xml:"key,attr"`
+			Value string `xml:"value,attr"`
+		} `xml:"coverageVariable"`
+		CoverageLevel []*struct {
+			Common
+			InLanguage  string `xml:"inLanguage,attr"`
+			InScript    string `xml:"inScript,attr"`
+			InTerritory string `xml:"inTerritory,attr"`
+			Value       string `xml:"value,attr"`
+			Match       string `xml:"match,attr"`
+		} `xml:"coverageLevel"`
+	} `xml:"coverageLevels"`
+	IdValidity *struct {
+		Common
+		Id []*struct {
+			Common
+			IdStatus string `xml:"idStatus,attr"`
+		} `xml:"id"`
+	} `xml:"idValidity"`
+	RgScope *struct {
+		Common
+		RgPath []*struct {
+			Common
+			Path string `xml:"path,attr"`
+		} `xml:"rgPath"`
+	} `xml:"rgScope"`
+}
+
+// LDML is the top-level type for locale-specific data.
+type LDML struct {
+	Common
+	Version  string `xml:"version,attr"`
+	Identity *struct {
+		Common
+		Version *struct {
+			Common
+			Number string `xml:"number,attr"`
+		} `xml:"version"`
+		Generation *struct {
+			Common
+			Date string `xml:"date,attr"`
+		} `xml:"generation"`
+		Language  *Common `xml:"language"`
+		Script    *Common `xml:"script"`
+		Territory *Common `xml:"territory"`
+		Variant   *Common `xml:"variant"`
+	} `xml:"identity"`
+	LocaleDisplayNames *LocaleDisplayNames `xml:"localeDisplayNames"`
+	Layout             *struct {
+		Common
+		Orientation []*struct {
+			Common
+			Characters     string    `xml:"characters,attr"`
+			Lines          string    `xml:"lines,attr"`
+			CharacterOrder []*Common `xml:"characterOrder"`
+			LineOrder      []*Common `xml:"lineOrder"`
+		} `xml:"orientation"`
+		InList []*struct {
+			Common
+			Casing string `xml:"casing,attr"`
+		} `xml:"inList"`
+		InText []*Common `xml:"inText"`
+	} `xml:"layout"`
+	ContextTransforms *struct {
+		Common
+		ContextTransformUsage []*struct {
+			Common
+			ContextTransform []*Common `xml:"contextTransform"`
+		} `xml:"contextTransformUsage"`
+	} `xml:"contextTransforms"`
+	Characters *struct {
+		Common
+		ExemplarCharacters []*Common `xml:"exemplarCharacters"`
+		Ellipsis           []*Common `xml:"ellipsis"`
+		MoreInformation    []*Common `xml:"moreInformation"`
+		Stopwords          []*struct {
+			Common
+			StopwordList []*Common `xml:"stopwordList"`
+		} `xml:"stopwords"`
+		IndexLabels []*struct {
+			Common
+			IndexSeparator           []*Common `xml:"indexSeparator"`
+			CompressedIndexSeparator []*Common `xml:"compressedIndexSeparator"`
+			IndexRangePattern        []*Common `xml:"indexRangePattern"`
+			IndexLabelBefore         []*Common `xml:"indexLabelBefore"`
+			IndexLabelAfter          []*Common `xml:"indexLabelAfter"`
+			IndexLabel               []*struct {
+				Common
+				IndexSource string `xml:"indexSource,attr"`
+				Priority    string `xml:"priority,attr"`
+			} `xml:"indexLabel"`
+		} `xml:"indexLabels"`
+		Mapping []*struct {
+			Common
+			Registry string `xml:"registry,attr"`
+		} `xml:"mapping"`
+		ParseLenients []*struct {
+			Common
+			Scope        string `xml:"scope,attr"`
+			Level        string `xml:"level,attr"`
+			ParseLenient []*struct {
+				Common
+				Sample string `xml:"sample,attr"`
+			} `xml:"parseLenient"`
+		} `xml:"parseLenients"`
+	} `xml:"characters"`
+	Delimiters *struct {
+		Common
+		QuotationStart          []*Common `xml:"quotationStart"`
+		QuotationEnd            []*Common `xml:"quotationEnd"`
+		AlternateQuotationStart []*Common `xml:"alternateQuotationStart"`
+		AlternateQuotationEnd   []*Common `xml:"alternateQuotationEnd"`
+	} `xml:"delimiters"`
+	Measurement *struct {
+		Common
+		MeasurementSystem []*Common `xml:"measurementSystem"`
+		PaperSize         []*struct {
+			Common
+			Height []*Common `xml:"height"`
+			Width  []*Common `xml:"width"`
+		} `xml:"paperSize"`
+	} `xml:"measurement"`
+	Dates *struct {
+		Common
+		LocalizedPatternChars []*Common `xml:"localizedPatternChars"`
+		DateRangePattern      []*Common `xml:"dateRangePattern"`
+		Calendars             *struct {
+			Common
+			Calendar []*Calendar `xml:"calendar"`
+		} `xml:"calendars"`
+		Fields *struct {
+			Common
+			Field []*struct {
+				Common
+				DisplayName []*struct {
+					Common
+					Count string `xml:"count,attr"`
+				} `xml:"displayName"`
+				Relative     []*Common `xml:"relative"`
+				RelativeTime []*struct {
+					Common
+					RelativeTimePattern []*struct {
+						Common
+						Count string `xml:"count,attr"`
+					} `xml:"relativeTimePattern"`
+				} `xml:"relativeTime"`
+				RelativePeriod []*Common `xml:"relativePeriod"`
+			} `xml:"field"`
+		} `xml:"fields"`
+		TimeZoneNames *TimeZoneNames `xml:"timeZoneNames"`
+	} `xml:"dates"`
+	Numbers *Numbers `xml:"numbers"`
+	Units   *struct {
+		Common
+		Unit []*struct {
+			Common
+			DisplayName []*struct {
+				Common
+				Count string `xml:"count,attr"`
+			} `xml:"displayName"`
+			UnitPattern []*struct {
+				Common
+				Count string `xml:"count,attr"`
+			} `xml:"unitPattern"`
+			PerUnitPattern []*Common `xml:"perUnitPattern"`
+		} `xml:"unit"`
+		UnitLength []*struct {
+			Common
+			CompoundUnit []*struct {
+				Common
+				CompoundUnitPattern []*Common `xml:"compoundUnitPattern"`
+			} `xml:"compoundUnit"`
+			Unit []*struct {
+				Common
+				DisplayName []*struct {
+					Common
+					Count string `xml:"count,attr"`
+				} `xml:"displayName"`
+				UnitPattern []*struct {
+					Common
+					Count string `xml:"count,attr"`
+				} `xml:"unitPattern"`
+				PerUnitPattern []*Common `xml:"perUnitPattern"`
+			} `xml:"unit"`
+			CoordinateUnit []*struct {
+				Common
+				CoordinateUnitPattern []*Common `xml:"coordinateUnitPattern"`
+			} `xml:"coordinateUnit"`
+		} `xml:"unitLength"`
+		DurationUnit []*struct {
+			Common
+			DurationUnitPattern []*Common `xml:"durationUnitPattern"`
+		} `xml:"durationUnit"`
+	} `xml:"units"`
+	ListPatterns *struct {
+		Common
+		ListPattern []*struct {
+			Common
+			ListPatternPart []*Common `xml:"listPatternPart"`
+		} `xml:"listPattern"`
+	} `xml:"listPatterns"`
+	Collations *struct {
+		Common
+		Version          string       `xml:"version,attr"`
+		DefaultCollation *Common      `xml:"defaultCollation"`
+		Collation        []*Collation `xml:"collation"`
+	} `xml:"collations"`
+	Posix *struct {
+		Common
+		Messages []*struct {
+			Common
+			Yesstr  []*Common `xml:"yesstr"`
+			Nostr   []*Common `xml:"nostr"`
+			Yesexpr []*Common `xml:"yesexpr"`
+			Noexpr  []*Common `xml:"noexpr"`
+		} `xml:"messages"`
+	} `xml:"posix"`
+	CharacterLabels *struct {
+		Common
+		CharacterLabelPattern []*struct {
+			Common
+			Count string `xml:"count,attr"`
+		} `xml:"characterLabelPattern"`
+		CharacterLabel []*Common `xml:"characterLabel"`
+	} `xml:"characterLabels"`
+	Segmentations *struct {
+		Common
+		Segmentation []*struct {
+			Common
+			Variables *struct {
+				Common
+				Variable []*struct {
+					Common
+					Id string `xml:"id,attr"`
+				} `xml:"variable"`
+			} `xml:"variables"`
+			SegmentRules *struct {
+				Common
+				Rule []*struct {
+					Common
+					Id string `xml:"id,attr"`
+				} `xml:"rule"`
+			} `xml:"segmentRules"`
+			Exceptions *struct {
+				Common
+				Exception []*Common `xml:"exception"`
+			} `xml:"exceptions"`
+			Suppressions *struct {
+				Common
+				Suppression []*Common `xml:"suppression"`
+			} `xml:"suppressions"`
+		} `xml:"segmentation"`
+	} `xml:"segmentations"`
+	Rbnf *struct {
+		Common
+		RulesetGrouping []*struct {
+			Common
+			Ruleset []*struct {
+				Common
+				Access        string `xml:"access,attr"`
+				AllowsParsing string `xml:"allowsParsing,attr"`
+				Rbnfrule      []*struct {
+					Common
+					Value  string `xml:"value,attr"`
+					Radix  string `xml:"radix,attr"`
+					Decexp string `xml:"decexp,attr"`
+				} `xml:"rbnfrule"`
+			} `xml:"ruleset"`
+		} `xml:"rulesetGrouping"`
+	} `xml:"rbnf"`
+	Annotations *struct {
+		Common
+		Annotation []*struct {
+			Common
+			Cp  string `xml:"cp,attr"`
+			Tts string `xml:"tts,attr"`
+		} `xml:"annotation"`
+	} `xml:"annotations"`
+	Metadata *struct {
+		Common
+		CasingData *struct {
+			Common
+			CasingItem []*struct {
+				Common
+				Override   string `xml:"override,attr"`
+				ForceError string `xml:"forceError,attr"`
+			} `xml:"casingItem"`
+		} `xml:"casingData"`
+	} `xml:"metadata"`
+	References *struct {
+		Common
+		Reference []*struct {
+			Common
+			Uri string `xml:"uri,attr"`
+		} `xml:"reference"`
+	} `xml:"references"`
+}
+
+// Collation contains rules that specify a certain sort-order,
+// as a tailoring of the root order.
+// The parsed rules are obtained by passing a RuleProcessor to Collation's
+// Process method.
+type Collation struct {
+	Common
+	Visibility string  `xml:"visibility,attr"`
+	Base       *Common `xml:"base"`
+	Import     []*struct {
+		Common
+		Source string `xml:"source,attr"`
+	} `xml:"import"`
+	Settings *struct {
+		Common
+		Strength           string `xml:"strength,attr"`
+		Alternate          string `xml:"alternate,attr"`
+		Backwards          string `xml:"backwards,attr"`
+		Normalization      string `xml:"normalization,attr"`
+		CaseLevel          string `xml:"caseLevel,attr"`
+		CaseFirst          string `xml:"caseFirst,attr"`
+		HiraganaQuaternary string `xml:"hiraganaQuaternary,attr"`
+		MaxVariable        string `xml:"maxVariable,attr"`
+		Numeric            string `xml:"numeric,attr"`
+		Private            string `xml:"private,attr"`
+		VariableTop        string `xml:"variableTop,attr"`
+		Reorder            string `xml:"reorder,attr"`
+	} `xml:"settings"`
+	SuppressContractions *Common   `xml:"suppress_contractions"`
+	Optimize             *Common   `xml:"optimize"`
+	Cr                   []*Common `xml:"cr"`
+	rulesElem
+}
+
+// Calendar specifies the fields used for formatting and parsing dates and times.
+// The month and quarter names are identified numerically, starting at 1.
+// The day (of the week) names are identified with short strings, since there is
+// no universally-accepted numeric designation.
+type Calendar struct {
+	Common
+	Months *struct {
+		Common
+		MonthContext []*struct {
+			Common
+			MonthWidth []*struct {
+				Common
+				Month []*struct {
+					Common
+					Yeartype string `xml:"yeartype,attr"`
+				} `xml:"month"`
+			} `xml:"monthWidth"`
+		} `xml:"monthContext"`
+	} `xml:"months"`
+	MonthNames *struct {
+		Common
+		Month []*struct {
+			Common
+			Yeartype string `xml:"yeartype,attr"`
+		} `xml:"month"`
+	} `xml:"monthNames"`
+	MonthAbbr *struct {
+		Common
+		Month []*struct {
+			Common
+			Yeartype string `xml:"yeartype,attr"`
+		} `xml:"month"`
+	} `xml:"monthAbbr"`
+	MonthPatterns *struct {
+		Common
+		MonthPatternContext []*struct {
+			Common
+			MonthPatternWidth []*struct {
+				Common
+				MonthPattern []*Common `xml:"monthPattern"`
+			} `xml:"monthPatternWidth"`
+		} `xml:"monthPatternContext"`
+	} `xml:"monthPatterns"`
+	Days *struct {
+		Common
+		DayContext []*struct {
+			Common
+			DayWidth []*struct {
+				Common
+				Day []*Common `xml:"day"`
+			} `xml:"dayWidth"`
+		} `xml:"dayContext"`
+	} `xml:"days"`
+	DayNames *struct {
+		Common
+		Day []*Common `xml:"day"`
+	} `xml:"dayNames"`
+	DayAbbr *struct {
+		Common
+		Day []*Common `xml:"day"`
+	} `xml:"dayAbbr"`
+	Quarters *struct {
+		Common
+		QuarterContext []*struct {
+			Common
+			QuarterWidth []*struct {
+				Common
+				Quarter []*Common `xml:"quarter"`
+			} `xml:"quarterWidth"`
+		} `xml:"quarterContext"`
+	} `xml:"quarters"`
+	Week *struct {
+		Common
+		MinDays []*struct {
+			Common
+			Count string `xml:"count,attr"`
+		} `xml:"minDays"`
+		FirstDay []*struct {
+			Common
+			Day string `xml:"day,attr"`
+		} `xml:"firstDay"`
+		WeekendStart []*struct {
+			Common
+			Day  string `xml:"day,attr"`
+			Time string `xml:"time,attr"`
+		} `xml:"weekendStart"`
+		WeekendEnd []*struct {
+			Common
+			Day  string `xml:"day,attr"`
+			Time string `xml:"time,attr"`
+		} `xml:"weekendEnd"`
+	} `xml:"week"`
+	Am         []*Common `xml:"am"`
+	Pm         []*Common `xml:"pm"`
+	DayPeriods *struct {
+		Common
+		DayPeriodContext []*struct {
+			Common
+			DayPeriodWidth []*struct {
+				Common
+				DayPeriod []*Common `xml:"dayPeriod"`
+			} `xml:"dayPeriodWidth"`
+		} `xml:"dayPeriodContext"`
+	} `xml:"dayPeriods"`
+	Eras *struct {
+		Common
+		EraNames *struct {
+			Common
+			Era []*Common `xml:"era"`
+		} `xml:"eraNames"`
+		EraAbbr *struct {
+			Common
+			Era []*Common `xml:"era"`
+		} `xml:"eraAbbr"`
+		EraNarrow *struct {
+			Common
+			Era []*Common `xml:"era"`
+		} `xml:"eraNarrow"`
+	} `xml:"eras"`
+	CyclicNameSets *struct {
+		Common
+		CyclicNameSet []*struct {
+			Common
+			CyclicNameContext []*struct {
+				Common
+				CyclicNameWidth []*struct {
+					Common
+					CyclicName []*Common `xml:"cyclicName"`
+				} `xml:"cyclicNameWidth"`
+			} `xml:"cyclicNameContext"`
+		} `xml:"cyclicNameSet"`
+	} `xml:"cyclicNameSets"`
+	DateFormats *struct {
+		Common
+		DateFormatLength []*struct {
+			Common
+			DateFormat []*struct {
+				Common
+				Pattern []*struct {
+					Common
+					Numbers string `xml:"numbers,attr"`
+					Count   string `xml:"count,attr"`
+				} `xml:"pattern"`
+				DisplayName []*struct {
+					Common
+					Count string `xml:"count,attr"`
+				} `xml:"displayName"`
+			} `xml:"dateFormat"`
+		} `xml:"dateFormatLength"`
+	} `xml:"dateFormats"`
+	TimeFormats *struct {
+		Common
+		TimeFormatLength []*struct {
+			Common
+			TimeFormat []*struct {
+				Common
+				Pattern []*struct {
+					Common
+					Numbers string `xml:"numbers,attr"`
+					Count   string `xml:"count,attr"`
+				} `xml:"pattern"`
+				DisplayName []*struct {
+					Common
+					Count string `xml:"count,attr"`
+				} `xml:"displayName"`
+			} `xml:"timeFormat"`
+		} `xml:"timeFormatLength"`
+	} `xml:"timeFormats"`
+	DateTimeFormats *struct {
+		Common
+		DateTimeFormatLength []*struct {
+			Common
+			DateTimeFormat []*struct {
+				Common
+				Pattern []*struct {
+					Common
+					Numbers string `xml:"numbers,attr"`
+					Count   string `xml:"count,attr"`
+				} `xml:"pattern"`
+				DisplayName []*struct {
+					Common
+					Count string `xml:"count,attr"`
+				} `xml:"displayName"`
+			} `xml:"dateTimeFormat"`
+		} `xml:"dateTimeFormatLength"`
+		AvailableFormats []*struct {
+			Common
+			DateFormatItem []*struct {
+				Common
+				Id    string `xml:"id,attr"`
+				Count string `xml:"count,attr"`
+			} `xml:"dateFormatItem"`
+		} `xml:"availableFormats"`
+		AppendItems []*struct {
+			Common
+			AppendItem []*struct {
+				Common
+				Request string `xml:"request,attr"`
+			} `xml:"appendItem"`
+		} `xml:"appendItems"`
+		IntervalFormats []*struct {
+			Common
+			IntervalFormatFallback []*Common `xml:"intervalFormatFallback"`
+			IntervalFormatItem     []*struct {
+				Common
+				Id                 string `xml:"id,attr"`
+				GreatestDifference []*struct {
+					Common
+					Id string `xml:"id,attr"`
+				} `xml:"greatestDifference"`
+			} `xml:"intervalFormatItem"`
+		} `xml:"intervalFormats"`
+	} `xml:"dateTimeFormats"`
+	Fields []*struct {
+		Common
+		Field []*struct {
+			Common
+			DisplayName []*struct {
+				Common
+				Count string `xml:"count,attr"`
+			} `xml:"displayName"`
+			Relative     []*Common `xml:"relative"`
+			RelativeTime []*struct {
+				Common
+				RelativeTimePattern []*struct {
+					Common
+					Count string `xml:"count,attr"`
+				} `xml:"relativeTimePattern"`
+			} `xml:"relativeTime"`
+			RelativePeriod []*Common `xml:"relativePeriod"`
+		} `xml:"field"`
+	} `xml:"fields"`
+}
+type TimeZoneNames struct {
+	Common
+	HourFormat           []*Common `xml:"hourFormat"`
+	HoursFormat          []*Common `xml:"hoursFormat"`
+	GmtFormat            []*Common `xml:"gmtFormat"`
+	GmtZeroFormat        []*Common `xml:"gmtZeroFormat"`
+	RegionFormat         []*Common `xml:"regionFormat"`
+	FallbackFormat       []*Common `xml:"fallbackFormat"`
+	FallbackRegionFormat []*Common `xml:"fallbackRegionFormat"`
+	AbbreviationFallback []*Common `xml:"abbreviationFallback"`
+	PreferenceOrdering   []*Common `xml:"preferenceOrdering"`
+	SingleCountries      []*struct {
+		Common
+		List string `xml:"list,attr"`
+	} `xml:"singleCountries"`
+	Zone []*struct {
+		Common
+		Long []*struct {
+			Common
+			Generic  []*Common `xml:"generic"`
+			Standard []*Common `xml:"standard"`
+			Daylight []*Common `xml:"daylight"`
+		} `xml:"long"`
+		Short []*struct {
+			Common
+			Generic  []*Common `xml:"generic"`
+			Standard []*Common `xml:"standard"`
+			Daylight []*Common `xml:"daylight"`
+		} `xml:"short"`
+		CommonlyUsed []*struct {
+			Common
+			Used string `xml:"used,attr"`
+		} `xml:"commonlyUsed"`
+		ExemplarCity []*Common `xml:"exemplarCity"`
+	} `xml:"zone"`
+	Metazone []*struct {
+		Common
+		Long []*struct {
+			Common
+			Generic  []*Common `xml:"generic"`
+			Standard []*Common `xml:"standard"`
+			Daylight []*Common `xml:"daylight"`
+		} `xml:"long"`
+		Short []*struct {
+			Common
+			Generic  []*Common `xml:"generic"`
+			Standard []*Common `xml:"standard"`
+			Daylight []*Common `xml:"daylight"`
+		} `xml:"short"`
+		CommonlyUsed []*struct {
+			Common
+			Used string `xml:"used,attr"`
+		} `xml:"commonlyUsed"`
+	} `xml:"metazone"`
+}
+
+// LocaleDisplayNames specifies localized display names for for scripts, languages,
+// countries, currencies, and variants.
+type LocaleDisplayNames struct {
+	Common
+	LocaleDisplayPattern *struct {
+		Common
+		LocalePattern        []*Common `xml:"localePattern"`
+		LocaleSeparator      []*Common `xml:"localeSeparator"`
+		LocaleKeyTypePattern []*Common `xml:"localeKeyTypePattern"`
+	} `xml:"localeDisplayPattern"`
+	Languages *struct {
+		Common
+		Language []*Common `xml:"language"`
+	} `xml:"languages"`
+	Scripts *struct {
+		Common
+		Script []*Common `xml:"script"`
+	} `xml:"scripts"`
+	Territories *struct {
+		Common
+		Territory []*Common `xml:"territory"`
+	} `xml:"territories"`
+	Subdivisions *struct {
+		Common
+		Subdivision []*Common `xml:"subdivision"`
+	} `xml:"subdivisions"`
+	Variants *struct {
+		Common
+		Variant []*Common `xml:"variant"`
+	} `xml:"variants"`
+	Keys *struct {
+		Common
+		Key []*Common `xml:"key"`
+	} `xml:"keys"`
+	Types *struct {
+		Common
+		Type []*struct {
+			Common
+			Key string `xml:"key,attr"`
+		} `xml:"type"`
+	} `xml:"types"`
+	TransformNames *struct {
+		Common
+		TransformName []*Common `xml:"transformName"`
+	} `xml:"transformNames"`
+	MeasurementSystemNames *struct {
+		Common
+		MeasurementSystemName []*Common `xml:"measurementSystemName"`
+	} `xml:"measurementSystemNames"`
+	CodePatterns *struct {
+		Common
+		CodePattern []*Common `xml:"codePattern"`
+	} `xml:"codePatterns"`
+}
+
+// Numbers supplies information for formatting and parsing numbers and currencies.
+type Numbers struct {
+	Common
+	DefaultNumberingSystem []*Common `xml:"defaultNumberingSystem"`
+	OtherNumberingSystems  []*struct {
+		Common
+		Native      []*Common `xml:"native"`
+		Traditional []*Common `xml:"traditional"`
+		Finance     []*Common `xml:"finance"`
+	} `xml:"otherNumberingSystems"`
+	MinimumGroupingDigits []*Common `xml:"minimumGroupingDigits"`
+	Symbols               []*struct {
+		Common
+		NumberSystem string `xml:"numberSystem,attr"`
+		Decimal      []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"decimal"`
+		Group []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"group"`
+		List []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"list"`
+		PercentSign []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"percentSign"`
+		NativeZeroDigit []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"nativeZeroDigit"`
+		PatternDigit []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"patternDigit"`
+		PlusSign []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"plusSign"`
+		MinusSign []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"minusSign"`
+		Exponential []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"exponential"`
+		SuperscriptingExponent []*Common `xml:"superscriptingExponent"`
+		PerMille               []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"perMille"`
+		Infinity []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"infinity"`
+		Nan []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"nan"`
+		CurrencyDecimal []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"currencyDecimal"`
+		CurrencyGroup []*struct {
+			Common
+			NumberSystem string `xml:"numberSystem,attr"`
+		} `xml:"currencyGroup"`
+		TimeSeparator []*Common `xml:"timeSeparator"`
+	} `xml:"symbols"`
+	DecimalFormats []*struct {
+		Common
+		NumberSystem        string `xml:"numberSystem,attr"`
+		DecimalFormatLength []*struct {
+			Common
+			DecimalFormat []*struct {
+				Common
+				Pattern []*struct {
+					Common
+					Numbers string `xml:"numbers,attr"`
+					Count   string `xml:"count,attr"`
+				} `xml:"pattern"`
+			} `xml:"decimalFormat"`
+		} `xml:"decimalFormatLength"`
+	} `xml:"decimalFormats"`
+	ScientificFormats []*struct {
+		Common
+		NumberSystem           string `xml:"numberSystem,attr"`
+		ScientificFormatLength []*struct {
+			Common
+			ScientificFormat []*struct {
+				Common
+				Pattern []*struct {
+					Common
+					Numbers string `xml:"numbers,attr"`
+					Count   string `xml:"count,attr"`
+				} `xml:"pattern"`
+			} `xml:"scientificFormat"`
+		} `xml:"scientificFormatLength"`
+	} `xml:"scientificFormats"`
+	PercentFormats []*struct {
+		Common
+		NumberSystem        string `xml:"numberSystem,attr"`
+		PercentFormatLength []*struct {
+			Common
+			PercentFormat []*struct {
+				Common
+				Pattern []*struct {
+					Common
+					Numbers string `xml:"numbers,attr"`
+					Count   string `xml:"count,attr"`
+				} `xml:"pattern"`
+			} `xml:"percentFormat"`
+		} `xml:"percentFormatLength"`
+	} `xml:"percentFormats"`
+	CurrencyFormats []*struct {
+		Common
+		NumberSystem    string `xml:"numberSystem,attr"`
+		CurrencySpacing []*struct {
+			Common
+			BeforeCurrency []*struct {
+				Common
+				CurrencyMatch    []*Common `xml:"currencyMatch"`
+				SurroundingMatch []*Common `xml:"surroundingMatch"`
+				InsertBetween    []*Common `xml:"insertBetween"`
+			} `xml:"beforeCurrency"`
+			AfterCurrency []*struct {
+				Common
+				CurrencyMatch    []*Common `xml:"currencyMatch"`
+				SurroundingMatch []*Common `xml:"surroundingMatch"`
+				InsertBetween    []*Common `xml:"insertBetween"`
+			} `xml:"afterCurrency"`
+		} `xml:"currencySpacing"`
+		CurrencyFormatLength []*struct {
+			Common
+			CurrencyFormat []*struct {
+				Common
+				Pattern []*struct {
+					Common
+					Numbers string `xml:"numbers,attr"`
+					Count   string `xml:"count,attr"`
+				} `xml:"pattern"`
+			} `xml:"currencyFormat"`
+		} `xml:"currencyFormatLength"`
+		UnitPattern []*struct {
+			Common
+			Count string `xml:"count,attr"`
+		} `xml:"unitPattern"`
+	} `xml:"currencyFormats"`
+	Currencies *struct {
+		Common
+		Currency []*struct {
+			Common
+			Pattern []*struct {
+				Common
+				Numbers string `xml:"numbers,attr"`
+				Count   string `xml:"count,attr"`
+			} `xml:"pattern"`
+			DisplayName []*struct {
+				Common
+				Count string `xml:"count,attr"`
+			} `xml:"displayName"`
+			Symbol  []*Common `xml:"symbol"`
+			Decimal []*struct {
+				Common
+				NumberSystem string `xml:"numberSystem,attr"`
+			} `xml:"decimal"`
+			Group []*struct {
+				Common
+				NumberSystem string `xml:"numberSystem,attr"`
+			} `xml:"group"`
+		} `xml:"currency"`
+	} `xml:"currencies"`
+	MiscPatterns []*struct {
+		Common
+		NumberSystem string `xml:"numberSystem,attr"`
+		Pattern      []*struct {
+			Common
+			Numbers string `xml:"numbers,attr"`
+			Count   string `xml:"count,attr"`
+		} `xml:"pattern"`
+	} `xml:"miscPatterns"`
+	MinimalPairs []*struct {
+		Common
+		PluralMinimalPairs []*struct {
+			Common
+			Count string `xml:"count,attr"`
+		} `xml:"pluralMinimalPairs"`
+		OrdinalMinimalPairs []*struct {
+			Common
+			Ordinal string `xml:"ordinal,attr"`
+		} `xml:"ordinalMinimalPairs"`
+	} `xml:"minimalPairs"`
+}
+
+// Version is the version of CLDR from which the XML definitions are generated.
+const Version = "31"
diff --git a/vendor/golang.org/x/text/unicode/doc.go b/vendor/golang.org/x/text/unicode/doc.go
new file mode 100644
index 0000000..e8f1032
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/doc.go
@@ -0,0 +1,8 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// unicode holds packages with implementations of Unicode standards that are
+// mostly used as building blocks for other packages in golang.org/x/text,
+// layout engines, or are otherwise more low-level in nature.
+package unicode
diff --git a/vendor/golang.org/x/text/unicode/rangetable/gen.go b/vendor/golang.org/x/text/unicode/rangetable/gen.go
new file mode 100644
index 0000000..bea49dd
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/rangetable/gen.go
@@ -0,0 +1,113 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build ignore
+
+package main
+
+import (
+	"bytes"
+	"flag"
+	"fmt"
+	"io"
+	"log"
+	"reflect"
+	"sort"
+	"strings"
+	"unicode"
+
+	"golang.org/x/text/internal/gen"
+	"golang.org/x/text/internal/ucd"
+	"golang.org/x/text/unicode/rangetable"
+)
+
+var versionList = flag.String("versions", "",
+	"list of versions for which to generate RangeTables")
+
+const bootstrapMessage = `No versions specified.
+To bootstrap the code generation, run:
+	go run gen.go --versions=4.1.0,5.0.0,6.0.0,6.1.0,6.2.0,6.3.0,7.0.0
+
+and ensure that the latest versions are included by checking:
+	http://www.unicode.org/Public/`
+
+func getVersions() []string {
+	if *versionList == "" {
+		log.Fatal(bootstrapMessage)
+	}
+
+	versions := strings.Split(*versionList, ",")
+	sort.Strings(versions)
+
+	// Ensure that at least the current version is included.
+	for _, v := range versions {
+		if v == gen.UnicodeVersion() {
+			return versions
+		}
+	}
+
+	versions = append(versions, gen.UnicodeVersion())
+	sort.Strings(versions)
+	return versions
+}
+
+func main() {
+	gen.Init()
+
+	versions := getVersions()
+
+	w := &bytes.Buffer{}
+
+	fmt.Fprintf(w, "//go:generate go run gen.go --versions=%s\n\n", strings.Join(versions, ","))
+	fmt.Fprintf(w, "import \"unicode\"\n\n")
+
+	vstr := func(s string) string { return strings.Replace(s, ".", "_", -1) }
+
+	fmt.Fprintf(w, "var assigned = map[string]*unicode.RangeTable{\n")
+	for _, v := range versions {
+		fmt.Fprintf(w, "\t%q: assigned%s,\n", v, vstr(v))
+	}
+	fmt.Fprintf(w, "}\n\n")
+
+	var size int
+	for _, v := range versions {
+		assigned := []rune{}
+
+		r := gen.Open("http://www.unicode.org/Public/", "", v+"/ucd/UnicodeData.txt")
+		ucd.Parse(r, func(p *ucd.Parser) {
+			assigned = append(assigned, p.Rune(0))
+		})
+
+		rt := rangetable.New(assigned...)
+		sz := int(reflect.TypeOf(unicode.RangeTable{}).Size())
+		sz += int(reflect.TypeOf(unicode.Range16{}).Size()) * len(rt.R16)
+		sz += int(reflect.TypeOf(unicode.Range32{}).Size()) * len(rt.R32)
+
+		fmt.Fprintf(w, "// size %d bytes (%d KiB)\n", sz, sz/1024)
+		fmt.Fprintf(w, "var assigned%s = ", vstr(v))
+		print(w, rt)
+
+		size += sz
+	}
+
+	fmt.Fprintf(w, "// Total size %d bytes (%d KiB)\n", size, size/1024)
+
+	gen.WriteGoFile("tables.go", "rangetable", w.Bytes())
+}
+
+func print(w io.Writer, rt *unicode.RangeTable) {
+	fmt.Fprintln(w, "&unicode.RangeTable{")
+	fmt.Fprintln(w, "\tR16: []unicode.Range16{")
+	for _, r := range rt.R16 {
+		fmt.Fprintf(w, "\t\t{%#04x, %#04x, %d},\n", r.Lo, r.Hi, r.Stride)
+	}
+	fmt.Fprintln(w, "\t},")
+	fmt.Fprintln(w, "\tR32: []unicode.Range32{")
+	for _, r := range rt.R32 {
+		fmt.Fprintf(w, "\t\t{%#08x, %#08x, %d},\n", r.Lo, r.Hi, r.Stride)
+	}
+	fmt.Fprintln(w, "\t},")
+	fmt.Fprintf(w, "\tLatinOffset: %d,\n", rt.LatinOffset)
+	fmt.Fprintf(w, "}\n\n")
+}
diff --git a/vendor/golang.org/x/text/unicode/rangetable/merge.go b/vendor/golang.org/x/text/unicode/rangetable/merge.go
new file mode 100644
index 0000000..ea2a080
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/rangetable/merge.go
@@ -0,0 +1,260 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package rangetable
+
+import (
+	"unicode"
+)
+
+// atEnd is used to mark a completed iteration.
+const atEnd = unicode.MaxRune + 1
+
+// Merge returns a new RangeTable that is the union of the given tables.
+// It can also be used to compact user-created RangeTables. The entries in
+// R16 and R32 for any given RangeTable should be sorted and non-overlapping.
+//
+// A lookup in the resulting table can be several times faster than using In
+// directly on the ranges. Merge is an expensive operation, however, and only
+// makes sense if one intends to use the result for more than a couple of
+// hundred lookups.
+func Merge(ranges ...*unicode.RangeTable) *unicode.RangeTable {
+	rt := &unicode.RangeTable{}
+	if len(ranges) == 0 {
+		return rt
+	}
+
+	iter := tablesIter(make([]tableIndex, len(ranges)))
+
+	for i, t := range ranges {
+		iter[i] = tableIndex{t, 0, atEnd}
+		if len(t.R16) > 0 {
+			iter[i].next = rune(t.R16[0].Lo)
+		}
+	}
+
+	if r0 := iter.next16(); r0.Stride != 0 {
+		for {
+			r1 := iter.next16()
+			if r1.Stride == 0 {
+				rt.R16 = append(rt.R16, r0)
+				break
+			}
+			stride := r1.Lo - r0.Hi
+			if (r1.Lo == r1.Hi || stride == r1.Stride) && (r0.Lo == r0.Hi || stride == r0.Stride) {
+				// Fully merge the next range into the previous one.
+				r0.Hi, r0.Stride = r1.Hi, stride
+				continue
+			} else if stride == r0.Stride {
+				// Move the first element of r1 to r0. This may eliminate an
+				// entry.
+				r0.Hi = r1.Lo
+				r0.Stride = stride
+				r1.Lo = r1.Lo + r1.Stride
+				if r1.Lo > r1.Hi {
+					continue
+				}
+			}
+			rt.R16 = append(rt.R16, r0)
+			r0 = r1
+		}
+	}
+
+	for i, t := range ranges {
+		iter[i] = tableIndex{t, 0, atEnd}
+		if len(t.R32) > 0 {
+			iter[i].next = rune(t.R32[0].Lo)
+		}
+	}
+
+	if r0 := iter.next32(); r0.Stride != 0 {
+		for {
+			r1 := iter.next32()
+			if r1.Stride == 0 {
+				rt.R32 = append(rt.R32, r0)
+				break
+			}
+			stride := r1.Lo - r0.Hi
+			if (r1.Lo == r1.Hi || stride == r1.Stride) && (r0.Lo == r0.Hi || stride == r0.Stride) {
+				// Fully merge the next range into the previous one.
+				r0.Hi, r0.Stride = r1.Hi, stride
+				continue
+			} else if stride == r0.Stride {
+				// Move the first element of r1 to r0. This may eliminate an
+				// entry.
+				r0.Hi = r1.Lo
+				r1.Lo = r1.Lo + r1.Stride
+				if r1.Lo > r1.Hi {
+					continue
+				}
+			}
+			rt.R32 = append(rt.R32, r0)
+			r0 = r1
+		}
+	}
+
+	for i := 0; i < len(rt.R16) && rt.R16[i].Hi <= unicode.MaxLatin1; i++ {
+		rt.LatinOffset = i + 1
+	}
+
+	return rt
+}
+
+type tableIndex struct {
+	t    *unicode.RangeTable
+	p    uint32
+	next rune
+}
+
+type tablesIter []tableIndex
+
+// sortIter does an insertion sort using the next field of tableIndex. Insertion
+// sort is a good sorting algorithm for this case.
+func sortIter(t []tableIndex) {
+	for i := range t {
+		for j := i; j > 0 && t[j-1].next > t[j].next; j-- {
+			t[j], t[j-1] = t[j-1], t[j]
+		}
+	}
+}
+
+// next16 finds the ranged to be added to the table. If ranges overlap between
+// multiple tables it clips the result to a non-overlapping range if the
+// elements are not fully subsumed. It returns a zero range if there are no more
+// ranges.
+func (ti tablesIter) next16() unicode.Range16 {
+	sortIter(ti)
+
+	t0 := ti[0]
+	if t0.next == atEnd {
+		return unicode.Range16{}
+	}
+	r0 := t0.t.R16[t0.p]
+	r0.Lo = uint16(t0.next)
+
+	// We restrict the Hi of the current range if it overlaps with another range.
+	for i := range ti {
+		tn := ti[i]
+		// Since our tableIndices are sorted by next, we can break if the there
+		// is no overlap. The first value of a next range can always be merged
+		// into the current one, so we can break in case of equality as well.
+		if rune(r0.Hi) <= tn.next {
+			break
+		}
+		rn := tn.t.R16[tn.p]
+		rn.Lo = uint16(tn.next)
+
+		// Limit r0.Hi based on next ranges in list, but allow it to overlap
+		// with ranges as long as it subsumes it.
+		m := (rn.Lo - r0.Lo) % r0.Stride
+		if m == 0 && (rn.Stride == r0.Stride || rn.Lo == rn.Hi) {
+			// Overlap, take the min of the two Hi values: for simplicity's sake
+			// we only process one range at a time.
+			if r0.Hi > rn.Hi {
+				r0.Hi = rn.Hi
+			}
+		} else {
+			// Not a compatible stride. Set to the last possible value before
+			// rn.Lo, but ensure there is at least one value.
+			if x := rn.Lo - m; r0.Lo <= x {
+				r0.Hi = x
+			}
+			break
+		}
+	}
+
+	// Update the next values for each table.
+	for i := range ti {
+		tn := &ti[i]
+		if rune(r0.Hi) < tn.next {
+			break
+		}
+		rn := tn.t.R16[tn.p]
+		stride := rune(rn.Stride)
+		tn.next += stride * (1 + ((rune(r0.Hi) - tn.next) / stride))
+		if rune(rn.Hi) < tn.next {
+			if tn.p++; int(tn.p) == len(tn.t.R16) {
+				tn.next = atEnd
+			} else {
+				tn.next = rune(tn.t.R16[tn.p].Lo)
+			}
+		}
+	}
+
+	if r0.Lo == r0.Hi {
+		r0.Stride = 1
+	}
+
+	return r0
+}
+
+// next32 finds the ranged to be added to the table. If ranges overlap between
+// multiple tables it clips the result to a non-overlapping range if the
+// elements are not fully subsumed. It returns a zero range if there are no more
+// ranges.
+func (ti tablesIter) next32() unicode.Range32 {
+	sortIter(ti)
+
+	t0 := ti[0]
+	if t0.next == atEnd {
+		return unicode.Range32{}
+	}
+	r0 := t0.t.R32[t0.p]
+	r0.Lo = uint32(t0.next)
+
+	// We restrict the Hi of the current range if it overlaps with another range.
+	for i := range ti {
+		tn := ti[i]
+		// Since our tableIndices are sorted by next, we can break if the there
+		// is no overlap. The first value of a next range can always be merged
+		// into the current one, so we can break in case of equality as well.
+		if rune(r0.Hi) <= tn.next {
+			break
+		}
+		rn := tn.t.R32[tn.p]
+		rn.Lo = uint32(tn.next)
+
+		// Limit r0.Hi based on next ranges in list, but allow it to overlap
+		// with ranges as long as it subsumes it.
+		m := (rn.Lo - r0.Lo) % r0.Stride
+		if m == 0 && (rn.Stride == r0.Stride || rn.Lo == rn.Hi) {
+			// Overlap, take the min of the two Hi values: for simplicity's sake
+			// we only process one range at a time.
+			if r0.Hi > rn.Hi {
+				r0.Hi = rn.Hi
+			}
+		} else {
+			// Not a compatible stride. Set to the last possible value before
+			// rn.Lo, but ensure there is at least one value.
+			if x := rn.Lo - m; r0.Lo <= x {
+				r0.Hi = x
+			}
+			break
+		}
+	}
+
+	// Update the next values for each table.
+	for i := range ti {
+		tn := &ti[i]
+		if rune(r0.Hi) < tn.next {
+			break
+		}
+		rn := tn.t.R32[tn.p]
+		stride := rune(rn.Stride)
+		tn.next += stride * (1 + ((rune(r0.Hi) - tn.next) / stride))
+		if rune(rn.Hi) < tn.next {
+			if tn.p++; int(tn.p) == len(tn.t.R32) {
+				tn.next = atEnd
+			} else {
+				tn.next = rune(tn.t.R32[tn.p].Lo)
+			}
+		}
+	}
+
+	if r0.Lo == r0.Hi {
+		r0.Stride = 1
+	}
+
+	return r0
+}
diff --git a/vendor/golang.org/x/text/unicode/rangetable/rangetable.go b/vendor/golang.org/x/text/unicode/rangetable/rangetable.go
new file mode 100644
index 0000000..187882c
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/rangetable/rangetable.go
@@ -0,0 +1,70 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package rangetable provides utilities for creating and inspecting
+// unicode.RangeTables.
+package rangetable
+
+import (
+	"sort"
+	"unicode"
+)
+
+// New creates a RangeTable from the given runes, which may contain duplicates.
+func New(r ...rune) *unicode.RangeTable {
+	if len(r) == 0 {
+		return &unicode.RangeTable{}
+	}
+
+	sort.Sort(byRune(r))
+
+	// Remove duplicates.
+	k := 1
+	for i := 1; i < len(r); i++ {
+		if r[k-1] != r[i] {
+			r[k] = r[i]
+			k++
+		}
+	}
+
+	var rt unicode.RangeTable
+	for _, r := range r[:k] {
+		if r <= 0xFFFF {
+			rt.R16 = append(rt.R16, unicode.Range16{Lo: uint16(r), Hi: uint16(r), Stride: 1})
+		} else {
+			rt.R32 = append(rt.R32, unicode.Range32{Lo: uint32(r), Hi: uint32(r), Stride: 1})
+		}
+	}
+
+	// Optimize RangeTable.
+	return Merge(&rt)
+}
+
+type byRune []rune
+
+func (r byRune) Len() int           { return len(r) }
+func (r byRune) Swap(i, j int)      { r[i], r[j] = r[j], r[i] }
+func (r byRune) Less(i, j int) bool { return r[i] < r[j] }
+
+// Visit visits all runes in the given RangeTable in order, calling fn for each.
+func Visit(rt *unicode.RangeTable, fn func(rune)) {
+	for _, r16 := range rt.R16 {
+		for r := rune(r16.Lo); r <= rune(r16.Hi); r += rune(r16.Stride) {
+			fn(r)
+		}
+	}
+	for _, r32 := range rt.R32 {
+		for r := rune(r32.Lo); r <= rune(r32.Hi); r += rune(r32.Stride) {
+			fn(r)
+		}
+	}
+}
+
+// Assigned returns a RangeTable with all assigned code points for a given
+// Unicode version. This includes graphic, format, control, and private-use
+// characters. It returns nil if the data for the given version is not
+// available.
+func Assigned(version string) *unicode.RangeTable {
+	return assigned[version]
+}
diff --git a/vendor/golang.org/x/text/unicode/rangetable/tables.go b/vendor/golang.org/x/text/unicode/rangetable/tables.go
new file mode 100644
index 0000000..61c989b
--- /dev/null
+++ b/vendor/golang.org/x/text/unicode/rangetable/tables.go
@@ -0,0 +1,5735 @@
+// Code generated by running "go generate" in golang.org/x/text. DO NOT EDIT.
+
+package rangetable
+
+//go:generate go run gen.go --versions=4.1.0,5.0.0,5.1.0,5.2.0,6.0.0,6.1.0,6.2.0,6.3.0,7.0.0,8.0.0,9.0.0
+
+import "unicode"
+
+var assigned = map[string]*unicode.RangeTable{
+	"4.1.0": assigned4_1_0,
+	"5.0.0": assigned5_0_0,
+	"5.1.0": assigned5_1_0,
+	"5.2.0": assigned5_2_0,
+	"6.0.0": assigned6_0_0,
+	"6.1.0": assigned6_1_0,
+	"6.2.0": assigned6_2_0,
+	"6.3.0": assigned6_3_0,
+	"7.0.0": assigned7_0_0,
+	"8.0.0": assigned8_0_0,
+	"9.0.0": assigned9_0_0,
+}
+
+// size 2924 bytes (2 KiB)
+var assigned4_1_0 = &unicode.RangeTable{
+	R16: []unicode.Range16{
+		{0x0000, 0x0241, 1},
+		{0x0250, 0x036f, 1},
+		{0x0374, 0x0375, 1},
+		{0x037a, 0x037e, 4},
+		{0x0384, 0x038a, 1},
+		{0x038c, 0x038e, 2},
+		{0x038f, 0x03a1, 1},
+		{0x03a3, 0x03ce, 1},
+		{0x03d0, 0x0486, 1},
+		{0x0488, 0x04ce, 1},
+		{0x04d0, 0x04f9, 1},
+		{0x0500, 0x050f, 1},
+		{0x0531, 0x0556, 1},
+		{0x0559, 0x055f, 1},
+		{0x0561, 0x0587, 1},
+		{0x0589, 0x058a, 1},
+		{0x0591, 0x05b9, 1},
+		{0x05bb, 0x05c7, 1},
+		{0x05d0, 0x05ea, 1},
+		{0x05f0, 0x05f4, 1},
+		{0x0600, 0x0603, 1},
+		{0x060b, 0x0615, 1},
+		{0x061b, 0x061e, 3},
+		{0x061f, 0x0621, 2},
+		{0x0622, 0x063a, 1},
+		{0x0640, 0x065e, 1},
+		{0x0660, 0x070d, 1},
+		{0x070f, 0x074a, 1},
+		{0x074d, 0x076d, 1},
+		{0x0780, 0x07b1, 1},
+		{0x0901, 0x0939, 1},
+		{0x093c, 0x094d, 1},
+		{0x0950, 0x0954, 1},
+		{0x0958, 0x0970, 1},
+		{0x097d, 0x0981, 4},
+		{0x0982, 0x0983, 1},
+		{0x0985, 0x098c, 1},
+		{0x098f, 0x0990, 1},
+		{0x0993, 0x09a8, 1},
+		{0x09aa, 0x09b0, 1},
+		{0x09b2, 0x09b6, 4},
+		{0x09b7, 0x09b9, 1},
+		{0x09bc, 0x09c4, 1},
+		{0x09c7, 0x09c8, 1},
+		{0x09cb, 0x09ce, 1},
+		{0x09d7, 0x09dc, 5},
+		{0x09dd, 0x09df, 2},
+		{0x09e0, 0x09e3, 1},
+		{0x09e6, 0x09fa, 1},
+		{0x0a01, 0x0a03, 1},
+		{0x0a05, 0x0a0a, 1},
+		{0x0a0f, 0x0a10, 1},
+		{0x0a13, 0x0a28, 1},
+		{0x0a2a, 0x0a30, 1},
+		{0x0a32, 0x0a33, 1},
+		{0x0a35, 0x0a36, 1},
+		{0x0a38, 0x0a39, 1},
+		{0x0a3c, 0x0a3e, 2},
+		{0x0a3f, 0x0a42, 1},
+		{0x0a47, 0x0a48, 1},
+		{0x0a4b, 0x0a4d, 1},
+		{0x0a59, 0x0a5c, 1},
+		{0x0a5e, 0x0a66, 8},
+		{0x0a67, 0x0a74, 1},
+		{0x0a81, 0x0a83, 1},
+		{0x0a85, 0x0a8d, 1},
+		{0x0a8f, 0x0a91, 1},
+		{0x0a93, 0x0aa8, 1},
+		{0x0aaa, 0x0ab0, 1},
+		{0x0ab2, 0x0ab3, 1},
+		{0x0ab5, 0x0ab9, 1},
+		{0x0abc, 0x0ac5, 1},
+		{0x0ac7, 0x0ac9, 1},
+		{0x0acb, 0x0acd, 1},
+		{0x0ad0, 0x0ae0, 16},
+		{0x0ae1, 0x0ae3, 1},
+		{0x0ae6, 0x0aef, 1},
+		{0x0af1, 0x0b01, 16},
+		{0x0b02, 0x0b03, 1},
+		{0x0b05, 0x0b0c, 1},
+		{0x0b0f, 0x0b10, 1},
+		{0x0b13, 0x0b28, 1},
+		{0x0b2a, 0x0b30, 1},
+		{0x0b32, 0x0b33, 1},
+		{0x0b35, 0x0b39, 1},
+		{0x0b3c, 0x0b43, 1},
+		{0x0b47, 0x0b48, 1},
+		{0x0b4b, 0x0b4d, 1},
+		{0x0b56, 0x0b57, 1},
+		{0x0b5c, 0x0b5d, 1},
+		{0x0b5f, 0x0b61, 1},
+		{0x0b66, 0x0b71, 1},
+		{0x0b82, 0x0b83, 1},
+		{0x0b85, 0x0b8a, 1},
+		{0x0b8e, 0x0b90, 1},
+		{0x0b92, 0x0b95, 1},
+		{0x0b99, 0x0b9a, 1},
+		{0x0b9c, 0x0b9e, 2},
+		{0x0b9f, 0x0ba3, 4},
+		{0x0ba4, 0x0ba8, 4},
+		{0x0ba9, 0x0baa, 1},
+		{0x0bae, 0x0bb9, 1},
+		{0x0bbe, 0x0bc2, 1},
+		{0x0bc6, 0x0bc8, 1},
+		{0x0bca, 0x0bcd, 1},
+		{0x0bd7, 0x0be6, 15},
+		{0x0be7, 0x0bfa, 1},
+		{0x0c01, 0x0c03, 1},
+		{0x0c05, 0x0c0c, 1},
+		{0x0c0e, 0x0c10, 1},
+		{0x0c12, 0x0c28, 1},
+		{0x0c2a, 0x0c33, 1},
+		{0x0c35, 0x0c39, 1},
+		{0x0c3e, 0x0c44, 1},
+		{0x0c46, 0x0c48, 1},
+		{0x0c4a, 0x0c4d, 1},
+		{0x0c55, 0x0c56, 1},
+		{0x0c60, 0x0c61, 1},
+		{0x0c66, 0x0c6f, 1},
+		{0x0c82, 0x0c83, 1},
+		{0x0c85, 0x0c8c, 1},
+		{0x0c8e, 0x0c90, 1},
+		{0x0c92, 0x0ca8, 1},
+		{0x0caa, 0x0cb3, 1},
+		{0x0cb5, 0x0cb9, 1},
+		{0x0cbc, 0x0cc4, 1},
+		{0x0cc6, 0x0cc8, 1},
+		{0x0cca, 0x0ccd, 1},
+		{0x0cd5, 0x0cd6, 1},
+		{0x0cde, 0x0ce0, 2},
+		{0x0ce1, 0x0ce6, 5},
+		{0x0ce7, 0x0cef, 1},
+		{0x0d02, 0x0d03, 1},
+		{0x0d05, 0x0d0c, 1},
+		{0x0d0e, 0x0d10, 1},
+		{0x0d12, 0x0d28, 1},
+		{0x0d2a, 0x0d39, 1},
+		{0x0d3e, 0x0d43, 1},
+		{0x0d46, 0x0d48, 1},
+		{0x0d4a, 0x0d4d, 1},
+		{0x0d57, 0x0d60, 9},
+		{0x0d61, 0x0d66, 5},
+		{0x0d67, 0x0d6f, 1},
+		{0x0d82, 0x0d83, 1},
+		{0x0d85, 0x0d96, 1},
+		{0x0d9a, 0x0db1, 1},
+		{0x0db3, 0x0dbb, 1},
+		{0x0dbd, 0x0dc0, 3},
+		{0x0dc1, 0x0dc6, 1},
+		{0x0dca, 0x0dcf, 5},
+		{0x0dd0, 0x0dd4, 1},
+		{0x0dd6, 0x0dd8, 2},
+		{0x0dd9, 0x0ddf, 1},
+		{0x0df2, 0x0df4, 1},
+		{0x0e01, 0x0e3a, 1},
+		{0x0e3f, 0x0e5b, 1},
+		{0x0e81, 0x0e82, 1},
+		{0x0e84, 0x0e87, 3},
+		{0x0e88, 0x0e8a, 2},
+		{0x0e8d, 0x0e94, 7},
+		{0x0e95, 0x0e97, 1},
+		{0x0e99, 0x0e9f, 1},
+		{0x0ea1, 0x0ea3, 1},
+		{0x0ea5, 0x0ea7, 2},
+		{0x0eaa, 0x0eab, 1},
+		{0x0ead, 0x0eb9, 1},
+		{0x0ebb, 0x0ebd, 1},
+		{0x0ec0, 0x0ec4, 1},
+		{0x0ec6, 0x0ec8, 2},
+		{0x0ec9, 0x0ecd, 1},
+		{0x0ed0, 0x0ed9, 1},
+		{0x0edc, 0x0edd, 1},
+		{0x0f00, 0x0f47, 1},
+		{0x0f49, 0x0f6a, 1},
+		{0x0f71, 0x0f8b, 1},
+		{0x0f90, 0x0f97, 1},
+		{0x0f99, 0x0fbc, 1},
+		{0x0fbe, 0x0fcc, 1},
+		{0x0fcf, 0x0fd1, 1},
+		{0x1000, 0x1021, 1},
+		{0x1023, 0x1027, 1},
+		{0x1029, 0x102a, 1},
+		{0x102c, 0x1032, 1},
+		{0x1036, 0x1039, 1},
+		{0x1040, 0x1059, 1},
+		{0x10a0, 0x10c5, 1},
+		{0x10d0, 0x10fc, 1},
+		{0x1100, 0x1159, 1},
+		{0x115f, 0x11a2, 1},
+		{0x11a8, 0x11f9, 1},
+		{0x1200, 0x1248, 1},
+		{0x124a, 0x124d, 1},
+		{0x1250, 0x1256, 1},
+		{0x1258, 0x125a, 2},
+		{0x125b, 0x125d, 1},
+		{0x1260, 0x1288, 1},
+		{0x128a, 0x128d, 1},
+		{0x1290, 0x12b0, 1},
+		{0x12b2, 0x12b5, 1},
+		{0x12b8, 0x12be, 1},
+		{0x12c0, 0x12c2, 2},
+		{0x12c3, 0x12c5, 1},
+		{0x12c8, 0x12d6, 1},
+		{0x12d8, 0x1310, 1},
+		{0x1312, 0x1315, 1},
+		{0x1318, 0x135a, 1},
+		{0x135f, 0x137c, 1},
+		{0x1380, 0x1399, 1},
+		{0x13a0, 0x13f4, 1},
+		{0x1401, 0x1676, 1},
+		{0x1680, 0x169c, 1},
+		{0x16a0, 0x16f0, 1},
+		{0x1700, 0x170c, 1},
+		{0x170e, 0x1714, 1},
+		{0x1720, 0x1736, 1},
+		{0x1740, 0x1753, 1},
+		{0x1760, 0x176c, 1},
+		{0x176e, 0x1770, 1},
+		{0x1772, 0x1773, 1},
+		{0x1780, 0x17dd, 1},
+		{0x17e0, 0x17e9, 1},
+		{0x17f0, 0x17f9, 1},
+		{0x1800, 0x180e, 1},
+		{0x1810, 0x1819, 1},
+		{0x1820, 0x1877, 1},
+		{0x1880, 0x18a9, 1},
+		{0x1900, 0x191c, 1},
+		{0x1920, 0x192b, 1},
+		{0x1930, 0x193b, 1},
+		{0x1940, 0x1944, 4},
+		{0x1945, 0x196d, 1},
+		{0x1970, 0x1974, 1},
+		{0x1980, 0x19a9, 1},
+		{0x19b0, 0x19c9, 1},
+		{0x19d0, 0x19d9, 1},
+		{0x19de, 0x1a1b, 1},
+		{0x1a1e, 0x1a1f, 1},
+		{0x1d00, 0x1dc3, 1},
+		{0x1e00, 0x1e9b, 1},
+		{0x1ea0, 0x1ef9, 1},
+		{0x1f00, 0x1f15, 1},
+		{0x1f18, 0x1f1d, 1},
+		{0x1f20, 0x1f45, 1},
+		{0x1f48, 0x1f4d, 1},
+		{0x1f50, 0x1f57, 1},
+		{0x1f59, 0x1f5f, 2},
+		{0x1f60, 0x1f7d, 1},
+		{0x1f80, 0x1fb4, 1},
+		{0x1fb6, 0x1fc4, 1},
+		{0x1fc6, 0x1fd3, 1},
+		{0x1fd6, 0x1fdb, 1},
+		{0x1fdd, 0x1fef, 1},
+		{0x1ff2, 0x1ff4, 1},
+		{0x1ff6, 0x1ffe, 1},
+		{0x2000, 0x2063, 1},
+		{0x206a, 0x2071, 1},
+		{0x2074, 0x208e, 1},
+		{0x2090, 0x2094, 1},
+		{0x20a0, 0x20b5, 1},
+		{0x20d0, 0x20eb, 1},
+		{0x2100, 0x214c, 1},
+		{0x2153, 0x2183, 1},
+		{0x2190, 0x23db, 1},
+		{0x2400, 0x2426, 1},
+		{0x2440, 0x244a, 1},
+		{0x2460, 0x269c, 1},
+		{0x26a0, 0x26b1, 1},
+		{0x2701, 0x2704, 1},
+		{0x2706, 0x2709, 1},
+		{0x270c, 0x2727, 1},
+		{0x2729, 0x274b, 1},
+		{0x274d, 0x274f, 2},
+		{0x2750, 0x2752, 1},
+		{0x2756, 0x2758, 2},
+		{0x2759, 0x275e, 1},
+		{0x2761, 0x2794, 1},
+		{0x2798, 0x27af, 1},
+		{0x27b1, 0x27be, 1},
+		{0x27c0, 0x27c6, 1},
+		{0x27d0, 0x27eb, 1},
+		{0x27f0, 0x2b13, 1},
+		{0x2c00, 0x2c2e, 1},
+		{0x2c30, 0x2c5e, 1},
+		{0x2c80, 0x2cea, 1},
+		{0x2cf9, 0x2d25, 1},
+		{0x2d30, 0x2d65, 1},
+		{0x2d6f, 0x2d80, 17},
+		{0x2d81, 0x2d96, 1},
+		{0x2da0, 0x2da6, 1},
+		{0x2da8, 0x2dae, 1},
+		{0x2db0, 0x2db6, 1},
+		{0x2db8, 0x2dbe, 1},
+		{0x2dc0, 0x2dc6, 1},
+		{0x2dc8, 0x2dce, 1},
+		{0x2dd0, 0x2dd6, 1},
+		{0x2dd8, 0x2dde, 1},
+		{0x2e00, 0x2e17, 1},
+		{0x2e1c, 0x2e1d, 1},
+		{0x2e80, 0x2e99, 1},
+		{0x2e9b, 0x2ef3, 1},
+		{0x2f00, 0x2fd5, 1},
+		{0x2ff0, 0x2ffb, 1},
+		{0x3000, 0x303f, 1},
+		{0x3041, 0x3096, 1},
+		{0x3099, 0x30ff, 1},
+		{0x3105, 0x312c, 1},
+		{0x3131, 0x318e, 1},
+		{0x3190, 0x31b7, 1},
+		{0x31c0, 0x31cf, 1},
+		{0x31f0, 0x321e, 1},
+		{0x3220, 0x3243, 1},
+		{0x3250, 0x32fe, 1},
+		{0x3300, 0x4db5, 1},
+		{0x4dc0, 0x9fbb, 1},
+		{0xa000, 0xa48c, 1},
+		{0xa490, 0xa4c6, 1},
+		{0xa700, 0xa716, 1},
+		{0xa800, 0xa82b, 1},
+		{0xac00, 0xd7a3, 1},
+		{0xd800, 0xfa2d, 1},
+		{0xfa30, 0xfa6a, 1},
+		{0xfa70, 0xfad9, 1},
+		{0xfb00, 0xfb06, 1},
+		{0xfb13, 0xfb17, 1},
+		{0xfb1d, 0xfb36, 1},
+		{0xfb38, 0xfb3c, 1},
+		{0xfb3e, 0xfb40, 2},
+		{0xfb41, 0xfb43, 2},
+		{0xfb44, 0xfb46, 2},
+		{0xfb47, 0xfbb1, 1},
+		{0xfbd3, 0xfd3f, 1},
+		{0xfd50, 0xfd8f, 1},
+		{0xfd92, 0xfdc7, 1},
+		{0xfdf0, 0xfdfd, 1},
+		{0xfe00, 0xfe19, 1},
+		{0xfe20, 0xfe23, 1},
+		{0xfe30, 0xfe52, 1},
+		{0xfe54, 0xfe66, 1},
+		{0xfe68, 0xfe6b, 1},
+		{0xfe70, 0xfe74, 1},
+		{0xfe76, 0xfefc, 1},
+		{0xfeff, 0xff01, 2},
+		{0xff02, 0xffbe, 1},
+		{0xffc2, 0xffc7, 1},
+		{0xffca, 0xffcf, 1},
+		{0xffd2, 0xffd7, 1},
+		{0xffda, 0xffdc, 1},
+		{0xffe0, 0xffe6, 1},
+		{0xffe8, 0xffee, 1},
+		{0xfff9, 0xfffd, 1},
+	},
+	R32: []unicode.Range32{
+		{0x00010000, 0x0001000b, 1},
+		{0x0001000d, 0x00010026, 1},
+		{0x00010028, 0x0001003a, 1},
+		{0x0001003c, 0x0001003d, 1},
+		{0x0001003f, 0x0001004d, 1},
+		{0x00010050, 0x0001005d, 1},
+		{0x00010080, 0x000100fa, 1},
+		{0x00010100, 0x00010102, 1},
+		{0x00010107, 0x00010133, 1},
+		{0x00010137, 0x0001018a, 1},
+		{0x00010300, 0x0001031e, 1},
+		{0x00010320, 0x00010323, 1},
+		{0x00010330, 0x0001034a, 1},
+		{0x00010380, 0x0001039d, 1},
+		{0x0001039f, 0x000103c3, 1},
+		{0x000103c8, 0x000103d5, 1},
+		{0x00010400, 0x0001049d, 1},
+		{0x000104a0, 0x000104a9, 1},
+		{0x00010800, 0x00010805, 1},
+		{0x00010808, 0x0001080a, 2},
+		{0x0001080b, 0x00010835, 1},
+		{0x00010837, 0x00010838, 1},
+		{0x0001083c, 0x0001083f, 3},
+		{0x00010a00, 0x00010a03, 1},
+		{0x00010a05, 0x00010a06, 1},
+		{0x00010a0c, 0x00010a13, 1},
+		{0x00010a15, 0x00010a17, 1},
+		{0x00010a19, 0x00010a33, 1},
+		{0x00010a38, 0x00010a3a, 1},
+		{0x00010a3f, 0x00010a47, 1},
+		{0x00010a50, 0x00010a58, 1},
+		{0x0001d000, 0x0001d0f5, 1},
+		{0x0001d100, 0x0001d126, 1},
+		{0x0001d12a, 0x0001d1dd, 1},
+		{0x0001d200, 0x0001d245, 1},
+		{0x0001d300, 0x0001d356, 1},
+		{0x0001d400, 0x0001d454, 1},
+		{0x0001d456, 0x0001d49c, 1},
+		{0x0001d49e, 0x0001d49f, 1},
+		{0x0001d4a2, 0x0001d4a5, 3},
+		{0x0001d4a6, 0x0001d4a9, 3},
+		{0x0001d4aa, 0x0001d4ac, 1},
+		{0x0001d4ae, 0x0001d4b9, 1},
+		{0x0001d4bb, 0x0001d4bd, 2},
+		{0x0001d4be, 0x0001d4c3, 1},
+		{0x0001d4c5, 0x0001d505, 1},
+		{0x0001d507, 0x0001d50a, 1},
+		{0x0001d50d, 0x0001d514, 1},
+		{0x0001d516, 0x0001d51c, 1},
+		{0x0001d51e, 0x0001d539, 1},
+		{0x0001d53b, 0x0001d53e, 1},
+		{0x0001d540, 0x0001d544, 1},
+		{0x0001d546, 0x0001d54a, 4},
+		{0x0001d54b, 0x0001d550, 1},
+		{0x0001d552, 0x0001d6a5, 1},
+		{0x0001d6a8, 0x0001d7c9, 1},
+		{0x0001d7ce, 0x0001d7ff, 1},
+		{0x00020000, 0x0002a6d6, 1},
+		{0x0002f800, 0x0002fa1d, 1},
+		{0x000e0001, 0x000e0020, 31},
+		{0x000e0021, 0x000e007f, 1},
+		{0x000e0100, 0x000e01ef, 1},
+		{0x000f0000, 0x000ffffd, 1},
+		{0x00100000, 0x0010fffd, 1},
+	},
+	LatinOffset: 0,
+}
+
+// size 3026 bytes (2 KiB)
+var assigned5_0_0 = &unicode.RangeTable{
+	R16: []unicode.Range16{
+		{0x0000, 0x036f, 1},
+		{0x0374, 0x0375, 1},
+		{0x037a, 0x037e, 1},
+		{0x0384, 0x038a, 1},
+		{0x038c, 0x038e, 2},
+		{0x038f, 0x03a1, 1},
+		{0x03a3, 0x03ce, 1},
+		{0x03d0, 0x0486, 1},
+		{0x0488, 0x0513, 1},
+		{0x0531, 0x0556, 1},
+		{0x0559, 0x055f, 1},
+		{0x0561, 0x0587, 1},
+		{0x0589, 0x058a, 1},
+		{0x0591, 0x05c7, 1},
+		{0x05d0, 0x05ea, 1},
+		{0x05f0, 0x05f4, 1},
+		{0x0600, 0x0603, 1},
+		{0x060b, 0x0615, 1},
+		{0x061b, 0x061e, 3},
+		{0x061f, 0x0621, 2},
+		{0x0622, 0x063a, 1},
+		{0x0640, 0x065e, 1},
+		{0x0660, 0x070d, 1},
+		{0x070f, 0x074a, 1},
+		{0x074d, 0x076d, 1},
+		{0x0780, 0x07b1, 1},
+		{0x07c0, 0x07fa, 1},
+		{0x0901, 0x0939, 1},
+		{0x093c, 0x094d, 1},
+		{0x0950, 0x0954, 1},
+		{0x0958, 0x0970, 1},
+		{0x097b, 0x097f, 1},
+		{0x0981, 0x0983, 1},
+		{0x0985, 0x098c, 1},
+		{0x098f, 0x0990, 1},
+		{0x0993, 0x09a8, 1},
+		{0x09aa, 0x09b0, 1},
+		{0x09b2, 0x09b6, 4},
+		{0x09b7, 0x09b9, 1},
+		{0x09bc, 0x09c4, 1},
+		{0x09c7, 0x09c8, 1},
+		{0x09cb, 0x09ce, 1},
+		{0x09d7, 0x09dc, 5},
+		{0x09dd, 0x09df, 2},
+		{0x09e0, 0x09e3, 1},
+		{0x09e6, 0x09fa, 1},
+		{0x0a01, 0x0a03, 1},
+		{0x0a05, 0x0a0a, 1},
+		{0x0a0f, 0x0a10, 1},
+		{0x0a13, 0x0a28, 1},
+		{0x0a2a, 0x0a30, 1},
+		{0x0a32, 0x0a33, 1},
+		{0x0a35, 0x0a36, 1},
+		{0x0a38, 0x0a39, 1},
+		{0x0a3c, 0x0a3e, 2},
+		{0x0a3f, 0x0a42, 1},
+		{0x0a47, 0x0a48, 1},
+		{0x0a4b, 0x0a4d, 1},
+		{0x0a59, 0x0a5c, 1},
+		{0x0a5e, 0x0a66, 8},
+		{0x0a67, 0x0a74, 1},
+		{0x0a81, 0x0a83, 1},
+		{0x0a85, 0x0a8d, 1},
+		{0x0a8f, 0x0a91, 1},
+		{0x0a93, 0x0aa8, 1},
+		{0x0aaa, 0x0ab0, 1},
+		{0x0ab2, 0x0ab3, 1},
+		{0x0ab5, 0x0ab9, 1},
+		{0x0abc, 0x0ac5, 1},
+		{0x0ac7, 0x0ac9, 1},
+		{0x0acb, 0x0acd, 1},
+		{0x0ad0, 0x0ae0, 16},
+		{0x0ae1, 0x0ae3, 1},
+		{0x0ae6, 0x0aef, 1},
+		{0x0af1, 0x0b01, 16},
+		{0x0b02, 0x0b03, 1},
+		{0x0b05, 0x0b0c, 1},
+		{0x0b0f, 0x0b10, 1},
+		{0x0b13, 0x0b28, 1},
+		{0x0b2a, 0x0b30, 1},
+		{0x0b32, 0x0b33, 1},
+		{0x0b35, 0x0b39, 1},
+		{0x0b3c, 0x0b43, 1},
+		{0x0b47, 0x0b48, 1},
+		{0x0b4b, 0x0b4d, 1},
+		{0x0b56, 0x0b57, 1},
+		{0x0b5c, 0x0b5d, 1},
+		{0x0b5f, 0x0b61, 1},
+		{0x0b66, 0x0b71, 1},
+		{0x0b82, 0x0b83, 1},
+		{0x0b85, 0x0b8a, 1},
+		{0x0b8e, 0x0b90, 1},
+		{0x0b92, 0x0b95, 1},
+		{0x0b99, 0x0b9a, 1},
+		{0x0b9c, 0x0b9e, 2},
+		{0x0b9f, 0x0ba3, 4},
+		{0x0ba4, 0x0ba8, 4},
+		{0x0ba9, 0x0baa, 1},
+		{0x0bae, 0x0bb9, 1},
+		{0x0bbe, 0x0bc2, 1},
+		{0x0bc6, 0x0bc8, 1},
+		{0x0bca, 0x0bcd, 1},
+		{0x0bd7, 0x0be6, 15},
+		{0x0be7, 0x0bfa, 1},
+		{0x0c01, 0x0c03, 1},
+		{0x0c05, 0x0c0c, 1},
+		{0x0c0e, 0x0c10, 1},
+		{0x0c12, 0x0c28, 1},
+		{0x0c2a, 0x0c33, 1},
+		{0x0c35, 0x0c39, 1},
+		{0x0c3e, 0x0c44, 1},
+		{0x0c46, 0x0c48, 1},
+		{0x0c4a, 0x0c4d, 1},
+		{0x0c55, 0x0c56, 1},
+		{0x0c60, 0x0c61, 1},
+		{0x0c66, 0x0c6f, 1},
+		{0x0c82, 0x0c83, 1},
+		{0x0c85, 0x0c8c, 1},
+		{0x0c8e, 0x0c90, 1},
+		{0x0c92, 0x0ca8, 1},
+		{0x0caa, 0x0cb3, 1},
+		{0x0cb5, 0x0cb9, 1},
+		{0x0cbc, 0x0cc4, 1},
+		{0x0cc6, 0x0cc8, 1},
+		{0x0cca, 0x0ccd, 1},
+		{0x0cd5, 0x0cd6, 1},
+		{0x0cde, 0x0ce0, 2},
+		{0x0ce1, 0x0ce3, 1},
+		{0x0ce6, 0x0cef, 1},
+		{0x0cf1, 0x0cf2, 1},
+		{0x0d02, 0x0d03, 1},
+		{0x0d05, 0x0d0c, 1},
+		{0x0d0e, 0x0d10, 1},
+		{0x0d12, 0x0d28, 1},
+		{0x0d2a, 0x0d39, 1},
+		{0x0d3e, 0x0d43, 1},
+		{0x0d46, 0x0d48, 1},
+		{0x0d4a, 0x0d4d, 1},
+		{0x0d57, 0x0d60, 9},
+		{0x0d61, 0x0d66, 5},
+		{0x0d67, 0x0d6f, 1},
+		{0x0d82, 0x0d83, 1},
+		{0x0d85, 0x0d96, 1},
+		{0x0d9a, 0x0db1, 1},
+		{0x0db3, 0x0dbb, 1},
+		{0x0dbd, 0x0dc0, 3},
+		{0x0dc1, 0x0dc6, 1},
+		{0x0dca, 0x0dcf, 5},
+		{0x0dd0, 0x0dd4, 1},
+		{0x0dd6, 0x0dd8, 2},
+		{0x0dd9, 0x0ddf, 1},
+		{0x0df2, 0x0df4, 1},
+		{0x0e01, 0x0e3a, 1},
+		{0x0e3f, 0x0e5b, 1},
+		{0x0e81, 0x0e82, 1},
+		{0x0e84, 0x0e87, 3},
+		{0x0e88, 0x0e8a, 2},
+		{0x0e8d, 0x0e94, 7},
+		{0x0e95, 0x0e97, 1},
+		{0x0e99, 0x0e9f, 1},
+		{0x0ea1, 0x0ea3, 1},
+		{0x0ea5, 0x0ea7, 2},
+		{0x0eaa, 0x0eab, 1},
+		{0x0ead, 0x0eb9, 1},
+		{0x0ebb, 0x0ebd, 1},
+		{0x0ec0, 0x0ec4, 1},
+		{0x0ec6, 0x0ec8, 2},
+		{0x0ec9, 0x0ecd, 1},
+		{0x0ed0, 0x0ed9, 1},
+		{0x0edc, 0x0edd, 1},
+		{0x0f00, 0x0f47, 1},
+		{0x0f49, 0x0f6a, 1},
+		{0x0f71, 0x0f8b, 1},
+		{0x0f90, 0x0f97, 1},
+		{0x0f99, 0x0fbc, 1},
+		{0x0fbe, 0x0fcc, 1},
+		{0x0fcf, 0x0fd1, 1},
+		{0x1000, 0x1021, 1},
+		{0x1023, 0x1027, 1},
+		{0x1029, 0x102a, 1},
+		{0x102c, 0x1032, 1},
+		{0x1036, 0x1039, 1},
+		{0x1040, 0x1059, 1},
+		{0x10a0, 0x10c5, 1},
+		{0x10d0, 0x10fc, 1},
+		{0x1100, 0x1159, 1},
+		{0x115f, 0x11a2, 1},
+		{0x11a8, 0x11f9, 1},
+		{0x1200, 0x1248, 1},
+		{0x124a, 0x124d, 1},
+		{0x1250, 0x1256, 1},
+		{0x1258, 0x125a, 2},
+		{0x125b, 0x125d, 1},
+		{0x1260, 0x1288, 1},
+		{0x128a, 0x128d, 1},
+		{0x1290, 0x12b0, 1},
+		{0x12b2, 0x12b5, 1},
+		{0x12b8, 0x12be, 1},
+		{0x12c0, 0x12c2, 2},
+		{0x12c3, 0x12c5, 1},
+		{0x12c8, 0x12d6, 1},
+		{0x12d8, 0x1310, 1},
+		{0x1312, 0x1315, 1},
+		{0x1318, 0x135a, 1},
+		{0x135f, 0x137c, 1},
+		{0x1380, 0x1399, 1},
+		{0x13a0, 0x13f4, 1},
+		{0x1401, 0x1676, 1},
+		{0x1680, 0x169c, 1},
+		{0x16a0, 0x16f0, 1},
+		{0x1700, 0x170c, 1},
+		{0x170e, 0x1714, 1},
+		{0x1720, 0x1736, 1},
+		{0x1740, 0x1753, 1},
+		{0x1760, 0x176c, 1},
+		{0x176e, 0x1770, 1},
+		{0x1772, 0x1773, 1},
+		{0x1780, 0x17dd, 1},
+		{0x17e0, 0x17e9, 1},
+		{0x17f0, 0x17f9, 1},
+		{0x1800, 0x180e, 1},
+		{0x1810, 0x1819, 1},
+		{0x1820, 0x1877, 1},
+		{0x1880, 0x18a9, 1},
+		{0x1900, 0x191c, 1},
+		{0x1920, 0x192b, 1},
+		{0x1930, 0x193b, 1},
+		{0x1940, 0x1944, 4},
+		{0x1945, 0x196d, 1},
+		{0x1970, 0x1974, 1},
+		{0x1980, 0x19a9, 1},
+		{0x19b0, 0x19c9, 1},
+		{0x19d0, 0x19d9, 1},
+		{0x19de, 0x1a1b, 1},
+		{0x1a1e, 0x1a1f, 1},
+		{0x1b00, 0x1b4b, 1},
+		{0x1b50, 0x1b7c, 1},
+		{0x1d00, 0x1dca, 1},
+		{0x1dfe, 0x1e9b, 1},
+		{0x1ea0, 0x1ef9, 1},
+		{0x1f00, 0x1f15, 1},
+		{0x1f18, 0x1f1d, 1},
+		{0x1f20, 0x1f45, 1},
+		{0x1f48, 0x1f4d, 1},
+		{0x1f50, 0x1f57, 1},
+		{0x1f59, 0x1f5f, 2},
+		{0x1f60, 0x1f7d, 1},
+		{0x1f80, 0x1fb4, 1},
+		{0x1fb6, 0x1fc4, 1},
+		{0x1fc6, 0x1fd3, 1},
+		{0x1fd6, 0x1fdb, 1},
+		{0x1fdd, 0x1fef, 1},
+		{0x1ff2, 0x1ff4, 1},
+		{0x1ff6, 0x1ffe, 1},
+		{0x2000, 0x2063, 1},
+		{0x206a, 0x2071, 1},
+		{0x2074, 0x208e, 1},
+		{0x2090, 0x2094, 1},
+		{0x20a0, 0x20b5, 1},
+		{0x20d0, 0x20ef, 1},
+		{0x2100, 0x214e, 1},
+		{0x2153, 0x2184, 1},
+		{0x2190, 0x23e7, 1},
+		{0x2400, 0x2426, 1},
+		{0x2440, 0x244a, 1},
+		{0x2460, 0x269c, 1},
+		{0x26a0, 0x26b2, 1},
+		{0x2701, 0x2704, 1},
+		{0x2706, 0x2709, 1},
+		{0x270c, 0x2727, 1},
+		{0x2729, 0x274b, 1},
+		{0x274d, 0x274f, 2},
+		{0x2750, 0x2752, 1},
+		{0x2756, 0x2758, 2},
+		{0x2759, 0x275e, 1},
+		{0x2761, 0x2794, 1},
+		{0x2798, 0x27af, 1},
+		{0x27b1, 0x27be, 1},
+		{0x27c0, 0x27ca, 1},
+		{0x27d0, 0x27eb, 1},
+		{0x27f0, 0x2b1a, 1},
+		{0x2b20, 0x2b23, 1},
+		{0x2c00, 0x2c2e, 1},
+		{0x2c30, 0x2c5e, 1},
+		{0x2c60, 0x2c6c, 1},
+		{0x2c74, 0x2c77, 1},
+		{0x2c80, 0x2cea, 1},
+		{0x2cf9, 0x2d25, 1},
+		{0x2d30, 0x2d65, 1},
+		{0x2d6f, 0x2d80, 17},
+		{0x2d81, 0x2d96, 1},
+		{0x2da0, 0x2da6, 1},
+		{0x2da8, 0x2dae, 1},
+		{0x2db0, 0x2db6, 1},
+		{0x2db8, 0x2dbe, 1},
+		{0x2dc0, 0x2dc6, 1},
+		{0x2dc8, 0x2dce, 1},
+		{0x2dd0, 0x2dd6, 1},
+		{0x2dd8, 0x2dde, 1},
+		{0x2e00, 0x2e17, 1},
+		{0x2e1c, 0x2e1d, 1},
+		{0x2e80, 0x2e99, 1},
+		{0x2e9b, 0x2ef3, 1},
+		{0x2f00, 0x2fd5, 1},
+		{0x2ff0, 0x2ffb, 1},
+		{0x3000, 0x303f, 1},
+		{0x3041, 0x3096, 1},
+		{0x3099, 0x30ff, 1},
+		{0x3105, 0x312c, 1},
+		{0x3131, 0x318e, 1},
+		{0x3190, 0x31b7, 1},
+		{0x31c0, 0x31cf, 1},
+		{0x31f0, 0x321e, 1},
+		{0x3220, 0x3243, 1},
+		{0x3250, 0x32fe, 1},
+		{0x3300, 0x4db5, 1},
+		{0x4dc0, 0x9fbb, 1},
+		{0xa000, 0xa48c, 1},
+		{0xa490, 0xa4c6, 1},
+		{0xa700, 0xa71a, 1},
+		{0xa720, 0xa721, 1},
+		{0xa800, 0xa82b, 1},
+		{0xa840, 0xa877, 1},
+		{0xac00, 0xd7a3, 1},
+		{0xd800, 0xfa2d, 1},
+		{0xfa30, 0xfa6a, 1},
+		{0xfa70, 0xfad9, 1},
+		{0xfb00, 0xfb06, 1},
+		{0xfb13, 0xfb17, 1},
+		{0xfb1d, 0xfb36, 1},
+		{0xfb38, 0xfb3c, 1},
+		{0xfb3e, 0xfb40, 2},
+		{0xfb41, 0xfb43, 2},
+		{0xfb44, 0xfb46, 2},
+		{0xfb47, 0xfbb1, 1},
+		{0xfbd3, 0xfd3f, 1},
+		{0xfd50, 0xfd8f, 1},
+		{0xfd92, 0xfdc7, 1},
+		{0xfdf0, 0xfdfd, 1},
+		{0xfe00, 0xfe19, 1},
+		{0xfe20, 0xfe23, 1},
+		{0xfe30, 0xfe52, 1},
+		{0xfe54, 0xfe66, 1},
+		{0xfe68, 0xfe6b, 1},
+		{0xfe70, 0xfe74, 1},
+		{0xfe76, 0xfefc, 1},
+		{0xfeff, 0xff01, 2},
+		{0xff02, 0xffbe, 1},
+		{0xffc2, 0xffc7, 1},
+		{0xffca, 0xffcf, 1},
+		{0xffd2, 0xffd7, 1},
+		{0xffda, 0xffdc, 1},
+		{0xffe0, 0xffe6, 1},
+		{0xffe8, 0xffee, 1},
+		{0xfff9, 0xfffd, 1},
+	},
+	R32: []unicode.Range32{
+		{0x00010000, 0x0001000b, 1},
+		{0x0001000d, 0x00010026, 1},
+		{0x00010028, 0x0001003a, 1},
+		{0x0001003c, 0x0001003d, 1},
+		{0x0001003f, 0x0001004d, 1},
+		{0x00010050, 0x0001005d, 1},
+		{0x00010080, 0x000100fa, 1},
+		{0x00010100, 0x00010102, 1},
+		{0x00010107, 0x00010133, 1},
+		{0x00010137, 0x0001018a, 1},
+		{0x00010300, 0x0001031e, 1},
+		{0x00010320, 0x00010323, 1},
+		{0x00010330, 0x0001034a, 1},
+		{0x00010380, 0x0001039d, 1},
+		{0x0001039f, 0x000103c3, 1},
+		{0x000103c8, 0x000103d5, 1},
+		{0x00010400, 0x0001049d, 1},
+		{0x000104a0, 0x000104a9, 1},
+		{0x00010800, 0x00010805, 1},
+		{0x00010808, 0x0001080a, 2},
+		{0x0001080b, 0x00010835, 1},
+		{0x00010837, 0x00010838, 1},
+		{0x0001083c, 0x0001083f, 3},
+		{0x00010900, 0x00010919, 1},
+		{0x0001091f, 0x00010a00, 225},
+		{0x00010a01, 0x00010a03, 1},
+		{0x00010a05, 0x00010a06, 1},
+		{0x00010a0c, 0x00010a13, 1},
+		{0x00010a15, 0x00010a17, 1},
+		{0x00010a19, 0x00010a33, 1},
+		{0x00010a38, 0x00010a3a, 1},
+		{0x00010a3f, 0x00010a47, 1},
+		{0x00010a50, 0x00010a58, 1},
+		{0x00012000, 0x0001236e, 1},
+		{0x00012400, 0x00012462, 1},
+		{0x00012470, 0x00012473, 1},
+		{0x0001d000, 0x0001d0f5, 1},
+		{0x0001d100, 0x0001d126, 1},
+		{0x0001d12a, 0x0001d1dd, 1},
+		{0x0001d200, 0x0001d245, 1},
+		{0x0001d300, 0x0001d356, 1},
+		{0x0001d360, 0x0001d371, 1},
+		{0x0001d400, 0x0001d454, 1},
+		{0x0001d456, 0x0001d49c, 1},
+		{0x0001d49e, 0x0001d49f, 1},
+		{0x0001d4a2, 0x0001d4a5, 3},
+		{0x0001d4a6, 0x0001d4a9, 3},
+		{0x0001d4aa, 0x0001d4ac, 1},
+		{0x0001d4ae, 0x0001d4b9, 1},
+		{0x0001d4bb, 0x0001d4bd, 2},
+		{0x0001d4be, 0x0001d4c3, 1},
+		{0x0001d4c5, 0x0001d505, 1},
+		{0x0001d507, 0x0001d50a, 1},
+		{0x0001d50d, 0x0001d514, 1},
+		{0x0001d516, 0x0001d51c, 1},
+		{0x0001d51e, 0x0001d539, 1},
+		{0x0001d53b, 0x0001d53e, 1},
+		{0x0001d540, 0x0001d544, 1},
+		{0x0001d546, 0x0001d54a, 4},
+		{0x0001d54b, 0x0001d550, 1},
+		{0x0001d552, 0x0001d6a5, 1},
+		{0x0001d6a8, 0x0001d7cb, 1},
+		{0x0001d7ce, 0x0001d7ff, 1},
+		{0x00020000, 0x0002a6d6, 1},
+		{0x0002f800, 0x0002fa1d, 1},
+		{0x000e0001, 0x000e0020, 31},
+		{0x000e0021, 0x000e007f, 1},
+		{0x000e0100, 0x000e01ef, 1},
+		{0x000f0000, 0x000ffffd, 1},
+		{0x00100000, 0x0010fffd, 1},
+	},
+	LatinOffset: 0,
+}
+
+// size 3152 bytes (3 KiB)
+var assigned5_1_0 = &unicode.RangeTable{
+	R16: []unicode.Range16{
+		{0x0000, 0x0377, 1},
+		{0x037a, 0x037e, 1},
+		{0x0384, 0x038a, 1},
+		{0x038c, 0x038e, 2},
+		{0x038f, 0x03a1, 1},
+		{0x03a3, 0x0523, 1},
+		{0x0531, 0x0556, 1},
+		{0x0559, 0x055f, 1},
+		{0x0561, 0x0587, 1},
+		{0x0589, 0x058a, 1},
+		{0x0591, 0x05c7, 1},
+		{0x05d0, 0x05ea, 1},
+		{0x05f0, 0x05f4, 1},
+		{0x0600, 0x0603, 1},
+		{0x0606, 0x061b, 1},
+		{0x061e, 0x061f, 1},
+		{0x0621, 0x065e, 1},
+		{0x0660, 0x070d, 1},
+		{0x070f, 0x074a, 1},
+		{0x074d, 0x07b1, 1},
+		{0x07c0, 0x07fa, 1},
+		{0x0901, 0x0939, 1},
+		{0x093c, 0x094d, 1},
+		{0x0950, 0x0954, 1},
+		{0x0958, 0x0972, 1},
+		{0x097b, 0x097f, 1},
+		{0x0981, 0x0983, 1},
+		{0x0985, 0x098c, 1},
+		{0x098f, 0x0990, 1},
+		{0x0993, 0x09a8, 1},
+		{0x09aa, 0x09b0, 1},
+		{0x09b2, 0x09b6, 4},
+		{0x09b7, 0x09b9, 1},
+		{0x09bc, 0x09c4, 1},
+		{0x09c7, 0x09c8, 1},
+		{0x09cb, 0x09ce, 1},
+		{0x09d7, 0x09dc, 5},
+		{0x09dd, 0x09df, 2},
+		{0x09e0, 0x09e3, 1},
+		{0x09e6, 0x09fa, 1},
+		{0x0a01, 0x0a03, 1},
+		{0x0a05, 0x0a0a, 1},
+		{0x0a0f, 0x0a10, 1},
+		{0x0a13, 0x0a28, 1},
+		{0x0a2a, 0x0a30, 1},
+		{0x0a32, 0x0a33, 1},
+		{0x0a35, 0x0a36, 1},
+		{0x0a38, 0x0a39, 1},
+		{0x0a3c, 0x0a3e, 2},
+		{0x0a3f, 0x0a42, 1},
+		{0x0a47, 0x0a48, 1},
+		{0x0a4b, 0x0a4d, 1},
+		{0x0a51, 0x0a59, 8},
+		{0x0a5a, 0x0a5c, 1},
+		{0x0a5e, 0x0a66, 8},
+		{0x0a67, 0x0a75, 1},
+		{0x0a81, 0x0a83, 1},
+		{0x0a85, 0x0a8d, 1},
+		{0x0a8f, 0x0a91, 1},
+		{0x0a93, 0x0aa8, 1},
+		{0x0aaa, 0x0ab0, 1},
+		{0x0ab2, 0x0ab3, 1},
+		{0x0ab5, 0x0ab9, 1},
+		{0x0abc, 0x0ac5, 1},
+		{0x0ac7, 0x0ac9, 1},
+		{0x0acb, 0x0acd, 1},
+		{0x0ad0, 0x0ae0, 16},
+		{0x0ae1, 0x0ae3, 1},
+		{0x0ae6, 0x0aef, 1},
+		{0x0af1, 0x0b01, 16},
+		{0x0b02, 0x0b03, 1},
+		{0x0b05, 0x0b0c, 1},
+		{0x0b0f, 0x0b10, 1},
+		{0x0b13, 0x0b28, 1},
+		{0x0b2a, 0x0b30, 1},
+		{0x0b32, 0x0b33, 1},
+		{0x0b35, 0x0b39, 1},
+		{0x0b3c, 0x0b44, 1},
+		{0x0b47, 0x0b48, 1},
+		{0x0b4b, 0x0b4d, 1},
+		{0x0b56, 0x0b57, 1},
+		{0x0b5c, 0x0b5d, 1},
+		{0x0b5f, 0x0b63, 1},
+		{0x0b66, 0x0b71, 1},
+		{0x0b82, 0x0b83, 1},
+		{0x0b85, 0x0b8a, 1},
+		{0x0b8e, 0x0b90, 1},
+		{0x0b92, 0x0b95, 1},
+		{0x0b99, 0x0b9a, 1},
+		{0x0b9c, 0x0b9e, 2},
+		{0x0b9f, 0x0ba3, 4},
+		{0x0ba4, 0x0ba8, 4},
+		{0x0ba9, 0x0baa, 1},
+		{0x0bae, 0x0bb9, 1},
+		{0x0bbe, 0x0bc2, 1},
+		{0x0bc6, 0x0bc8, 1},
+		{0x0bca, 0x0bcd, 1},
+		{0x0bd0, 0x0bd7, 7},
+		{0x0be6, 0x0bfa, 1},
+		{0x0c01, 0x0c03, 1},
+		{0x0c05, 0x0c0c, 1},
+		{0x0c0e, 0x0c10, 1},
+		{0x0c12, 0x0c28, 1},
+		{0x0c2a, 0x0c33, 1},
+		{0x0c35, 0x0c39, 1},
+		{0x0c3d, 0x0c44, 1},
+		{0x0c46, 0x0c48, 1},
+		{0x0c4a, 0x0c4d, 1},
+		{0x0c55, 0x0c56, 1},
+		{0x0c58, 0x0c59, 1},
+		{0x0c60, 0x0c63, 1},
+		{0x0c66, 0x0c6f, 1},
+		{0x0c78, 0x0c7f, 1},
+		{0x0c82, 0x0c83, 1},
+		{0x0c85, 0x0c8c, 1},
+		{0x0c8e, 0x0c90, 1},
+		{0x0c92, 0x0ca8, 1},
+		{0x0caa, 0x0cb3, 1},
+		{0x0cb5, 0x0cb9, 1},
+		{0x0cbc, 0x0cc4, 1},
+		{0x0cc6, 0x0cc8, 1},
+		{0x0cca, 0x0ccd, 1},
+		{0x0cd5, 0x0cd6, 1},
+		{0x0cde, 0x0ce0, 2},
+		{0x0ce1, 0x0ce3, 1},
+		{0x0ce6, 0x0cef, 1},
+		{0x0cf1, 0x0cf2, 1},
+		{0x0d02, 0x0d03, 1},
+		{0x0d05, 0x0d0c, 1},
+		{0x0d0e, 0x0d10, 1},
+		{0x0d12, 0x0d28, 1},
+		{0x0d2a, 0x0d39, 1},
+		{0x0d3d, 0x0d44, 1},
+		{0x0d46, 0x0d48, 1},
+		{0x0d4a, 0x0d4d, 1},
+		{0x0d57, 0x0d60, 9},
+		{0x0d61, 0x0d63, 1},
+		{0x0d66, 0x0d75, 1},
+		{0x0d79, 0x0d7f, 1},
+		{0x0d82, 0x0d83, 1},
+		{0x0d85, 0x0d96, 1},
+		{0x0d9a, 0x0db1, 1},
+		{0x0db3, 0x0dbb, 1},
+		{0x0dbd, 0x0dc0, 3},
+		{0x0dc1, 0x0dc6, 1},
+		{0x0dca, 0x0dcf, 5},
+		{0x0dd0, 0x0dd4, 1},
+		{0x0dd6, 0x0dd8, 2},
+		{0x0dd9, 0x0ddf, 1},
+		{0x0df2, 0x0df4, 1},
+		{0x0e01, 0x0e3a, 1},
+		{0x0e3f, 0x0e5b, 1},
+		{0x0e81, 0x0e82, 1},
+		{0x0e84, 0x0e87, 3},
+		{0x0e88, 0x0e8a, 2},
+		{0x0e8d, 0x0e94, 7},
+		{0x0e95, 0x0e97, 1},
+		{0x0e99, 0x0e9f, 1},
+		{0x0ea1, 0x0ea3, 1},
+		{0x0ea5, 0x0ea7, 2},
+		{0x0eaa, 0x0eab, 1},
+		{0x0ead, 0x0eb9, 1},
+		{0x0ebb, 0x0ebd, 1},
+		{0x0ec0, 0x0ec4, 1},
+		{0x0ec6, 0x0ec8, 2},
+		{0x0ec9, 0x0ecd, 1},
+		{0x0ed0, 0x0ed9, 1},
+		{0x0edc, 0x0edd, 1},
+		{0x0f00, 0x0f47, 1},
+		{0x0f49, 0x0f6c, 1},
+		{0x0f71, 0x0f8b, 1},
+		{0x0f90, 0x0f97, 1},
+		{0x0f99, 0x0fbc, 1},
+		{0x0fbe, 0x0fcc, 1},
+		{0x0fce, 0x0fd4, 1},
+		{0x1000, 0x1099, 1},
+		{0x109e, 0x10c5, 1},
+		{0x10d0, 0x10fc, 1},
+		{0x1100, 0x1159, 1},
+		{0x115f, 0x11a2, 1},
+		{0x11a8, 0x11f9, 1},
+		{0x1200, 0x1248, 1},
+		{0x124a, 0x124d, 1},
+		{0x1250, 0x1256, 1},
+		{0x1258, 0x125a, 2},
+		{0x125b, 0x125d, 1},
+		{0x1260, 0x1288, 1},
+		{0x128a, 0x128d, 1},
+		{0x1290, 0x12b0, 1},
+		{0x12b2, 0x12b5, 1},
+		{0x12b8, 0x12be, 1},
+		{0x12c0, 0x12c2, 2},
+		{0x12c3, 0x12c5, 1},
+		{0x12c8, 0x12d6, 1},
+		{0x12d8, 0x1310, 1},
+		{0x1312, 0x1315, 1},
+		{0x1318, 0x135a, 1},
+		{0x135f, 0x137c, 1},
+		{0x1380, 0x1399, 1},
+		{0x13a0, 0x13f4, 1},
+		{0x1401, 0x1676, 1},
+		{0x1680, 0x169c, 1},
+		{0x16a0, 0x16f0, 1},
+		{0x1700, 0x170c, 1},
+		{0x170e, 0x1714, 1},
+		{0x1720, 0x1736, 1},
+		{0x1740, 0x1753, 1},
+		{0x1760, 0x176c, 1},
+		{0x176e, 0x1770, 1},
+		{0x1772, 0x1773, 1},
+		{0x1780, 0x17dd, 1},
+		{0x17e0, 0x17e9, 1},
+		{0x17f0, 0x17f9, 1},
+		{0x1800, 0x180e, 1},
+		{0x1810, 0x1819, 1},
+		{0x1820, 0x1877, 1},
+		{0x1880, 0x18aa, 1},
+		{0x1900, 0x191c, 1},
+		{0x1920, 0x192b, 1},
+		{0x1930, 0x193b, 1},
+		{0x1940, 0x1944, 4},
+		{0x1945, 0x196d, 1},
+		{0x1970, 0x1974, 1},
+		{0x1980, 0x19a9, 1},
+		{0x19b0, 0x19c9, 1},
+		{0x19d0, 0x19d9, 1},
+		{0x19de, 0x1a1b, 1},
+		{0x1a1e, 0x1a1f, 1},
+		{0x1b00, 0x1b4b, 1},
+		{0x1b50, 0x1b7c, 1},
+		{0x1b80, 0x1baa, 1},
+		{0x1bae, 0x1bb9, 1},
+		{0x1c00, 0x1c37, 1},
+		{0x1c3b, 0x1c49, 1},
+		{0x1c4d, 0x1c7f, 1},
+		{0x1d00, 0x1de6, 1},
+		{0x1dfe, 0x1f15, 1},
+		{0x1f18, 0x1f1d, 1},
+		{0x1f20, 0x1f45, 1},
+		{0x1f48, 0x1f4d, 1},
+		{0x1f50, 0x1f57, 1},
+		{0x1f59, 0x1f5f, 2},
+		{0x1f60, 0x1f7d, 1},
+		{0x1f80, 0x1fb4, 1},
+		{0x1fb6, 0x1fc4, 1},
+		{0x1fc6, 0x1fd3, 1},
+		{0x1fd6, 0x1fdb, 1},
+		{0x1fdd, 0x1fef, 1},
+		{0x1ff2, 0x1ff4, 1},
+		{0x1ff6, 0x1ffe, 1},
+		{0x2000, 0x2064, 1},
+		{0x206a, 0x2071, 1},
+		{0x2074, 0x208e, 1},
+		{0x2090, 0x2094, 1},
+		{0x20a0, 0x20b5, 1},
+		{0x20d0, 0x20f0, 1},
+		{0x2100, 0x214f, 1},
+		{0x2153, 0x2188, 1},
+		{0x2190, 0x23e7, 1},
+		{0x2400, 0x2426, 1},
+		{0x2440, 0x244a, 1},
+		{0x2460, 0x269d, 1},
+		{0x26a0, 0x26bc, 1},
+		{0x26c0, 0x26c3, 1},
+		{0x2701, 0x2704, 1},
+		{0x2706, 0x2709, 1},
+		{0x270c, 0x2727, 1},
+		{0x2729, 0x274b, 1},
+		{0x274d, 0x274f, 2},
+		{0x2750, 0x2752, 1},
+		{0x2756, 0x2758, 2},
+		{0x2759, 0x275e, 1},
+		{0x2761, 0x2794, 1},
+		{0x2798, 0x27af, 1},
+		{0x27b1, 0x27be, 1},
+		{0x27c0, 0x27ca, 1},
+		{0x27cc, 0x27d0, 4},
+		{0x27d1, 0x2b4c, 1},
+		{0x2b50, 0x2b54, 1},
+		{0x2c00, 0x2c2e, 1},
+		{0x2c30, 0x2c5e, 1},
+		{0x2c60, 0x2c6f, 1},
+		{0x2c71, 0x2c7d, 1},
+		{0x2c80, 0x2cea, 1},
+		{0x2cf9, 0x2d25, 1},
+		{0x2d30, 0x2d65, 1},
+		{0x2d6f, 0x2d80, 17},
+		{0x2d81, 0x2d96, 1},
+		{0x2da0, 0x2da6, 1},
+		{0x2da8, 0x2dae, 1},
+		{0x2db0, 0x2db6, 1},
+		{0x2db8, 0x2dbe, 1},
+		{0x2dc0, 0x2dc6, 1},
+		{0x2dc8, 0x2dce, 1},
+		{0x2dd0, 0x2dd6, 1},
+		{0x2dd8, 0x2dde, 1},
+		{0x2de0, 0x2e30, 1},
+		{0x2e80, 0x2e99, 1},
+		{0x2e9b, 0x2ef3, 1},
+		{0x2f00, 0x2fd5, 1},
+		{0x2ff0, 0x2ffb, 1},
+		{0x3000, 0x303f, 1},
+		{0x3041, 0x3096, 1},
+		{0x3099, 0x30ff, 1},
+		{0x3105, 0x312d, 1},
+		{0x3131, 0x318e, 1},
+		{0x3190, 0x31b7, 1},
+		{0x31c0, 0x31e3, 1},
+		{0x31f0, 0x321e, 1},
+		{0x3220, 0x3243, 1},
+		{0x3250, 0x32fe, 1},
+		{0x3300, 0x4db5, 1},
+		{0x4dc0, 0x9fc3, 1},
+		{0xa000, 0xa48c, 1},
+		{0xa490, 0xa4c6, 1},
+		{0xa500, 0xa62b, 1},
+		{0xa640, 0xa65f, 1},
+		{0xa662, 0xa673, 1},
+		{0xa67c, 0xa697, 1},
+		{0xa700, 0xa78c, 1},
+		{0xa7fb, 0xa82b, 1},
+		{0xa840, 0xa877, 1},
+		{0xa880, 0xa8c4, 1},
+		{0xa8ce, 0xa8d9, 1},
+		{0xa900, 0xa953, 1},
+		{0xa95f, 0xaa00, 161},
+		{0xaa01, 0xaa36, 1},
+		{0xaa40, 0xaa4d, 1},
+		{0xaa50, 0xaa59, 1},
+		{0xaa5c, 0xaa5f, 1},
+		{0xac00, 0xd7a3, 1},
+		{0xd800, 0xfa2d, 1},
+		{0xfa30, 0xfa6a, 1},
+		{0xfa70, 0xfad9, 1},
+		{0xfb00, 0xfb06, 1},
+		{0xfb13, 0xfb17, 1},
+		{0xfb1d, 0xfb36, 1},
+		{0xfb38, 0xfb3c, 1},
+		{0xfb3e, 0xfb40, 2},
+		{0xfb41, 0xfb43, 2},
+		{0xfb44, 0xfb46, 2},
+		{0xfb47, 0xfbb1, 1},
+		{0xfbd3, 0xfd3f, 1},
+		{0xfd50, 0xfd8f, 1},
+		{0xfd92, 0xfdc7, 1},
+		{0xfdf0, 0xfdfd, 1},
+		{0xfe00, 0xfe19, 1},
+		{0xfe20, 0xfe26, 1},
+		{0xfe30, 0xfe52, 1},
+		{0xfe54, 0xfe66, 1},
+		{0xfe68, 0xfe6b, 1},
+		{0xfe70, 0xfe74, 1},
+		{0xfe76, 0xfefc, 1},
+		{0xfeff, 0xff01, 2},
+		{0xff02, 0xffbe, 1},
+		{0xffc2, 0xffc7, 1},
+		{0xffca, 0xffcf, 1},
+		{0xffd2, 0xffd7, 1},
+		{0xffda, 0xffdc, 1},
+		{0xffe0, 0xffe6, 1},
+		{0xffe8, 0xffee, 1},
+		{0xfff9, 0xfffd, 1},
+	},
+	R32: []unicode.Range32{
+		{0x00010000, 0x0001000b, 1},
+		{0x0001000d, 0x00010026, 1},
+		{0x00010028, 0x0001003a, 1},
+		{0x0001003c, 0x0001003d, 1},
+		{0x0001003f, 0x0001004d, 1},
+		{0x00010050, 0x0001005d, 1},
+		{0x00010080, 0x000100fa, 1},
+		{0x00010100, 0x00010102, 1},
+		{0x00010107, 0x00010133, 1},
+		{0x00010137, 0x0001018a, 1},
+		{0x00010190, 0x0001019b, 1},
+		{0x000101d0, 0x000101fd, 1},
+		{0x00010280, 0x0001029c, 1},
+		{0x000102a0, 0x000102d0, 1},
+		{0x00010300, 0x0001031e, 1},
+		{0x00010320, 0x00010323, 1},
+		{0x00010330, 0x0001034a, 1},
+		{0x00010380, 0x0001039d, 1},
+		{0x0001039f, 0x000103c3, 1},
+		{0x000103c8, 0x000103d5, 1},
+		{0x00010400, 0x0001049d, 1},
+		{0x000104a0, 0x000104a9, 1},
+		{0x00010800, 0x00010805, 1},
+		{0x00010808, 0x0001080a, 2},
+		{0x0001080b, 0x00010835, 1},
+		{0x00010837, 0x00010838, 1},
+		{0x0001083c, 0x0001083f, 3},
+		{0x00010900, 0x00010919, 1},
+		{0x0001091f, 0x00010939, 1},
+		{0x0001093f, 0x00010a00, 193},
+		{0x00010a01, 0x00010a03, 1},
+		{0x00010a05, 0x00010a06, 1},
+		{0x00010a0c, 0x00010a13, 1},
+		{0x00010a15, 0x00010a17, 1},
+		{0x00010a19, 0x00010a33, 1},
+		{0x00010a38, 0x00010a3a, 1},
+		{0x00010a3f, 0x00010a47, 1},
+		{0x00010a50, 0x00010a58, 1},
+		{0x00012000, 0x0001236e, 1},
+		{0x00012400, 0x00012462, 1},
+		{0x00012470, 0x00012473, 1},
+		{0x0001d000, 0x0001d0f5, 1},
+		{0x0001d100, 0x0001d126, 1},
+		{0x0001d129, 0x0001d1dd, 1},
+		{0x0001d200, 0x0001d245, 1},
+		{0x0001d300, 0x0001d356, 1},
+		{0x0001d360, 0x0001d371, 1},
+		{0x0001d400, 0x0001d454, 1},
+		{0x0001d456, 0x0001d49c, 1},
+		{0x0001d49e, 0x0001d49f, 1},
+		{0x0001d4a2, 0x0001d4a5, 3},
+		{0x0001d4a6, 0x0001d4a9, 3},
+		{0x0001d4aa, 0x0001d4ac, 1},
+		{0x0001d4ae, 0x0001d4b9, 1},
+		{0x0001d4bb, 0x0001d4bd, 2},
+		{0x0001d4be, 0x0001d4c3, 1},
+		{0x0001d4c5, 0x0001d505, 1},
+		{0x0001d507, 0x0001d50a, 1},
+		{0x0001d50d, 0x0001d514, 1},
+		{0x0001d516, 0x0001d51c, 1},
+		{0x0001d51e, 0x0001d539, 1},
+		{0x0001d53b, 0x0001d53e, 1},
+		{0x0001d540, 0x0001d544, 1},
+		{0x0001d546, 0x0001d54a, 4},
+		{0x0001d54b, 0x0001d550, 1},
+		{0x0001d552, 0x0001d6a5, 1},
+		{0x0001d6a8, 0x0001d7cb, 1},
+		{0x0001d7ce, 0x0001d7ff, 1},
+		{0x0001f000, 0x0001f02b, 1},
+		{0x0001f030, 0x0001f093, 1},
+		{0x00020000, 0x0002a6d6, 1},
+		{0x0002f800, 0x0002fa1d, 1},
+		{0x000e0001, 0x000e0020, 31},
+		{0x000e0021, 0x000e007f, 1},
+		{0x000e0100, 0x000e01ef, 1},
+		{0x000f0000, 0x000ffffd, 1},
+		{0x00100000, 0x0010fffd, 1},
+	},
+	LatinOffset: 0,
+}
+
+// size 3518 bytes (3 KiB)
+var assigned5_2_0 = &unicode.RangeTable{
+	R16: []unicode.Range16{
+		{0x0000, 0x0377, 1},
+		{0x037a, 0x037e, 1},
+		{0x0384, 0x038a, 1},
+		{0x038c, 0x038e, 2},
+		{0x038f, 0x03a1, 1},
+		{0x03a3, 0x0525, 1},
+		{0x0531, 0x0556, 1},
+		{0x0559, 0x055f, 1},
+		{0x0561, 0x0587, 1},
+		{0x0589, 0x058a, 1},
+		{0x0591, 0x05c7, 1},
+		{0x05d0, 0x05ea, 1},
+		{0x05f0, 0x05f4, 1},
+		{0x0600, 0x0603, 1},
+		{0x0606, 0x061b, 1},
+		{0x061e, 0x061f, 1},
+		{0x0621, 0x065e, 1},
+		{0x0660, 0x070d, 1},
+		{0x070f, 0x074a, 1},
+		{0x074d, 0x07b1, 1},
+		{0x07c0, 0x07fa, 1},
+		{0x0800, 0x082d, 1},
+		{0x0830, 0x083e, 1},
+		{0x0900, 0x0939, 1},
+		{0x093c, 0x094e, 1},
+		{0x0950, 0x0955, 1},
+		{0x0958, 0x0972, 1},
+		{0x0979, 0x097f, 1},
+		{0x0981, 0x0983, 1},
+		{0x0985, 0x098c, 1},
+		{0x098f, 0x0990, 1},
+		{0x0993, 0x09a8, 1},
+		{0x09aa, 0x09b0, 1},
+		{0x09b2, 0x09b6, 4},
+		{0x09b7, 0x09b9, 1},
+		{0x09bc, 0x09c4, 1},
+		{0x09c7, 0x09c8, 1},
+		{0x09cb, 0x09ce, 1},
+		{0x09d7, 0x09dc, 5},
+		{0x09dd, 0x09df, 2},
+		{0x09e0, 0x09e3, 1},
+		{0x09e6, 0x09fb, 1},
+		{0x0a01, 0x0a03, 1},
+		{0x0a05, 0x0a0a, 1},
+		{0x0a0f, 0x0a10, 1},
+		{0x0a13, 0x0a28, 1},
+		{0x0a2a, 0x0a30, 1},
+		{0x0a32, 0x0a33, 1},
+		{0x0a35, 0x0a36, 1},
+		{0x0a38, 0x0a39, 1},
+		{0x0a3c, 0x0a3e, 2},
+		{0x0a3f, 0x0a42, 1},
+		{0x0a47, 0x0a48, 1},
+		{0x0a4b, 0x0a4d, 1},
+		{0x0a51, 0x0a59, 8},
+		{0x0a5a, 0x0a5c, 1},
+		{0x0a5e, 0x0a66, 8},
+		{0x0a67, 0x0a75, 1},
+		{0x0a81, 0x0a83, 1},
+		{0x0a85, 0x0a8d, 1},
+		{0x0a8f, 0x0a91, 1},
+		{0x0a93, 0x0aa8, 1},
+		{0x0aaa, 0x0ab0, 1},
+		{0x0ab2, 0x0ab3, 1},
+		{0x0ab5, 0x0ab9, 1},
+		{0x0abc, 0x0ac5, 1},
+		{0x0ac7, 0x0ac9, 1},
+		{0x0acb, 0x0acd, 1},
+		{0x0ad0, 0x0ae0, 16},
+		{0x0ae1, 0x0ae3, 1},
+		{0x0ae6, 0x0aef, 1},
+		{0x0af1, 0x0b01, 16},
+		{0x0b02, 0x0b03, 1},
+		{0x0b05, 0x0b0c, 1},
+		{0x0b0f, 0x0b10, 1},
+		{0x0b13, 0x0b28, 1},
+		{0x0b2a, 0x0b30, 1},
+		{0x0b32, 0x0b33, 1},
+		{0x0b35, 0x0b39, 1},
+		{0x0b3c, 0x0b44, 1},
+		{0x0b47, 0x0b48, 1},
+		{0x0b4b, 0x0b4d, 1},
+		{0x0b56, 0x0b57, 1},
+		{0x0b5c, 0x0b5d, 1},
+		{0x0b5f, 0x0b63, 1},
+		{0x0b66, 0x0b71, 1},
+		{0x0b82, 0x0b83, 1},
+		{0x0b85, 0x0b8a, 1},
+		{0x0b8e, 0x0b90, 1},
+		{0x0b92, 0x0b95, 1},
+		{0x0b99, 0x0b9a, 1},
+		{0x0b9c, 0x0b9e, 2},
+		{0x0b9f, 0x0ba3, 4},
+		{0x0ba4, 0x0ba8, 4},
+		{0x0ba9, 0x0baa, 1},
+		{0x0bae, 0x0bb9, 1},
+		{0x0bbe, 0x0bc2, 1},
+		{0x0bc6, 0x0bc8, 1},
+		{0x0bca, 0x0bcd, 1},
+		{0x0bd0, 0x0bd7, 7},
+		{0x0be6, 0x0bfa, 1},
+		{0x0c01, 0x0c03, 1},
+		{0x0c05, 0x0c0c, 1},
+		{0x0c0e, 0x0c10, 1},
+		{0x0c12, 0x0c28, 1},
+		{0x0c2a, 0x0c33, 1},
+		{0x0c35, 0x0c39, 1},
+		{0x0c3d, 0x0c44, 1},
+		{0x0c46, 0x0c48, 1},
+		{0x0c4a, 0x0c4d, 1},
+		{0x0c55, 0x0c56, 1},
+		{0x0c58, 0x0c59, 1},
+		{0x0c60, 0x0c63, 1},
+		{0x0c66, 0x0c6f, 1},
+		{0x0c78, 0x0c7f, 1},
+		{0x0c82, 0x0c83, 1},
+		{0x0c85, 0x0c8c, 1},
+		{0x0c8e, 0x0c90, 1},
+		{0x0c92, 0x0ca8, 1},
+		{0x0caa, 0x0cb3, 1},
+		{0x0cb5, 0x0cb9, 1},
+		{0x0cbc, 0x0cc4, 1},
+		{0x0cc6, 0x0cc8, 1},
+		{0x0cca, 0x0ccd, 1},
+		{0x0cd5, 0x0cd6, 1},
+		{0x0cde, 0x0ce0, 2},
+		{0x0ce1, 0x0ce3, 1},
+		{0x0ce6, 0x0cef, 1},
+		{0x0cf1, 0x0cf2, 1},
+		{0x0d02, 0x0d03, 1},
+		{0x0d05, 0x0d0c, 1},
+		{0x0d0e, 0x0d10, 1},
+		{0x0d12, 0x0d28, 1},
+		{0x0d2a, 0x0d39, 1},
+		{0x0d3d, 0x0d44, 1},
+		{0x0d46, 0x0d48, 1},
+		{0x0d4a, 0x0d4d, 1},
+		{0x0d57, 0x0d60, 9},
+		{0x0d61, 0x0d63, 1},
+		{0x0d66, 0x0d75, 1},
+		{0x0d79, 0x0d7f, 1},
+		{0x0d82, 0x0d83, 1},
+		{0x0d85, 0x0d96, 1},
+		{0x0d9a, 0x0db1, 1},
+		{0x0db3, 0x0dbb, 1},
+		{0x0dbd, 0x0dc0, 3},
+		{0x0dc1, 0x0dc6, 1},
+		{0x0dca, 0x0dcf, 5},
+		{0x0dd0, 0x0dd4, 1},
+		{0x0dd6, 0x0dd8, 2},
+		{0x0dd9, 0x0ddf, 1},
+		{0x0df2, 0x0df4, 1},
+		{0x0e01, 0x0e3a, 1},
+		{0x0e3f, 0x0e5b, 1},
+		{0x0e81, 0x0e82, 1},
+		{0x0e84, 0x0e87, 3},
+		{0x0e88, 0x0e8a, 2},
+		{0x0e8d, 0x0e94, 7},
+		{0x0e95, 0x0e97, 1},
+		{0x0e99, 0x0e9f, 1},
+		{0x0ea1, 0x0ea3, 1},
+		{0x0ea5, 0x0ea7, 2},
+		{0x0eaa, 0x0eab, 1},
+		{0x0ead, 0x0eb9, 1},
+		{0x0ebb, 0x0ebd, 1},
+		{0x0ec0, 0x0ec4, 1},
+		{0x0ec6, 0x0ec8, 2},
+		{0x0ec9, 0x0ecd, 1},
+		{0x0ed0, 0x0ed9, 1},
+		{0x0edc, 0x0edd, 1},
+		{0x0f00, 0x0f47, 1},
+		{0x0f49, 0x0f6c, 1},
+		{0x0f71, 0x0f8b, 1},
+		{0x0f90, 0x0f97, 1},
+		{0x0f99, 0x0fbc, 1},
+		{0x0fbe, 0x0fcc, 1},
+		{0x0fce, 0x0fd8, 1},
+		{0x1000, 0x10c5, 1},
+		{0x10d0, 0x10fc, 1},
+		{0x1100, 0x1248, 1},
+		{0x124a, 0x124d, 1},
+		{0x1250, 0x1256, 1},
+		{0x1258, 0x125a, 2},
+		{0x125b, 0x125d, 1},
+		{0x1260, 0x1288, 1},
+		{0x128a, 0x128d, 1},
+		{0x1290, 0x12b0, 1},
+		{0x12b2, 0x12b5, 1},
+		{0x12b8, 0x12be, 1},
+		{0x12c0, 0x12c2, 2},
+		{0x12c3, 0x12c5, 1},
+		{0x12c8, 0x12d6, 1},
+		{0x12d8, 0x1310, 1},
+		{0x1312, 0x1315, 1},
+		{0x1318, 0x135a, 1},
+		{0x135f, 0x137c, 1},
+		{0x1380, 0x1399, 1},
+		{0x13a0, 0x13f4, 1},
+		{0x1400, 0x169c, 1},
+		{0x16a0, 0x16f0, 1},
+		{0x1700, 0x170c, 1},
+		{0x170e, 0x1714, 1},
+		{0x1720, 0x1736, 1},
+		{0x1740, 0x1753, 1},
+		{0x1760, 0x176c, 1},
+		{0x176e, 0x1770, 1},
+		{0x1772, 0x1773, 1},
+		{0x1780, 0x17dd, 1},
+		{0x17e0, 0x17e9, 1},
+		{0x17f0, 0x17f9, 1},
+		{0x1800, 0x180e, 1},
+		{0x1810, 0x1819, 1},
+		{0x1820, 0x1877, 1},
+		{0x1880, 0x18aa, 1},
+		{0x18b0, 0x18f5, 1},
+		{0x1900, 0x191c, 1},
+		{0x1920, 0x192b, 1},
+		{0x1930, 0x193b, 1},
+		{0x1940, 0x1944, 4},
+		{0x1945, 0x196d, 1},
+		{0x1970, 0x1974, 1},
+		{0x1980, 0x19ab, 1},
+		{0x19b0, 0x19c9, 1},
+		{0x19d0, 0x19da, 1},
+		{0x19de, 0x1a1b, 1},
+		{0x1a1e, 0x1a5e, 1},
+		{0x1a60, 0x1a7c, 1},
+		{0x1a7f, 0x1a89, 1},
+		{0x1a90, 0x1a99, 1},
+		{0x1aa0, 0x1aad, 1},
+		{0x1b00, 0x1b4b, 1},
+		{0x1b50, 0x1b7c, 1},
+		{0x1b80, 0x1baa, 1},
+		{0x1bae, 0x1bb9, 1},
+		{0x1c00, 0x1c37, 1},
+		{0x1c3b, 0x1c49, 1},
+		{0x1c4d, 0x1c7f, 1},
+		{0x1cd0, 0x1cf2, 1},
+		{0x1d00, 0x1de6, 1},
+		{0x1dfd, 0x1f15, 1},
+		{0x1f18, 0x1f1d, 1},
+		{0x1f20, 0x1f45, 1},
+		{0x1f48, 0x1f4d, 1},
+		{0x1f50, 0x1f57, 1},
+		{0x1f59, 0x1f5f, 2},
+		{0x1f60, 0x1f7d, 1},
+		{0x1f80, 0x1fb4, 1},
+		{0x1fb6, 0x1fc4, 1},
+		{0x1fc6, 0x1fd3, 1},
+		{0x1fd6, 0x1fdb, 1},
+		{0x1fdd, 0x1fef, 1},
+		{0x1ff2, 0x1ff4, 1},
+		{0x1ff6, 0x1ffe, 1},
+		{0x2000, 0x2064, 1},
+		{0x206a, 0x2071, 1},
+		{0x2074, 0x208e, 1},
+		{0x2090, 0x2094, 1},
+		{0x20a0, 0x20b8, 1},
+		{0x20d0, 0x20f0, 1},
+		{0x2100, 0x2189, 1},
+		{0x2190, 0x23e8, 1},
+		{0x2400, 0x2426, 1},
+		{0x2440, 0x244a, 1},
+		{0x2460, 0x26cd, 1},
+		{0x26cf, 0x26e1, 1},
+		{0x26e3, 0x26e8, 5},
+		{0x26e9, 0x26ff, 1},
+		{0x2701, 0x2704, 1},
+		{0x2706, 0x2709, 1},
+		{0x270c, 0x2727, 1},
+		{0x2729, 0x274b, 1},
+		{0x274d, 0x274f, 2},
+		{0x2750, 0x2752, 1},
+		{0x2756, 0x275e, 1},
+		{0x2761, 0x2794, 1},
+		{0x2798, 0x27af, 1},
+		{0x27b1, 0x27be, 1},
+		{0x27c0, 0x27ca, 1},
+		{0x27cc, 0x27d0, 4},
+		{0x27d1, 0x2b4c, 1},
+		{0x2b50, 0x2b59, 1},
+		{0x2c00, 0x2c2e, 1},
+		{0x2c30, 0x2c5e, 1},
+		{0x2c60, 0x2cf1, 1},
+		{0x2cf9, 0x2d25, 1},
+		{0x2d30, 0x2d65, 1},
+		{0x2d6f, 0x2d80, 17},
+		{0x2d81, 0x2d96, 1},
+		{0x2da0, 0x2da6, 1},
+		{0x2da8, 0x2dae, 1},
+		{0x2db0, 0x2db6, 1},
+		{0x2db8, 0x2dbe, 1},
+		{0x2dc0, 0x2dc6, 1},
+		{0x2dc8, 0x2dce, 1},
+		{0x2dd0, 0x2dd6, 1},
+		{0x2dd8, 0x2dde, 1},
+		{0x2de0, 0x2e31, 1},
+		{0x2e80, 0x2e99, 1},
+		{0x2e9b, 0x2ef3, 1},
+		{0x2f00, 0x2fd5, 1},
+		{0x2ff0, 0x2ffb, 1},
+		{0x3000, 0x303f, 1},
+		{0x3041, 0x3096, 1},
+		{0x3099, 0x30ff, 1},
+		{0x3105, 0x312d, 1},
+		{0x3131, 0x318e, 1},
+		{0x3190, 0x31b7, 1},
+		{0x31c0, 0x31e3, 1},
+		{0x31f0, 0x321e, 1},
+		{0x3220, 0x32fe, 1},
+		{0x3300, 0x4db5, 1},
+		{0x4dc0, 0x9fcb, 1},
+		{0xa000, 0xa48c, 1},
+		{0xa490, 0xa4c6, 1},
+		{0xa4d0, 0xa62b, 1},
+		{0xa640, 0xa65f, 1},
+		{0xa662, 0xa673, 1},
+		{0xa67c, 0xa697, 1},
+		{0xa6a0, 0xa6f7, 1},
+		{0xa700, 0xa78c, 1},
+		{0xa7fb, 0xa82b, 1},
+		{0xa830, 0xa839, 1},
+		{0xa840, 0xa877, 1},
+		{0xa880, 0xa8c4, 1},
+		{0xa8ce, 0xa8d9, 1},
+		{0xa8e0, 0xa8fb, 1},
+		{0xa900, 0xa953, 1},
+		{0xa95f, 0xa97c, 1},
+		{0xa980, 0xa9cd, 1},
+		{0xa9cf, 0xa9d9, 1},
+		{0xa9de, 0xa9df, 1},
+		{0xaa00, 0xaa36, 1},
+		{0xaa40, 0xaa4d, 1},
+		{0xaa50, 0xaa59, 1},
+		{0xaa5c, 0xaa7b, 1},
+		{0xaa80, 0xaac2, 1},
+		{0xaadb, 0xaadf, 1},
+		{0xabc0, 0xabed, 1},
+		{0xabf0, 0xabf9, 1},
+		{0xac00, 0xd7a3, 1},
+		{0xd7b0, 0xd7c6, 1},
+		{0xd7cb, 0xd7fb, 1},
+		{0xd800, 0xfa2d, 1},
+		{0xfa30, 0xfa6d, 1},
+		{0xfa70, 0xfad9, 1},
+		{0xfb00, 0xfb06, 1},
+		{0xfb13, 0xfb17, 1},
+		{0xfb1d, 0xfb36, 1},
+		{0xfb38, 0xfb3c, 1},
+		{0xfb3e, 0xfb40, 2},
+		{0xfb41, 0xfb43, 2},
+		{0xfb44, 0xfb46, 2},
+		{0xfb47, 0xfbb1, 1},
+		{0xfbd3, 0xfd3f, 1},
+		{0xfd50, 0xfd8f, 1},
+		{0xfd92, 0xfdc7, 1},
+		{0xfdf0, 0xfdfd, 1},
+		{0xfe00, 0xfe19, 1},
+		{0xfe20, 0xfe26, 1},
+		{0xfe30, 0xfe52, 1},
+		{0xfe54, 0xfe66, 1},
+		{0xfe68, 0xfe6b, 1},
+		{0xfe70, 0xfe74, 1},
+		{0xfe76, 0xfefc, 1},
+		{0xfeff, 0xff01, 2},
+		{0xff02, 0xffbe, 1},
+		{0xffc2, 0xffc7, 1},
+		{0xffca, 0xffcf, 1},
+		{0xffd2, 0xffd7, 1},
+		{0xffda, 0xffdc, 1},
+		{0xffe0, 0xffe6, 1},
+		{0xffe8, 0xffee, 1},
+		{0xfff9, 0xfffd, 1},
+	},
+	R32: []unicode.Range32{
+		{0x00010000, 0x0001000b, 1},
+		{0x0001000d, 0x00010026, 1},
+		{0x00010028, 0x0001003a, 1},
+		{0x0001003c, 0x0001003d, 1},
+		{0x0001003f, 0x0001004d, 1},
+		{0x00010050, 0x0001005d, 1},
+		{0x00010080, 0x000100fa, 1},
+		{0x00010100, 0x00010102, 1},
+		{0x00010107, 0x00010133, 1},
+		{0x00010137, 0x0001018a, 1},
+		{0x00010190, 0x0001019b, 1},
+		{0x000101d0, 0x000101fd, 1},
+		{0x00010280, 0x0001029c, 1},
+		{0x000102a0, 0x000102d0, 1},
+		{0x00010300, 0x0001031e, 1},
+		{0x00010320, 0x00010323, 1},
+		{0x00010330, 0x0001034a, 1},
+		{0x00010380, 0x0001039d, 1},
+		{0x0001039f, 0x000103c3, 1},
+		{0x000103c8, 0x000103d5, 1},
+		{0x00010400, 0x0001049d, 1},
+		{0x000104a0, 0x000104a9, 1},
+		{0x00010800, 0x00010805, 1},
+		{0x00010808, 0x0001080a, 2},
+		{0x0001080b, 0x00010835, 1},
+		{0x00010837, 0x00010838, 1},
+		{0x0001083c, 0x0001083f, 3},
+		{0x00010840, 0x00010855, 1},
+		{0x00010857, 0x0001085f, 1},
+		{0x00010900, 0x0001091b, 1},
+		{0x0001091f, 0x00010939, 1},
+		{0x0001093f, 0x00010a00, 193},
+		{0x00010a01, 0x00010a03, 1},
+		{0x00010a05, 0x00010a06, 1},
+		{0x00010a0c, 0x00010a13, 1},
+		{0x00010a15, 0x00010a17, 1},
+		{0x00010a19, 0x00010a33, 1},
+		{0x00010a38, 0x00010a3a, 1},
+		{0x00010a3f, 0x00010a47, 1},
+		{0x00010a50, 0x00010a58, 1},
+		{0x00010a60, 0x00010a7f, 1},
+		{0x00010b00, 0x00010b35, 1},
+		{0x00010b39, 0x00010b55, 1},
+		{0x00010b58, 0x00010b72, 1},
+		{0x00010b78, 0x00010b7f, 1},
+		{0x00010c00, 0x00010c48, 1},
+		{0x00010e60, 0x00010e7e, 1},
+		{0x00011080, 0x000110c1, 1},
+		{0x00012000, 0x0001236e, 1},
+		{0x00012400, 0x00012462, 1},
+		{0x00012470, 0x00012473, 1},
+		{0x00013000, 0x0001342e, 1},
+		{0x0001d000, 0x0001d0f5, 1},
+		{0x0001d100, 0x0001d126, 1},
+		{0x0001d129, 0x0001d1dd, 1},
+		{0x0001d200, 0x0001d245, 1},
+		{0x0001d300, 0x0001d356, 1},
+		{0x0001d360, 0x0001d371, 1},
+		{0x0001d400, 0x0001d454, 1},
+		{0x0001d456, 0x0001d49c, 1},
+		{0x0001d49e, 0x0001d49f, 1},
+		{0x0001d4a2, 0x0001d4a5, 3},
+		{0x0001d4a6, 0x0001d4a9, 3},
+		{0x0001d4aa, 0x0001d4ac, 1},
+		{0x0001d4ae, 0x0001d4b9, 1},
+		{0x0001d4bb, 0x0001d4bd, 2},
+		{0x0001d4be, 0x0001d4c3, 1},
+		{0x0001d4c5, 0x0001d505, 1},
+		{0x0001d507, 0x0001d50a, 1},
+		{0x0001d50d, 0x0001d514, 1},
+		{0x0001d516, 0x0001d51c, 1},
+		{0x0001d51e, 0x0001d539, 1},
+		{0x0001d53b, 0x0001d53e, 1},
+		{0x0001d540, 0x0001d544, 1},
+		{0x0001d546, 0x0001d54a, 4},
+		{0x0001d54b, 0x0001d550, 1},
+		{0x0001d552, 0x0001d6a5, 1},
+		{0x0001d6a8, 0x0001d7cb, 1},
+		{0x0001d7ce, 0x0001d7ff, 1},
+		{0x0001f000, 0x0001f02b, 1},
+		{0x0001f030, 0x0001f093, 1},
+		{0x0001f100, 0x0001f10a, 1},
+		{0x0001f110, 0x0001f12e, 1},
+		{0x0001f131, 0x0001f13d, 12},
+		{0x0001f13f, 0x0001f142, 3},
+		{0x0001f146, 0x0001f14a, 4},
+		{0x0001f14b, 0x0001f14e, 1},
+		{0x0001f157, 0x0001f15f, 8},
+		{0x0001f179, 0x0001f17b, 2},
+		{0x0001f17c, 0x0001f17f, 3},
+		{0x0001f18a, 0x0001f18d, 1},
+		{0x0001f190, 0x0001f200, 112},
+		{0x0001f210, 0x0001f231, 1},
+		{0x0001f240, 0x0001f248, 1},
+		{0x00020000, 0x0002a6d6, 1},
+		{0x0002a700, 0x0002b734, 1},
+		{0x0002f800, 0x0002fa1d, 1},
+		{0x000e0001, 0x000e0020, 31},
+		{0x000e0021, 0x000e007f, 1},
+		{0x000e0100, 0x000e01ef, 1},
+		{0x000f0000, 0x000ffffd, 1},
+		{0x00100000, 0x0010fffd, 1},
+	},
+	LatinOffset: 0,
+}
+
+// size 3812 bytes (3 KiB)
+var assigned6_0_0 = &unicode.RangeTable{
+	R16: []unicode.Range16{
+		{0x0000, 0x0377, 1},
+		{0x037a, 0x037e, 1},
+		{0x0384, 0x038a, 1},
+		{0x038c, 0x038e, 2},
+		{0x038f, 0x03a1, 1},
+		{0x03a3, 0x0527, 1},
+		{0x0531, 0x0556, 1},
+		{0x0559, 0x055f, 1},
+		{0x0561, 0x0587, 1},
+		{0x0589, 0x058a, 1},
+		{0x0591, 0x05c7, 1},
+		{0x05d0, 0x05ea, 1},
+		{0x05f0, 0x05f4, 1},
+		{0x0600, 0x0603, 1},
+		{0x0606, 0x061b, 1},
+		{0x061e, 0x070d, 1},
+		{0x070f, 0x074a, 1},
+		{0x074d, 0x07b1, 1},
+		{0x07c0, 0x07fa, 1},
+		{0x0800, 0x082d, 1},
+		{0x0830, 0x083e, 1},
+		{0x0840, 0x085b, 1},
+		{0x085e, 0x0900, 162},
+		{0x0901, 0x0977, 1},
+		{0x0979, 0x097f, 1},
+		{0x0981, 0x0983, 1},
+		{0x0985, 0x098c, 1},
+		{0x098f, 0x0990, 1},
+		{0x0993, 0x09a8, 1},
+		{0x09aa, 0x09b0, 1},
+		{0x09b2, 0x09b6, 4},
+		{0x09b7, 0x09b9, 1},
+		{0x09bc, 0x09c4, 1},
+		{0x09c7, 0x09c8, 1},
+		{0x09cb, 0x09ce, 1},
+		{0x09d7, 0x09dc, 5},
+		{0x09dd, 0x09df, 2},
+		{0x09e0, 0x09e3, 1},
+		{0x09e6, 0x09fb, 1},
+		{0x0a01, 0x0a03, 1},
+		{0x0a05, 0x0a0a, 1},
+		{0x0a0f, 0x0a10, 1},
+		{0x0a13, 0x0a28, 1},
+		{0x0a2a, 0x0a30, 1},
+		{0x0a32, 0x0a33, 1},
+		{0x0a35, 0x0a36, 1},
+		{0x0a38, 0x0a39, 1},
+		{0x0a3c, 0x0a3e, 2},
+		{0x0a3f, 0x0a42, 1},
+		{0x0a47, 0x0a48, 1},
+		{0x0a4b, 0x0a4d, 1},
+		{0x0a51, 0x0a59, 8},
+		{0x0a5a, 0x0a5c, 1},
+		{0x0a5e, 0x0a66, 8},
+		{0x0a67, 0x0a75, 1},
+		{0x0a81, 0x0a83, 1},
+		{0x0a85, 0x0a8d, 1},
+		{0x0a8f, 0x0a91, 1},
+		{0x0a93, 0x0aa8, 1},
+		{0x0aaa, 0x0ab0, 1},
+		{0x0ab2, 0x0ab3, 1},
+		{0x0ab5, 0x0ab9, 1},
+		{0x0abc, 0x0ac5, 1},
+		{0x0ac7, 0x0ac9, 1},
+		{0x0acb, 0x0acd, 1},
+		{0x0ad0, 0x0ae0, 16},
+		{0x0ae1, 0x0ae3, 1},
+		{0x0ae6, 0x0aef, 1},
+		{0x0af1, 0x0b01, 16},
+		{0x0b02, 0x0b03, 1},
+		{0x0b05, 0x0b0c, 1},
+		{0x0b0f, 0x0b10, 1},
+		{0x0b13, 0x0b28, 1},
+		{0x0b2a, 0x0b30, 1},
+		{0x0b32, 0x0b33, 1},
+		{0x0b35, 0x0b39, 1},
+		{0x0b3c, 0x0b44, 1},
+		{0x0b47, 0x0b48, 1},
+		{0x0b4b, 0x0b4d, 1},
+		{0x0b56, 0x0b57, 1},
+		{0x0b5c, 0x0b5d, 1},
+		{0x0b5f, 0x0b63, 1},
+		{0x0b66, 0x0b77, 1},
+		{0x0b82, 0x0b83, 1},
+		{0x0b85, 0x0b8a, 1},
+		{0x0b8e, 0x0b90, 1},
+		{0x0b92, 0x0b95, 1},
+		{0x0b99, 0x0b9a, 1},
+		{0x0b9c, 0x0b9e, 2},
+		{0x0b9f, 0x0ba3, 4},
+		{0x0ba4, 0x0ba8, 4},
+		{0x0ba9, 0x0baa, 1},
+		{0x0bae, 0x0bb9, 1},
+		{0x0bbe, 0x0bc2, 1},
+		{0x0bc6, 0x0bc8, 1},
+		{0x0bca, 0x0bcd, 1},
+		{0x0bd0, 0x0bd7, 7},
+		{0x0be6, 0x0bfa, 1},
+		{0x0c01, 0x0c03, 1},
+		{0x0c05, 0x0c0c, 1},
+		{0x0c0e, 0x0c10, 1},
+		{0x0c12, 0x0c28, 1},
+		{0x0c2a, 0x0c33, 1},
+		{0x0c35, 0x0c39, 1},
+		{0x0c3d, 0x0c44, 1},
+		{0x0c46, 0x0c48, 1},
+		{0x0c4a, 0x0c4d, 1},
+		{0x0c55, 0x0c56, 1},
+		{0x0c58, 0x0c59, 1},
+		{0x0c60, 0x0c63, 1},
+		{0x0c66, 0x0c6f, 1},
+		{0x0c78, 0x0c7f, 1},
+		{0x0c82, 0x0c83, 1},
+		{0x0c85, 0x0c8c, 1},
+		{0x0c8e, 0x0c90, 1},
+		{0x0c92, 0x0ca8, 1},
+		{0x0caa, 0x0cb3, 1},
+		{0x0cb5, 0x0cb9, 1},
+		{0x0cbc, 0x0cc4, 1},
+		{0x0cc6, 0x0cc8, 1},
+		{0x0cca, 0x0ccd, 1},
+		{0x0cd5, 0x0cd6, 1},
+		{0x0cde, 0x0ce0, 2},
+		{0x0ce1, 0x0ce3, 1},
+		{0x0ce6, 0x0cef, 1},
+		{0x0cf1, 0x0cf2, 1},
+		{0x0d02, 0x0d03, 1},
+		{0x0d05, 0x0d0c, 1},
+		{0x0d0e, 0x0d10, 1},
+		{0x0d12, 0x0d3a, 1},
+		{0x0d3d, 0x0d44, 1},
+		{0x0d46, 0x0d48, 1},
+		{0x0d4a, 0x0d4e, 1},
+		{0x0d57, 0x0d60, 9},
+		{0x0d61, 0x0d63, 1},
+		{0x0d66, 0x0d75, 1},
+		{0x0d79, 0x0d7f, 1},
+		{0x0d82, 0x0d83, 1},
+		{0x0d85, 0x0d96, 1},
+		{0x0d9a, 0x0db1, 1},
+		{0x0db3, 0x0dbb, 1},
+		{0x0dbd, 0x0dc0, 3},
+		{0x0dc1, 0x0dc6, 1},
+		{0x0dca, 0x0dcf, 5},
+		{0x0dd0, 0x0dd4, 1},
+		{0x0dd6, 0x0dd8, 2},
+		{0x0dd9, 0x0ddf, 1},
+		{0x0df2, 0x0df4, 1},
+		{0x0e01, 0x0e3a, 1},
+		{0x0e3f, 0x0e5b, 1},
+		{0x0e81, 0x0e82, 1},
+		{0x0e84, 0x0e87, 3},
+		{0x0e88, 0x0e8a, 2},
+		{0x0e8d, 0x0e94, 7},
+		{0x0e95, 0x0e97, 1},
+		{0x0e99, 0x0e9f, 1},
+		{0x0ea1, 0x0ea3, 1},
+		{0x0ea5, 0x0ea7, 2},
+		{0x0eaa, 0x0eab, 1},
+		{0x0ead, 0x0eb9, 1},
+		{0x0ebb, 0x0ebd, 1},
+		{0x0ec0, 0x0ec4, 1},
+		{0x0ec6, 0x0ec8, 2},
+		{0x0ec9, 0x0ecd, 1},
+		{0x0ed0, 0x0ed9, 1},
+		{0x0edc, 0x0edd, 1},
+		{0x0f00, 0x0f47, 1},
+		{0x0f49, 0x0f6c, 1},
+		{0x0f71, 0x0f97, 1},
+		{0x0f99, 0x0fbc, 1},
+		{0x0fbe, 0x0fcc, 1},
+		{0x0fce, 0x0fda, 1},
+		{0x1000, 0x10c5, 1},
+		{0x10d0, 0x10fc, 1},
+		{0x1100, 0x1248, 1},
+		{0x124a, 0x124d, 1},
+		{0x1250, 0x1256, 1},
+		{0x1258, 0x125a, 2},
+		{0x125b, 0x125d, 1},
+		{0x1260, 0x1288, 1},
+		{0x128a, 0x128d, 1},
+		{0x1290, 0x12b0, 1},
+		{0x12b2, 0x12b5, 1},
+		{0x12b8, 0x12be, 1},
+		{0x12c0, 0x12c2, 2},
+		{0x12c3, 0x12c5, 1},
+		{0x12c8, 0x12d6, 1},
+		{0x12d8, 0x1310, 1},
+		{0x1312, 0x1315, 1},
+		{0x1318, 0x135a, 1},
+		{0x135d, 0x137c, 1},
+		{0x1380, 0x1399, 1},
+		{0x13a0, 0x13f4, 1},
+		{0x1400, 0x169c, 1},
+		{0x16a0, 0x16f0, 1},
+		{0x1700, 0x170c, 1},
+		{0x170e, 0x1714, 1},
+		{0x1720, 0x1736, 1},
+		{0x1740, 0x1753, 1},
+		{0x1760, 0x176c, 1},
+		{0x176e, 0x1770, 1},
+		{0x1772, 0x1773, 1},
+		{0x1780, 0x17dd, 1},
+		{0x17e0, 0x17e9, 1},
+		{0x17f0, 0x17f9, 1},
+		{0x1800, 0x180e, 1},
+		{0x1810, 0x1819, 1},
+		{0x1820, 0x1877, 1},
+		{0x1880, 0x18aa, 1},
+		{0x18b0, 0x18f5, 1},
+		{0x1900, 0x191c, 1},
+		{0x1920, 0x192b, 1},
+		{0x1930, 0x193b, 1},
+		{0x1940, 0x1944, 4},
+		{0x1945, 0x196d, 1},
+		{0x1970, 0x1974, 1},
+		{0x1980, 0x19ab, 1},
+		{0x19b0, 0x19c9, 1},
+		{0x19d0, 0x19da, 1},
+		{0x19de, 0x1a1b, 1},
+		{0x1a1e, 0x1a5e, 1},
+		{0x1a60, 0x1a7c, 1},
+		{0x1a7f, 0x1a89, 1},
+		{0x1a90, 0x1a99, 1},
+		{0x1aa0, 0x1aad, 1},
+		{0x1b00, 0x1b4b, 1},
+		{0x1b50, 0x1b7c, 1},
+		{0x1b80, 0x1baa, 1},
+		{0x1bae, 0x1bb9, 1},
+		{0x1bc0, 0x1bf3, 1},
+		{0x1bfc, 0x1c37, 1},
+		{0x1c3b, 0x1c49, 1},
+		{0x1c4d, 0x1c7f, 1},
+		{0x1cd0, 0x1cf2, 1},
+		{0x1d00, 0x1de6, 1},
+		{0x1dfc, 0x1f15, 1},
+		{0x1f18, 0x1f1d, 1},
+		{0x1f20, 0x1f45, 1},
+		{0x1f48, 0x1f4d, 1},
+		{0x1f50, 0x1f57, 1},
+		{0x1f59, 0x1f5f, 2},
+		{0x1f60, 0x1f7d, 1},
+		{0x1f80, 0x1fb4, 1},
+		{0x1fb6, 0x1fc4, 1},
+		{0x1fc6, 0x1fd3, 1},
+		{0x1fd6, 0x1fdb, 1},
+		{0x1fdd, 0x1fef, 1},
+		{0x1ff2, 0x1ff4, 1},
+		{0x1ff6, 0x1ffe, 1},
+		{0x2000, 0x2064, 1},
+		{0x206a, 0x2071, 1},
+		{0x2074, 0x208e, 1},
+		{0x2090, 0x209c, 1},
+		{0x20a0, 0x20b9, 1},
+		{0x20d0, 0x20f0, 1},
+		{0x2100, 0x2189, 1},
+		{0x2190, 0x23f3, 1},
+		{0x2400, 0x2426, 1},
+		{0x2440, 0x244a, 1},
+		{0x2460, 0x26ff, 1},
+		{0x2701, 0x27ca, 1},
+		{0x27cc, 0x27ce, 2},
+		{0x27cf, 0x2b4c, 1},
+		{0x2b50, 0x2b59, 1},
+		{0x2c00, 0x2c2e, 1},
+		{0x2c30, 0x2c5e, 1},
+		{0x2c60, 0x2cf1, 1},
+		{0x2cf9, 0x2d25, 1},
+		{0x2d30, 0x2d65, 1},
+		{0x2d6f, 0x2d70, 1},
+		{0x2d7f, 0x2d96, 1},
+		{0x2da0, 0x2da6, 1},
+		{0x2da8, 0x2dae, 1},
+		{0x2db0, 0x2db6, 1},
+		{0x2db8, 0x2dbe, 1},
+		{0x2dc0, 0x2dc6, 1},
+		{0x2dc8, 0x2dce, 1},
+		{0x2dd0, 0x2dd6, 1},
+		{0x2dd8, 0x2dde, 1},
+		{0x2de0, 0x2e31, 1},
+		{0x2e80, 0x2e99, 1},
+		{0x2e9b, 0x2ef3, 1},
+		{0x2f00, 0x2fd5, 1},
+		{0x2ff0, 0x2ffb, 1},
+		{0x3000, 0x303f, 1},
+		{0x3041, 0x3096, 1},
+		{0x3099, 0x30ff, 1},
+		{0x3105, 0x312d, 1},
+		{0x3131, 0x318e, 1},
+		{0x3190, 0x31ba, 1},
+		{0x31c0, 0x31e3, 1},
+		{0x31f0, 0x321e, 1},
+		{0x3220, 0x32fe, 1},
+		{0x3300, 0x4db5, 1},
+		{0x4dc0, 0x9fcb, 1},
+		{0xa000, 0xa48c, 1},
+		{0xa490, 0xa4c6, 1},
+		{0xa4d0, 0xa62b, 1},
+		{0xa640, 0xa673, 1},
+		{0xa67c, 0xa697, 1},
+		{0xa6a0, 0xa6f7, 1},
+		{0xa700, 0xa78e, 1},
+		{0xa790, 0xa791, 1},
+		{0xa7a0, 0xa7a9, 1},
+		{0xa7fa, 0xa82b, 1},
+		{0xa830, 0xa839, 1},
+		{0xa840, 0xa877, 1},
+		{0xa880, 0xa8c4, 1},
+		{0xa8ce, 0xa8d9, 1},
+		{0xa8e0, 0xa8fb, 1},
+		{0xa900, 0xa953, 1},
+		{0xa95f, 0xa97c, 1},
+		{0xa980, 0xa9cd, 1},
+		{0xa9cf, 0xa9d9, 1},
+		{0xa9de, 0xa9df, 1},
+		{0xaa00, 0xaa36, 1},
+		{0xaa40, 0xaa4d, 1},
+		{0xaa50, 0xaa59, 1},
+		{0xaa5c, 0xaa7b, 1},
+		{0xaa80, 0xaac2, 1},
+		{0xaadb, 0xaadf, 1},
+		{0xab01, 0xab06, 1},
+		{0xab09, 0xab0e, 1},
+		{0xab11, 0xab16, 1},
+		{0xab20, 0xab26, 1},
+		{0xab28, 0xab2e, 1},
+		{0xabc0, 0xabed, 1},
+		{0xabf0, 0xabf9, 1},
+		{0xac00, 0xd7a3, 1},
+		{0xd7b0, 0xd7c6, 1},
+		{0xd7cb, 0xd7fb, 1},
+		{0xd800, 0xfa2d, 1},
+		{0xfa30, 0xfa6d, 1},
+		{0xfa70, 0xfad9, 1},
+		{0xfb00, 0xfb06, 1},
+		{0xfb13, 0xfb17, 1},
+		{0xfb1d, 0xfb36, 1},
+		{0xfb38, 0xfb3c, 1},
+		{0xfb3e, 0xfb40, 2},
+		{0xfb41, 0xfb43, 2},
+		{0xfb44, 0xfb46, 2},
+		{0xfb47, 0xfbc1, 1},
+		{0xfbd3, 0xfd3f, 1},
+		{0xfd50, 0xfd8f, 1},
+		{0xfd92, 0xfdc7, 1},
+		{0xfdf0, 0xfdfd, 1},
+		{0xfe00, 0xfe19, 1},
+		{0xfe20, 0xfe26, 1},
+		{0xfe30, 0xfe52, 1},
+		{0xfe54, 0xfe66, 1},
+		{0xfe68, 0xfe6b, 1},
+		{0xfe70, 0xfe74, 1},
+		{0xfe76, 0xfefc, 1},
+		{0xfeff, 0xff01, 2},
+		{0xff02, 0xffbe, 1},
+		{0xffc2, 0xffc7, 1},
+		{0xffca, 0xffcf, 1},
+		{0xffd2, 0xffd7, 1},
+		{0xffda, 0xffdc, 1},
+		{0xffe0, 0xffe6, 1},
+		{0xffe8, 0xffee, 1},
+		{0xfff9, 0xfffd, 1},
+	},
+	R32: []unicode.Range32{
+		{0x00010000, 0x0001000b, 1},
+		{0x0001000d, 0x00010026, 1},
+		{0x00010028, 0x0001003a, 1},
+		{0x0001003c, 0x0001003d, 1},
+		{0x0001003f, 0x0001004d, 1},
+		{0x00010050, 0x0001005d, 1},
+		{0x00010080, 0x000100fa, 1},
+		{0x00010100, 0x00010102, 1},
+		{0x00010107, 0x00010133, 1},
+		{0x00010137, 0x0001018a, 1},
+		{0x00010190, 0x0001019b, 1},
+		{0x000101d0, 0x000101fd, 1},
+		{0x00010280, 0x0001029c, 1},
+		{0x000102a0, 0x000102d0, 1},
+		{0x00010300, 0x0001031e, 1},
+		{0x00010320, 0x00010323, 1},
+		{0x00010330, 0x0001034a, 1},
+		{0x00010380, 0x0001039d, 1},
+		{0x0001039f, 0x000103c3, 1},
+		{0x000103c8, 0x000103d5, 1},
+		{0x00010400, 0x0001049d, 1},
+		{0x000104a0, 0x000104a9, 1},
+		{0x00010800, 0x00010805, 1},
+		{0x00010808, 0x0001080a, 2},
+		{0x0001080b, 0x00010835, 1},
+		{0x00010837, 0x00010838, 1},
+		{0x0001083c, 0x0001083f, 3},
+		{0x00010840, 0x00010855, 1},
+		{0x00010857, 0x0001085f, 1},
+		{0x00010900, 0x0001091b, 1},
+		{0x0001091f, 0x00010939, 1},
+		{0x0001093f, 0x00010a00, 193},
+		{0x00010a01, 0x00010a03, 1},
+		{0x00010a05, 0x00010a06, 1},
+		{0x00010a0c, 0x00010a13, 1},
+		{0x00010a15, 0x00010a17, 1},
+		{0x00010a19, 0x00010a33, 1},
+		{0x00010a38, 0x00010a3a, 1},
+		{0x00010a3f, 0x00010a47, 1},
+		{0x00010a50, 0x00010a58, 1},
+		{0x00010a60, 0x00010a7f, 1},
+		{0x00010b00, 0x00010b35, 1},
+		{0x00010b39, 0x00010b55, 1},
+		{0x00010b58, 0x00010b72, 1},
+		{0x00010b78, 0x00010b7f, 1},
+		{0x00010c00, 0x00010c48, 1},
+		{0x00010e60, 0x00010e7e, 1},
+		{0x00011000, 0x0001104d, 1},
+		{0x00011052, 0x0001106f, 1},
+		{0x00011080, 0x000110c1, 1},
+		{0x00012000, 0x0001236e, 1},
+		{0x00012400, 0x00012462, 1},
+		{0x00012470, 0x00012473, 1},
+		{0x00013000, 0x0001342e, 1},
+		{0x00016800, 0x00016a38, 1},
+		{0x0001b000, 0x0001b001, 1},
+		{0x0001d000, 0x0001d0f5, 1},
+		{0x0001d100, 0x0001d126, 1},
+		{0x0001d129, 0x0001d1dd, 1},
+		{0x0001d200, 0x0001d245, 1},
+		{0x0001d300, 0x0001d356, 1},
+		{0x0001d360, 0x0001d371, 1},
+		{0x0001d400, 0x0001d454, 1},
+		{0x0001d456, 0x0001d49c, 1},
+		{0x0001d49e, 0x0001d49f, 1},
+		{0x0001d4a2, 0x0001d4a5, 3},
+		{0x0001d4a6, 0x0001d4a9, 3},
+		{0x0001d4aa, 0x0001d4ac, 1},
+		{0x0001d4ae, 0x0001d4b9, 1},
+		{0x0001d4bb, 0x0001d4bd, 2},
+		{0x0001d4be, 0x0001d4c3, 1},
+		{0x0001d4c5, 0x0001d505, 1},
+		{0x0001d507, 0x0001d50a, 1},
+		{0x0001d50d, 0x0001d514, 1},
+		{0x0001d516, 0x0001d51c, 1},
+		{0x0001d51e, 0x0001d539, 1},
+		{0x0001d53b, 0x0001d53e, 1},
+		{0x0001d540, 0x0001d544, 1},
+		{0x0001d546, 0x0001d54a, 4},
+		{0x0001d54b, 0x0001d550, 1},
+		{0x0001d552, 0x0001d6a5, 1},
+		{0x0001d6a8, 0x0001d7cb, 1},
+		{0x0001d7ce, 0x0001d7ff, 1},
+		{0x0001f000, 0x0001f02b, 1},
+		{0x0001f030, 0x0001f093, 1},
+		{0x0001f0a0, 0x0001f0ae, 1},
+		{0x0001f0b1, 0x0001f0be, 1},
+		{0x0001f0c1, 0x0001f0cf, 1},
+		{0x0001f0d1, 0x0001f0df, 1},
+		{0x0001f100, 0x0001f10a, 1},
+		{0x0001f110, 0x0001f12e, 1},
+		{0x0001f130, 0x0001f169, 1},
+		{0x0001f170, 0x0001f19a, 1},
+		{0x0001f1e6, 0x0001f202, 1},
+		{0x0001f210, 0x0001f23a, 1},
+		{0x0001f240, 0x0001f248, 1},
+		{0x0001f250, 0x0001f251, 1},
+		{0x0001f300, 0x0001f320, 1},
+		{0x0001f330, 0x0001f335, 1},
+		{0x0001f337, 0x0001f37c, 1},
+		{0x0001f380, 0x0001f393, 1},
+		{0x0001f3a0, 0x0001f3c4, 1},
+		{0x0001f3c6, 0x0001f3ca, 1},
+		{0x0001f3e0, 0x0001f3f0, 1},
+		{0x0001f400, 0x0001f43e, 1},
+		{0x0001f440, 0x0001f442, 2},
+		{0x0001f443, 0x0001f4f7, 1},
+		{0x0001f4f9, 0x0001f4fc, 1},
+		{0x0001f500, 0x0001f53d, 1},
+		{0x0001f550, 0x0001f567, 1},
+		{0x0001f5fb, 0x0001f5ff, 1},
+		{0x0001f601, 0x0001f610, 1},
+		{0x0001f612, 0x0001f614, 1},
+		{0x0001f616, 0x0001f61c, 2},
+		{0x0001f61d, 0x0001f61e, 1},
+		{0x0001f620, 0x0001f625, 1},
+		{0x0001f628, 0x0001f62b, 1},
+		{0x0001f62d, 0x0001f630, 3},
+		{0x0001f631, 0x0001f633, 1},
+		{0x0001f635, 0x0001f640, 1},
+		{0x0001f645, 0x0001f64f, 1},
+		{0x0001f680, 0x0001f6c5, 1},
+		{0x0001f700, 0x0001f773, 1},
+		{0x00020000, 0x0002a6d6, 1},
+		{0x0002a700, 0x0002b734, 1},
+		{0x0002b740, 0x0002b81d, 1},
+		{0x0002f800, 0x0002fa1d, 1},
+		{0x000e0001, 0x000e0020, 31},
+		{0x000e0021, 0x000e007f, 1},
+		{0x000e0100, 0x000e01ef, 1},
+		{0x000f0000, 0x000ffffd, 1},
+		{0x00100000, 0x0010fffd, 1},
+	},
+	LatinOffset: 0,
+}
+
+// size 4160 bytes (4 KiB)
+var assigned6_1_0 = &unicode.RangeTable{
+	R16: []unicode.Range16{
+		{0x0000, 0x0377, 1},
+		{0x037a, 0x037e, 1},
+		{0x0384, 0x038a, 1},
+		{0x038c, 0x038e, 2},
+		{0x038f, 0x03a1, 1},
+		{0x03a3, 0x0527, 1},
+		{0x0531, 0x0556, 1},
+		{0x0559, 0x055f, 1},
+		{0x0561, 0x0587, 1},
+		{0x0589, 0x058a, 1},
+		{0x058f, 0x0591, 2},
+		{0x0592, 0x05c7, 1},
+		{0x05d0, 0x05ea, 1},
+		{0x05f0, 0x05f4, 1},
+		{0x0600, 0x0604, 1},
+		{0x0606, 0x061b, 1},
+		{0x061e, 0x070d, 1},
+		{0x070f, 0x074a, 1},
+		{0x074d, 0x07b1, 1},
+		{0x07c0, 0x07fa, 1},
+		{0x0800, 0x082d, 1},
+		{0x0830, 0x083e, 1},
+		{0x0840, 0x085b, 1},
+		{0x085e, 0x08a0, 66},
+		{0x08a2, 0x08ac, 1},
+		{0x08e4, 0x08fe, 1},
+		{0x0900, 0x0977, 1},
+		{0x0979, 0x097f, 1},
+		{0x0981, 0x0983, 1},
+		{0x0985, 0x098c, 1},
+		{0x098f, 0x0990, 1},
+		{0x0993, 0x09a8, 1},
+		{0x09aa, 0x09b0, 1},
+		{0x09b2, 0x09b6, 4},
+		{0x09b7, 0x09b9, 1},
+		{0x09bc, 0x09c4, 1},
+		{0x09c7, 0x09c8, 1},
+		{0x09cb, 0x09ce, 1},
+		{0x09d7, 0x09dc, 5},
+		{0x09dd, 0x09df, 2},
+		{0x09e0, 0x09e3, 1},
+		{0x09e6, 0x09fb, 1},
+		{0x0a01, 0x0a03, 1},
+		{0x0a05, 0x0a0a, 1},
+		{0x0a0f, 0x0a10, 1},
+		{0x0a13, 0x0a28, 1},
+		{0x0a2a, 0x0a30, 1},
+		{0x0a32, 0x0a33, 1},
+		{0x0a35, 0x0a36, 1},
+		{0x0a38, 0x0a39, 1},
+		{0x0a3c, 0x0a3e, 2},
+		{0x0a3f, 0x0a42, 1},
+		{0x0a47, 0x0a48, 1},
+		{0x0a4b, 0x0a4d, 1},
+		{0x0a51, 0x0a59, 8},
+		{0x0a5a, 0x0a5c, 1},
+		{0x0a5e, 0x0a66, 8},
+		{0x0a67, 0x0a75, 1},
+		{0x0a81, 0x0a83, 1},
+		{0x0a85, 0x0a8d, 1},
+		{0x0a8f, 0x0a91, 1},
+		{0x0a93, 0x0aa8, 1},
+		{0x0aaa, 0x0ab0, 1},
+		{0x0ab2, 0x0ab3, 1},
+		{0x0ab5, 0x0ab9, 1},
+		{0x0abc, 0x0ac5, 1},
+		{0x0ac7, 0x0ac9, 1},
+		{0x0acb, 0x0acd, 1},
+		{0x0ad0, 0x0ae0, 16},
+		{0x0ae1, 0x0ae3, 1},
+		{0x0ae6, 0x0af1, 1},
+		{0x0b01, 0x0b03, 1},
+		{0x0b05, 0x0b0c, 1},
+		{0x0b0f, 0x0b10, 1},
+		{0x0b13, 0x0b28, 1},
+		{0x0b2a, 0x0b30, 1},
+		{0x0b32, 0x0b33, 1},
+		{0x0b35, 0x0b39, 1},
+		{0x0b3c, 0x0b44, 1},
+		{0x0b47, 0x0b48, 1},
+		{0x0b4b, 0x0b4d, 1},
+		{0x0b56, 0x0b57, 1},
+		{0x0b5c, 0x0b5d, 1},
+		{0x0b5f, 0x0b63, 1},
+		{0x0b66, 0x0b77, 1},
+		{0x0b82, 0x0b83, 1},
+		{0x0b85, 0x0b8a, 1},
+		{0x0b8e, 0x0b90, 1},
+		{0x0b92, 0x0b95, 1},
+		{0x0b99, 0x0b9a, 1},
+		{0x0b9c, 0x0b9e, 2},
+		{0x0b9f, 0x0ba3, 4},
+		{0x0ba4, 0x0ba8, 4},
+		{0x0ba9, 0x0baa, 1},
+		{0x0bae, 0x0bb9, 1},
+		{0x0bbe, 0x0bc2, 1},
+		{0x0bc6, 0x0bc8, 1},
+		{0x0bca, 0x0bcd, 1},
+		{0x0bd0, 0x0bd7, 7},
+		{0x0be6, 0x0bfa, 1},
+		{0x0c01, 0x0c03, 1},
+		{0x0c05, 0x0c0c, 1},
+		{0x0c0e, 0x0c10, 1},
+		{0x0c12, 0x0c28, 1},
+		{0x0c2a, 0x0c33, 1},
+		{0x0c35, 0x0c39, 1},
+		{0x0c3d, 0x0c44, 1},
+		{0x0c46, 0x0c48, 1},
+		{0x0c4a, 0x0c4d, 1},
+		{0x0c55, 0x0c56, 1},
+		{0x0c58, 0x0c59, 1},
+		{0x0c60, 0x0c63, 1},
+		{0x0c66, 0x0c6f, 1},
+		{0x0c78, 0x0c7f, 1},
+		{0x0c82, 0x0c83, 1},
+		{0x0c85, 0x0c8c, 1},
+		{0x0c8e, 0x0c90, 1},
+		{0x0c92, 0x0ca8, 1},
+		{0x0caa, 0x0cb3, 1},
+		{0x0cb5, 0x0cb9, 1},
+		{0x0cbc, 0x0cc4, 1},
+		{0x0cc6, 0x0cc8, 1},
+		{0x0cca, 0x0ccd, 1},
+		{0x0cd5, 0x0cd6, 1},
+		{0x0cde, 0x0ce0, 2},
+		{0x0ce1, 0x0ce3, 1},
+		{0x0ce6, 0x0cef, 1},
+		{0x0cf1, 0x0cf2, 1},
+		{0x0d02, 0x0d03, 1},
+		{0x0d05, 0x0d0c, 1},
+		{0x0d0e, 0x0d10, 1},
+		{0x0d12, 0x0d3a, 1},
+		{0x0d3d, 0x0d44, 1},
+		{0x0d46, 0x0d48, 1},
+		{0x0d4a, 0x0d4e, 1},
+		{0x0d57, 0x0d60, 9},
+		{0x0d61, 0x0d63, 1},
+		{0x0d66, 0x0d75, 1},
+		{0x0d79, 0x0d7f, 1},
+		{0x0d82, 0x0d83, 1},
+		{0x0d85, 0x0d96, 1},
+		{0x0d9a, 0x0db1, 1},
+		{0x0db3, 0x0dbb, 1},
+		{0x0dbd, 0x0dc0, 3},
+		{0x0dc1, 0x0dc6, 1},
+		{0x0dca, 0x0dcf, 5},
+		{0x0dd0, 0x0dd4, 1},
+		{0x0dd6, 0x0dd8, 2},
+		{0x0dd9, 0x0ddf, 1},
+		{0x0df2, 0x0df4, 1},
+		{0x0e01, 0x0e3a, 1},
+		{0x0e3f, 0x0e5b, 1},
+		{0x0e81, 0x0e82, 1},
+		{0x0e84, 0x0e87, 3},
+		{0x0e88, 0x0e8a, 2},
+		{0x0e8d, 0x0e94, 7},
+		{0x0e95, 0x0e97, 1},
+		{0x0e99, 0x0e9f, 1},
+		{0x0ea1, 0x0ea3, 1},
+		{0x0ea5, 0x0ea7, 2},
+		{0x0eaa, 0x0eab, 1},
+		{0x0ead, 0x0eb9, 1},
+		{0x0ebb, 0x0ebd, 1},
+		{0x0ec0, 0x0ec4, 1},
+		{0x0ec6, 0x0ec8, 2},
+		{0x0ec9, 0x0ecd, 1},
+		{0x0ed0, 0x0ed9, 1},
+		{0x0edc, 0x0edf, 1},
+		{0x0f00, 0x0f47, 1},
+		{0x0f49, 0x0f6c, 1},
+		{0x0f71, 0x0f97, 1},
+		{0x0f99, 0x0fbc, 1},
+		{0x0fbe, 0x0fcc, 1},
+		{0x0fce, 0x0fda, 1},
+		{0x1000, 0x10c5, 1},
+		{0x10c7, 0x10cd, 6},
+		{0x10d0, 0x1248, 1},
+		{0x124a, 0x124d, 1},
+		{0x1250, 0x1256, 1},
+		{0x1258, 0x125a, 2},
+		{0x125b, 0x125d, 1},
+		{0x1260, 0x1288, 1},
+		{0x128a, 0x128d, 1},
+		{0x1290, 0x12b0, 1},
+		{0x12b2, 0x12b5, 1},
+		{0x12b8, 0x12be, 1},
+		{0x12c0, 0x12c2, 2},
+		{0x12c3, 0x12c5, 1},
+		{0x12c8, 0x12d6, 1},
+		{0x12d8, 0x1310, 1},
+		{0x1312, 0x1315, 1},
+		{0x1318, 0x135a, 1},
+		{0x135d, 0x137c, 1},
+		{0x1380, 0x1399, 1},
+		{0x13a0, 0x13f4, 1},
+		{0x1400, 0x169c, 1},
+		{0x16a0, 0x16f0, 1},
+		{0x1700, 0x170c, 1},
+		{0x170e, 0x1714, 1},
+		{0x1720, 0x1736, 1},
+		{0x1740, 0x1753, 1},
+		{0x1760, 0x176c, 1},
+		{0x176e, 0x1770, 1},
+		{0x1772, 0x1773, 1},
+		{0x1780, 0x17dd, 1},
+		{0x17e0, 0x17e9, 1},
+		{0x17f0, 0x17f9, 1},
+		{0x1800, 0x180e, 1},
+		{0x1810, 0x1819, 1},
+		{0x1820, 0x1877, 1},
+		{0x1880, 0x18aa, 1},
+		{0x18b0, 0x18f5, 1},
+		{0x1900, 0x191c, 1},
+		{0x1920, 0x192b, 1},
+		{0x1930, 0x193b, 1},
+		{0x1940, 0x1944, 4},
+		{0x1945, 0x196d, 1},
+		{0x1970, 0x1974, 1},
+		{0x1980, 0x19ab, 1},
+		{0x19b0, 0x19c9, 1},
+		{0x19d0, 0x19da, 1},
+		{0x19de, 0x1a1b, 1},
+		{0x1a1e, 0x1a5e, 1},
+		{0x1a60, 0x1a7c, 1},
+		{0x1a7f, 0x1a89, 1},
+		{0x1a90, 0x1a99, 1},
+		{0x1aa0, 0x1aad, 1},
+		{0x1b00, 0x1b4b, 1},
+		{0x1b50, 0x1b7c, 1},
+		{0x1b80, 0x1bf3, 1},
+		{0x1bfc, 0x1c37, 1},
+		{0x1c3b, 0x1c49, 1},
+		{0x1c4d, 0x1c7f, 1},
+		{0x1cc0, 0x1cc7, 1},
+		{0x1cd0, 0x1cf6, 1},
+		{0x1d00, 0x1de6, 1},
+		{0x1dfc, 0x1f15, 1},
+		{0x1f18, 0x1f1d, 1},
+		{0x1f20, 0x1f45, 1},
+		{0x1f48, 0x1f4d, 1},
+		{0x1f50, 0x1f57, 1},
+		{0x1f59, 0x1f5f, 2},
+		{0x1f60, 0x1f7d, 1},
+		{0x1f80, 0x1fb4, 1},
+		{0x1fb6, 0x1fc4, 1},
+		{0x1fc6, 0x1fd3, 1},
+		{0x1fd6, 0x1fdb, 1},
+		{0x1fdd, 0x1fef, 1},
+		{0x1ff2, 0x1ff4, 1},
+		{0x1ff6, 0x1ffe, 1},
+		{0x2000, 0x2064, 1},
+		{0x206a, 0x2071, 1},
+		{0x2074, 0x208e, 1},
+		{0x2090, 0x209c, 1},
+		{0x20a0, 0x20b9, 1},
+		{0x20d0, 0x20f0, 1},
+		{0x2100, 0x2189, 1},
+		{0x2190, 0x23f3, 1},
+		{0x2400, 0x2426, 1},
+		{0x2440, 0x244a, 1},
+		{0x2460, 0x26ff, 1},
+		{0x2701, 0x2b4c, 1},
+		{0x2b50, 0x2b59, 1},
+		{0x2c00, 0x2c2e, 1},
+		{0x2c30, 0x2c5e, 1},
+		{0x2c60, 0x2cf3, 1},
+		{0x2cf9, 0x2d25, 1},
+		{0x2d27, 0x2d2d, 6},
+		{0x2d30, 0x2d67, 1},
+		{0x2d6f, 0x2d70, 1},
+		{0x2d7f, 0x2d96, 1},
+		{0x2da0, 0x2da6, 1},
+		{0x2da8, 0x2dae, 1},
+		{0x2db0, 0x2db6, 1},
+		{0x2db8, 0x2dbe, 1},
+		{0x2dc0, 0x2dc6, 1},
+		{0x2dc8, 0x2dce, 1},
+		{0x2dd0, 0x2dd6, 1},
+		{0x2dd8, 0x2dde, 1},
+		{0x2de0, 0x2e3b, 1},
+		{0x2e80, 0x2e99, 1},
+		{0x2e9b, 0x2ef3, 1},
+		{0x2f00, 0x2fd5, 1},
+		{0x2ff0, 0x2ffb, 1},
+		{0x3000, 0x303f, 1},
+		{0x3041, 0x3096, 1},
+		{0x3099, 0x30ff, 1},
+		{0x3105, 0x312d, 1},
+		{0x3131, 0x318e, 1},
+		{0x3190, 0x31ba, 1},
+		{0x31c0, 0x31e3, 1},
+		{0x31f0, 0x321e, 1},
+		{0x3220, 0x32fe, 1},
+		{0x3300, 0x4db5, 1},
+		{0x4dc0, 0x9fcc, 1},
+		{0xa000, 0xa48c, 1},
+		{0xa490, 0xa4c6, 1},
+		{0xa4d0, 0xa62b, 1},
+		{0xa640, 0xa697, 1},
+		{0xa69f, 0xa6f7, 1},
+		{0xa700, 0xa78e, 1},
+		{0xa790, 0xa793, 1},
+		{0xa7a0, 0xa7aa, 1},
+		{0xa7f8, 0xa82b, 1},
+		{0xa830, 0xa839, 1},
+		{0xa840, 0xa877, 1},
+		{0xa880, 0xa8c4, 1},
+		{0xa8ce, 0xa8d9, 1},
+		{0xa8e0, 0xa8fb, 1},
+		{0xa900, 0xa953, 1},
+		{0xa95f, 0xa97c, 1},
+		{0xa980, 0xa9cd, 1},
+		{0xa9cf, 0xa9d9, 1},
+		{0xa9de, 0xa9df, 1},
+		{0xaa00, 0xaa36, 1},
+		{0xaa40, 0xaa4d, 1},
+		{0xaa50, 0xaa59, 1},
+		{0xaa5c, 0xaa7b, 1},
+		{0xaa80, 0xaac2, 1},
+		{0xaadb, 0xaaf6, 1},
+		{0xab01, 0xab06, 1},
+		{0xab09, 0xab0e, 1},
+		{0xab11, 0xab16, 1},
+		{0xab20, 0xab26, 1},
+		{0xab28, 0xab2e, 1},
+		{0xabc0, 0xabed, 1},
+		{0xabf0, 0xabf9, 1},
+		{0xac00, 0xd7a3, 1},
+		{0xd7b0, 0xd7c6, 1},
+		{0xd7cb, 0xd7fb, 1},
+		{0xd800, 0xfa6d, 1},
+		{0xfa70, 0xfad9, 1},
+		{0xfb00, 0xfb06, 1},
+		{0xfb13, 0xfb17, 1},
+		{0xfb1d, 0xfb36, 1},
+		{0xfb38, 0xfb3c, 1},
+		{0xfb3e, 0xfb40, 2},
+		{0xfb41, 0xfb43, 2},
+		{0xfb44, 0xfb46, 2},
+		{0xfb47, 0xfbc1, 1},
+		{0xfbd3, 0xfd3f, 1},
+		{0xfd50, 0xfd8f, 1},
+		{0xfd92, 0xfdc7, 1},
+		{0xfdf0, 0xfdfd, 1},
+		{0xfe00, 0xfe19, 1},
+		{0xfe20, 0xfe26, 1},
+		{0xfe30, 0xfe52, 1},
+		{0xfe54, 0xfe66, 1},
+		{0xfe68, 0xfe6b, 1},
+		{0xfe70, 0xfe74, 1},
+		{0xfe76, 0xfefc, 1},
+		{0xfeff, 0xff01, 2},
+		{0xff02, 0xffbe, 1},
+		{0xffc2, 0xffc7, 1},
+		{0xffca, 0xffcf, 1},
+		{0xffd2, 0xffd7, 1},
+		{0xffda, 0xffdc, 1},
+		{0xffe0, 0xffe6, 1},
+		{0xffe8, 0xffee, 1},
+		{0xfff9, 0xfffd, 1},
+	},
+	R32: []unicode.Range32{
+		{0x00010000, 0x0001000b, 1},
+		{0x0001000d, 0x00010026, 1},
+		{0x00010028, 0x0001003a, 1},
+		{0x0001003c, 0x0001003d, 1},
+		{0x0001003f, 0x0001004d, 1},
+		{0x00010050, 0x0001005d, 1},
+		{0x00010080, 0x000100fa, 1},
+		{0x00010100, 0x00010102, 1},
+		{0x00010107, 0x00010133, 1},
+		{0x00010137, 0x0001018a, 1},
+		{0x00010190, 0x0001019b, 1},
+		{0x000101d0, 0x000101fd, 1},
+		{0x00010280, 0x0001029c, 1},
+		{0x000102a0, 0x000102d0, 1},
+		{0x00010300, 0x0001031e, 1},
+		{0x00010320, 0x00010323, 1},
+		{0x00010330, 0x0001034a, 1},
+		{0x00010380, 0x0001039d, 1},
+		{0x0001039f, 0x000103c3, 1},
+		{0x000103c8, 0x000103d5, 1},
+		{0x00010400, 0x0001049d, 1},
+		{0x000104a0, 0x000104a9, 1},
+		{0x00010800, 0x00010805, 1},
+		{0x00010808, 0x0001080a, 2},
+		{0x0001080b, 0x00010835, 1},
+		{0x00010837, 0x00010838, 1},
+		{0x0001083c, 0x0001083f, 3},
+		{0x00010840, 0x00010855, 1},
+		{0x00010857, 0x0001085f, 1},
+		{0x00010900, 0x0001091b, 1},
+		{0x0001091f, 0x00010939, 1},
+		{0x0001093f, 0x00010980, 65},
+		{0x00010981, 0x000109b7, 1},
+		{0x000109be, 0x000109bf, 1},
+		{0x00010a00, 0x00010a03, 1},
+		{0x00010a05, 0x00010a06, 1},
+		{0x00010a0c, 0x00010a13, 1},
+		{0x00010a15, 0x00010a17, 1},
+		{0x00010a19, 0x00010a33, 1},
+		{0x00010a38, 0x00010a3a, 1},
+		{0x00010a3f, 0x00010a47, 1},
+		{0x00010a50, 0x00010a58, 1},
+		{0x00010a60, 0x00010a7f, 1},
+		{0x00010b00, 0x00010b35, 1},
+		{0x00010b39, 0x00010b55, 1},
+		{0x00010b58, 0x00010b72, 1},
+		{0x00010b78, 0x00010b7f, 1},
+		{0x00010c00, 0x00010c48, 1},
+		{0x00010e60, 0x00010e7e, 1},
+		{0x00011000, 0x0001104d, 1},
+		{0x00011052, 0x0001106f, 1},
+		{0x00011080, 0x000110c1, 1},
+		{0x000110d0, 0x000110e8, 1},
+		{0x000110f0, 0x000110f9, 1},
+		{0x00011100, 0x00011134, 1},
+		{0x00011136, 0x00011143, 1},
+		{0x00011180, 0x000111c8, 1},
+		{0x000111d0, 0x000111d9, 1},
+		{0x00011680, 0x000116b7, 1},
+		{0x000116c0, 0x000116c9, 1},
+		{0x00012000, 0x0001236e, 1},
+		{0x00012400, 0x00012462, 1},
+		{0x00012470, 0x00012473, 1},
+		{0x00013000, 0x0001342e, 1},
+		{0x00016800, 0x00016a38, 1},
+		{0x00016f00, 0x00016f44, 1},
+		{0x00016f50, 0x00016f7e, 1},
+		{0x00016f8f, 0x00016f9f, 1},
+		{0x0001b000, 0x0001b001, 1},
+		{0x0001d000, 0x0001d0f5, 1},
+		{0x0001d100, 0x0001d126, 1},
+		{0x0001d129, 0x0001d1dd, 1},
+		{0x0001d200, 0x0001d245, 1},
+		{0x0001d300, 0x0001d356, 1},
+		{0x0001d360, 0x0001d371, 1},
+		{0x0001d400, 0x0001d454, 1},
+		{0x0001d456, 0x0001d49c, 1},
+		{0x0001d49e, 0x0001d49f, 1},
+		{0x0001d4a2, 0x0001d4a5, 3},
+		{0x0001d4a6, 0x0001d4a9, 3},
+		{0x0001d4aa, 0x0001d4ac, 1},
+		{0x0001d4ae, 0x0001d4b9, 1},
+		{0x0001d4bb, 0x0001d4bd, 2},
+		{0x0001d4be, 0x0001d4c3, 1},
+		{0x0001d4c5, 0x0001d505, 1},
+		{0x0001d507, 0x0001d50a, 1},
+		{0x0001d50d, 0x0001d514, 1},
+		{0x0001d516, 0x0001d51c, 1},
+		{0x0001d51e, 0x0001d539, 1},
+		{0x0001d53b, 0x0001d53e, 1},
+		{0x0001d540, 0x0001d544, 1},
+		{0x0001d546, 0x0001d54a, 4},
+		{0x0001d54b, 0x0001d550, 1},
+		{0x0001d552, 0x0001d6a5, 1},
+		{0x0001d6a8, 0x0001d7cb, 1},
+		{0x0001d7ce, 0x0001d7ff, 1},
+		{0x0001ee00, 0x0001ee03, 1},
+		{0x0001ee05, 0x0001ee1f, 1},
+		{0x0001ee21, 0x0001ee22, 1},
+		{0x0001ee24, 0x0001ee27, 3},
+		{0x0001ee29, 0x0001ee32, 1},
+		{0x0001ee34, 0x0001ee37, 1},
+		{0x0001ee39, 0x0001ee3b, 2},
+		{0x0001ee42, 0x0001ee47, 5},
+		{0x0001ee49, 0x0001ee4d, 2},
+		{0x0001ee4e, 0x0001ee4f, 1},
+		{0x0001ee51, 0x0001ee52, 1},
+		{0x0001ee54, 0x0001ee57, 3},
+		{0x0001ee59, 0x0001ee61, 2},
+		{0x0001ee62, 0x0001ee64, 2},
+		{0x0001ee67, 0x0001ee6a, 1},
+		{0x0001ee6c, 0x0001ee72, 1},
+		{0x0001ee74, 0x0001ee77, 1},
+		{0x0001ee79, 0x0001ee7c, 1},
+		{0x0001ee7e, 0x0001ee80, 2},
+		{0x0001ee81, 0x0001ee89, 1},
+		{0x0001ee8b, 0x0001ee9b, 1},
+		{0x0001eea1, 0x0001eea3, 1},
+		{0x0001eea5, 0x0001eea9, 1},
+		{0x0001eeab, 0x0001eebb, 1},
+		{0x0001eef0, 0x0001eef1, 1},
+		{0x0001f000, 0x0001f02b, 1},
+		{0x0001f030, 0x0001f093, 1},
+		{0x0001f0a0, 0x0001f0ae, 1},
+		{0x0001f0b1, 0x0001f0be, 1},
+		{0x0001f0c1, 0x0001f0cf, 1},
+		{0x0001f0d1, 0x0001f0df, 1},
+		{0x0001f100, 0x0001f10a, 1},
+		{0x0001f110, 0x0001f12e, 1},
+		{0x0001f130, 0x0001f16b, 1},
+		{0x0001f170, 0x0001f19a, 1},
+		{0x0001f1e6, 0x0001f202, 1},
+		{0x0001f210, 0x0001f23a, 1},
+		{0x0001f240, 0x0001f248, 1},
+		{0x0001f250, 0x0001f251, 1},
+		{0x0001f300, 0x0001f320, 1},
+		{0x0001f330, 0x0001f335, 1},
+		{0x0001f337, 0x0001f37c, 1},
+		{0x0001f380, 0x0001f393, 1},
+		{0x0001f3a0, 0x0001f3c4, 1},
+		{0x0001f3c6, 0x0001f3ca, 1},
+		{0x0001f3e0, 0x0001f3f0, 1},
+		{0x0001f400, 0x0001f43e, 1},
+		{0x0001f440, 0x0001f442, 2},
+		{0x0001f443, 0x0001f4f7, 1},
+		{0x0001f4f9, 0x0001f4fc, 1},
+		{0x0001f500, 0x0001f53d, 1},
+		{0x0001f540, 0x0001f543, 1},
+		{0x0001f550, 0x0001f567, 1},
+		{0x0001f5fb, 0x0001f640, 1},
+		{0x0001f645, 0x0001f64f, 1},
+		{0x0001f680, 0x0001f6c5, 1},
+		{0x0001f700, 0x0001f773, 1},
+		{0x00020000, 0x0002a6d6, 1},
+		{0x0002a700, 0x0002b734, 1},
+		{0x0002b740, 0x0002b81d, 1},
+		{0x0002f800, 0x0002fa1d, 1},
+		{0x000e0001, 0x000e0020, 31},
+		{0x000e0021, 0x000e007f, 1},
+		{0x000e0100, 0x000e01ef, 1},
+		{0x000f0000, 0x000ffffd, 1},
+		{0x00100000, 0x0010fffd, 1},
+	},
+	LatinOffset: 0,
+}
+
+// size 4160 bytes (4 KiB)
+var assigned6_2_0 = &unicode.RangeTable{
+	R16: []unicode.Range16{
+		{0x0000, 0x0377, 1},
+		{0x037a, 0x037e, 1},
+		{0x0384, 0x038a, 1},
+		{0x038c, 0x038e, 2},
+		{0x038f, 0x03a1, 1},
+		{0x03a3, 0x0527, 1},
+		{0x0531, 0x0556, 1},
+		{0x0559, 0x055f, 1},
+		{0x0561, 0x0587, 1},
+		{0x0589, 0x058a, 1},
+		{0x058f, 0x0591, 2},
+		{0x0592, 0x05c7, 1},
+		{0x05d0, 0x05ea, 1},
+		{0x05f0, 0x05f4, 1},
+		{0x0600, 0x0604, 1},
+		{0x0606, 0x061b, 1},
+		{0x061e, 0x070d, 1},
+		{0x070f, 0x074a, 1},
+		{0x074d, 0x07b1, 1},
+		{0x07c0, 0x07fa, 1},
+		{0x0800, 0x082d, 1},
+		{0x0830, 0x083e, 1},
+		{0x0840, 0x085b, 1},
+		{0x085e, 0x08a0, 66},
+		{0x08a2, 0x08ac, 1},
+		{0x08e4, 0x08fe, 1},
+		{0x0900, 0x0977, 1},
+		{0x0979, 0x097f, 1},
+		{0x0981, 0x0983, 1},
+		{0x0985, 0x098c, 1},
+		{0x098f, 0x0990, 1},
+		{0x0993, 0x09a8, 1},
+		{0x09aa, 0x09b0, 1},
+		{0x09b2, 0x09b6, 4},
+		{0x09b7, 0x09b9, 1},
+		{0x09bc, 0x09c4, 1},
+		{0x09c7, 0x09c8, 1},
+		{0x09cb, 0x09ce, 1},
+		{0x09d7, 0x09dc, 5},
+		{0x09dd, 0x09df, 2},
+		{0x09e0, 0x09e3, 1},
+		{0x09e6, 0x09fb, 1},
+		{0x0a01, 0x0a03, 1},
+		{0x0a05, 0x0a0a, 1},
+		{0x0a0f, 0x0a10, 1},
+		{0x0a13, 0x0a28, 1},
+		{0x0a2a, 0x0a30, 1},
+		{0x0a32, 0x0a33, 1},
+		{0x0a35, 0x0a36, 1},
+		{0x0a38, 0x0a39, 1},
+		{0x0a3c, 0x0a3e, 2},
+		{0x0a3f, 0x0a42, 1},
+		{0x0a47, 0x0a48, 1},
+		{0x0a4b, 0x0a4d, 1},
+		{0x0a51, 0x0a59, 8},
+		{0x0a5a, 0x0a5c, 1},
+		{0x0a5e, 0x0a66, 8},
+		{0x0a67, 0x0a75, 1},
+		{0x0a81, 0x0a83, 1},
+		{0x0a85, 0x0a8d, 1},
+		{0x0a8f, 0x0a91, 1},
+		{0x0a93, 0x0aa8, 1},
+		{0x0aaa, 0x0ab0, 1},
+		{0x0ab2, 0x0ab3, 1},
+		{0x0ab5, 0x0ab9, 1},
+		{0x0abc, 0x0ac5, 1},
+		{0x0ac7, 0x0ac9, 1},
+		{0x0acb, 0x0acd, 1},
+		{0x0ad0, 0x0ae0, 16},
+		{0x0ae1, 0x0ae3, 1},
+		{0x0ae6, 0x0af1, 1},
+		{0x0b01, 0x0b03, 1},
+		{0x0b05, 0x0b0c, 1},
+		{0x0b0f, 0x0b10, 1},
+		{0x0b13, 0x0b28, 1},
+		{0x0b2a, 0x0b30, 1},
+		{0x0b32, 0x0b33, 1},
+		{0x0b35, 0x0b39, 1},
+		{0x0b3c, 0x0b44, 1},
+		{0x0b47, 0x0b48, 1},
+		{0x0b4b, 0x0b4d, 1},
+		{0x0b56, 0x0b57, 1},
+		{0x0b5c, 0x0b5d, 1},
+		{0x0b5f, 0x0b63, 1},
+		{0x0b66, 0x0b77, 1},
+		{0x0b82, 0x0b83, 1},
+		{0x0b85, 0x0b8a, 1},
+		{0x0b8e, 0x0b90, 1},
+		{0x0b92, 0x0b95, 1},
+		{0x0b99, 0x0b9a, 1},
+		{0x0b9c, 0x0b9e, 2},
+		{0x0b9f, 0x0ba3, 4},
+		{0x0ba4, 0x0ba8, 4},
+		{0x0ba9, 0x0baa, 1},
+		{0x0bae, 0x0bb9, 1},
+		{0x0bbe, 0x0bc2, 1},
+		{0x0bc6, 0x0bc8, 1},
+		{0x0bca, 0x0bcd, 1},
+		{0x0bd0, 0x0bd7, 7},
+		{0x0be6, 0x0bfa, 1},
+		{0x0c01, 0x0c03, 1},
+		{0x0c05, 0x0c0c, 1},
+		{0x0c0e, 0x0c10, 1},
+		{0x0c12, 0x0c28, 1},
+		{0x0c2a, 0x0c33, 1},
+		{0x0c35, 0x0c39, 1},
+		{0x0c3d, 0x0c44, 1},
+		{0x0c46, 0x0c48, 1},
+		{0x0c4a, 0x0c4d, 1},
+		{0x0c55, 0x0c56, 1},
+		{0x0c58, 0x0c59, 1},
+		{0x0c60, 0x0c63, 1},
+		{0x0c66, 0x0c6f, 1},
+		{0x0c78, 0x0c7f, 1},
+		{0x0c82, 0x0c83, 1},
+		{0x0c85, 0x0c8c, 1},
+		{0x0c8e, 0x0c90, 1},
+		{0x0c92, 0x0ca8, 1},
+		{0x0caa, 0x0cb3, 1},
+		{0x0cb5, 0x0cb9, 1},
+		{0x0cbc, 0x0cc4, 1},
+		{0x0cc6, 0x0cc8, 1},
+		{0x0cca, 0x0ccd, 1},
+		{0x0cd5, 0x0cd6, 1},
+		{0x0cde, 0x0ce0, 2},
+		{0x0ce1, 0x0ce3, 1},
+		{0x0ce6, 0x0cef, 1},
+		{0x0cf1, 0x0cf2, 1},
+		{0x0d02, 0x0d03, 1},
+		{0x0d05, 0x0d0c, 1},
+		{0x0d0e, 0x0d10, 1},
+		{0x0d12, 0x0d3a, 1},
+		{0x0d3d, 0x0d44, 1},
+		{0x0d46, 0x0d48, 1},
+		{0x0d4a, 0x0d4e, 1},
+		{0x0d57, 0x0d60, 9},
+		{0x0d61, 0x0d63, 1},
+		{0x0d66, 0x0d75, 1},
+		{0x0d79, 0x0d7f, 1},
+		{0x0d82, 0x0d83, 1},
+		{0x0d85, 0x0d96, 1},
+		{0x0d9a, 0x0db1, 1},
+		{0x0db3, 0x0dbb, 1},
+		{0x0dbd, 0x0dc0, 3},
+		{0x0dc1, 0x0dc6, 1},
+		{0x0dca, 0x0dcf, 5},
+		{0x0dd0, 0x0dd4, 1},
+		{0x0dd6, 0x0dd8, 2},
+		{0x0dd9, 0x0ddf, 1},
+		{0x0df2, 0x0df4, 1},
+		{0x0e01, 0x0e3a, 1},
+		{0x0e3f, 0x0e5b, 1},
+		{0x0e81, 0x0e82, 1},
+		{0x0e84, 0x0e87, 3},
+		{0x0e88, 0x0e8a, 2},
+		{0x0e8d, 0x0e94, 7},
+		{0x0e95, 0x0e97, 1},
+		{0x0e99, 0x0e9f, 1},
+		{0x0ea1, 0x0ea3, 1},
+		{0x0ea5, 0x0ea7, 2},
+		{0x0eaa, 0x0eab, 1},
+		{0x0ead, 0x0eb9, 1},
+		{0x0ebb, 0x0ebd, 1},
+		{0x0ec0, 0x0ec4, 1},
+		{0x0ec6, 0x0ec8, 2},
+		{0x0ec9, 0x0ecd, 1},
+		{0x0ed0, 0x0ed9, 1},
+		{0x0edc, 0x0edf, 1},
+		{0x0f00, 0x0f47, 1},
+		{0x0f49, 0x0f6c, 1},
+		{0x0f71, 0x0f97, 1},
+		{0x0f99, 0x0fbc, 1},
+		{0x0fbe, 0x0fcc, 1},
+		{0x0fce, 0x0fda, 1},
+		{0x1000, 0x10c5, 1},
+		{0x10c7, 0x10cd, 6},
+		{0x10d0, 0x1248, 1},
+		{0x124a, 0x124d, 1},
+		{0x1250, 0x1256, 1},
+		{0x1258, 0x125a, 2},
+		{0x125b, 0x125d, 1},
+		{0x1260, 0x1288, 1},
+		{0x128a, 0x128d, 1},
+		{0x1290, 0x12b0, 1},
+		{0x12b2, 0x12b5, 1},
+		{0x12b8, 0x12be, 1},
+		{0x12c0, 0x12c2, 2},
+		{0x12c3, 0x12c5, 1},
+		{0x12c8, 0x12d6, 1},
+		{0x12d8, 0x1310, 1},
+		{0x1312, 0x1315, 1},
+		{0x1318, 0x135a, 1},
+		{0x135d, 0x137c, 1},
+		{0x1380, 0x1399, 1},
+		{0x13a0, 0x13f4, 1},
+		{0x1400, 0x169c, 1},
+		{0x16a0, 0x16f0, 1},
+		{0x1700, 0x170c, 1},
+		{0x170e, 0x1714, 1},
+		{0x1720, 0x1736, 1},
+		{0x1740, 0x1753, 1},
+		{0x1760, 0x176c, 1},
+		{0x176e, 0x1770, 1},
+		{0x1772, 0x1773, 1},
+		{0x1780, 0x17dd, 1},
+		{0x17e0, 0x17e9, 1},
+		{0x17f0, 0x17f9, 1},
+		{0x1800, 0x180e, 1},
+		{0x1810, 0x1819, 1},
+		{0x1820, 0x1877, 1},
+		{0x1880, 0x18aa, 1},
+		{0x18b0, 0x18f5, 1},
+		{0x1900, 0x191c, 1},
+		{0x1920, 0x192b, 1},
+		{0x1930, 0x193b, 1},
+		{0x1940, 0x1944, 4},
+		{0x1945, 0x196d, 1},
+		{0x1970, 0x1974, 1},
+		{0x1980, 0x19ab, 1},
+		{0x19b0, 0x19c9, 1},
+		{0x19d0, 0x19da, 1},
+		{0x19de, 0x1a1b, 1},
+		{0x1a1e, 0x1a5e, 1},
+		{0x1a60, 0x1a7c, 1},
+		{0x1a7f, 0x1a89, 1},
+		{0x1a90, 0x1a99, 1},
+		{0x1aa0, 0x1aad, 1},
+		{0x1b00, 0x1b4b, 1},
+		{0x1b50, 0x1b7c, 1},
+		{0x1b80, 0x1bf3, 1},
+		{0x1bfc, 0x1c37, 1},
+		{0x1c3b, 0x1c49, 1},
+		{0x1c4d, 0x1c7f, 1},
+		{0x1cc0, 0x1cc7, 1},
+		{0x1cd0, 0x1cf6, 1},
+		{0x1d00, 0x1de6, 1},
+		{0x1dfc, 0x1f15, 1},
+		{0x1f18, 0x1f1d, 1},
+		{0x1f20, 0x1f45, 1},
+		{0x1f48, 0x1f4d, 1},
+		{0x1f50, 0x1f57, 1},
+		{0x1f59, 0x1f5f, 2},
+		{0x1f60, 0x1f7d, 1},
+		{0x1f80, 0x1fb4, 1},
+		{0x1fb6, 0x1fc4, 1},
+		{0x1fc6, 0x1fd3, 1},
+		{0x1fd6, 0x1fdb, 1},
+		{0x1fdd, 0x1fef, 1},
+		{0x1ff2, 0x1ff4, 1},
+		{0x1ff6, 0x1ffe, 1},
+		{0x2000, 0x2064, 1},
+		{0x206a, 0x2071, 1},
+		{0x2074, 0x208e, 1},
+		{0x2090, 0x209c, 1},
+		{0x20a0, 0x20ba, 1},
+		{0x20d0, 0x20f0, 1},
+		{0x2100, 0x2189, 1},
+		{0x2190, 0x23f3, 1},
+		{0x2400, 0x2426, 1},
+		{0x2440, 0x244a, 1},
+		{0x2460, 0x26ff, 1},
+		{0x2701, 0x2b4c, 1},
+		{0x2b50, 0x2b59, 1},
+		{0x2c00, 0x2c2e, 1},
+		{0x2c30, 0x2c5e, 1},
+		{0x2c60, 0x2cf3, 1},
+		{0x2cf9, 0x2d25, 1},
+		{0x2d27, 0x2d2d, 6},
+		{0x2d30, 0x2d67, 1},
+		{0x2d6f, 0x2d70, 1},
+		{0x2d7f, 0x2d96, 1},
+		{0x2da0, 0x2da6, 1},
+		{0x2da8, 0x2dae, 1},
+		{0x2db0, 0x2db6, 1},
+		{0x2db8, 0x2dbe, 1},
+		{0x2dc0, 0x2dc6, 1},
+		{0x2dc8, 0x2dce, 1},
+		{0x2dd0, 0x2dd6, 1},
+		{0x2dd8, 0x2dde, 1},
+		{0x2de0, 0x2e3b, 1},
+		{0x2e80, 0x2e99, 1},
+		{0x2e9b, 0x2ef3, 1},
+		{0x2f00, 0x2fd5, 1},
+		{0x2ff0, 0x2ffb, 1},
+		{0x3000, 0x303f, 1},
+		{0x3041, 0x3096, 1},
+		{0x3099, 0x30ff, 1},
+		{0x3105, 0x312d, 1},
+		{0x3131, 0x318e, 1},
+		{0x3190, 0x31ba, 1},
+		{0x31c0, 0x31e3, 1},
+		{0x31f0, 0x321e, 1},
+		{0x3220, 0x32fe, 1},
+		{0x3300, 0x4db5, 1},
+		{0x4dc0, 0x9fcc, 1},
+		{0xa000, 0xa48c, 1},
+		{0xa490, 0xa4c6, 1},
+		{0xa4d0, 0xa62b, 1},
+		{0xa640, 0xa697, 1},
+		{0xa69f, 0xa6f7, 1},
+		{0xa700, 0xa78e, 1},
+		{0xa790, 0xa793, 1},
+		{0xa7a0, 0xa7aa, 1},
+		{0xa7f8, 0xa82b, 1},
+		{0xa830, 0xa839, 1},
+		{0xa840, 0xa877, 1},
+		{0xa880, 0xa8c4, 1},
+		{0xa8ce, 0xa8d9, 1},
+		{0xa8e0, 0xa8fb, 1},
+		{0xa900, 0xa953, 1},
+		{0xa95f, 0xa97c, 1},
+		{0xa980, 0xa9cd, 1},
+		{0xa9cf, 0xa9d9, 1},
+		{0xa9de, 0xa9df, 1},
+		{0xaa00, 0xaa36, 1},
+		{0xaa40, 0xaa4d, 1},
+		{0xaa50, 0xaa59, 1},
+		{0xaa5c, 0xaa7b, 1},
+		{0xaa80, 0xaac2, 1},
+		{0xaadb, 0xaaf6, 1},
+		{0xab01, 0xab06, 1},
+		{0xab09, 0xab0e, 1},
+		{0xab11, 0xab16, 1},
+		{0xab20, 0xab26, 1},
+		{0xab28, 0xab2e, 1},
+		{0xabc0, 0xabed, 1},
+		{0xabf0, 0xabf9, 1},
+		{0xac00, 0xd7a3, 1},
+		{0xd7b0, 0xd7c6, 1},
+		{0xd7cb, 0xd7fb, 1},
+		{0xd800, 0xfa6d, 1},
+		{0xfa70, 0xfad9, 1},
+		{0xfb00, 0xfb06, 1},
+		{0xfb13, 0xfb17, 1},
+		{0xfb1d, 0xfb36, 1},
+		{0xfb38, 0xfb3c, 1},
+		{0xfb3e, 0xfb40, 2},
+		{0xfb41, 0xfb43, 2},
+		{0xfb44, 0xfb46, 2},
+		{0xfb47, 0xfbc1, 1},
+		{0xfbd3, 0xfd3f, 1},
+		{0xfd50, 0xfd8f, 1},
+		{0xfd92, 0xfdc7, 1},
+		{0xfdf0, 0xfdfd, 1},
+		{0xfe00, 0xfe19, 1},
+		{0xfe20, 0xfe26, 1},
+		{0xfe30, 0xfe52, 1},
+		{0xfe54, 0xfe66, 1},
+		{0xfe68, 0xfe6b, 1},
+		{0xfe70, 0xfe74, 1},
+		{0xfe76, 0xfefc, 1},
+		{0xfeff, 0xff01, 2},
+		{0xff02, 0xffbe, 1},
+		{0xffc2, 0xffc7, 1},
+		{0xffca, 0xffcf, 1},
+		{0xffd2, 0xffd7, 1},
+		{0xffda, 0xffdc, 1},
+		{0xffe0, 0xffe6, 1},
+		{0xffe8, 0xffee, 1},
+		{0xfff9, 0xfffd, 1},
+	},
+	R32: []unicode.Range32{
+		{0x00010000, 0x0001000b, 1},
+		{0x0001000d, 0x00010026, 1},
+		{0x00010028, 0x0001003a, 1},
+		{0x0001003c, 0x0001003d, 1},
+		{0x0001003f, 0x0001004d, 1},
+		{0x00010050, 0x0001005d, 1},
+		{0x00010080, 0x000100fa, 1},
+		{0x00010100, 0x00010102, 1},
+		{0x00010107, 0x00010133, 1},
+		{0x00010137, 0x0001018a, 1},
+		{0x00010190, 0x0001019b, 1},
+		{0x000101d0, 0x000101fd, 1},
+		{0x00010280, 0x0001029c, 1},
+		{0x000102a0, 0x000102d0, 1},
+		{0x00010300, 0x0001031e, 1},
+		{0x00010320, 0x00010323, 1},
+		{0x00010330, 0x0001034a, 1},
+		{0x00010380, 0x0001039d, 1},
+		{0x0001039f, 0x000103c3, 1},
+		{0x000103c8, 0x000103d5, 1},
+		{0x00010400, 0x0001049d, 1},
+		{0x000104a0, 0x000104a9, 1},
+		{0x00010800, 0x00010805, 1},
+		{0x00010808, 0x0001080a, 2},
+		{0x0001080b, 0x00010835, 1},
+		{0x00010837, 0x00010838, 1},
+		{0x0001083c, 0x0001083f, 3},
+		{0x00010840, 0x00010855, 1},
+		{0x00010857, 0x0001085f, 1},
+		{0x00010900, 0x0001091b, 1},
+		{0x0001091f, 0x00010939, 1},
+		{0x0001093f, 0x00010980, 65},
+		{0x00010981, 0x000109b7, 1},
+		{0x000109be, 0x000109bf, 1},
+		{0x00010a00, 0x00010a03, 1},
+		{0x00010a05, 0x00010a06, 1},
+		{0x00010a0c, 0x00010a13, 1},
+		{0x00010a15, 0x00010a17, 1},
+		{0x00010a19, 0x00010a33, 1},
+		{0x00010a38, 0x00010a3a, 1},
+		{0x00010a3f, 0x00010a47, 1},
+		{0x00010a50, 0x00010a58, 1},
+		{0x00010a60, 0x00010a7f, 1},
+		{0x00010b00, 0x00010b35, 1},
+		{0x00010b39, 0x00010b55, 1},
+		{0x00010b58, 0x00010b72, 1},
+		{0x00010b78, 0x00010b7f, 1},
+		{0x00010c00, 0x00010c48, 1},
+		{0x00010e60, 0x00010e7e, 1},
+		{0x00011000, 0x0001104d, 1},
+		{0x00011052, 0x0001106f, 1},
+		{0x00011080, 0x000110c1, 1},
+		{0x000110d0, 0x000110e8, 1},
+		{0x000110f0, 0x000110f9, 1},
+		{0x00011100, 0x00011134, 1},
+		{0x00011136, 0x00011143, 1},
+		{0x00011180, 0x000111c8, 1},
+		{0x000111d0, 0x000111d9, 1},
+		{0x00011680, 0x000116b7, 1},
+		{0x000116c0, 0x000116c9, 1},
+		{0x00012000, 0x0001236e, 1},
+		{0x00012400, 0x00012462, 1},
+		{0x00012470, 0x00012473, 1},
+		{0x00013000, 0x0001342e, 1},
+		{0x00016800, 0x00016a38, 1},
+		{0x00016f00, 0x00016f44, 1},
+		{0x00016f50, 0x00016f7e, 1},
+		{0x00016f8f, 0x00016f9f, 1},
+		{0x0001b000, 0x0001b001, 1},
+		{0x0001d000, 0x0001d0f5, 1},
+		{0x0001d100, 0x0001d126, 1},
+		{0x0001d129, 0x0001d1dd, 1},
+		{0x0001d200, 0x0001d245, 1},
+		{0x0001d300, 0x0001d356, 1},
+		{0x0001d360, 0x0001d371, 1},
+		{0x0001d400, 0x0001d454, 1},
+		{0x0001d456, 0x0001d49c, 1},
+		{0x0001d49e, 0x0001d49f, 1},
+		{0x0001d4a2, 0x0001d4a5, 3},
+		{0x0001d4a6, 0x0001d4a9, 3},
+		{0x0001d4aa, 0x0001d4ac, 1},
+		{0x0001d4ae, 0x0001d4b9, 1},
+		{0x0001d4bb, 0x0001d4bd, 2},
+		{0x0001d4be, 0x0001d4c3, 1},
+		{0x0001d4c5, 0x0001d505, 1},
+		{0x0001d507, 0x0001d50a, 1},
+		{0x0001d50d, 0x0001d514, 1},
+		{0x0001d516, 0x0001d51c, 1},
+		{0x0001d51e, 0x0001d539, 1},
+		{0x0001d53b, 0x0001d53e, 1},
+		{0x0001d540, 0x0001d544, 1},
+		{0x0001d546, 0x0001d54a, 4},
+		{0x0001d54b, 0x0001d550, 1},
+		{0x0001d552, 0x0001d6a5, 1},
+		{0x0001d6a8, 0x0001d7cb, 1},
+		{0x0001d7ce, 0x0001d7ff, 1},
+		{0x0001ee00, 0x0001ee03, 1},
+		{0x0001ee05, 0x0001ee1f, 1},
+		{0x0001ee21, 0x0001ee22, 1},
+		{0x0001ee24, 0x0001ee27, 3},
+		{0x0001ee29, 0x0001ee32, 1},
+		{0x0001ee34, 0x0001ee37, 1},
+		{0x0001ee39, 0x0001ee3b, 2},
+		{0x0001ee42, 0x0001ee47, 5},
+		{0x0001ee49, 0x0001ee4d, 2},
+		{0x0001ee4e, 0x0001ee4f, 1},
+		{0x0001ee51, 0x0001ee52, 1},
+		{0x0001ee54, 0x0001ee57, 3},
+		{0x0001ee59, 0x0001ee61, 2},
+		{0x0001ee62, 0x0001ee64, 2},
+		{0x0001ee67, 0x0001ee6a, 1},
+		{0x0001ee6c, 0x0001ee72, 1},
+		{0x0001ee74, 0x0001ee77, 1},
+		{0x0001ee79, 0x0001ee7c, 1},
+		{0x0001ee7e, 0x0001ee80, 2},
+		{0x0001ee81, 0x0001ee89, 1},
+		{0x0001ee8b, 0x0001ee9b, 1},
+		{0x0001eea1, 0x0001eea3, 1},
+		{0x0001eea5, 0x0001eea9, 1},
+		{0x0001eeab, 0x0001eebb, 1},
+		{0x0001eef0, 0x0001eef1, 1},
+		{0x0001f000, 0x0001f02b, 1},
+		{0x0001f030, 0x0001f093, 1},
+		{0x0001f0a0, 0x0001f0ae, 1},
+		{0x0001f0b1, 0x0001f0be, 1},
+		{0x0001f0c1, 0x0001f0cf, 1},
+		{0x0001f0d1, 0x0001f0df, 1},
+		{0x0001f100, 0x0001f10a, 1},
+		{0x0001f110, 0x0001f12e, 1},
+		{0x0001f130, 0x0001f16b, 1},
+		{0x0001f170, 0x0001f19a, 1},
+		{0x0001f1e6, 0x0001f202, 1},
+		{0x0001f210, 0x0001f23a, 1},
+		{0x0001f240, 0x0001f248, 1},
+		{0x0001f250, 0x0001f251, 1},
+		{0x0001f300, 0x0001f320, 1},
+		{0x0001f330, 0x0001f335, 1},
+		{0x0001f337, 0x0001f37c, 1},
+		{0x0001f380, 0x0001f393, 1},
+		{0x0001f3a0, 0x0001f3c4, 1},
+		{0x0001f3c6, 0x0001f3ca, 1},
+		{0x0001f3e0, 0x0001f3f0, 1},
+		{0x0001f400, 0x0001f43e, 1},
+		{0x0001f440, 0x0001f442, 2},
+		{0x0001f443, 0x0001f4f7, 1},
+		{0x0001f4f9, 0x0001f4fc, 1},
+		{0x0001f500, 0x0001f53d, 1},
+		{0x0001f540, 0x0001f543, 1},
+		{0x0001f550, 0x0001f567, 1},
+		{0x0001f5fb, 0x0001f640, 1},
+		{0x0001f645, 0x0001f64f, 1},
+		{0x0001f680, 0x0001f6c5, 1},
+		{0x0001f700, 0x0001f773, 1},
+		{0x00020000, 0x0002a6d6, 1},
+		{0x0002a700, 0x0002b734, 1},
+		{0x0002b740, 0x0002b81d, 1},
+		{0x0002f800, 0x0002fa1d, 1},
+		{0x000e0001, 0x000e0020, 31},
+		{0x000e0021, 0x000e007f, 1},
+		{0x000e0100, 0x000e01ef, 1},
+		{0x000f0000, 0x000ffffd, 1},
+		{0x00100000, 0x0010fffd, 1},
+	},
+	LatinOffset: 0,
+}
+
+// size 4160 bytes (4 KiB)
+var assigned6_3_0 = &unicode.RangeTable{
+	R16: []unicode.Range16{
+		{0x0000, 0x0377, 1},
+		{0x037a, 0x037e, 1},
+		{0x0384, 0x038a, 1},
+		{0x038c, 0x038e, 2},
+		{0x038f, 0x03a1, 1},
+		{0x03a3, 0x0527, 1},
+		{0x0531, 0x0556, 1},
+		{0x0559, 0x055f, 1},
+		{0x0561, 0x0587, 1},
+		{0x0589, 0x058a, 1},
+		{0x058f, 0x0591, 2},
+		{0x0592, 0x05c7, 1},
+		{0x05d0, 0x05ea, 1},
+		{0x05f0, 0x05f4, 1},
+		{0x0600, 0x0604, 1},
+		{0x0606, 0x061c, 1},
+		{0x061e, 0x070d, 1},
+		{0x070f, 0x074a, 1},
+		{0x074d, 0x07b1, 1},
+		{0x07c0, 0x07fa, 1},
+		{0x0800, 0x082d, 1},
+		{0x0830, 0x083e, 1},
+		{0x0840, 0x085b, 1},
+		{0x085e, 0x08a0, 66},
+		{0x08a2, 0x08ac, 1},
+		{0x08e4, 0x08fe, 1},
+		{0x0900, 0x0977, 1},
+		{0x0979, 0x097f, 1},
+		{0x0981, 0x0983, 1},
+		{0x0985, 0x098c, 1},
+		{0x098f, 0x0990, 1},
+		{0x0993, 0x09a8, 1},
+		{0x09aa, 0x09b0, 1},
+		{0x09b2, 0x09b6, 4},
+		{0x09b7, 0x09b9, 1},
+		{0x09bc, 0x09c4, 1},
+		{0x09c7, 0x09c8, 1},
+		{0x09cb, 0x09ce, 1},
+		{0x09d7, 0x09dc, 5},
+		{0x09dd, 0x09df, 2},
+		{0x09e0, 0x09e3, 1},
+		{0x09e6, 0x09fb, 1},
+		{0x0a01, 0x0a03, 1},
+		{0x0a05, 0x0a0a, 1},
+		{0x0a0f, 0x0a10, 1},
+		{0x0a13, 0x0a28, 1},
+		{0x0a2a, 0x0a30, 1},
+		{0x0a32, 0x0a33, 1},
+		{0x0a35, 0x0a36, 1},
+		{0x0a38, 0x0a39, 1},
+		{0x0a3c, 0x0a3e, 2},
+		{0x0a3f, 0x0a42, 1},
+		{0x0a47, 0x0a48, 1},
+		{0x0a4b, 0x0a4d, 1},
+		{0x0a51, 0x0a59, 8},
+		{0x0a5a, 0x0a5c, 1},
+		{0x0a5e, 0x0a66, 8},
+		{0x0a67, 0x0a75, 1},
+		{0x0a81, 0x0a83, 1},
+		{0x0a85, 0x0a8d, 1},
+		{0x0a8f, 0x0a91, 1},
+		{0x0a93, 0x0aa8, 1},
+		{0x0aaa, 0x0ab0, 1},
+		{0x0ab2, 0x0ab3, 1},
+		{0x0ab5, 0x0ab9, 1},
+		{0x0abc, 0x0ac5, 1},
+		{0x0ac7, 0x0ac9, 1},
+		{0x0acb, 0x0acd, 1},
+		{0x0ad0, 0x0ae0, 16},
+		{0x0ae1, 0x0ae3, 1},
+		{0x0ae6, 0x0af1, 1},
+		{0x0b01, 0x0b03, 1},
+		{0x0b05, 0x0b0c, 1},
+		{0x0b0f, 0x0b10, 1},
+		{0x0b13, 0x0b28, 1},
+		{0x0b2a, 0x0b30, 1},
+		{0x0b32, 0x0b33, 1},
+		{0x0b35, 0x0b39, 1},
+		{0x0b3c, 0x0b44, 1},
+		{0x0b47, 0x0b48, 1},
+		{0x0b4b, 0x0b4d, 1},
+		{0x0b56, 0x0b57, 1},
+		{0x0b5c, 0x0b5d, 1},
+		{0x0b5f, 0x0b63, 1},
+		{0x0b66, 0x0b77, 1},
+		{0x0b82, 0x0b83, 1},
+		{0x0b85, 0x0b8a, 1},
+		{0x0b8e, 0x0b90, 1},
+		{0x0b92, 0x0b95, 1},
+		{0x0b99, 0x0b9a, 1},
+		{0x0b9c, 0x0b9e, 2},
+		{0x0b9f, 0x0ba3, 4},
+		{0x0ba4, 0x0ba8, 4},
+		{0x0ba9, 0x0baa, 1},
+		{0x0bae, 0x0bb9, 1},
+		{0x0bbe, 0x0bc2, 1},
+		{0x0bc6, 0x0bc8, 1},
+		{0x0bca, 0x0bcd, 1},
+		{0x0bd0, 0x0bd7, 7},
+		{0x0be6, 0x0bfa, 1},
+		{0x0c01, 0x0c03, 1},
+		{0x0c05, 0x0c0c, 1},
+		{0x0c0e, 0x0c10, 1},
+		{0x0c12, 0x0c28, 1},
+		{0x0c2a, 0x0c33, 1},
+		{0x0c35, 0x0c39, 1},
+		{0x0c3d, 0x0c44, 1},
+		{0x0c46, 0x0c48, 1},
+		{0x0c4a, 0x0c4d, 1},
+		{0x0c55, 0x0c56, 1},
+		{0x0c58, 0x0c59, 1},
+		{0x0c60, 0x0c63, 1},
+		{0x0c66, 0x0c6f, 1},
+		{0x0c78, 0x0c7f, 1},
+		{0x0c82, 0x0c83, 1},
+		{0x0c85, 0x0c8c, 1},
+		{0x0c8e, 0x0c90, 1},
+		{0x0c92, 0x0ca8, 1},
+		{0x0caa, 0x0cb3, 1},
+		{0x0cb5, 0x0cb9, 1},
+		{0x0cbc, 0x0cc4, 1},
+		{0x0cc6, 0x0cc8, 1},
+		{0x0cca, 0x0ccd, 1},
+		{0x0cd5, 0x0cd6, 1},
+		{0x0cde, 0x0ce0, 2},
+		{0x0ce1, 0x0ce3, 1},
+		{0x0ce6, 0x0cef, 1},
+		{0x0cf1, 0x0cf2, 1},
+		{0x0d02, 0x0d03, 1},
+		{0x0d05, 0x0d0c, 1},
+		{0x0d0e, 0x0d10, 1},
+		{0x0d12, 0x0d3a, 1},
+		{0x0d3d, 0x0d44, 1},
+		{0x0d46, 0x0d48, 1},
+		{0x0d4a, 0x0d4e, 1},
+		{0x0d57, 0x0d60, 9},
+		{0x0d61, 0x0d63, 1},
+		{0x0d66, 0x0d75, 1},
+		{0x0d79, 0x0d7f, 1},
+		{0x0d82, 0x0d83, 1},
+		{0x0d85, 0x0d96, 1},
+		{0x0d9a, 0x0db1, 1},
+		{0x0db3, 0x0dbb, 1},
+		{0x0dbd, 0x0dc0, 3},
+		{0x0dc1, 0x0dc6, 1},
+		{0x0dca, 0x0dcf, 5},
+		{0x0dd0, 0x0dd4, 1},
+		{0x0dd6, 0x0dd8, 2},
+		{0x0dd9, 0x0ddf, 1},
+		{0x0df2, 0x0df4, 1},
+		{0x0e01, 0x0e3a, 1},
+		{0x0e3f, 0x0e5b, 1},
+		{0x0e81, 0x0e82, 1},
+		{0x0e84, 0x0e87, 3},
+		{0x0e88, 0x0e8a, 2},
+		{0x0e8d, 0x0e94, 7},
+		{0x0e95, 0x0e97, 1},
+		{0x0e99, 0x0e9f, 1},
+		{0x0ea1, 0x0ea3, 1},
+		{0x0ea5, 0x0ea7, 2},
+		{0x0eaa, 0x0eab, 1},
+		{0x0ead, 0x0eb9, 1},
+		{0x0ebb, 0x0ebd, 1},
+		{0x0ec0, 0x0ec4, 1},
+		{0x0ec6, 0x0ec8, 2},
+		{0x0ec9, 0x0ecd, 1},
+		{0x0ed0, 0x0ed9, 1},
+		{0x0edc, 0x0edf, 1},
+		{0x0f00, 0x0f47, 1},
+		{0x0f49, 0x0f6c, 1},
+		{0x0f71, 0x0f97, 1},
+		{0x0f99, 0x0fbc, 1},
+		{0x0fbe, 0x0fcc, 1},
+		{0x0fce, 0x0fda, 1},
+		{0x1000, 0x10c5, 1},
+		{0x10c7, 0x10cd, 6},
+		{0x10d0, 0x1248, 1},
+		{0x124a, 0x124d, 1},
+		{0x1250, 0x1256, 1},
+		{0x1258, 0x125a, 2},
+		{0x125b, 0x125d, 1},
+		{0x1260, 0x1288, 1},
+		{0x128a, 0x128d, 1},
+		{0x1290, 0x12b0, 1},
+		{0x12b2, 0x12b5, 1},
+		{0x12b8, 0x12be, 1},
+		{0x12c0, 0x12c2, 2},
+		{0x12c3, 0x12c5, 1},
+		{0x12c8, 0x12d6, 1},
+		{0x12d8, 0x1310, 1},
+		{0x1312, 0x1315, 1},
+		{0x1318, 0x135a, 1},
+		{0x135d, 0x137c, 1},
+		{0x1380, 0x1399, 1},
+		{0x13a0, 0x13f4, 1},
+		{0x1400, 0x169c, 1},
+		{0x16a0, 0x16f0, 1},
+		{0x1700, 0x170c, 1},
+		{0x170e, 0x1714, 1},
+		{0x1720, 0x1736, 1},
+		{0x1740, 0x1753, 1},
+		{0x1760, 0x176c, 1},
+		{0x176e, 0x1770, 1},
+		{0x1772, 0x1773, 1},
+		{0x1780, 0x17dd, 1},
+		{0x17e0, 0x17e9, 1},
+		{0x17f0, 0x17f9, 1},
+		{0x1800, 0x180e, 1},
+		{0x1810, 0x1819, 1},
+		{0x1820, 0x1877, 1},
+		{0x1880, 0x18aa, 1},
+		{0x18b0, 0x18f5, 1},
+		{0x1900, 0x191c, 1},
+		{0x1920, 0x192b, 1},
+		{0x1930, 0x193b, 1},
+		{0x1940, 0x1944, 4},
+		{0x1945, 0x196d, 1},
+		{0x1970, 0x1974, 1},
+		{0x1980, 0x19ab, 1},
+		{0x19b0, 0x19c9, 1},
+		{0x19d0, 0x19da, 1},
+		{0x19de, 0x1a1b, 1},
+		{0x1a1e, 0x1a5e, 1},
+		{0x1a60, 0x1a7c, 1},
+		{0x1a7f, 0x1a89, 1},
+		{0x1a90, 0x1a99, 1},
+		{0x1aa0, 0x1aad, 1},
+		{0x1b00, 0x1b4b, 1},
+		{0x1b50, 0x1b7c, 1},
+		{0x1b80, 0x1bf3, 1},
+		{0x1bfc, 0x1c37, 1},
+		{0x1c3b, 0x1c49, 1},
+		{0x1c4d, 0x1c7f, 1},
+		{0x1cc0, 0x1cc7, 1},
+		{0x1cd0, 0x1cf6, 1},
+		{0x1d00, 0x1de6, 1},
+		{0x1dfc, 0x1f15, 1},
+		{0x1f18, 0x1f1d, 1},
+		{0x1f20, 0x1f45, 1},
+		{0x1f48, 0x1f4d, 1},
+		{0x1f50, 0x1f57, 1},
+		{0x1f59, 0x1f5f, 2},
+		{0x1f60, 0x1f7d, 1},
+		{0x1f80, 0x1fb4, 1},
+		{0x1fb6, 0x1fc4, 1},
+		{0x1fc6, 0x1fd3, 1},
+		{0x1fd6, 0x1fdb, 1},
+		{0x1fdd, 0x1fef, 1},
+		{0x1ff2, 0x1ff4, 1},
+		{0x1ff6, 0x1ffe, 1},
+		{0x2000, 0x2064, 1},
+		{0x2066, 0x2071, 1},
+		{0x2074, 0x208e, 1},
+		{0x2090, 0x209c, 1},
+		{0x20a0, 0x20ba, 1},
+		{0x20d0, 0x20f0, 1},
+		{0x2100, 0x2189, 1},
+		{0x2190, 0x23f3, 1},
+		{0x2400, 0x2426, 1},
+		{0x2440, 0x244a, 1},
+		{0x2460, 0x26ff, 1},
+		{0x2701, 0x2b4c, 1},
+		{0x2b50, 0x2b59, 1},
+		{0x2c00, 0x2c2e, 1},
+		{0x2c30, 0x2c5e, 1},
+		{0x2c60, 0x2cf3, 1},
+		{0x2cf9, 0x2d25, 1},
+		{0x2d27, 0x2d2d, 6},
+		{0x2d30, 0x2d67, 1},
+		{0x2d6f, 0x2d70, 1},
+		{0x2d7f, 0x2d96, 1},
+		{0x2da0, 0x2da6, 1},
+		{0x2da8, 0x2dae, 1},
+		{0x2db0, 0x2db6, 1},
+		{0x2db8, 0x2dbe, 1},
+		{0x2dc0, 0x2dc6, 1},
+		{0x2dc8, 0x2dce, 1},
+		{0x2dd0, 0x2dd6, 1},
+		{0x2dd8, 0x2dde, 1},
+		{0x2de0, 0x2e3b, 1},
+		{0x2e80, 0x2e99, 1},
+		{0x2e9b, 0x2ef3, 1},
+		{0x2f00, 0x2fd5, 1},
+		{0x2ff0, 0x2ffb, 1},
+		{0x3000, 0x303f, 1},
+		{0x3041, 0x3096, 1},
+		{0x3099, 0x30ff, 1},
+		{0x3105, 0x312d, 1},
+		{0x3131, 0x318e, 1},
+		{0x3190, 0x31ba, 1},
+		{0x31c0, 0x31e3, 1},
+		{0x31f0, 0x321e, 1},
+		{0x3220, 0x32fe, 1},
+		{0x3300, 0x4db5, 1},
+		{0x4dc0, 0x9fcc, 1},
+		{0xa000, 0xa48c, 1},
+		{0xa490, 0xa4c6, 1},
+		{0xa4d0, 0xa62b, 1},
+		{0xa640, 0xa697, 1},
+		{0xa69f, 0xa6f7, 1},
+		{0xa700, 0xa78e, 1},
+		{0xa790, 0xa793, 1},
+		{0xa7a0, 0xa7aa, 1},
+		{0xa7f8, 0xa82b, 1},
+		{0xa830, 0xa839, 1},
+		{0xa840, 0xa877, 1},
+		{0xa880, 0xa8c4, 1},
+		{0xa8ce, 0xa8d9, 1},
+		{0xa8e0, 0xa8fb, 1},
+		{0xa900, 0xa953, 1},
+		{0xa95f, 0xa97c, 1},
+		{0xa980, 0xa9cd, 1},
+		{0xa9cf, 0xa9d9, 1},
+		{0xa9de, 0xa9df, 1},
+		{0xaa00, 0xaa36, 1},
+		{0xaa40, 0xaa4d, 1},
+		{0xaa50, 0xaa59, 1},
+		{0xaa5c, 0xaa7b, 1},
+		{0xaa80, 0xaac2, 1},
+		{0xaadb, 0xaaf6, 1},
+		{0xab01, 0xab06, 1},
+		{0xab09, 0xab0e, 1},
+		{0xab11, 0xab16, 1},
+		{0xab20, 0xab26, 1},
+		{0xab28, 0xab2e, 1},
+		{0xabc0, 0xabed, 1},
+		{0xabf0, 0xabf9, 1},
+		{0xac00, 0xd7a3, 1},
+		{0xd7b0, 0xd7c6, 1},
+		{0xd7cb, 0xd7fb, 1},
+		{0xd800, 0xfa6d, 1},
+		{0xfa70, 0xfad9, 1},
+		{0xfb00, 0xfb06, 1},
+		{0xfb13, 0xfb17, 1},
+		{0xfb1d, 0xfb36, 1},
+		{0xfb38, 0xfb3c, 1},
+		{0xfb3e, 0xfb40, 2},
+		{0xfb41, 0xfb43, 2},
+		{0xfb44, 0xfb46, 2},
+		{0xfb47, 0xfbc1, 1},
+		{0xfbd3, 0xfd3f, 1},
+		{0xfd50, 0xfd8f, 1},
+		{0xfd92, 0xfdc7, 1},
+		{0xfdf0, 0xfdfd, 1},
+		{0xfe00, 0xfe19, 1},
+		{0xfe20, 0xfe26, 1},
+		{0xfe30, 0xfe52, 1},
+		{0xfe54, 0xfe66, 1},
+		{0xfe68, 0xfe6b, 1},
+		{0xfe70, 0xfe74, 1},
+		{0xfe76, 0xfefc, 1},
+		{0xfeff, 0xff01, 2},
+		{0xff02, 0xffbe, 1},
+		{0xffc2, 0xffc7, 1},
+		{0xffca, 0xffcf, 1},
+		{0xffd2, 0xffd7, 1},
+		{0xffda, 0xffdc, 1},
+		{0xffe0, 0xffe6, 1},
+		{0xffe8, 0xffee, 1},
+		{0xfff9, 0xfffd, 1},
+	},
+	R32: []unicode.Range32{
+		{0x00010000, 0x0001000b, 1},
+		{0x0001000d, 0x00010026, 1},
+		{0x00010028, 0x0001003a, 1},
+		{0x0001003c, 0x0001003d, 1},
+		{0x0001003f, 0x0001004d, 1},
+		{0x00010050, 0x0001005d, 1},
+		{0x00010080, 0x000100fa, 1},
+		{0x00010100, 0x00010102, 1},
+		{0x00010107, 0x00010133, 1},
+		{0x00010137, 0x0001018a, 1},
+		{0x00010190, 0x0001019b, 1},
+		{0x000101d0, 0x000101fd, 1},
+		{0x00010280, 0x0001029c, 1},
+		{0x000102a0, 0x000102d0, 1},
+		{0x00010300, 0x0001031e, 1},
+		{0x00010320, 0x00010323, 1},
+		{0x00010330, 0x0001034a, 1},
+		{0x00010380, 0x0001039d, 1},
+		{0x0001039f, 0x000103c3, 1},
+		{0x000103c8, 0x000103d5, 1},
+		{0x00010400, 0x0001049d, 1},
+		{0x000104a0, 0x000104a9, 1},
+		{0x00010800, 0x00010805, 1},
+		{0x00010808, 0x0001080a, 2},
+		{0x0001080b, 0x00010835, 1},
+		{0x00010837, 0x00010838, 1},
+		{0x0001083c, 0x0001083f, 3},
+		{0x00010840, 0x00010855, 1},
+		{0x00010857, 0x0001085f, 1},
+		{0x00010900, 0x0001091b, 1},
+		{0x0001091f, 0x00010939, 1},
+		{0x0001093f, 0x00010980, 65},
+		{0x00010981, 0x000109b7, 1},
+		{0x000109be, 0x000109bf, 1},
+		{0x00010a00, 0x00010a03, 1},
+		{0x00010a05, 0x00010a06, 1},
+		{0x00010a0c, 0x00010a13, 1},
+		{0x00010a15, 0x00010a17, 1},
+		{0x00010a19, 0x00010a33, 1},
+		{0x00010a38, 0x00010a3a, 1},
+		{0x00010a3f, 0x00010a47, 1},
+		{0x00010a50, 0x00010a58, 1},
+		{0x00010a60, 0x00010a7f, 1},
+		{0x00010b00, 0x00010b35, 1},
+		{0x00010b39, 0x00010b55, 1},
+		{0x00010b58, 0x00010b72, 1},
+		{0x00010b78, 0x00010b7f, 1},
+		{0x00010c00, 0x00010c48, 1},
+		{0x00010e60, 0x00010e7e, 1},
+		{0x00011000, 0x0001104d, 1},
+		{0x00011052, 0x0001106f, 1},
+		{0x00011080, 0x000110c1, 1},
+		{0x000110d0, 0x000110e8, 1},
+		{0x000110f0, 0x000110f9, 1},
+		{0x00011100, 0x00011134, 1},
+		{0x00011136, 0x00011143, 1},
+		{0x00011180, 0x000111c8, 1},
+		{0x000111d0, 0x000111d9, 1},
+		{0x00011680, 0x000116b7, 1},
+		{0x000116c0, 0x000116c9, 1},
+		{0x00012000, 0x0001236e, 1},
+		{0x00012400, 0x00012462, 1},
+		{0x00012470, 0x00012473, 1},
+		{0x00013000, 0x0001342e, 1},
+		{0x00016800, 0x00016a38, 1},
+		{0x00016f00, 0x00016f44, 1},
+		{0x00016f50, 0x00016f7e, 1},
+		{0x00016f8f, 0x00016f9f, 1},
+		{0x0001b000, 0x0001b001, 1},
+		{0x0001d000, 0x0001d0f5, 1},
+		{0x0001d100, 0x0001d126, 1},
+		{0x0001d129, 0x0001d1dd, 1},
+		{0x0001d200, 0x0001d245, 1},
+		{0x0001d300, 0x0001d356, 1},
+		{0x0001d360, 0x0001d371, 1},
+		{0x0001d400, 0x0001d454, 1},
+		{0x0001d456, 0x0001d49c, 1},
+		{0x0001d49e, 0x0001d49f, 1},
+		{0x0001d4a2, 0x0001d4a5, 3},
+		{0x0001d4a6, 0x0001d4a9, 3},
+		{0x0001d4aa, 0x0001d4ac, 1},
+		{0x0001d4ae, 0x0001d4b9, 1},
+		{0x0001d4bb, 0x0001d4bd, 2},
+		{0x0001d4be, 0x0001d4c3, 1},
+		{0x0001d4c5, 0x0001d505, 1},
+		{0x0001d507, 0x0001d50a, 1},
+		{0x0001d50d, 0x0001d514, 1},
+		{0x0001d516, 0x0001d51c, 1},
+		{0x0001d51e, 0x0001d539, 1},
+		{0x0001d53b, 0x0001d53e, 1},
+		{0x0001d540, 0x0001d544, 1},
+		{0x0001d546, 0x0001d54a, 4},
+		{0x0001d54b, 0x0001d550, 1},
+		{0x0001d552, 0x0001d6a5, 1},
+		{0x0001d6a8, 0x0001d7cb, 1},
+		{0x0001d7ce, 0x0001d7ff, 1},
+		{0x0001ee00, 0x0001ee03, 1},
+		{0x0001ee05, 0x0001ee1f, 1},
+		{0x0001ee21, 0x0001ee22, 1},
+		{0x0001ee24, 0x0001ee27, 3},
+		{0x0001ee29, 0x0001ee32, 1},
+		{0x0001ee34, 0x0001ee37, 1},
+		{0x0001ee39, 0x0001ee3b, 2},
+		{0x0001ee42, 0x0001ee47, 5},
+		{0x0001ee49, 0x0001ee4d, 2},
+		{0x0001ee4e, 0x0001ee4f, 1},
+		{0x0001ee51, 0x0001ee52, 1},
+		{0x0001ee54, 0x0001ee57, 3},
+		{0x0001ee59, 0x0001ee61, 2},
+		{0x0001ee62, 0x0001ee64, 2},
+		{0x0001ee67, 0x0001ee6a, 1},
+		{0x0001ee6c, 0x0001ee72, 1},
+		{0x0001ee74, 0x0001ee77, 1},
+		{0x0001ee79, 0x0001ee7c, 1},
+		{0x0001ee7e, 0x0001ee80, 2},
+		{0x0001ee81, 0x0001ee89, 1},
+		{0x0001ee8b, 0x0001ee9b, 1},
+		{0x0001eea1, 0x0001eea3, 1},
+		{0x0001eea5, 0x0001eea9, 1},
+		{0x0001eeab, 0x0001eebb, 1},
+		{0x0001eef0, 0x0001eef1, 1},
+		{0x0001f000, 0x0001f02b, 1},
+		{0x0001f030, 0x0001f093, 1},
+		{0x0001f0a0, 0x0001f0ae, 1},
+		{0x0001f0b1, 0x0001f0be, 1},
+		{0x0001f0c1, 0x0001f0cf, 1},
+		{0x0001f0d1, 0x0001f0df, 1},
+		{0x0001f100, 0x0001f10a, 1},
+		{0x0001f110, 0x0001f12e, 1},
+		{0x0001f130, 0x0001f16b, 1},
+		{0x0001f170, 0x0001f19a, 1},
+		{0x0001f1e6, 0x0001f202, 1},
+		{0x0001f210, 0x0001f23a, 1},
+		{0x0001f240, 0x0001f248, 1},
+		{0x0001f250, 0x0001f251, 1},
+		{0x0001f300, 0x0001f320, 1},
+		{0x0001f330, 0x0001f335, 1},
+		{0x0001f337, 0x0001f37c, 1},
+		{0x0001f380, 0x0001f393, 1},
+		{0x0001f3a0, 0x0001f3c4, 1},
+		{0x0001f3c6, 0x0001f3ca, 1},
+		{0x0001f3e0, 0x0001f3f0, 1},
+		{0x0001f400, 0x0001f43e, 1},
+		{0x0001f440, 0x0001f442, 2},
+		{0x0001f443, 0x0001f4f7, 1},
+		{0x0001f4f9, 0x0001f4fc, 1},
+		{0x0001f500, 0x0001f53d, 1},
+		{0x0001f540, 0x0001f543, 1},
+		{0x0001f550, 0x0001f567, 1},
+		{0x0001f5fb, 0x0001f640, 1},
+		{0x0001f645, 0x0001f64f, 1},
+		{0x0001f680, 0x0001f6c5, 1},
+		{0x0001f700, 0x0001f773, 1},
+		{0x00020000, 0x0002a6d6, 1},
+		{0x0002a700, 0x0002b734, 1},
+		{0x0002b740, 0x0002b81d, 1},
+		{0x0002f800, 0x0002fa1d, 1},
+		{0x000e0001, 0x000e0020, 31},
+		{0x000e0021, 0x000e007f, 1},
+		{0x000e0100, 0x000e01ef, 1},
+		{0x000f0000, 0x000ffffd, 1},
+		{0x00100000, 0x0010fffd, 1},
+	},
+	LatinOffset: 0,
+}
+
+// size 4898 bytes (4 KiB)
+var assigned7_0_0 = &unicode.RangeTable{
+	R16: []unicode.Range16{
+		{0x0000, 0x0377, 1},
+		{0x037a, 0x037f, 1},
+		{0x0384, 0x038a, 1},
+		{0x038c, 0x038e, 2},
+		{0x038f, 0x03a1, 1},
+		{0x03a3, 0x052f, 1},
+		{0x0531, 0x0556, 1},
+		{0x0559, 0x055f, 1},
+		{0x0561, 0x0587, 1},
+		{0x0589, 0x058a, 1},
+		{0x058d, 0x058f, 1},
+		{0x0591, 0x05c7, 1},
+		{0x05d0, 0x05ea, 1},
+		{0x05f0, 0x05f4, 1},
+		{0x0600, 0x061c, 1},
+		{0x061e, 0x070d, 1},
+		{0x070f, 0x074a, 1},
+		{0x074d, 0x07b1, 1},
+		{0x07c0, 0x07fa, 1},
+		{0x0800, 0x082d, 1},
+		{0x0830, 0x083e, 1},
+		{0x0840, 0x085b, 1},
+		{0x085e, 0x08a0, 66},
+		{0x08a1, 0x08b2, 1},
+		{0x08e4, 0x0983, 1},
+		{0x0985, 0x098c, 1},
+		{0x098f, 0x0990, 1},
+		{0x0993, 0x09a8, 1},
+		{0x09aa, 0x09b0, 1},
+		{0x09b2, 0x09b6, 4},
+		{0x09b7, 0x09b9, 1},
+		{0x09bc, 0x09c4, 1},
+		{0x09c7, 0x09c8, 1},
+		{0x09cb, 0x09ce, 1},
+		{0x09d7, 0x09dc, 5},
+		{0x09dd, 0x09df, 2},
+		{0x09e0, 0x09e3, 1},
+		{0x09e6, 0x09fb, 1},
+		{0x0a01, 0x0a03, 1},
+		{0x0a05, 0x0a0a, 1},
+		{0x0a0f, 0x0a10, 1},
+		{0x0a13, 0x0a28, 1},
+		{0x0a2a, 0x0a30, 1},
+		{0x0a32, 0x0a33, 1},
+		{0x0a35, 0x0a36, 1},
+		{0x0a38, 0x0a39, 1},
+		{0x0a3c, 0x0a3e, 2},
+		{0x0a3f, 0x0a42, 1},
+		{0x0a47, 0x0a48, 1},
+		{0x0a4b, 0x0a4d, 1},
+		{0x0a51, 0x0a59, 8},
+		{0x0a5a, 0x0a5c, 1},
+		{0x0a5e, 0x0a66, 8},
+		{0x0a67, 0x0a75, 1},
+		{0x0a81, 0x0a83, 1},
+		{0x0a85, 0x0a8d, 1},
+		{0x0a8f, 0x0a91, 1},
+		{0x0a93, 0x0aa8, 1},
+		{0x0aaa, 0x0ab0, 1},
+		{0x0ab2, 0x0ab3, 1},
+		{0x0ab5, 0x0ab9, 1},
+		{0x0abc, 0x0ac5, 1},
+		{0x0ac7, 0x0ac9, 1},
+		{0x0acb, 0x0acd, 1},
+		{0x0ad0, 0x0ae0, 16},
+		{0x0ae1, 0x0ae3, 1},
+		{0x0ae6, 0x0af1, 1},
+		{0x0b01, 0x0b03, 1},
+		{0x0b05, 0x0b0c, 1},
+		{0x0b0f, 0x0b10, 1},
+		{0x0b13, 0x0b28, 1},
+		{0x0b2a, 0x0b30, 1},
+		{0x0b32, 0x0b33, 1},
+		{0x0b35, 0x0b39, 1},
+		{0x0b3c, 0x0b44, 1},
+		{0x0b47, 0x0b48, 1},
+		{0x0b4b, 0x0b4d, 1},
+		{0x0b56, 0x0b57, 1},
+		{0x0b5c, 0x0b5d, 1},
+		{0x0b5f, 0x0b63, 1},
+		{0x0b66, 0x0b77, 1},
+		{0x0b82, 0x0b83, 1},
+		{0x0b85, 0x0b8a, 1},
+		{0x0b8e, 0x0b90, 1},
+		{0x0b92, 0x0b95, 1},
+		{0x0b99, 0x0b9a, 1},
+		{0x0b9c, 0x0b9e, 2},
+		{0x0b9f, 0x0ba3, 4},
+		{0x0ba4, 0x0ba8, 4},
+		{0x0ba9, 0x0baa, 1},
+		{0x0bae, 0x0bb9, 1},
+		{0x0bbe, 0x0bc2, 1},
+		{0x0bc6, 0x0bc8, 1},
+		{0x0bca, 0x0bcd, 1},
+		{0x0bd0, 0x0bd7, 7},
+		{0x0be6, 0x0bfa, 1},
+		{0x0c00, 0x0c03, 1},
+		{0x0c05, 0x0c0c, 1},
+		{0x0c0e, 0x0c10, 1},
+		{0x0c12, 0x0c28, 1},
+		{0x0c2a, 0x0c39, 1},
+		{0x0c3d, 0x0c44, 1},
+		{0x0c46, 0x0c48, 1},
+		{0x0c4a, 0x0c4d, 1},
+		{0x0c55, 0x0c56, 1},
+		{0x0c58, 0x0c59, 1},
+		{0x0c60, 0x0c63, 1},
+		{0x0c66, 0x0c6f, 1},
+		{0x0c78, 0x0c7f, 1},
+		{0x0c81, 0x0c83, 1},
+		{0x0c85, 0x0c8c, 1},
+		{0x0c8e, 0x0c90, 1},
+		{0x0c92, 0x0ca8, 1},
+		{0x0caa, 0x0cb3, 1},
+		{0x0cb5, 0x0cb9, 1},
+		{0x0cbc, 0x0cc4, 1},
+		{0x0cc6, 0x0cc8, 1},
+		{0x0cca, 0x0ccd, 1},
+		{0x0cd5, 0x0cd6, 1},
+		{0x0cde, 0x0ce0, 2},
+		{0x0ce1, 0x0ce3, 1},
+		{0x0ce6, 0x0cef, 1},
+		{0x0cf1, 0x0cf2, 1},
+		{0x0d01, 0x0d03, 1},
+		{0x0d05, 0x0d0c, 1},
+		{0x0d0e, 0x0d10, 1},
+		{0x0d12, 0x0d3a, 1},
+		{0x0d3d, 0x0d44, 1},
+		{0x0d46, 0x0d48, 1},
+		{0x0d4a, 0x0d4e, 1},
+		{0x0d57, 0x0d60, 9},
+		{0x0d61, 0x0d63, 1},
+		{0x0d66, 0x0d75, 1},
+		{0x0d79, 0x0d7f, 1},
+		{0x0d82, 0x0d83, 1},
+		{0x0d85, 0x0d96, 1},
+		{0x0d9a, 0x0db1, 1},
+		{0x0db3, 0x0dbb, 1},
+		{0x0dbd, 0x0dc0, 3},
+		{0x0dc1, 0x0dc6, 1},
+		{0x0dca, 0x0dcf, 5},
+		{0x0dd0, 0x0dd4, 1},
+		{0x0dd6, 0x0dd8, 2},
+		{0x0dd9, 0x0ddf, 1},
+		{0x0de6, 0x0def, 1},
+		{0x0df2, 0x0df4, 1},
+		{0x0e01, 0x0e3a, 1},
+		{0x0e3f, 0x0e5b, 1},
+		{0x0e81, 0x0e82, 1},
+		{0x0e84, 0x0e87, 3},
+		{0x0e88, 0x0e8a, 2},
+		{0x0e8d, 0x0e94, 7},
+		{0x0e95, 0x0e97, 1},
+		{0x0e99, 0x0e9f, 1},
+		{0x0ea1, 0x0ea3, 1},
+		{0x0ea5, 0x0ea7, 2},
+		{0x0eaa, 0x0eab, 1},
+		{0x0ead, 0x0eb9, 1},
+		{0x0ebb, 0x0ebd, 1},
+		{0x0ec0, 0x0ec4, 1},
+		{0x0ec6, 0x0ec8, 2},
+		{0x0ec9, 0x0ecd, 1},
+		{0x0ed0, 0x0ed9, 1},
+		{0x0edc, 0x0edf, 1},
+		{0x0f00, 0x0f47, 1},
+		{0x0f49, 0x0f6c, 1},
+		{0x0f71, 0x0f97, 1},
+		{0x0f99, 0x0fbc, 1},
+		{0x0fbe, 0x0fcc, 1},
+		{0x0fce, 0x0fda, 1},
+		{0x1000, 0x10c5, 1},
+		{0x10c7, 0x10cd, 6},
+		{0x10d0, 0x1248, 1},
+		{0x124a, 0x124d, 1},
+		{0x1250, 0x1256, 1},
+		{0x1258, 0x125a, 2},
+		{0x125b, 0x125d, 1},
+		{0x1260, 0x1288, 1},
+		{0x128a, 0x128d, 1},
+		{0x1290, 0x12b0, 1},
+		{0x12b2, 0x12b5, 1},
+		{0x12b8, 0x12be, 1},
+		{0x12c0, 0x12c2, 2},
+		{0x12c3, 0x12c5, 1},
+		{0x12c8, 0x12d6, 1},
+		{0x12d8, 0x1310, 1},
+		{0x1312, 0x1315, 1},
+		{0x1318, 0x135a, 1},
+		{0x135d, 0x137c, 1},
+		{0x1380, 0x1399, 1},
+		{0x13a0, 0x13f4, 1},
+		{0x1400, 0x169c, 1},
+		{0x16a0, 0x16f8, 1},
+		{0x1700, 0x170c, 1},
+		{0x170e, 0x1714, 1},
+		{0x1720, 0x1736, 1},
+		{0x1740, 0x1753, 1},
+		{0x1760, 0x176c, 1},
+		{0x176e, 0x1770, 1},
+		{0x1772, 0x1773, 1},
+		{0x1780, 0x17dd, 1},
+		{0x17e0, 0x17e9, 1},
+		{0x17f0, 0x17f9, 1},
+		{0x1800, 0x180e, 1},
+		{0x1810, 0x1819, 1},
+		{0x1820, 0x1877, 1},
+		{0x1880, 0x18aa, 1},
+		{0x18b0, 0x18f5, 1},
+		{0x1900, 0x191e, 1},
+		{0x1920, 0x192b, 1},
+		{0x1930, 0x193b, 1},
+		{0x1940, 0x1944, 4},
+		{0x1945, 0x196d, 1},
+		{0x1970, 0x1974, 1},
+		{0x1980, 0x19ab, 1},
+		{0x19b0, 0x19c9, 1},
+		{0x19d0, 0x19da, 1},
+		{0x19de, 0x1a1b, 1},
+		{0x1a1e, 0x1a5e, 1},
+		{0x1a60, 0x1a7c, 1},
+		{0x1a7f, 0x1a89, 1},
+		{0x1a90, 0x1a99, 1},
+		{0x1aa0, 0x1aad, 1},
+		{0x1ab0, 0x1abe, 1},
+		{0x1b00, 0x1b4b, 1},
+		{0x1b50, 0x1b7c, 1},
+		{0x1b80, 0x1bf3, 1},
+		{0x1bfc, 0x1c37, 1},
+		{0x1c3b, 0x1c49, 1},
+		{0x1c4d, 0x1c7f, 1},
+		{0x1cc0, 0x1cc7, 1},
+		{0x1cd0, 0x1cf6, 1},
+		{0x1cf8, 0x1cf9, 1},
+		{0x1d00, 0x1df5, 1},
+		{0x1dfc, 0x1f15, 1},
+		{0x1f18, 0x1f1d, 1},
+		{0x1f20, 0x1f45, 1},
+		{0x1f48, 0x1f4d, 1},
+		{0x1f50, 0x1f57, 1},
+		{0x1f59, 0x1f5f, 2},
+		{0x1f60, 0x1f7d, 1},
+		{0x1f80, 0x1fb4, 1},
+		{0x1fb6, 0x1fc4, 1},
+		{0x1fc6, 0x1fd3, 1},
+		{0x1fd6, 0x1fdb, 1},
+		{0x1fdd, 0x1fef, 1},
+		{0x1ff2, 0x1ff4, 1},
+		{0x1ff6, 0x1ffe, 1},
+		{0x2000, 0x2064, 1},
+		{0x2066, 0x2071, 1},
+		{0x2074, 0x208e, 1},
+		{0x2090, 0x209c, 1},
+		{0x20a0, 0x20bd, 1},
+		{0x20d0, 0x20f0, 1},
+		{0x2100, 0x2189, 1},
+		{0x2190, 0x23fa, 1},
+		{0x2400, 0x2426, 1},
+		{0x2440, 0x244a, 1},
+		{0x2460, 0x2b73, 1},
+		{0x2b76, 0x2b95, 1},
+		{0x2b98, 0x2bb9, 1},
+		{0x2bbd, 0x2bc8, 1},
+		{0x2bca, 0x2bd1, 1},
+		{0x2c00, 0x2c2e, 1},
+		{0x2c30, 0x2c5e, 1},
+		{0x2c60, 0x2cf3, 1},
+		{0x2cf9, 0x2d25, 1},
+		{0x2d27, 0x2d2d, 6},
+		{0x2d30, 0x2d67, 1},
+		{0x2d6f, 0x2d70, 1},
+		{0x2d7f, 0x2d96, 1},
+		{0x2da0, 0x2da6, 1},
+		{0x2da8, 0x2dae, 1},
+		{0x2db0, 0x2db6, 1},
+		{0x2db8, 0x2dbe, 1},
+		{0x2dc0, 0x2dc6, 1},
+		{0x2dc8, 0x2dce, 1},
+		{0x2dd0, 0x2dd6, 1},
+		{0x2dd8, 0x2dde, 1},
+		{0x2de0, 0x2e42, 1},
+		{0x2e80, 0x2e99, 1},
+		{0x2e9b, 0x2ef3, 1},
+		{0x2f00, 0x2fd5, 1},
+		{0x2ff0, 0x2ffb, 1},
+		{0x3000, 0x303f, 1},
+		{0x3041, 0x3096, 1},
+		{0x3099, 0x30ff, 1},
+		{0x3105, 0x312d, 1},
+		{0x3131, 0x318e, 1},
+		{0x3190, 0x31ba, 1},
+		{0x31c0, 0x31e3, 1},
+		{0x31f0, 0x321e, 1},
+		{0x3220, 0x32fe, 1},
+		{0x3300, 0x4db5, 1},
+		{0x4dc0, 0x9fcc, 1},
+		{0xa000, 0xa48c, 1},
+		{0xa490, 0xa4c6, 1},
+		{0xa4d0, 0xa62b, 1},
+		{0xa640, 0xa69d, 1},
+		{0xa69f, 0xa6f7, 1},
+		{0xa700, 0xa78e, 1},
+		{0xa790, 0xa7ad, 1},
+		{0xa7b0, 0xa7b1, 1},
+		{0xa7f7, 0xa82b, 1},
+		{0xa830, 0xa839, 1},
+		{0xa840, 0xa877, 1},
+		{0xa880, 0xa8c4, 1},
+		{0xa8ce, 0xa8d9, 1},
+		{0xa8e0, 0xa8fb, 1},
+		{0xa900, 0xa953, 1},
+		{0xa95f, 0xa97c, 1},
+		{0xa980, 0xa9cd, 1},
+		{0xa9cf, 0xa9d9, 1},
+		{0xa9de, 0xa9fe, 1},
+		{0xaa00, 0xaa36, 1},
+		{0xaa40, 0xaa4d, 1},
+		{0xaa50, 0xaa59, 1},
+		{0xaa5c, 0xaac2, 1},
+		{0xaadb, 0xaaf6, 1},
+		{0xab01, 0xab06, 1},
+		{0xab09, 0xab0e, 1},
+		{0xab11, 0xab16, 1},
+		{0xab20, 0xab26, 1},
+		{0xab28, 0xab2e, 1},
+		{0xab30, 0xab5f, 1},
+		{0xab64, 0xab65, 1},
+		{0xabc0, 0xabed, 1},
+		{0xabf0, 0xabf9, 1},
+		{0xac00, 0xd7a3, 1},
+		{0xd7b0, 0xd7c6, 1},
+		{0xd7cb, 0xd7fb, 1},
+		{0xd800, 0xfa6d, 1},
+		{0xfa70, 0xfad9, 1},
+		{0xfb00, 0xfb06, 1},
+		{0xfb13, 0xfb17, 1},
+		{0xfb1d, 0xfb36, 1},
+		{0xfb38, 0xfb3c, 1},
+		{0xfb3e, 0xfb40, 2},
+		{0xfb41, 0xfb43, 2},
+		{0xfb44, 0xfb46, 2},
+		{0xfb47, 0xfbc1, 1},
+		{0xfbd3, 0xfd3f, 1},
+		{0xfd50, 0xfd8f, 1},
+		{0xfd92, 0xfdc7, 1},
+		{0xfdf0, 0xfdfd, 1},
+		{0xfe00, 0xfe19, 1},
+		{0xfe20, 0xfe2d, 1},
+		{0xfe30, 0xfe52, 1},
+		{0xfe54, 0xfe66, 1},
+		{0xfe68, 0xfe6b, 1},
+		{0xfe70, 0xfe74, 1},
+		{0xfe76, 0xfefc, 1},
+		{0xfeff, 0xff01, 2},
+		{0xff02, 0xffbe, 1},
+		{0xffc2, 0xffc7, 1},
+		{0xffca, 0xffcf, 1},
+		{0xffd2, 0xffd7, 1},
+		{0xffda, 0xffdc, 1},
+		{0xffe0, 0xffe6, 1},
+		{0xffe8, 0xffee, 1},
+		{0xfff9, 0xfffd, 1},
+	},
+	R32: []unicode.Range32{
+		{0x00010000, 0x0001000b, 1},
+		{0x0001000d, 0x00010026, 1},
+		{0x00010028, 0x0001003a, 1},
+		{0x0001003c, 0x0001003d, 1},
+		{0x0001003f, 0x0001004d, 1},
+		{0x00010050, 0x0001005d, 1},
+		{0x00010080, 0x000100fa, 1},
+		{0x00010100, 0x00010102, 1},
+		{0x00010107, 0x00010133, 1},
+		{0x00010137, 0x0001018c, 1},
+		{0x00010190, 0x0001019b, 1},
+		{0x000101a0, 0x000101d0, 48},
+		{0x000101d1, 0x000101fd, 1},
+		{0x00010280, 0x0001029c, 1},
+		{0x000102a0, 0x000102d0, 1},
+		{0x000102e0, 0x000102fb, 1},
+		{0x00010300, 0x00010323, 1},
+		{0x00010330, 0x0001034a, 1},
+		{0x00010350, 0x0001037a, 1},
+		{0x00010380, 0x0001039d, 1},
+		{0x0001039f, 0x000103c3, 1},
+		{0x000103c8, 0x000103d5, 1},
+		{0x00010400, 0x0001049d, 1},
+		{0x000104a0, 0x000104a9, 1},
+		{0x00010500, 0x00010527, 1},
+		{0x00010530, 0x00010563, 1},
+		{0x0001056f, 0x00010600, 145},
+		{0x00010601, 0x00010736, 1},
+		{0x00010740, 0x00010755, 1},
+		{0x00010760, 0x00010767, 1},
+		{0x00010800, 0x00010805, 1},
+		{0x00010808, 0x0001080a, 2},
+		{0x0001080b, 0x00010835, 1},
+		{0x00010837, 0x00010838, 1},
+		{0x0001083c, 0x0001083f, 3},
+		{0x00010840, 0x00010855, 1},
+		{0x00010857, 0x0001089e, 1},
+		{0x000108a7, 0x000108af, 1},
+		{0x00010900, 0x0001091b, 1},
+		{0x0001091f, 0x00010939, 1},
+		{0x0001093f, 0x00010980, 65},
+		{0x00010981, 0x000109b7, 1},
+		{0x000109be, 0x000109bf, 1},
+		{0x00010a00, 0x00010a03, 1},
+		{0x00010a05, 0x00010a06, 1},
+		{0x00010a0c, 0x00010a13, 1},
+		{0x00010a15, 0x00010a17, 1},
+		{0x00010a19, 0x00010a33, 1},
+		{0x00010a38, 0x00010a3a, 1},
+		{0x00010a3f, 0x00010a47, 1},
+		{0x00010a50, 0x00010a58, 1},
+		{0x00010a60, 0x00010a9f, 1},
+		{0x00010ac0, 0x00010ae6, 1},
+		{0x00010aeb, 0x00010af6, 1},
+		{0x00010b00, 0x00010b35, 1},
+		{0x00010b39, 0x00010b55, 1},
+		{0x00010b58, 0x00010b72, 1},
+		{0x00010b78, 0x00010b91, 1},
+		{0x00010b99, 0x00010b9c, 1},
+		{0x00010ba9, 0x00010baf, 1},
+		{0x00010c00, 0x00010c48, 1},
+		{0x00010e60, 0x00010e7e, 1},
+		{0x00011000, 0x0001104d, 1},
+		{0x00011052, 0x0001106f, 1},
+		{0x0001107f, 0x000110c1, 1},
+		{0x000110d0, 0x000110e8, 1},
+		{0x000110f0, 0x000110f9, 1},
+		{0x00011100, 0x00011134, 1},
+		{0x00011136, 0x00011143, 1},
+		{0x00011150, 0x00011176, 1},
+		{0x00011180, 0x000111c8, 1},
+		{0x000111cd, 0x000111d0, 3},
+		{0x000111d1, 0x000111da, 1},
+		{0x000111e1, 0x000111f4, 1},
+		{0x00011200, 0x00011211, 1},
+		{0x00011213, 0x0001123d, 1},
+		{0x000112b0, 0x000112ea, 1},
+		{0x000112f0, 0x000112f9, 1},
+		{0x00011301, 0x00011303, 1},
+		{0x00011305, 0x0001130c, 1},
+		{0x0001130f, 0x00011310, 1},
+		{0x00011313, 0x00011328, 1},
+		{0x0001132a, 0x00011330, 1},
+		{0x00011332, 0x00011333, 1},
+		{0x00011335, 0x00011339, 1},
+		{0x0001133c, 0x00011344, 1},
+		{0x00011347, 0x00011348, 1},
+		{0x0001134b, 0x0001134d, 1},
+		{0x00011357, 0x0001135d, 6},
+		{0x0001135e, 0x00011363, 1},
+		{0x00011366, 0x0001136c, 1},
+		{0x00011370, 0x00011374, 1},
+		{0x00011480, 0x000114c7, 1},
+		{0x000114d0, 0x000114d9, 1},
+		{0x00011580, 0x000115b5, 1},
+		{0x000115b8, 0x000115c9, 1},
+		{0x00011600, 0x00011644, 1},
+		{0x00011650, 0x00011659, 1},
+		{0x00011680, 0x000116b7, 1},
+		{0x000116c0, 0x000116c9, 1},
+		{0x000118a0, 0x000118f2, 1},
+		{0x000118ff, 0x00011ac0, 449},
+		{0x00011ac1, 0x00011af8, 1},
+		{0x00012000, 0x00012398, 1},
+		{0x00012400, 0x0001246e, 1},
+		{0x00012470, 0x00012474, 1},
+		{0x00013000, 0x0001342e, 1},
+		{0x00016800, 0x00016a38, 1},
+		{0x00016a40, 0x00016a5e, 1},
+		{0x00016a60, 0x00016a69, 1},
+		{0x00016a6e, 0x00016a6f, 1},
+		{0x00016ad0, 0x00016aed, 1},
+		{0x00016af0, 0x00016af5, 1},
+		{0x00016b00, 0x00016b45, 1},
+		{0x00016b50, 0x00016b59, 1},
+		{0x00016b5b, 0x00016b61, 1},
+		{0x00016b63, 0x00016b77, 1},
+		{0x00016b7d, 0x00016b8f, 1},
+		{0x00016f00, 0x00016f44, 1},
+		{0x00016f50, 0x00016f7e, 1},
+		{0x00016f8f, 0x00016f9f, 1},
+		{0x0001b000, 0x0001b001, 1},
+		{0x0001bc00, 0x0001bc6a, 1},
+		{0x0001bc70, 0x0001bc7c, 1},
+		{0x0001bc80, 0x0001bc88, 1},
+		{0x0001bc90, 0x0001bc99, 1},
+		{0x0001bc9c, 0x0001bca3, 1},
+		{0x0001d000, 0x0001d0f5, 1},
+		{0x0001d100, 0x0001d126, 1},
+		{0x0001d129, 0x0001d1dd, 1},
+		{0x0001d200, 0x0001d245, 1},
+		{0x0001d300, 0x0001d356, 1},
+		{0x0001d360, 0x0001d371, 1},
+		{0x0001d400, 0x0001d454, 1},
+		{0x0001d456, 0x0001d49c, 1},
+		{0x0001d49e, 0x0001d49f, 1},
+		{0x0001d4a2, 0x0001d4a5, 3},
+		{0x0001d4a6, 0x0001d4a9, 3},
+		{0x0001d4aa, 0x0001d4ac, 1},
+		{0x0001d4ae, 0x0001d4b9, 1},
+		{0x0001d4bb, 0x0001d4bd, 2},
+		{0x0001d4be, 0x0001d4c3, 1},
+		{0x0001d4c5, 0x0001d505, 1},
+		{0x0001d507, 0x0001d50a, 1},
+		{0x0001d50d, 0x0001d514, 1},
+		{0x0001d516, 0x0001d51c, 1},
+		{0x0001d51e, 0x0001d539, 1},
+		{0x0001d53b, 0x0001d53e, 1},
+		{0x0001d540, 0x0001d544, 1},
+		{0x0001d546, 0x0001d54a, 4},
+		{0x0001d54b, 0x0001d550, 1},
+		{0x0001d552, 0x0001d6a5, 1},
+		{0x0001d6a8, 0x0001d7cb, 1},
+		{0x0001d7ce, 0x0001d7ff, 1},
+		{0x0001e800, 0x0001e8c4, 1},
+		{0x0001e8c7, 0x0001e8d6, 1},
+		{0x0001ee00, 0x0001ee03, 1},
+		{0x0001ee05, 0x0001ee1f, 1},
+		{0x0001ee21, 0x0001ee22, 1},
+		{0x0001ee24, 0x0001ee27, 3},
+		{0x0001ee29, 0x0001ee32, 1},
+		{0x0001ee34, 0x0001ee37, 1},
+		{0x0001ee39, 0x0001ee3b, 2},
+		{0x0001ee42, 0x0001ee47, 5},
+		{0x0001ee49, 0x0001ee4d, 2},
+		{0x0001ee4e, 0x0001ee4f, 1},
+		{0x0001ee51, 0x0001ee52, 1},
+		{0x0001ee54, 0x0001ee57, 3},
+		{0x0001ee59, 0x0001ee61, 2},
+		{0x0001ee62, 0x0001ee64, 2},
+		{0x0001ee67, 0x0001ee6a, 1},
+		{0x0001ee6c, 0x0001ee72, 1},
+		{0x0001ee74, 0x0001ee77, 1},
+		{0x0001ee79, 0x0001ee7c, 1},
+		{0x0001ee7e, 0x0001ee80, 2},
+		{0x0001ee81, 0x0001ee89, 1},
+		{0x0001ee8b, 0x0001ee9b, 1},
+		{0x0001eea1, 0x0001eea3, 1},
+		{0x0001eea5, 0x0001eea9, 1},
+		{0x0001eeab, 0x0001eebb, 1},
+		{0x0001eef0, 0x0001eef1, 1},
+		{0x0001f000, 0x0001f02b, 1},
+		{0x0001f030, 0x0001f093, 1},
+		{0x0001f0a0, 0x0001f0ae, 1},
+		{0x0001f0b1, 0x0001f0bf, 1},
+		{0x0001f0c1, 0x0001f0cf, 1},
+		{0x0001f0d1, 0x0001f0f5, 1},
+		{0x0001f100, 0x0001f10c, 1},
+		{0x0001f110, 0x0001f12e, 1},
+		{0x0001f130, 0x0001f16b, 1},
+		{0x0001f170, 0x0001f19a, 1},
+		{0x0001f1e6, 0x0001f202, 1},
+		{0x0001f210, 0x0001f23a, 1},
+		{0x0001f240, 0x0001f248, 1},
+		{0x0001f250, 0x0001f251, 1},
+		{0x0001f300, 0x0001f32c, 1},
+		{0x0001f330, 0x0001f37d, 1},
+		{0x0001f380, 0x0001f3ce, 1},
+		{0x0001f3d4, 0x0001f3f7, 1},
+		{0x0001f400, 0x0001f4fe, 1},
+		{0x0001f500, 0x0001f54a, 1},
+		{0x0001f550, 0x0001f579, 1},
+		{0x0001f57b, 0x0001f5a3, 1},
+		{0x0001f5a5, 0x0001f642, 1},
+		{0x0001f645, 0x0001f6cf, 1},
+		{0x0001f6e0, 0x0001f6ec, 1},
+		{0x0001f6f0, 0x0001f6f3, 1},
+		{0x0001f700, 0x0001f773, 1},
+		{0x0001f780, 0x0001f7d4, 1},
+		{0x0001f800, 0x0001f80b, 1},
+		{0x0001f810, 0x0001f847, 1},
+		{0x0001f850, 0x0001f859, 1},
+		{0x0001f860, 0x0001f887, 1},
+		{0x0001f890, 0x0001f8ad, 1},
+		{0x00020000, 0x0002a6d6, 1},
+		{0x0002a700, 0x0002b734, 1},
+		{0x0002b740, 0x0002b81d, 1},
+		{0x0002f800, 0x0002fa1d, 1},
+		{0x000e0001, 0x000e0020, 31},
+		{0x000e0021, 0x000e007f, 1},
+		{0x000e0100, 0x000e01ef, 1},
+		{0x000f0000, 0x000ffffd, 1},
+		{0x00100000, 0x0010fffd, 1},
+	},
+	LatinOffset: 0,
+}
+
+// size 5048 bytes (4 KiB)
+var assigned8_0_0 = &unicode.RangeTable{
+	R16: []unicode.Range16{
+		{0x0000, 0x0377, 1},
+		{0x037a, 0x037f, 1},
+		{0x0384, 0x038a, 1},
+		{0x038c, 0x038e, 2},
+		{0x038f, 0x03a1, 1},
+		{0x03a3, 0x052f, 1},
+		{0x0531, 0x0556, 1},
+		{0x0559, 0x055f, 1},
+		{0x0561, 0x0587, 1},
+		{0x0589, 0x058a, 1},
+		{0x058d, 0x058f, 1},
+		{0x0591, 0x05c7, 1},
+		{0x05d0, 0x05ea, 1},
+		{0x05f0, 0x05f4, 1},
+		{0x0600, 0x061c, 1},
+		{0x061e, 0x070d, 1},
+		{0x070f, 0x074a, 1},
+		{0x074d, 0x07b1, 1},
+		{0x07c0, 0x07fa, 1},
+		{0x0800, 0x082d, 1},
+		{0x0830, 0x083e, 1},
+		{0x0840, 0x085b, 1},
+		{0x085e, 0x08a0, 66},
+		{0x08a1, 0x08b4, 1},
+		{0x08e3, 0x0983, 1},
+		{0x0985, 0x098c, 1},
+		{0x098f, 0x0990, 1},
+		{0x0993, 0x09a8, 1},
+		{0x09aa, 0x09b0, 1},
+		{0x09b2, 0x09b6, 4},
+		{0x09b7, 0x09b9, 1},
+		{0x09bc, 0x09c4, 1},
+		{0x09c7, 0x09c8, 1},
+		{0x09cb, 0x09ce, 1},
+		{0x09d7, 0x09dc, 5},
+		{0x09dd, 0x09df, 2},
+		{0x09e0, 0x09e3, 1},
+		{0x09e6, 0x09fb, 1},
+		{0x0a01, 0x0a03, 1},
+		{0x0a05, 0x0a0a, 1},
+		{0x0a0f, 0x0a10, 1},
+		{0x0a13, 0x0a28, 1},
+		{0x0a2a, 0x0a30, 1},
+		{0x0a32, 0x0a33, 1},
+		{0x0a35, 0x0a36, 1},
+		{0x0a38, 0x0a39, 1},
+		{0x0a3c, 0x0a3e, 2},
+		{0x0a3f, 0x0a42, 1},
+		{0x0a47, 0x0a48, 1},
+		{0x0a4b, 0x0a4d, 1},
+		{0x0a51, 0x0a59, 8},
+		{0x0a5a, 0x0a5c, 1},
+		{0x0a5e, 0x0a66, 8},
+		{0x0a67, 0x0a75, 1},
+		{0x0a81, 0x0a83, 1},
+		{0x0a85, 0x0a8d, 1},
+		{0x0a8f, 0x0a91, 1},
+		{0x0a93, 0x0aa8, 1},
+		{0x0aaa, 0x0ab0, 1},
+		{0x0ab2, 0x0ab3, 1},
+		{0x0ab5, 0x0ab9, 1},
+		{0x0abc, 0x0ac5, 1},
+		{0x0ac7, 0x0ac9, 1},
+		{0x0acb, 0x0acd, 1},
+		{0x0ad0, 0x0ae0, 16},
+		{0x0ae1, 0x0ae3, 1},
+		{0x0ae6, 0x0af1, 1},
+		{0x0af9, 0x0b01, 8},
+		{0x0b02, 0x0b03, 1},
+		{0x0b05, 0x0b0c, 1},
+		{0x0b0f, 0x0b10, 1},
+		{0x0b13, 0x0b28, 1},
+		{0x0b2a, 0x0b30, 1},
+		{0x0b32, 0x0b33, 1},
+		{0x0b35, 0x0b39, 1},
+		{0x0b3c, 0x0b44, 1},
+		{0x0b47, 0x0b48, 1},
+		{0x0b4b, 0x0b4d, 1},
+		{0x0b56, 0x0b57, 1},
+		{0x0b5c, 0x0b5d, 1},
+		{0x0b5f, 0x0b63, 1},
+		{0x0b66, 0x0b77, 1},
+		{0x0b82, 0x0b83, 1},
+		{0x0b85, 0x0b8a, 1},
+		{0x0b8e, 0x0b90, 1},
+		{0x0b92, 0x0b95, 1},
+		{0x0b99, 0x0b9a, 1},
+		{0x0b9c, 0x0b9e, 2},
+		{0x0b9f, 0x0ba3, 4},
+		{0x0ba4, 0x0ba8, 4},
+		{0x0ba9, 0x0baa, 1},
+		{0x0bae, 0x0bb9, 1},
+		{0x0bbe, 0x0bc2, 1},
+		{0x0bc6, 0x0bc8, 1},
+		{0x0bca, 0x0bcd, 1},
+		{0x0bd0, 0x0bd7, 7},
+		{0x0be6, 0x0bfa, 1},
+		{0x0c00, 0x0c03, 1},
+		{0x0c05, 0x0c0c, 1},
+		{0x0c0e, 0x0c10, 1},
+		{0x0c12, 0x0c28, 1},
+		{0x0c2a, 0x0c39, 1},
+		{0x0c3d, 0x0c44, 1},
+		{0x0c46, 0x0c48, 1},
+		{0x0c4a, 0x0c4d, 1},
+		{0x0c55, 0x0c56, 1},
+		{0x0c58, 0x0c5a, 1},
+		{0x0c60, 0x0c63, 1},
+		{0x0c66, 0x0c6f, 1},
+		{0x0c78, 0x0c7f, 1},
+		{0x0c81, 0x0c83, 1},
+		{0x0c85, 0x0c8c, 1},
+		{0x0c8e, 0x0c90, 1},
+		{0x0c92, 0x0ca8, 1},
+		{0x0caa, 0x0cb3, 1},
+		{0x0cb5, 0x0cb9, 1},
+		{0x0cbc, 0x0cc4, 1},
+		{0x0cc6, 0x0cc8, 1},
+		{0x0cca, 0x0ccd, 1},
+		{0x0cd5, 0x0cd6, 1},
+		{0x0cde, 0x0ce0, 2},
+		{0x0ce1, 0x0ce3, 1},
+		{0x0ce6, 0x0cef, 1},
+		{0x0cf1, 0x0cf2, 1},
+		{0x0d01, 0x0d03, 1},
+		{0x0d05, 0x0d0c, 1},
+		{0x0d0e, 0x0d10, 1},
+		{0x0d12, 0x0d3a, 1},
+		{0x0d3d, 0x0d44, 1},
+		{0x0d46, 0x0d48, 1},
+		{0x0d4a, 0x0d4e, 1},
+		{0x0d57, 0x0d5f, 8},
+		{0x0d60, 0x0d63, 1},
+		{0x0d66, 0x0d75, 1},
+		{0x0d79, 0x0d7f, 1},
+		{0x0d82, 0x0d83, 1},
+		{0x0d85, 0x0d96, 1},
+		{0x0d9a, 0x0db1, 1},
+		{0x0db3, 0x0dbb, 1},
+		{0x0dbd, 0x0dc0, 3},
+		{0x0dc1, 0x0dc6, 1},
+		{0x0dca, 0x0dcf, 5},
+		{0x0dd0, 0x0dd4, 1},
+		{0x0dd6, 0x0dd8, 2},
+		{0x0dd9, 0x0ddf, 1},
+		{0x0de6, 0x0def, 1},
+		{0x0df2, 0x0df4, 1},
+		{0x0e01, 0x0e3a, 1},
+		{0x0e3f, 0x0e5b, 1},
+		{0x0e81, 0x0e82, 1},
+		{0x0e84, 0x0e87, 3},
+		{0x0e88, 0x0e8a, 2},
+		{0x0e8d, 0x0e94, 7},
+		{0x0e95, 0x0e97, 1},
+		{0x0e99, 0x0e9f, 1},
+		{0x0ea1, 0x0ea3, 1},
+		{0x0ea5, 0x0ea7, 2},
+		{0x0eaa, 0x0eab, 1},
+		{0x0ead, 0x0eb9, 1},
+		{0x0ebb, 0x0ebd, 1},
+		{0x0ec0, 0x0ec4, 1},
+		{0x0ec6, 0x0ec8, 2},
+		{0x0ec9, 0x0ecd, 1},
+		{0x0ed0, 0x0ed9, 1},
+		{0x0edc, 0x0edf, 1},
+		{0x0f00, 0x0f47, 1},
+		{0x0f49, 0x0f6c, 1},
+		{0x0f71, 0x0f97, 1},
+		{0x0f99, 0x0fbc, 1},
+		{0x0fbe, 0x0fcc, 1},
+		{0x0fce, 0x0fda, 1},
+		{0x1000, 0x10c5, 1},
+		{0x10c7, 0x10cd, 6},
+		{0x10d0, 0x1248, 1},
+		{0x124a, 0x124d, 1},
+		{0x1250, 0x1256, 1},
+		{0x1258, 0x125a, 2},
+		{0x125b, 0x125d, 1},
+		{0x1260, 0x1288, 1},
+		{0x128a, 0x128d, 1},
+		{0x1290, 0x12b0, 1},
+		{0x12b2, 0x12b5, 1},
+		{0x12b8, 0x12be, 1},
+		{0x12c0, 0x12c2, 2},
+		{0x12c3, 0x12c5, 1},
+		{0x12c8, 0x12d6, 1},
+		{0x12d8, 0x1310, 1},
+		{0x1312, 0x1315, 1},
+		{0x1318, 0x135a, 1},
+		{0x135d, 0x137c, 1},
+		{0x1380, 0x1399, 1},
+		{0x13a0, 0x13f5, 1},
+		{0x13f8, 0x13fd, 1},
+		{0x1400, 0x169c, 1},
+		{0x16a0, 0x16f8, 1},
+		{0x1700, 0x170c, 1},
+		{0x170e, 0x1714, 1},
+		{0x1720, 0x1736, 1},
+		{0x1740, 0x1753, 1},
+		{0x1760, 0x176c, 1},
+		{0x176e, 0x1770, 1},
+		{0x1772, 0x1773, 1},
+		{0x1780, 0x17dd, 1},
+		{0x17e0, 0x17e9, 1},
+		{0x17f0, 0x17f9, 1},
+		{0x1800, 0x180e, 1},
+		{0x1810, 0x1819, 1},
+		{0x1820, 0x1877, 1},
+		{0x1880, 0x18aa, 1},
+		{0x18b0, 0x18f5, 1},
+		{0x1900, 0x191e, 1},
+		{0x1920, 0x192b, 1},
+		{0x1930, 0x193b, 1},
+		{0x1940, 0x1944, 4},
+		{0x1945, 0x196d, 1},
+		{0x1970, 0x1974, 1},
+		{0x1980, 0x19ab, 1},
+		{0x19b0, 0x19c9, 1},
+		{0x19d0, 0x19da, 1},
+		{0x19de, 0x1a1b, 1},
+		{0x1a1e, 0x1a5e, 1},
+		{0x1a60, 0x1a7c, 1},
+		{0x1a7f, 0x1a89, 1},
+		{0x1a90, 0x1a99, 1},
+		{0x1aa0, 0x1aad, 1},
+		{0x1ab0, 0x1abe, 1},
+		{0x1b00, 0x1b4b, 1},
+		{0x1b50, 0x1b7c, 1},
+		{0x1b80, 0x1bf3, 1},
+		{0x1bfc, 0x1c37, 1},
+		{0x1c3b, 0x1c49, 1},
+		{0x1c4d, 0x1c7f, 1},
+		{0x1cc0, 0x1cc7, 1},
+		{0x1cd0, 0x1cf6, 1},
+		{0x1cf8, 0x1cf9, 1},
+		{0x1d00, 0x1df5, 1},
+		{0x1dfc, 0x1f15, 1},
+		{0x1f18, 0x1f1d, 1},
+		{0x1f20, 0x1f45, 1},
+		{0x1f48, 0x1f4d, 1},
+		{0x1f50, 0x1f57, 1},
+		{0x1f59, 0x1f5f, 2},
+		{0x1f60, 0x1f7d, 1},
+		{0x1f80, 0x1fb4, 1},
+		{0x1fb6, 0x1fc4, 1},
+		{0x1fc6, 0x1fd3, 1},
+		{0x1fd6, 0x1fdb, 1},
+		{0x1fdd, 0x1fef, 1},
+		{0x1ff2, 0x1ff4, 1},
+		{0x1ff6, 0x1ffe, 1},
+		{0x2000, 0x2064, 1},
+		{0x2066, 0x2071, 1},
+		{0x2074, 0x208e, 1},
+		{0x2090, 0x209c, 1},
+		{0x20a0, 0x20be, 1},
+		{0x20d0, 0x20f0, 1},
+		{0x2100, 0x218b, 1},
+		{0x2190, 0x23fa, 1},
+		{0x2400, 0x2426, 1},
+		{0x2440, 0x244a, 1},
+		{0x2460, 0x2b73, 1},
+		{0x2b76, 0x2b95, 1},
+		{0x2b98, 0x2bb9, 1},
+		{0x2bbd, 0x2bc8, 1},
+		{0x2bca, 0x2bd1, 1},
+		{0x2bec, 0x2bef, 1},
+		{0x2c00, 0x2c2e, 1},
+		{0x2c30, 0x2c5e, 1},
+		{0x2c60, 0x2cf3, 1},
+		{0x2cf9, 0x2d25, 1},
+		{0x2d27, 0x2d2d, 6},
+		{0x2d30, 0x2d67, 1},
+		{0x2d6f, 0x2d70, 1},
+		{0x2d7f, 0x2d96, 1},
+		{0x2da0, 0x2da6, 1},
+		{0x2da8, 0x2dae, 1},
+		{0x2db0, 0x2db6, 1},
+		{0x2db8, 0x2dbe, 1},
+		{0x2dc0, 0x2dc6, 1},
+		{0x2dc8, 0x2dce, 1},
+		{0x2dd0, 0x2dd6, 1},
+		{0x2dd8, 0x2dde, 1},
+		{0x2de0, 0x2e42, 1},
+		{0x2e80, 0x2e99, 1},
+		{0x2e9b, 0x2ef3, 1},
+		{0x2f00, 0x2fd5, 1},
+		{0x2ff0, 0x2ffb, 1},
+		{0x3000, 0x303f, 1},
+		{0x3041, 0x3096, 1},
+		{0x3099, 0x30ff, 1},
+		{0x3105, 0x312d, 1},
+		{0x3131, 0x318e, 1},
+		{0x3190, 0x31ba, 1},
+		{0x31c0, 0x31e3, 1},
+		{0x31f0, 0x321e, 1},
+		{0x3220, 0x32fe, 1},
+		{0x3300, 0x4db5, 1},
+		{0x4dc0, 0x9fd5, 1},
+		{0xa000, 0xa48c, 1},
+		{0xa490, 0xa4c6, 1},
+		{0xa4d0, 0xa62b, 1},
+		{0xa640, 0xa6f7, 1},
+		{0xa700, 0xa7ad, 1},
+		{0xa7b0, 0xa7b7, 1},
+		{0xa7f7, 0xa82b, 1},
+		{0xa830, 0xa839, 1},
+		{0xa840, 0xa877, 1},
+		{0xa880, 0xa8c4, 1},
+		{0xa8ce, 0xa8d9, 1},
+		{0xa8e0, 0xa8fd, 1},
+		{0xa900, 0xa953, 1},
+		{0xa95f, 0xa97c, 1},
+		{0xa980, 0xa9cd, 1},
+		{0xa9cf, 0xa9d9, 1},
+		{0xa9de, 0xa9fe, 1},
+		{0xaa00, 0xaa36, 1},
+		{0xaa40, 0xaa4d, 1},
+		{0xaa50, 0xaa59, 1},
+		{0xaa5c, 0xaac2, 1},
+		{0xaadb, 0xaaf6, 1},
+		{0xab01, 0xab06, 1},
+		{0xab09, 0xab0e, 1},
+		{0xab11, 0xab16, 1},
+		{0xab20, 0xab26, 1},
+		{0xab28, 0xab2e, 1},
+		{0xab30, 0xab65, 1},
+		{0xab70, 0xabed, 1},
+		{0xabf0, 0xabf9, 1},
+		{0xac00, 0xd7a3, 1},
+		{0xd7b0, 0xd7c6, 1},
+		{0xd7cb, 0xd7fb, 1},
+		{0xd800, 0xfa6d, 1},
+		{0xfa70, 0xfad9, 1},
+		{0xfb00, 0xfb06, 1},
+		{0xfb13, 0xfb17, 1},
+		{0xfb1d, 0xfb36, 1},
+		{0xfb38, 0xfb3c, 1},
+		{0xfb3e, 0xfb40, 2},
+		{0xfb41, 0xfb43, 2},
+		{0xfb44, 0xfb46, 2},
+		{0xfb47, 0xfbc1, 1},
+		{0xfbd3, 0xfd3f, 1},
+		{0xfd50, 0xfd8f, 1},
+		{0xfd92, 0xfdc7, 1},
+		{0xfdf0, 0xfdfd, 1},
+		{0xfe00, 0xfe19, 1},
+		{0xfe20, 0xfe52, 1},
+		{0xfe54, 0xfe66, 1},
+		{0xfe68, 0xfe6b, 1},
+		{0xfe70, 0xfe74, 1},
+		{0xfe76, 0xfefc, 1},
+		{0xfeff, 0xff01, 2},
+		{0xff02, 0xffbe, 1},
+		{0xffc2, 0xffc7, 1},
+		{0xffca, 0xffcf, 1},
+		{0xffd2, 0xffd7, 1},
+		{0xffda, 0xffdc, 1},
+		{0xffe0, 0xffe6, 1},
+		{0xffe8, 0xffee, 1},
+		{0xfff9, 0xfffd, 1},
+	},
+	R32: []unicode.Range32{
+		{0x00010000, 0x0001000b, 1},
+		{0x0001000d, 0x00010026, 1},
+		{0x00010028, 0x0001003a, 1},
+		{0x0001003c, 0x0001003d, 1},
+		{0x0001003f, 0x0001004d, 1},
+		{0x00010050, 0x0001005d, 1},
+		{0x00010080, 0x000100fa, 1},
+		{0x00010100, 0x00010102, 1},
+		{0x00010107, 0x00010133, 1},
+		{0x00010137, 0x0001018c, 1},
+		{0x00010190, 0x0001019b, 1},
+		{0x000101a0, 0x000101d0, 48},
+		{0x000101d1, 0x000101fd, 1},
+		{0x00010280, 0x0001029c, 1},
+		{0x000102a0, 0x000102d0, 1},
+		{0x000102e0, 0x000102fb, 1},
+		{0x00010300, 0x00010323, 1},
+		{0x00010330, 0x0001034a, 1},
+		{0x00010350, 0x0001037a, 1},
+		{0x00010380, 0x0001039d, 1},
+		{0x0001039f, 0x000103c3, 1},
+		{0x000103c8, 0x000103d5, 1},
+		{0x00010400, 0x0001049d, 1},
+		{0x000104a0, 0x000104a9, 1},
+		{0x00010500, 0x00010527, 1},
+		{0x00010530, 0x00010563, 1},
+		{0x0001056f, 0x00010600, 145},
+		{0x00010601, 0x00010736, 1},
+		{0x00010740, 0x00010755, 1},
+		{0x00010760, 0x00010767, 1},
+		{0x00010800, 0x00010805, 1},
+		{0x00010808, 0x0001080a, 2},
+		{0x0001080b, 0x00010835, 1},
+		{0x00010837, 0x00010838, 1},
+		{0x0001083c, 0x0001083f, 3},
+		{0x00010840, 0x00010855, 1},
+		{0x00010857, 0x0001089e, 1},
+		{0x000108a7, 0x000108af, 1},
+		{0x000108e0, 0x000108f2, 1},
+		{0x000108f4, 0x000108f5, 1},
+		{0x000108fb, 0x0001091b, 1},
+		{0x0001091f, 0x00010939, 1},
+		{0x0001093f, 0x00010980, 65},
+		{0x00010981, 0x000109b7, 1},
+		{0x000109bc, 0x000109cf, 1},
+		{0x000109d2, 0x00010a03, 1},
+		{0x00010a05, 0x00010a06, 1},
+		{0x00010a0c, 0x00010a13, 1},
+		{0x00010a15, 0x00010a17, 1},
+		{0x00010a19, 0x00010a33, 1},
+		{0x00010a38, 0x00010a3a, 1},
+		{0x00010a3f, 0x00010a47, 1},
+		{0x00010a50, 0x00010a58, 1},
+		{0x00010a60, 0x00010a9f, 1},
+		{0x00010ac0, 0x00010ae6, 1},
+		{0x00010aeb, 0x00010af6, 1},
+		{0x00010b00, 0x00010b35, 1},
+		{0x00010b39, 0x00010b55, 1},
+		{0x00010b58, 0x00010b72, 1},
+		{0x00010b78, 0x00010b91, 1},
+		{0x00010b99, 0x00010b9c, 1},
+		{0x00010ba9, 0x00010baf, 1},
+		{0x00010c00, 0x00010c48, 1},
+		{0x00010c80, 0x00010cb2, 1},
+		{0x00010cc0, 0x00010cf2, 1},
+		{0x00010cfa, 0x00010cff, 1},
+		{0x00010e60, 0x00010e7e, 1},
+		{0x00011000, 0x0001104d, 1},
+		{0x00011052, 0x0001106f, 1},
+		{0x0001107f, 0x000110c1, 1},
+		{0x000110d0, 0x000110e8, 1},
+		{0x000110f0, 0x000110f9, 1},
+		{0x00011100, 0x00011134, 1},
+		{0x00011136, 0x00011143, 1},
+		{0x00011150, 0x00011176, 1},
+		{0x00011180, 0x000111cd, 1},
+		{0x000111d0, 0x000111df, 1},
+		{0x000111e1, 0x000111f4, 1},
+		{0x00011200, 0x00011211, 1},
+		{0x00011213, 0x0001123d, 1},
+		{0x00011280, 0x00011286, 1},
+		{0x00011288, 0x0001128a, 2},
+		{0x0001128b, 0x0001128d, 1},
+		{0x0001128f, 0x0001129d, 1},
+		{0x0001129f, 0x000112a9, 1},
+		{0x000112b0, 0x000112ea, 1},
+		{0x000112f0, 0x000112f9, 1},
+		{0x00011300, 0x00011303, 1},
+		{0x00011305, 0x0001130c, 1},
+		{0x0001130f, 0x00011310, 1},
+		{0x00011313, 0x00011328, 1},
+		{0x0001132a, 0x00011330, 1},
+		{0x00011332, 0x00011333, 1},
+		{0x00011335, 0x00011339, 1},
+		{0x0001133c, 0x00011344, 1},
+		{0x00011347, 0x00011348, 1},
+		{0x0001134b, 0x0001134d, 1},
+		{0x00011350, 0x00011357, 7},
+		{0x0001135d, 0x00011363, 1},
+		{0x00011366, 0x0001136c, 1},
+		{0x00011370, 0x00011374, 1},
+		{0x00011480, 0x000114c7, 1},
+		{0x000114d0, 0x000114d9, 1},
+		{0x00011580, 0x000115b5, 1},
+		{0x000115b8, 0x000115dd, 1},
+		{0x00011600, 0x00011644, 1},
+		{0x00011650, 0x00011659, 1},
+		{0x00011680, 0x000116b7, 1},
+		{0x000116c0, 0x000116c9, 1},
+		{0x00011700, 0x00011719, 1},
+		{0x0001171d, 0x0001172b, 1},
+		{0x00011730, 0x0001173f, 1},
+		{0x000118a0, 0x000118f2, 1},
+		{0x000118ff, 0x00011ac0, 449},
+		{0x00011ac1, 0x00011af8, 1},
+		{0x00012000, 0x00012399, 1},
+		{0x00012400, 0x0001246e, 1},
+		{0x00012470, 0x00012474, 1},
+		{0x00012480, 0x00012543, 1},
+		{0x00013000, 0x0001342e, 1},
+		{0x00014400, 0x00014646, 1},
+		{0x00016800, 0x00016a38, 1},
+		{0x00016a40, 0x00016a5e, 1},
+		{0x00016a60, 0x00016a69, 1},
+		{0x00016a6e, 0x00016a6f, 1},
+		{0x00016ad0, 0x00016aed, 1},
+		{0x00016af0, 0x00016af5, 1},
+		{0x00016b00, 0x00016b45, 1},
+		{0x00016b50, 0x00016b59, 1},
+		{0x00016b5b, 0x00016b61, 1},
+		{0x00016b63, 0x00016b77, 1},
+		{0x00016b7d, 0x00016b8f, 1},
+		{0x00016f00, 0x00016f44, 1},
+		{0x00016f50, 0x00016f7e, 1},
+		{0x00016f8f, 0x00016f9f, 1},
+		{0x0001b000, 0x0001b001, 1},
+		{0x0001bc00, 0x0001bc6a, 1},
+		{0x0001bc70, 0x0001bc7c, 1},
+		{0x0001bc80, 0x0001bc88, 1},
+		{0x0001bc90, 0x0001bc99, 1},
+		{0x0001bc9c, 0x0001bca3, 1},
+		{0x0001d000, 0x0001d0f5, 1},
+		{0x0001d100, 0x0001d126, 1},
+		{0x0001d129, 0x0001d1e8, 1},
+		{0x0001d200, 0x0001d245, 1},
+		{0x0001d300, 0x0001d356, 1},
+		{0x0001d360, 0x0001d371, 1},
+		{0x0001d400, 0x0001d454, 1},
+		{0x0001d456, 0x0001d49c, 1},
+		{0x0001d49e, 0x0001d49f, 1},
+		{0x0001d4a2, 0x0001d4a5, 3},
+		{0x0001d4a6, 0x0001d4a9, 3},
+		{0x0001d4aa, 0x0001d4ac, 1},
+		{0x0001d4ae, 0x0001d4b9, 1},
+		{0x0001d4bb, 0x0001d4bd, 2},
+		{0x0001d4be, 0x0001d4c3, 1},
+		{0x0001d4c5, 0x0001d505, 1},
+		{0x0001d507, 0x0001d50a, 1},
+		{0x0001d50d, 0x0001d514, 1},
+		{0x0001d516, 0x0001d51c, 1},
+		{0x0001d51e, 0x0001d539, 1},
+		{0x0001d53b, 0x0001d53e, 1},
+		{0x0001d540, 0x0001d544, 1},
+		{0x0001d546, 0x0001d54a, 4},
+		{0x0001d54b, 0x0001d550, 1},
+		{0x0001d552, 0x0001d6a5, 1},
+		{0x0001d6a8, 0x0001d7cb, 1},
+		{0x0001d7ce, 0x0001da8b, 1},
+		{0x0001da9b, 0x0001da9f, 1},
+		{0x0001daa1, 0x0001daaf, 1},
+		{0x0001e800, 0x0001e8c4, 1},
+		{0x0001e8c7, 0x0001e8d6, 1},
+		{0x0001ee00, 0x0001ee03, 1},
+		{0x0001ee05, 0x0001ee1f, 1},
+		{0x0001ee21, 0x0001ee22, 1},
+		{0x0001ee24, 0x0001ee27, 3},
+		{0x0001ee29, 0x0001ee32, 1},
+		{0x0001ee34, 0x0001ee37, 1},
+		{0x0001ee39, 0x0001ee3b, 2},
+		{0x0001ee42, 0x0001ee47, 5},
+		{0x0001ee49, 0x0001ee4d, 2},
+		{0x0001ee4e, 0x0001ee4f, 1},
+		{0x0001ee51, 0x0001ee52, 1},
+		{0x0001ee54, 0x0001ee57, 3},
+		{0x0001ee59, 0x0001ee61, 2},
+		{0x0001ee62, 0x0001ee64, 2},
+		{0x0001ee67, 0x0001ee6a, 1},
+		{0x0001ee6c, 0x0001ee72, 1},
+		{0x0001ee74, 0x0001ee77, 1},
+		{0x0001ee79, 0x0001ee7c, 1},
+		{0x0001ee7e, 0x0001ee80, 2},
+		{0x0001ee81, 0x0001ee89, 1},
+		{0x0001ee8b, 0x0001ee9b, 1},
+		{0x0001eea1, 0x0001eea3, 1},
+		{0x0001eea5, 0x0001eea9, 1},
+		{0x0001eeab, 0x0001eebb, 1},
+		{0x0001eef0, 0x0001eef1, 1},
+		{0x0001f000, 0x0001f02b, 1},
+		{0x0001f030, 0x0001f093, 1},
+		{0x0001f0a0, 0x0001f0ae, 1},
+		{0x0001f0b1, 0x0001f0bf, 1},
+		{0x0001f0c1, 0x0001f0cf, 1},
+		{0x0001f0d1, 0x0001f0f5, 1},
+		{0x0001f100, 0x0001f10c, 1},
+		{0x0001f110, 0x0001f12e, 1},
+		{0x0001f130, 0x0001f16b, 1},
+		{0x0001f170, 0x0001f19a, 1},
+		{0x0001f1e6, 0x0001f202, 1},
+		{0x0001f210, 0x0001f23a, 1},
+		{0x0001f240, 0x0001f248, 1},
+		{0x0001f250, 0x0001f251, 1},
+		{0x0001f300, 0x0001f579, 1},
+		{0x0001f57b, 0x0001f5a3, 1},
+		{0x0001f5a5, 0x0001f6d0, 1},
+		{0x0001f6e0, 0x0001f6ec, 1},
+		{0x0001f6f0, 0x0001f6f3, 1},
+		{0x0001f700, 0x0001f773, 1},
+		{0x0001f780, 0x0001f7d4, 1},
+		{0x0001f800, 0x0001f80b, 1},
+		{0x0001f810, 0x0001f847, 1},
+		{0x0001f850, 0x0001f859, 1},
+		{0x0001f860, 0x0001f887, 1},
+		{0x0001f890, 0x0001f8ad, 1},
+		{0x0001f910, 0x0001f918, 1},
+		{0x0001f980, 0x0001f984, 1},
+		{0x0001f9c0, 0x00020000, 1600},
+		{0x00020001, 0x0002a6d6, 1},
+		{0x0002a700, 0x0002b734, 1},
+		{0x0002b740, 0x0002b81d, 1},
+		{0x0002b820, 0x0002cea1, 1},
+		{0x0002f800, 0x0002fa1d, 1},
+		{0x000e0001, 0x000e0020, 31},
+		{0x000e0021, 0x000e007f, 1},
+		{0x000e0100, 0x000e01ef, 1},
+		{0x000f0000, 0x000ffffd, 1},
+		{0x00100000, 0x0010fffd, 1},
+	},
+	LatinOffset: 0,
+}
+
+// size 5348 bytes (5 KiB)
+var assigned9_0_0 = &unicode.RangeTable{
+	R16: []unicode.Range16{
+		{0x0000, 0x0377, 1},
+		{0x037a, 0x037f, 1},
+		{0x0384, 0x038a, 1},
+		{0x038c, 0x038e, 2},
+		{0x038f, 0x03a1, 1},
+		{0x03a3, 0x052f, 1},
+		{0x0531, 0x0556, 1},
+		{0x0559, 0x055f, 1},
+		{0x0561, 0x0587, 1},
+		{0x0589, 0x058a, 1},
+		{0x058d, 0x058f, 1},
+		{0x0591, 0x05c7, 1},
+		{0x05d0, 0x05ea, 1},
+		{0x05f0, 0x05f4, 1},
+		{0x0600, 0x061c, 1},
+		{0x061e, 0x070d, 1},
+		{0x070f, 0x074a, 1},
+		{0x074d, 0x07b1, 1},
+		{0x07c0, 0x07fa, 1},
+		{0x0800, 0x082d, 1},
+		{0x0830, 0x083e, 1},
+		{0x0840, 0x085b, 1},
+		{0x085e, 0x08a0, 66},
+		{0x08a1, 0x08b4, 1},
+		{0x08b6, 0x08bd, 1},
+		{0x08d4, 0x0983, 1},
+		{0x0985, 0x098c, 1},
+		{0x098f, 0x0990, 1},
+		{0x0993, 0x09a8, 1},
+		{0x09aa, 0x09b0, 1},
+		{0x09b2, 0x09b6, 4},
+		{0x09b7, 0x09b9, 1},
+		{0x09bc, 0x09c4, 1},
+		{0x09c7, 0x09c8, 1},
+		{0x09cb, 0x09ce, 1},
+		{0x09d7, 0x09dc, 5},
+		{0x09dd, 0x09df, 2},
+		{0x09e0, 0x09e3, 1},
+		{0x09e6, 0x09fb, 1},
+		{0x0a01, 0x0a03, 1},
+		{0x0a05, 0x0a0a, 1},
+		{0x0a0f, 0x0a10, 1},
+		{0x0a13, 0x0a28, 1},
+		{0x0a2a, 0x0a30, 1},
+		{0x0a32, 0x0a33, 1},
+		{0x0a35, 0x0a36, 1},
+		{0x0a38, 0x0a39, 1},
+		{0x0a3c, 0x0a3e, 2},
+		{0x0a3f, 0x0a42, 1},
+		{0x0a47, 0x0a48, 1},
+		{0x0a4b, 0x0a4d, 1},
+		{0x0a51, 0x0a59, 8},
+		{0x0a5a, 0x0a5c, 1},
+		{0x0a5e, 0x0a66, 8},
+		{0x0a67, 0x0a75, 1},
+		{0x0a81, 0x0a83, 1},
+		{0x0a85, 0x0a8d, 1},
+		{0x0a8f, 0x0a91, 1},
+		{0x0a93, 0x0aa8, 1},
+		{0x0aaa, 0x0ab0, 1},
+		{0x0ab2, 0x0ab3, 1},
+		{0x0ab5, 0x0ab9, 1},
+		{0x0abc, 0x0ac5, 1},
+		{0x0ac7, 0x0ac9, 1},
+		{0x0acb, 0x0acd, 1},
+		{0x0ad0, 0x0ae0, 16},
+		{0x0ae1, 0x0ae3, 1},
+		{0x0ae6, 0x0af1, 1},
+		{0x0af9, 0x0b01, 8},
+		{0x0b02, 0x0b03, 1},
+		{0x0b05, 0x0b0c, 1},
+		{0x0b0f, 0x0b10, 1},
+		{0x0b13, 0x0b28, 1},
+		{0x0b2a, 0x0b30, 1},
+		{0x0b32, 0x0b33, 1},
+		{0x0b35, 0x0b39, 1},
+		{0x0b3c, 0x0b44, 1},
+		{0x0b47, 0x0b48, 1},
+		{0x0b4b, 0x0b4d, 1},
+		{0x0b56, 0x0b57, 1},
+		{0x0b5c, 0x0b5d, 1},
+		{0x0b5f, 0x0b63, 1},
+		{0x0b66, 0x0b77, 1},
+		{0x0b82, 0x0b83, 1},
+		{0x0b85, 0x0b8a, 1},
+		{0x0b8e, 0x0b90, 1},
+		{0x0b92, 0x0b95, 1},
+		{0x0b99, 0x0b9a, 1},
+		{0x0b9c, 0x0b9e, 2},
+		{0x0b9f, 0x0ba3, 4},
+		{0x0ba4, 0x0ba8, 4},
+		{0x0ba9, 0x0baa, 1},
+		{0x0bae, 0x0bb9, 1},
+		{0x0bbe, 0x0bc2, 1},
+		{0x0bc6, 0x0bc8, 1},
+		{0x0bca, 0x0bcd, 1},
+		{0x0bd0, 0x0bd7, 7},
+		{0x0be6, 0x0bfa, 1},
+		{0x0c00, 0x0c03, 1},
+		{0x0c05, 0x0c0c, 1},
+		{0x0c0e, 0x0c10, 1},
+		{0x0c12, 0x0c28, 1},
+		{0x0c2a, 0x0c39, 1},
+		{0x0c3d, 0x0c44, 1},
+		{0x0c46, 0x0c48, 1},
+		{0x0c4a, 0x0c4d, 1},
+		{0x0c55, 0x0c56, 1},
+		{0x0c58, 0x0c5a, 1},
+		{0x0c60, 0x0c63, 1},
+		{0x0c66, 0x0c6f, 1},
+		{0x0c78, 0x0c83, 1},
+		{0x0c85, 0x0c8c, 1},
+		{0x0c8e, 0x0c90, 1},
+		{0x0c92, 0x0ca8, 1},
+		{0x0caa, 0x0cb3, 1},
+		{0x0cb5, 0x0cb9, 1},
+		{0x0cbc, 0x0cc4, 1},
+		{0x0cc6, 0x0cc8, 1},
+		{0x0cca, 0x0ccd, 1},
+		{0x0cd5, 0x0cd6, 1},
+		{0x0cde, 0x0ce0, 2},
+		{0x0ce1, 0x0ce3, 1},
+		{0x0ce6, 0x0cef, 1},
+		{0x0cf1, 0x0cf2, 1},
+		{0x0d01, 0x0d03, 1},
+		{0x0d05, 0x0d0c, 1},
+		{0x0d0e, 0x0d10, 1},
+		{0x0d12, 0x0d3a, 1},
+		{0x0d3d, 0x0d44, 1},
+		{0x0d46, 0x0d48, 1},
+		{0x0d4a, 0x0d4f, 1},
+		{0x0d54, 0x0d63, 1},
+		{0x0d66, 0x0d7f, 1},
+		{0x0d82, 0x0d83, 1},
+		{0x0d85, 0x0d96, 1},
+		{0x0d9a, 0x0db1, 1},
+		{0x0db3, 0x0dbb, 1},
+		{0x0dbd, 0x0dc0, 3},
+		{0x0dc1, 0x0dc6, 1},
+		{0x0dca, 0x0dcf, 5},
+		{0x0dd0, 0x0dd4, 1},
+		{0x0dd6, 0x0dd8, 2},
+		{0x0dd9, 0x0ddf, 1},
+		{0x0de6, 0x0def, 1},
+		{0x0df2, 0x0df4, 1},
+		{0x0e01, 0x0e3a, 1},
+		{0x0e3f, 0x0e5b, 1},
+		{0x0e81, 0x0e82, 1},
+		{0x0e84, 0x0e87, 3},
+		{0x0e88, 0x0e8a, 2},
+		{0x0e8d, 0x0e94, 7},
+		{0x0e95, 0x0e97, 1},
+		{0x0e99, 0x0e9f, 1},
+		{0x0ea1, 0x0ea3, 1},
+		{0x0ea5, 0x0ea7, 2},
+		{0x0eaa, 0x0eab, 1},
+		{0x0ead, 0x0eb9, 1},
+		{0x0ebb, 0x0ebd, 1},
+		{0x0ec0, 0x0ec4, 1},
+		{0x0ec6, 0x0ec8, 2},
+		{0x0ec9, 0x0ecd, 1},
+		{0x0ed0, 0x0ed9, 1},
+		{0x0edc, 0x0edf, 1},
+		{0x0f00, 0x0f47, 1},
+		{0x0f49, 0x0f6c, 1},
+		{0x0f71, 0x0f97, 1},
+		{0x0f99, 0x0fbc, 1},
+		{0x0fbe, 0x0fcc, 1},
+		{0x0fce, 0x0fda, 1},
+		{0x1000, 0x10c5, 1},
+		{0x10c7, 0x10cd, 6},
+		{0x10d0, 0x1248, 1},
+		{0x124a, 0x124d, 1},
+		{0x1250, 0x1256, 1},
+		{0x1258, 0x125a, 2},
+		{0x125b, 0x125d, 1},
+		{0x1260, 0x1288, 1},
+		{0x128a, 0x128d, 1},
+		{0x1290, 0x12b0, 1},
+		{0x12b2, 0x12b5, 1},
+		{0x12b8, 0x12be, 1},
+		{0x12c0, 0x12c2, 2},
+		{0x12c3, 0x12c5, 1},
+		{0x12c8, 0x12d6, 1},
+		{0x12d8, 0x1310, 1},
+		{0x1312, 0x1315, 1},
+		{0x1318, 0x135a, 1},
+		{0x135d, 0x137c, 1},
+		{0x1380, 0x1399, 1},
+		{0x13a0, 0x13f5, 1},
+		{0x13f8, 0x13fd, 1},
+		{0x1400, 0x169c, 1},
+		{0x16a0, 0x16f8, 1},
+		{0x1700, 0x170c, 1},
+		{0x170e, 0x1714, 1},
+		{0x1720, 0x1736, 1},
+		{0x1740, 0x1753, 1},
+		{0x1760, 0x176c, 1},
+		{0x176e, 0x1770, 1},
+		{0x1772, 0x1773, 1},
+		{0x1780, 0x17dd, 1},
+		{0x17e0, 0x17e9, 1},
+		{0x17f0, 0x17f9, 1},
+		{0x1800, 0x180e, 1},
+		{0x1810, 0x1819, 1},
+		{0x1820, 0x1877, 1},
+		{0x1880, 0x18aa, 1},
+		{0x18b0, 0x18f5, 1},
+		{0x1900, 0x191e, 1},
+		{0x1920, 0x192b, 1},
+		{0x1930, 0x193b, 1},
+		{0x1940, 0x1944, 4},
+		{0x1945, 0x196d, 1},
+		{0x1970, 0x1974, 1},
+		{0x1980, 0x19ab, 1},
+		{0x19b0, 0x19c9, 1},
+		{0x19d0, 0x19da, 1},
+		{0x19de, 0x1a1b, 1},
+		{0x1a1e, 0x1a5e, 1},
+		{0x1a60, 0x1a7c, 1},
+		{0x1a7f, 0x1a89, 1},
+		{0x1a90, 0x1a99, 1},
+		{0x1aa0, 0x1aad, 1},
+		{0x1ab0, 0x1abe, 1},
+		{0x1b00, 0x1b4b, 1},
+		{0x1b50, 0x1b7c, 1},
+		{0x1b80, 0x1bf3, 1},
+		{0x1bfc, 0x1c37, 1},
+		{0x1c3b, 0x1c49, 1},
+		{0x1c4d, 0x1c88, 1},
+		{0x1cc0, 0x1cc7, 1},
+		{0x1cd0, 0x1cf6, 1},
+		{0x1cf8, 0x1cf9, 1},
+		{0x1d00, 0x1df5, 1},
+		{0x1dfb, 0x1f15, 1},
+		{0x1f18, 0x1f1d, 1},
+		{0x1f20, 0x1f45, 1},
+		{0x1f48, 0x1f4d, 1},
+		{0x1f50, 0x1f57, 1},
+		{0x1f59, 0x1f5f, 2},
+		{0x1f60, 0x1f7d, 1},
+		{0x1f80, 0x1fb4, 1},
+		{0x1fb6, 0x1fc4, 1},
+		{0x1fc6, 0x1fd3, 1},
+		{0x1fd6, 0x1fdb, 1},
+		{0x1fdd, 0x1fef, 1},
+		{0x1ff2, 0x1ff4, 1},
+		{0x1ff6, 0x1ffe, 1},
+		{0x2000, 0x2064, 1},
+		{0x2066, 0x2071, 1},
+		{0x2074, 0x208e, 1},
+		{0x2090, 0x209c, 1},
+		{0x20a0, 0x20be, 1},
+		{0x20d0, 0x20f0, 1},
+		{0x2100, 0x218b, 1},
+		{0x2190, 0x23fe, 1},
+		{0x2400, 0x2426, 1},
+		{0x2440, 0x244a, 1},
+		{0x2460, 0x2b73, 1},
+		{0x2b76, 0x2b95, 1},
+		{0x2b98, 0x2bb9, 1},
+		{0x2bbd, 0x2bc8, 1},
+		{0x2bca, 0x2bd1, 1},
+		{0x2bec, 0x2bef, 1},
+		{0x2c00, 0x2c2e, 1},
+		{0x2c30, 0x2c5e, 1},
+		{0x2c60, 0x2cf3, 1},
+		{0x2cf9, 0x2d25, 1},
+		{0x2d27, 0x2d2d, 6},
+		{0x2d30, 0x2d67, 1},
+		{0x2d6f, 0x2d70, 1},
+		{0x2d7f, 0x2d96, 1},
+		{0x2da0, 0x2da6, 1},
+		{0x2da8, 0x2dae, 1},
+		{0x2db0, 0x2db6, 1},
+		{0x2db8, 0x2dbe, 1},
+		{0x2dc0, 0x2dc6, 1},
+		{0x2dc8, 0x2dce, 1},
+		{0x2dd0, 0x2dd6, 1},
+		{0x2dd8, 0x2dde, 1},
+		{0x2de0, 0x2e44, 1},
+		{0x2e80, 0x2e99, 1},
+		{0x2e9b, 0x2ef3, 1},
+		{0x2f00, 0x2fd5, 1},
+		{0x2ff0, 0x2ffb, 1},
+		{0x3000, 0x303f, 1},
+		{0x3041, 0x3096, 1},
+		{0x3099, 0x30ff, 1},
+		{0x3105, 0x312d, 1},
+		{0x3131, 0x318e, 1},
+		{0x3190, 0x31ba, 1},
+		{0x31c0, 0x31e3, 1},
+		{0x31f0, 0x321e, 1},
+		{0x3220, 0x32fe, 1},
+		{0x3300, 0x4db5, 1},
+		{0x4dc0, 0x9fd5, 1},
+		{0xa000, 0xa48c, 1},
+		{0xa490, 0xa4c6, 1},
+		{0xa4d0, 0xa62b, 1},
+		{0xa640, 0xa6f7, 1},
+		{0xa700, 0xa7ae, 1},
+		{0xa7b0, 0xa7b7, 1},
+		{0xa7f7, 0xa82b, 1},
+		{0xa830, 0xa839, 1},
+		{0xa840, 0xa877, 1},
+		{0xa880, 0xa8c5, 1},
+		{0xa8ce, 0xa8d9, 1},
+		{0xa8e0, 0xa8fd, 1},
+		{0xa900, 0xa953, 1},
+		{0xa95f, 0xa97c, 1},
+		{0xa980, 0xa9cd, 1},
+		{0xa9cf, 0xa9d9, 1},
+		{0xa9de, 0xa9fe, 1},
+		{0xaa00, 0xaa36, 1},
+		{0xaa40, 0xaa4d, 1},
+		{0xaa50, 0xaa59, 1},
+		{0xaa5c, 0xaac2, 1},
+		{0xaadb, 0xaaf6, 1},
+		{0xab01, 0xab06, 1},
+		{0xab09, 0xab0e, 1},
+		{0xab11, 0xab16, 1},
+		{0xab20, 0xab26, 1},
+		{0xab28, 0xab2e, 1},
+		{0xab30, 0xab65, 1},
+		{0xab70, 0xabed, 1},
+		{0xabf0, 0xabf9, 1},
+		{0xac00, 0xd7a3, 1},
+		{0xd7b0, 0xd7c6, 1},
+		{0xd7cb, 0xd7fb, 1},
+		{0xd800, 0xfa6d, 1},
+		{0xfa70, 0xfad9, 1},
+		{0xfb00, 0xfb06, 1},
+		{0xfb13, 0xfb17, 1},
+		{0xfb1d, 0xfb36, 1},
+		{0xfb38, 0xfb3c, 1},
+		{0xfb3e, 0xfb40, 2},
+		{0xfb41, 0xfb43, 2},
+		{0xfb44, 0xfb46, 2},
+		{0xfb47, 0xfbc1, 1},
+		{0xfbd3, 0xfd3f, 1},
+		{0xfd50, 0xfd8f, 1},
+		{0xfd92, 0xfdc7, 1},
+		{0xfdf0, 0xfdfd, 1},
+		{0xfe00, 0xfe19, 1},
+		{0xfe20, 0xfe52, 1},
+		{0xfe54, 0xfe66, 1},
+		{0xfe68, 0xfe6b, 1},
+		{0xfe70, 0xfe74, 1},
+		{0xfe76, 0xfefc, 1},
+		{0xfeff, 0xff01, 2},
+		{0xff02, 0xffbe, 1},
+		{0xffc2, 0xffc7, 1},
+		{0xffca, 0xffcf, 1},
+		{0xffd2, 0xffd7, 1},
+		{0xffda, 0xffdc, 1},
+		{0xffe0, 0xffe6, 1},
+		{0xffe8, 0xffee, 1},
+		{0xfff9, 0xfffd, 1},
+	},
+	R32: []unicode.Range32{
+		{0x00010000, 0x0001000b, 1},
+		{0x0001000d, 0x00010026, 1},
+		{0x00010028, 0x0001003a, 1},
+		{0x0001003c, 0x0001003d, 1},
+		{0x0001003f, 0x0001004d, 1},
+		{0x00010050, 0x0001005d, 1},
+		{0x00010080, 0x000100fa, 1},
+		{0x00010100, 0x00010102, 1},
+		{0x00010107, 0x00010133, 1},
+		{0x00010137, 0x0001018e, 1},
+		{0x00010190, 0x0001019b, 1},
+		{0x000101a0, 0x000101d0, 48},
+		{0x000101d1, 0x000101fd, 1},
+		{0x00010280, 0x0001029c, 1},
+		{0x000102a0, 0x000102d0, 1},
+		{0x000102e0, 0x000102fb, 1},
+		{0x00010300, 0x00010323, 1},
+		{0x00010330, 0x0001034a, 1},
+		{0x00010350, 0x0001037a, 1},
+		{0x00010380, 0x0001039d, 1},
+		{0x0001039f, 0x000103c3, 1},
+		{0x000103c8, 0x000103d5, 1},
+		{0x00010400, 0x0001049d, 1},
+		{0x000104a0, 0x000104a9, 1},
+		{0x000104b0, 0x000104d3, 1},
+		{0x000104d8, 0x000104fb, 1},
+		{0x00010500, 0x00010527, 1},
+		{0x00010530, 0x00010563, 1},
+		{0x0001056f, 0x00010600, 145},
+		{0x00010601, 0x00010736, 1},
+		{0x00010740, 0x00010755, 1},
+		{0x00010760, 0x00010767, 1},
+		{0x00010800, 0x00010805, 1},
+		{0x00010808, 0x0001080a, 2},
+		{0x0001080b, 0x00010835, 1},
+		{0x00010837, 0x00010838, 1},
+		{0x0001083c, 0x0001083f, 3},
+		{0x00010840, 0x00010855, 1},
+		{0x00010857, 0x0001089e, 1},
+		{0x000108a7, 0x000108af, 1},
+		{0x000108e0, 0x000108f2, 1},
+		{0x000108f4, 0x000108f5, 1},
+		{0x000108fb, 0x0001091b, 1},
+		{0x0001091f, 0x00010939, 1},
+		{0x0001093f, 0x00010980, 65},
+		{0x00010981, 0x000109b7, 1},
+		{0x000109bc, 0x000109cf, 1},
+		{0x000109d2, 0x00010a03, 1},
+		{0x00010a05, 0x00010a06, 1},
+		{0x00010a0c, 0x00010a13, 1},
+		{0x00010a15, 0x00010a17, 1},
+		{0x00010a19, 0x00010a33, 1},
+		{0x00010a38, 0x00010a3a, 1},
+		{0x00010a3f, 0x00010a47, 1},
+		{0x00010a50, 0x00010a58, 1},
+		{0x00010a60, 0x00010a9f, 1},
+		{0x00010ac0, 0x00010ae6, 1},
+		{0x00010aeb, 0x00010af6, 1},
+		{0x00010b00, 0x00010b35, 1},
+		{0x00010b39, 0x00010b55, 1},
+		{0x00010b58, 0x00010b72, 1},
+		{0x00010b78, 0x00010b91, 1},
+		{0x00010b99, 0x00010b9c, 1},
+		{0x00010ba9, 0x00010baf, 1},
+		{0x00010c00, 0x00010c48, 1},
+		{0x00010c80, 0x00010cb2, 1},
+		{0x00010cc0, 0x00010cf2, 1},
+		{0x00010cfa, 0x00010cff, 1},
+		{0x00010e60, 0x00010e7e, 1},
+		{0x00011000, 0x0001104d, 1},
+		{0x00011052, 0x0001106f, 1},
+		{0x0001107f, 0x000110c1, 1},
+		{0x000110d0, 0x000110e8, 1},
+		{0x000110f0, 0x000110f9, 1},
+		{0x00011100, 0x00011134, 1},
+		{0x00011136, 0x00011143, 1},
+		{0x00011150, 0x00011176, 1},
+		{0x00011180, 0x000111cd, 1},
+		{0x000111d0, 0x000111df, 1},
+		{0x000111e1, 0x000111f4, 1},
+		{0x00011200, 0x00011211, 1},
+		{0x00011213, 0x0001123e, 1},
+		{0x00011280, 0x00011286, 1},
+		{0x00011288, 0x0001128a, 2},
+		{0x0001128b, 0x0001128d, 1},
+		{0x0001128f, 0x0001129d, 1},
+		{0x0001129f, 0x000112a9, 1},
+		{0x000112b0, 0x000112ea, 1},
+		{0x000112f0, 0x000112f9, 1},
+		{0x00011300, 0x00011303, 1},
+		{0x00011305, 0x0001130c, 1},
+		{0x0001130f, 0x00011310, 1},
+		{0x00011313, 0x00011328, 1},
+		{0x0001132a, 0x00011330, 1},
+		{0x00011332, 0x00011333, 1},
+		{0x00011335, 0x00011339, 1},
+		{0x0001133c, 0x00011344, 1},
+		{0x00011347, 0x00011348, 1},
+		{0x0001134b, 0x0001134d, 1},
+		{0x00011350, 0x00011357, 7},
+		{0x0001135d, 0x00011363, 1},
+		{0x00011366, 0x0001136c, 1},
+		{0x00011370, 0x00011374, 1},
+		{0x00011400, 0x00011459, 1},
+		{0x0001145b, 0x0001145d, 2},
+		{0x00011480, 0x000114c7, 1},
+		{0x000114d0, 0x000114d9, 1},
+		{0x00011580, 0x000115b5, 1},
+		{0x000115b8, 0x000115dd, 1},
+		{0x00011600, 0x00011644, 1},
+		{0x00011650, 0x00011659, 1},
+		{0x00011660, 0x0001166c, 1},
+		{0x00011680, 0x000116b7, 1},
+		{0x000116c0, 0x000116c9, 1},
+		{0x00011700, 0x00011719, 1},
+		{0x0001171d, 0x0001172b, 1},
+		{0x00011730, 0x0001173f, 1},
+		{0x000118a0, 0x000118f2, 1},
+		{0x000118ff, 0x00011ac0, 449},
+		{0x00011ac1, 0x00011af8, 1},
+		{0x00011c00, 0x00011c08, 1},
+		{0x00011c0a, 0x00011c36, 1},
+		{0x00011c38, 0x00011c45, 1},
+		{0x00011c50, 0x00011c6c, 1},
+		{0x00011c70, 0x00011c8f, 1},
+		{0x00011c92, 0x00011ca7, 1},
+		{0x00011ca9, 0x00011cb6, 1},
+		{0x00012000, 0x00012399, 1},
+		{0x00012400, 0x0001246e, 1},
+		{0x00012470, 0x00012474, 1},
+		{0x00012480, 0x00012543, 1},
+		{0x00013000, 0x0001342e, 1},
+		{0x00014400, 0x00014646, 1},
+		{0x00016800, 0x00016a38, 1},
+		{0x00016a40, 0x00016a5e, 1},
+		{0x00016a60, 0x00016a69, 1},
+		{0x00016a6e, 0x00016a6f, 1},
+		{0x00016ad0, 0x00016aed, 1},
+		{0x00016af0, 0x00016af5, 1},
+		{0x00016b00, 0x00016b45, 1},
+		{0x00016b50, 0x00016b59, 1},
+		{0x00016b5b, 0x00016b61, 1},
+		{0x00016b63, 0x00016b77, 1},
+		{0x00016b7d, 0x00016b8f, 1},
+		{0x00016f00, 0x00016f44, 1},
+		{0x00016f50, 0x00016f7e, 1},
+		{0x00016f8f, 0x00016f9f, 1},
+		{0x00016fe0, 0x00017000, 32},
+		{0x00017001, 0x000187ec, 1},
+		{0x00018800, 0x00018af2, 1},
+		{0x0001b000, 0x0001b001, 1},
+		{0x0001bc00, 0x0001bc6a, 1},
+		{0x0001bc70, 0x0001bc7c, 1},
+		{0x0001bc80, 0x0001bc88, 1},
+		{0x0001bc90, 0x0001bc99, 1},
+		{0x0001bc9c, 0x0001bca3, 1},
+		{0x0001d000, 0x0001d0f5, 1},
+		{0x0001d100, 0x0001d126, 1},
+		{0x0001d129, 0x0001d1e8, 1},
+		{0x0001d200, 0x0001d245, 1},
+		{0x0001d300, 0x0001d356, 1},
+		{0x0001d360, 0x0001d371, 1},
+		{0x0001d400, 0x0001d454, 1},
+		{0x0001d456, 0x0001d49c, 1},
+		{0x0001d49e, 0x0001d49f, 1},
+		{0x0001d4a2, 0x0001d4a5, 3},
+		{0x0001d4a6, 0x0001d4a9, 3},
+		{0x0001d4aa, 0x0001d4ac, 1},
+		{0x0001d4ae, 0x0001d4b9, 1},
+		{0x0001d4bb, 0x0001d4bd, 2},
+		{0x0001d4be, 0x0001d4c3, 1},
+		{0x0001d4c5, 0x0001d505, 1},
+		{0x0001d507, 0x0001d50a, 1},
+		{0x0001d50d, 0x0001d514, 1},
+		{0x0001d516, 0x0001d51c, 1},
+		{0x0001d51e, 0x0001d539, 1},
+		{0x0001d53b, 0x0001d53e, 1},
+		{0x0001d540, 0x0001d544, 1},
+		{0x0001d546, 0x0001d54a, 4},
+		{0x0001d54b, 0x0001d550, 1},
+		{0x0001d552, 0x0001d6a5, 1},
+		{0x0001d6a8, 0x0001d7cb, 1},
+		{0x0001d7ce, 0x0001da8b, 1},
+		{0x0001da9b, 0x0001da9f, 1},
+		{0x0001daa1, 0x0001daaf, 1},
+		{0x0001e000, 0x0001e006, 1},
+		{0x0001e008, 0x0001e018, 1},
+		{0x0001e01b, 0x0001e021, 1},
+		{0x0001e023, 0x0001e024, 1},
+		{0x0001e026, 0x0001e02a, 1},
+		{0x0001e800, 0x0001e8c4, 1},
+		{0x0001e8c7, 0x0001e8d6, 1},
+		{0x0001e900, 0x0001e94a, 1},
+		{0x0001e950, 0x0001e959, 1},
+		{0x0001e95e, 0x0001e95f, 1},
+		{0x0001ee00, 0x0001ee03, 1},
+		{0x0001ee05, 0x0001ee1f, 1},
+		{0x0001ee21, 0x0001ee22, 1},
+		{0x0001ee24, 0x0001ee27, 3},
+		{0x0001ee29, 0x0001ee32, 1},
+		{0x0001ee34, 0x0001ee37, 1},
+		{0x0001ee39, 0x0001ee3b, 2},
+		{0x0001ee42, 0x0001ee47, 5},
+		{0x0001ee49, 0x0001ee4d, 2},
+		{0x0001ee4e, 0x0001ee4f, 1},
+		{0x0001ee51, 0x0001ee52, 1},
+		{0x0001ee54, 0x0001ee57, 3},
+		{0x0001ee59, 0x0001ee61, 2},
+		{0x0001ee62, 0x0001ee64, 2},
+		{0x0001ee67, 0x0001ee6a, 1},
+		{0x0001ee6c, 0x0001ee72, 1},
+		{0x0001ee74, 0x0001ee77, 1},
+		{0x0001ee79, 0x0001ee7c, 1},
+		{0x0001ee7e, 0x0001ee80, 2},
+		{0x0001ee81, 0x0001ee89, 1},
+		{0x0001ee8b, 0x0001ee9b, 1},
+		{0x0001eea1, 0x0001eea3, 1},
+		{0x0001eea5, 0x0001eea9, 1},
+		{0x0001eeab, 0x0001eebb, 1},
+		{0x0001eef0, 0x0001eef1, 1},
+		{0x0001f000, 0x0001f02b, 1},
+		{0x0001f030, 0x0001f093, 1},
+		{0x0001f0a0, 0x0001f0ae, 1},
+		{0x0001f0b1, 0x0001f0bf, 1},
+		{0x0001f0c1, 0x0001f0cf, 1},
+		{0x0001f0d1, 0x0001f0f5, 1},
+		{0x0001f100, 0x0001f10c, 1},
+		{0x0001f110, 0x0001f12e, 1},
+		{0x0001f130, 0x0001f16b, 1},
+		{0x0001f170, 0x0001f1ac, 1},
+		{0x0001f1e6, 0x0001f202, 1},
+		{0x0001f210, 0x0001f23b, 1},
+		{0x0001f240, 0x0001f248, 1},
+		{0x0001f250, 0x0001f251, 1},
+		{0x0001f300, 0x0001f6d2, 1},
+		{0x0001f6e0, 0x0001f6ec, 1},
+		{0x0001f6f0, 0x0001f6f6, 1},
+		{0x0001f700, 0x0001f773, 1},
+		{0x0001f780, 0x0001f7d4, 1},
+		{0x0001f800, 0x0001f80b, 1},
+		{0x0001f810, 0x0001f847, 1},
+		{0x0001f850, 0x0001f859, 1},
+		{0x0001f860, 0x0001f887, 1},
+		{0x0001f890, 0x0001f8ad, 1},
+		{0x0001f910, 0x0001f91e, 1},
+		{0x0001f920, 0x0001f927, 1},
+		{0x0001f930, 0x0001f933, 3},
+		{0x0001f934, 0x0001f93e, 1},
+		{0x0001f940, 0x0001f94b, 1},
+		{0x0001f950, 0x0001f95e, 1},
+		{0x0001f980, 0x0001f991, 1},
+		{0x0001f9c0, 0x00020000, 1600},
+		{0x00020001, 0x0002a6d6, 1},
+		{0x0002a700, 0x0002b734, 1},
+		{0x0002b740, 0x0002b81d, 1},
+		{0x0002b820, 0x0002cea1, 1},
+		{0x0002f800, 0x0002fa1d, 1},
+		{0x000e0001, 0x000e0020, 31},
+		{0x000e0021, 0x000e007f, 1},
+		{0x000e0100, 0x000e01ef, 1},
+		{0x000f0000, 0x000ffffd, 1},
+		{0x00100000, 0x0010fffd, 1},
+	},
+	LatinOffset: 0,
+}
+
+// Total size 44206 bytes (43 KiB)
diff --git a/vendor/google.golang.org/genproto/regen.go b/vendor/google.golang.org/genproto/regen.go
new file mode 100644
index 0000000..9c906f2
--- /dev/null
+++ b/vendor/google.golang.org/genproto/regen.go
@@ -0,0 +1,123 @@
+// Copyright 2016 Google Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build ignore
+
+// Regen.go regenerates the genproto repository.
+//
+// Regen.go recursively walks through each directory named by given arguments,
+// looking for all .proto files. (Symlinks are not followed.)
+// If the pkg_prefix flag is not an empty string,
+// any proto file without `go_package` option
+// or whose option does not begin with the prefix is ignored.
+// Protoc is executed on remaining files,
+// one invocation per set of files declaring the same Go package.
+package main
+
+import (
+	"flag"
+	"fmt"
+	"io/ioutil"
+	"log"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"regexp"
+	"strconv"
+	"strings"
+)
+
+var goPkgOptRe = regexp.MustCompile(`(?m)^option go_package = (.*);`)
+
+func usage() {
+	fmt.Fprintln(os.Stderr, `usage: go run regen.go -go_out=path/to/output [-pkg_prefix=pkg/prefix] roots...
+
+Most users will not need to run this file directly.
+To regenerate this repository, run regen.sh instead.`)
+	flag.PrintDefaults()
+}
+
+func main() {
+	goOutDir := flag.String("go_out", "", "go_out argument to pass to protoc-gen-go")
+	pkgPrefix := flag.String("pkg_prefix", "", "only include proto files with go_package starting with this prefix")
+	flag.Usage = usage
+	flag.Parse()
+
+	if *goOutDir == "" {
+		log.Fatal("need go_out flag")
+	}
+
+	pkgFiles := make(map[string][]string)
+	walkFn := func(path string, info os.FileInfo, err error) error {
+		if err != nil {
+			return err
+		}
+		if !info.Mode().IsRegular() || !strings.HasSuffix(path, ".proto") {
+			return nil
+		}
+		pkg, err := goPkg(path)
+		if err != nil {
+			return err
+		}
+		pkgFiles[pkg] = append(pkgFiles[pkg], path)
+		return nil
+	}
+	for _, root := range flag.Args() {
+		if err := filepath.Walk(root, walkFn); err != nil {
+			log.Fatal(err)
+		}
+	}
+	for pkg, fnames := range pkgFiles {
+		if !strings.HasPrefix(pkg, *pkgPrefix) {
+			continue
+		}
+		if out, err := protoc(*goOutDir, flag.Args(), fnames); err != nil {
+			log.Fatalf("error executing protoc: %s\n%s", err, out)
+		}
+	}
+}
+
+// goPkg reports the import path declared in the given file's
+// `go_package` option. If the option is missing, goPkg returns empty string.
+func goPkg(fname string) (string, error) {
+	content, err := ioutil.ReadFile(fname)
+	if err != nil {
+		return "", err
+	}
+
+	var pkgName string
+	if match := goPkgOptRe.FindSubmatch(content); len(match) > 0 {
+		pn, err := strconv.Unquote(string(match[1]))
+		if err != nil {
+			return "", err
+		}
+		pkgName = pn
+	}
+	if p := strings.IndexRune(pkgName, ';'); p > 0 {
+		pkgName = pkgName[:p]
+	}
+	return pkgName, nil
+}
+
+// protoc executes the "protoc" command on files named in fnames,
+// passing go_out and include flags specified in goOut and includes respectively.
+// protoc returns combined output from stdout and stderr.
+func protoc(goOut string, includes, fnames []string) ([]byte, error) {
+	args := []string{"--go_out=plugins=grpc:" + goOut}
+	for _, inc := range includes {
+		args = append(args, "-I", inc)
+	}
+	args = append(args, fnames...)
+	return exec.Command("protoc", args...).CombinedOutput()
+}
diff --git a/vendor/google.golang.org/grpc/grpclb/grpc_lb_v1/doc.go b/vendor/google.golang.org/grpc/grpclb/grpc_lb_v1/doc.go
new file mode 100644
index 0000000..aba9628
--- /dev/null
+++ b/vendor/google.golang.org/grpc/grpclb/grpc_lb_v1/doc.go
@@ -0,0 +1,21 @@
+/*
+ *
+ * Copyright 2017 gRPC authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+// Package grpc_lb_v1 is the parent package of all gRPC loadbalancer
+// message and service protobuf definitions.
+package grpc_lb_v1
