commit 9b2719869857ef1b49a56959a2475f9abef18628
Author: Anthony Romano <anthony.romano@coreos.com>
Date:   Mon Jan 11 19:51:02 2016 -0800

    godeps: add gexpect and deps

diff --git a/Godeps/Godeps.json b/Godeps/Godeps.json
index 4a08bf8..7580327 100644
--- a/Godeps/Godeps.json
+++ b/Godeps/Godeps.json
@@ -41,6 +41,10 @@
 			"Rev": "b5232bb2934f606f9f27a1305f1eea224e8e8b88"
 		},
 		{
+			"ImportPath": "github.com/coreos/gexpect",
+			"Rev": "5173270e159f5aa8fbc999dc7e3dcb50f4098a69"
+		},
+		{
 			"ImportPath": "github.com/coreos/go-semver/semver",
 			"Rev": "568e959cd89871e61434c1143528d9162da89ef2"
 		},
@@ -93,6 +97,15 @@
 			"Rev": "72f9bd7c4e0c2a40055ab3d0f09654f730cce982"
 		},
 		{
+			"ImportPath": "github.com/kballard/go-shellquote",
+			"Rev": "d8ec1a69a250a17bb0e419c386eac1f3711dc142"
+		},
+		{
+			"ImportPath": "github.com/kr/pty",
+			"Comment": "release.r56-29-gf7ee69f",
+			"Rev": "f7ee69f31298ecbe5d2b349c711e2547a617d398"
+		},
+		{
 			"ImportPath": "github.com/matttproud/golang_protobuf_extensions/pbutil",
 			"Rev": "fc2b8d3a73c4867e51861bbdd5ae3c1f0869dd6a"
 		},
diff --git a/Godeps/_workspace/src/github.com/coreos/gexpect/LICENCE b/Godeps/_workspace/src/github.com/coreos/gexpect/LICENCE
new file mode 100644
index 0000000..50adb0f
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/coreos/gexpect/LICENCE
@@ -0,0 +1,7 @@
+Copyright (C) 2014 Thomas Rooney
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff --git a/Godeps/_workspace/src/github.com/coreos/gexpect/README.md b/Godeps/_workspace/src/github.com/coreos/gexpect/README.md
new file mode 100644
index 0000000..2784b01
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/coreos/gexpect/README.md
@@ -0,0 +1,64 @@
+# Gexpect
+
+Gexpect is a pure golang expect-like module.
+
+It makes it simpler to create and control other terminal applications.
+
+	child, err := gexpect.Spawn("python")
+	if err != nil {
+		panic(err)
+	}
+	child.Expect(">>>")
+	child.SendLine("print 'Hello World'")
+	child.Interact()
+	child.Close()
+
+## Examples
+
+`Spawn` handles the argument parsing from a string
+
+	child.Spawn("/bin/sh -c 'echo \"my complicated command\" | tee log | cat > log2'")
+	child.ReadLine() // ReadLine() (string, error)
+	child.ReadUntil(' ') // ReadUntil(delim byte) ([]byte, error)
+
+`ReadLine`, `ReadUntil` and `SendLine` send strings from/to `stdout/stdin` respectively
+
+	child := gexpect.Spawn("cat")
+	child.SendLine("echoing process_stdin") //  SendLine(command string) (error)
+	msg, _ := child.ReadLine() // msg = echoing process_stdin
+
+`Wait` and `Close` allow for graceful and ungraceful termination.
+
+	child.Wait() // Waits until the child terminates naturally.
+	child.Close() // Sends a kill command
+
+`AsyncInteractChannels` spawns two go routines to pipe into and from `stdout`/`stdin`, allowing for some usecases to be a little simpler.
+
+	child := gexpect.spawn("sh")
+	sender, reciever := child.AsyncInteractChannels()
+	sender <- "echo Hello World\n" // Send to stdin
+	line, open := <- reciever // Recieve a line from stdout/stderr
+	// When the subprocess stops (e.g. with child.Close()) , receiver is closed
+	if open {
+		fmt.Printf("Received %s", line)]
+	}
+
+`ExpectRegex` uses golang's internal regex engine to wait until a match from the process with the given regular expression (or an error on process termination with no match).
+
+	child := gexpect.Spawn("echo accb")	
+	match, _ := child.ExpectRegex("a..b")
+	// (match=true)
+
+`ExpectRegexFind` allows for groups to be extracted from process stdout. The first element is an array of containing the total matched text, followed by each subexpression group match.
+
+	child := gexpect.Spawn("echo 123 456 789")
+	result, _ := child.ExpectRegexFind("\d+ (\d+) (\d+)")
+	// result = []string{"123 456 789", "456", "789"}
+
+See `gexpect_test.go` and the `examples` folder for full syntax
+
+## Credits
+
+	github.com/kballard/go-shellquote	
+	github.com/kr/pty
+	KMP Algorithm: "http://blog.databigbang.com/searching-for-substrings-in-streams-a-slight-modification-of-the-knuth-morris-pratt-algorithm-in-haxe/"
\ No newline at end of file
diff --git a/Godeps/_workspace/src/github.com/coreos/gexpect/examples/ftp.go b/Godeps/_workspace/src/github.com/coreos/gexpect/examples/ftp.go
new file mode 100644
index 0000000..fe3872a
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/coreos/gexpect/examples/ftp.go
@@ -0,0 +1,27 @@
+package main
+
+import gexpect "github.com/coreos/etcd/Godeps/_workspace/src/github.com/coreos/gexpect"
+import "log"
+
+func main() {
+	log.Printf("Testing Ftp... ")
+
+	child, err := gexpect.Spawn("ftp ftp.openbsd.org")
+	if err != nil {
+		panic(err)
+	}
+	child.Expect("Name")
+	child.SendLine("anonymous")
+	child.Expect("Password")
+	child.SendLine("pexpect@sourceforge.net")
+	child.Expect("ftp> ")
+	child.SendLine("cd /pub/OpenBSD/3.7/packages/i386")
+	child.Expect("ftp> ")
+	child.SendLine("bin")
+	child.Expect("ftp> ")
+	child.SendLine("prompt")
+	child.Expect("ftp> ")
+	child.SendLine("pwd")
+	child.Expect("ftp> ")
+	log.Printf("Success\n")
+}
diff --git a/Godeps/_workspace/src/github.com/coreos/gexpect/examples/ping.go b/Godeps/_workspace/src/github.com/coreos/gexpect/examples/ping.go
new file mode 100644
index 0000000..c467f4b
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/coreos/gexpect/examples/ping.go
@@ -0,0 +1,15 @@
+package main
+
+import gexpect "github.com/coreos/etcd/Godeps/_workspace/src/github.com/coreos/gexpect"
+import "log"
+
+func main() {
+	log.Printf("Testing Ping interact... \n")
+
+	child, err := gexpect.Spawn("ping -c8 127.0.0.1")
+	if err != nil {
+		panic(err)
+	}
+	child.Interact()
+	log.Printf("Success\n")
+}
diff --git a/Godeps/_workspace/src/github.com/coreos/gexpect/examples/python.go b/Godeps/_workspace/src/github.com/coreos/gexpect/examples/python.go
new file mode 100644
index 0000000..4c7c50f
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/coreos/gexpect/examples/python.go
@@ -0,0 +1,22 @@
+package main
+
+import "github.com/coreos/etcd/Godeps/_workspace/src/github.com/coreos/gexpect"
+import "fmt"
+
+func main() {
+	fmt.Printf("Starting python.. \n")
+	child, err := gexpect.Spawn("python")
+	if err != nil {
+		panic(err)
+	}
+	fmt.Printf("Expecting >>>.. \n")
+	child.Expect(">>>")
+	fmt.Printf("print 'Hello World'..\n")
+	child.SendLine("print 'Hello World'")
+	child.Expect(">>>")
+
+	fmt.Printf("Interacting.. \n")
+	child.Interact()
+	fmt.Printf("Done \n")
+	child.Close()
+}
diff --git a/Godeps/_workspace/src/github.com/coreos/gexpect/examples/screen.go b/Godeps/_workspace/src/github.com/coreos/gexpect/examples/screen.go
new file mode 100644
index 0000000..157552f
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/coreos/gexpect/examples/screen.go
@@ -0,0 +1,53 @@
+package main
+
+import "github.com/coreos/etcd/Godeps/_workspace/src/github.com/coreos/gexpect"
+import "fmt"
+import "strings"
+
+func main() {
+	waitChan := make(chan string)
+
+	fmt.Printf("Starting screen.. \n")
+
+	child, err := gexpect.Spawn("screen")
+	if err != nil {
+		panic(err)
+	}
+
+	sender, reciever := child.AsyncInteractChannels()
+	go func() {
+		waitString := ""
+		count := 0
+		for {
+			select {
+			case waitString = <-waitChan:
+				count++
+			case msg, open := <-reciever:
+				if !open {
+					return
+				}
+				fmt.Printf("Recieved: %s\n", msg)
+
+				if strings.Contains(msg, waitString) {
+					if count >= 1 {
+						waitChan <- msg
+						count -= 1
+					}
+				}
+			}
+		}
+	}()
+	wait := func(str string) {
+		waitChan <- str
+		<-waitChan
+	}
+	fmt.Printf("Waiting until started.. \n")
+	wait(" ")
+	fmt.Printf("Sending Enter.. \n")
+	sender <- "\n"
+	wait("$")
+	fmt.Printf("Sending echo.. \n")
+	sender <- "echo Hello World\n"
+	wait("Hello World")
+	fmt.Printf("Received echo. \n")
+}
diff --git a/Godeps/_workspace/src/github.com/coreos/gexpect/gexpect.go b/Godeps/_workspace/src/github.com/coreos/gexpect/gexpect.go
new file mode 100644
index 0000000..6d89411
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/coreos/gexpect/gexpect.go
@@ -0,0 +1,430 @@
+package gexpect
+
+import (
+	"bytes"
+	"errors"
+	"fmt"
+	"io"
+	"os"
+	"os/exec"
+	"regexp"
+	"time"
+	"unicode/utf8"
+
+	shell "github.com/coreos/etcd/Godeps/_workspace/src/github.com/kballard/go-shellquote"
+	"github.com/coreos/etcd/Godeps/_workspace/src/github.com/kr/pty"
+)
+
+type ExpectSubprocess struct {
+	Cmd          *exec.Cmd
+	buf          *buffer
+	outputBuffer []byte
+}
+
+type buffer struct {
+	f       *os.File
+	b       bytes.Buffer
+	collect bool
+
+	collection bytes.Buffer
+}
+
+func (buf *buffer) StartCollecting() {
+	buf.collect = true
+}
+
+func (buf *buffer) StopCollecting() (result string) {
+	result = string(buf.collection.Bytes())
+	buf.collect = false
+	buf.collection.Reset()
+	return result
+}
+
+func (buf *buffer) Read(chunk []byte) (int, error) {
+	nread := 0
+	if buf.b.Len() > 0 {
+		n, err := buf.b.Read(chunk)
+		if err != nil {
+			return n, err
+		}
+		if n == len(chunk) {
+			return n, nil
+		}
+		nread = n
+	}
+	fn, err := buf.f.Read(chunk[nread:])
+	return fn + nread, err
+}
+
+func (buf *buffer) ReadRune() (r rune, size int, err error) {
+	l := buf.b.Len()
+
+	chunk := make([]byte, utf8.UTFMax)
+	if l > 0 {
+		n, err := buf.b.Read(chunk)
+		if err != nil {
+			return 0, 0, err
+		}
+		if utf8.FullRune(chunk) {
+			r, rL := utf8.DecodeRune(chunk)
+			if n > rL {
+				buf.PutBack(chunk[rL:n])
+			}
+			if buf.collect {
+				buf.collection.WriteRune(r)
+			}
+			return r, rL, nil
+		}
+	}
+	// else add bytes from the file, then try that
+	for l < utf8.UTFMax {
+		fn, err := buf.f.Read(chunk[l : l+1])
+		if err != nil {
+			return 0, 0, err
+		}
+		l = l + fn
+
+		if utf8.FullRune(chunk) {
+			r, rL := utf8.DecodeRune(chunk)
+			if buf.collect {
+				buf.collection.WriteRune(r)
+			}
+			return r, rL, nil
+		}
+	}
+	return 0, 0, errors.New("File is not a valid UTF=8 encoding")
+}
+
+func (buf *buffer) PutBack(chunk []byte) {
+	if len(chunk) == 0 {
+		return
+	}
+	if buf.b.Len() == 0 {
+		buf.b.Write(chunk)
+		return
+	}
+	d := make([]byte, 0, len(chunk)+buf.b.Len())
+	d = append(d, chunk...)
+	d = append(d, buf.b.Bytes()...)
+	buf.b.Reset()
+	buf.b.Write(d)
+}
+
+func SpawnAtDirectory(command string, directory string) (*ExpectSubprocess, error) {
+	expect, err := _spawn(command)
+	if err != nil {
+		return nil, err
+	}
+	expect.Cmd.Dir = directory
+	return _start(expect)
+}
+
+func Command(command string) (*ExpectSubprocess, error) {
+	expect, err := _spawn(command)
+	if err != nil {
+		return nil, err
+	}
+	return expect, nil
+}
+
+func (expect *ExpectSubprocess) Start() error {
+	_, err := _start(expect)
+	return err
+}
+
+func Spawn(command string) (*ExpectSubprocess, error) {
+	expect, err := _spawn(command)
+	if err != nil {
+		return nil, err
+	}
+	return _start(expect)
+}
+
+func (expect *ExpectSubprocess) Close() error {
+	return expect.Cmd.Process.Kill()
+}
+
+func (expect *ExpectSubprocess) AsyncInteractChannels() (send chan string, receive chan string) {
+	receive = make(chan string)
+	send = make(chan string)
+
+	go func() {
+		for {
+			str, err := expect.ReadLine()
+			if err != nil {
+				close(receive)
+				return
+			}
+			receive <- str
+		}
+	}()
+
+	go func() {
+		for {
+			select {
+			case sendCommand, exists := <-send:
+				{
+					if !exists {
+						return
+					}
+					err := expect.Send(sendCommand)
+					if err != nil {
+						receive <- "gexpect Error: " + err.Error()
+						return
+					}
+				}
+			}
+		}
+	}()
+
+	return
+}
+
+func (expect *ExpectSubprocess) ExpectRegex(regex string) (bool, error) {
+	return regexp.MatchReader(regex, expect.buf)
+}
+
+func (expect *ExpectSubprocess) expectRegexFind(regex string, output bool) ([]string, string, error) {
+	re, err := regexp.Compile(regex)
+	if err != nil {
+		return nil, "", err
+	}
+	expect.buf.StartCollecting()
+	pairs := re.FindReaderSubmatchIndex(expect.buf)
+	stringIndexedInto := expect.buf.StopCollecting()
+	l := len(pairs)
+	numPairs := l / 2
+	result := make([]string, numPairs)
+	for i := 0; i < numPairs; i += 1 {
+		result[i] = stringIndexedInto[pairs[i*2]:pairs[i*2+1]]
+	}
+	// convert indexes to strings
+
+	if len(result) == 0 {
+		err = fmt.Errorf("ExpectRegex didn't find regex '%v'.", regex)
+	}
+	return result, stringIndexedInto, err
+}
+
+func (expect *ExpectSubprocess) expectTimeoutRegexFind(regex string, timeout time.Duration) (result []string, out string, err error) {
+	t := make(chan bool)
+	go func() {
+		result, out, err = expect.ExpectRegexFindWithOutput(regex)
+		t <- false
+	}()
+	go func() {
+		time.Sleep(timeout)
+		err = fmt.Errorf("ExpectRegex timed out after %v finding '%v'.\nOutput:\n%s", timeout, regex, expect.Collect())
+		t <- true
+	}()
+	<-t
+	return result, out, err
+}
+
+func (expect *ExpectSubprocess) ExpectRegexFind(regex string) ([]string, error) {
+	result, _, err := expect.expectRegexFind(regex, false)
+	return result, err
+}
+
+func (expect *ExpectSubprocess) ExpectTimeoutRegexFind(regex string, timeout time.Duration) ([]string, error) {
+	result, _, err := expect.expectTimeoutRegexFind(regex, timeout)
+	return result, err
+}
+
+func (expect *ExpectSubprocess) ExpectRegexFindWithOutput(regex string) ([]string, string, error) {
+	return expect.expectRegexFind(regex, true)
+}
+
+func (expect *ExpectSubprocess) ExpectTimeoutRegexFindWithOutput(regex string, timeout time.Duration) ([]string, string, error) {
+	return expect.expectTimeoutRegexFind(regex, timeout)
+}
+
+func buildKMPTable(searchString string) []int {
+	pos := 2
+	cnd := 0
+	length := len(searchString)
+
+	var table []int
+	if length < 2 {
+		length = 2
+	}
+
+	table = make([]int, length)
+	table[0] = -1
+	table[1] = 0
+
+	for pos < len(searchString) {
+		if searchString[pos-1] == searchString[cnd] {
+			cnd += 1
+			table[pos] = cnd
+			pos += 1
+		} else if cnd > 0 {
+			cnd = table[cnd]
+		} else {
+			table[pos] = 0
+			pos += 1
+		}
+	}
+	return table
+}
+
+func (expect *ExpectSubprocess) ExpectTimeout(searchString string, timeout time.Duration) (e error) {
+	result := make(chan error)
+	go func() {
+		result <- expect.Expect(searchString)
+	}()
+	select {
+	case e = <-result:
+	case <-time.After(timeout):
+		e = fmt.Errorf("Expect timed out after %v waiting for '%v'.\nOutput:\n%s", timeout, searchString, expect.Collect())
+	}
+	return e
+}
+
+func (expect *ExpectSubprocess) Expect(searchString string) (e error) {
+	chunk := make([]byte, len(searchString)*2)
+	target := len(searchString)
+	if expect.outputBuffer != nil {
+		expect.outputBuffer = expect.outputBuffer[0:]
+	}
+	m := 0
+	i := 0
+	// Build KMP Table
+	table := buildKMPTable(searchString)
+
+	for {
+		n, err := expect.buf.Read(chunk)
+
+		if err != nil {
+			return err
+		}
+		if expect.outputBuffer != nil {
+			expect.outputBuffer = append(expect.outputBuffer, chunk[:n]...)
+		}
+		offset := m + i
+		for m+i-offset < n {
+			if searchString[i] == chunk[m+i-offset] {
+				i += 1
+				if i == target {
+					unreadIndex := m + i - offset
+					if len(chunk) > unreadIndex {
+						expect.buf.PutBack(chunk[unreadIndex:])
+					}
+					return nil
+				}
+			} else {
+				m += i - table[i]
+				if table[i] > -1 {
+					i = table[i]
+				} else {
+					i = 0
+				}
+			}
+		}
+	}
+}
+
+func (expect *ExpectSubprocess) Send(command string) error {
+	_, err := io.WriteString(expect.buf.f, command)
+	return err
+}
+
+func (expect *ExpectSubprocess) Capture() {
+	if expect.outputBuffer == nil {
+		expect.outputBuffer = make([]byte, 0)
+	}
+}
+
+func (expect *ExpectSubprocess) Collect() []byte {
+	collectOutput := make([]byte, len(expect.outputBuffer))
+	copy(collectOutput, expect.outputBuffer)
+	expect.outputBuffer = nil
+	return collectOutput
+}
+
+func (expect *ExpectSubprocess) SendLine(command string) error {
+	_, err := io.WriteString(expect.buf.f, command+"\r\n")
+	return err
+}
+
+func (expect *ExpectSubprocess) Interact() {
+	defer expect.Cmd.Wait()
+	io.Copy(os.Stdout, &expect.buf.b)
+	go io.Copy(os.Stdout, expect.buf.f)
+	go io.Copy(expect.buf.f, os.Stdin)
+}
+
+func (expect *ExpectSubprocess) ReadUntil(delim byte) ([]byte, error) {
+	join := make([]byte, 1, 512)
+	chunk := make([]byte, 255)
+
+	for {
+
+		n, err := expect.buf.Read(chunk)
+
+		if err != nil {
+			return join, err
+		}
+
+		for i := 0; i < n; i++ {
+			if chunk[i] == delim {
+				if len(chunk) > i+1 {
+					expect.buf.PutBack(chunk[i+1:])
+				}
+				return join, nil
+			} else {
+				join = append(join, chunk[i])
+			}
+		}
+	}
+}
+
+func (expect *ExpectSubprocess) Wait() error {
+	return expect.Cmd.Wait()
+}
+
+func (expect *ExpectSubprocess) ReadLine() (string, error) {
+	str, err := expect.ReadUntil('\n')
+	if err != nil {
+		return "", err
+	}
+	return string(str), nil
+}
+
+func _start(expect *ExpectSubprocess) (*ExpectSubprocess, error) {
+	f, err := pty.Start(expect.Cmd)
+	if err != nil {
+		return nil, err
+	}
+	expect.buf.f = f
+
+	return expect, nil
+}
+
+func _spawn(command string) (*ExpectSubprocess, error) {
+	wrapper := new(ExpectSubprocess)
+
+	wrapper.outputBuffer = nil
+
+	splitArgs, err := shell.Split(command)
+	if err != nil {
+		return nil, err
+	}
+	numArguments := len(splitArgs) - 1
+	if numArguments < 0 {
+		return nil, errors.New("gexpect: No command given to spawn")
+	}
+	path, err := exec.LookPath(splitArgs[0])
+	if err != nil {
+		return nil, err
+	}
+
+	if numArguments >= 1 {
+		wrapper.Cmd = exec.Command(path, splitArgs[1:]...)
+	} else {
+		wrapper.Cmd = exec.Command(path)
+	}
+	wrapper.buf = new(buffer)
+
+	return wrapper, nil
+}
diff --git a/Godeps/_workspace/src/github.com/kballard/go-shellquote/LICENSE b/Godeps/_workspace/src/github.com/kballard/go-shellquote/LICENSE
new file mode 100644
index 0000000..a6d7731
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kballard/go-shellquote/LICENSE
@@ -0,0 +1,19 @@
+Copyright (C) 2014 Kevin Ballard
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the "Software"),
+to deal in the Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute, sublicense,
+and/or sell copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/Godeps/_workspace/src/github.com/kballard/go-shellquote/README b/Godeps/_workspace/src/github.com/kballard/go-shellquote/README
new file mode 100644
index 0000000..4d34e87
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kballard/go-shellquote/README
@@ -0,0 +1,36 @@
+PACKAGE
+
+package shellquote
+    import "github.com/kballard/go-shellquote"
+
+    Shellquote provides utilities for joining/splitting strings using sh's
+    word-splitting rules.
+
+VARIABLES
+
+var (
+    UnterminatedSingleQuoteError = errors.New("Unterminated single-quoted string")
+    UnterminatedDoubleQuoteError = errors.New("Unterminated double-quoted string")
+    UnterminatedEscapeError      = errors.New("Unterminated backslash-escape")
+)
+
+
+FUNCTIONS
+
+func Join(args ...string) string
+    Join quotes each argument and joins them with a space. If passed to
+    /bin/sh, the resulting string will be split back into the original
+    arguments.
+
+func Split(input string) (words []string, err error)
+    Split splits a string according to /bin/sh's word-splitting rules. It
+    supports backslash-escapes, single-quotes, and double-quotes. Notably it
+    does not support the $'' style of quoting. It also doesn't attempt to
+    perform any other sort of expansion, including brace expansion, shell
+    expansion, or pathname expansion.
+
+    If the given input has an unterminated quoted string or ends in a
+    backslash-escape, one of UnterminatedSingleQuoteError,
+    UnterminatedDoubleQuoteError, or UnterminatedEscapeError is returned.
+
+
diff --git a/Godeps/_workspace/src/github.com/kballard/go-shellquote/doc.go b/Godeps/_workspace/src/github.com/kballard/go-shellquote/doc.go
new file mode 100644
index 0000000..9445fa4
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kballard/go-shellquote/doc.go
@@ -0,0 +1,3 @@
+// Shellquote provides utilities for joining/splitting strings using sh's
+// word-splitting rules.
+package shellquote
diff --git a/Godeps/_workspace/src/github.com/kballard/go-shellquote/quote.go b/Godeps/_workspace/src/github.com/kballard/go-shellquote/quote.go
new file mode 100644
index 0000000..9842d5e
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kballard/go-shellquote/quote.go
@@ -0,0 +1,102 @@
+package shellquote
+
+import (
+	"bytes"
+	"strings"
+	"unicode/utf8"
+)
+
+// Join quotes each argument and joins them with a space.
+// If passed to /bin/sh, the resulting string will be split back into the
+// original arguments.
+func Join(args ...string) string {
+	var buf bytes.Buffer
+	for i, arg := range args {
+		if i != 0 {
+			buf.WriteByte(' ')
+		}
+		quote(arg, &buf)
+	}
+	return buf.String()
+}
+
+const (
+	specialChars      = "\\'\"`${[|&;<>()*?!"
+	extraSpecialChars = " \t\n"
+	prefixChars       = "~"
+)
+
+func quote(word string, buf *bytes.Buffer) {
+	// We want to try to produce a "nice" output. As such, we will
+	// backslash-escape most characters, but if we encounter a space, or if we
+	// encounter an extra-special char (which doesn't work with
+	// backslash-escaping) we switch over to quoting the whole word. We do this
+	// with a space because it's typically easier for people to read multi-word
+	// arguments when quoted with a space rather than with ugly backslashes
+	// everywhere.
+	origLen := buf.Len()
+
+	if len(word) == 0 {
+		// oops, no content
+		buf.WriteString("''")
+		return
+	}
+
+	cur, prev := word, word
+	atStart := true
+	for len(cur) > 0 {
+		c, l := utf8.DecodeRuneInString(cur)
+		cur = cur[l:]
+		if strings.ContainsRune(specialChars, c) || (atStart && strings.ContainsRune(prefixChars, c)) {
+			// copy the non-special chars up to this point
+			if len(cur) < len(prev) {
+				buf.WriteString(prev[0 : len(prev)-len(cur)-l])
+			}
+			buf.WriteByte('\\')
+			buf.WriteRune(c)
+			prev = cur
+		} else if strings.ContainsRune(extraSpecialChars, c) {
+			// start over in quote mode
+			buf.Truncate(origLen)
+			goto quote
+		}
+		atStart = false
+	}
+	if len(prev) > 0 {
+		buf.WriteString(prev)
+	}
+	return
+
+quote:
+	// quote mode
+	// Use single-quotes, but if we find a single-quote in the word, we need
+	// to terminate the string, emit an escaped quote, and start the string up
+	// again
+	inQuote := false
+	for len(word) > 0 {
+		i := strings.IndexRune(word, '\'')
+		if i == -1 {
+			break
+		}
+		if i > 0 {
+			if !inQuote {
+				buf.WriteByte('\'')
+				inQuote = true
+			}
+			buf.WriteString(word[0:i])
+			word = word[i+1:]
+		}
+		if inQuote {
+			buf.WriteByte('\'')
+			inQuote = false
+		}
+		buf.WriteString("\\'")
+	}
+	if len(word) > 0 {
+		if !inQuote {
+			buf.WriteByte('\'')
+		}
+		buf.WriteString(word)
+		buf.WriteByte('\'')
+	}
+}
diff --git a/Godeps/_workspace/src/github.com/kballard/go-shellquote/unquote.go b/Godeps/_workspace/src/github.com/kballard/go-shellquote/unquote.go
new file mode 100644
index 0000000..ba3a0f2
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kballard/go-shellquote/unquote.go
@@ -0,0 +1,144 @@
+package shellquote
+
+import (
+	"bytes"
+	"errors"
+	"strings"
+	"unicode/utf8"
+)
+
+var (
+	UnterminatedSingleQuoteError = errors.New("Unterminated single-quoted string")
+	UnterminatedDoubleQuoteError = errors.New("Unterminated double-quoted string")
+	UnterminatedEscapeError      = errors.New("Unterminated backslash-escape")
+)
+
+var (
+	splitChars        = " \n\t"
+	singleChar        = '\''
+	doubleChar        = '"'
+	escapeChar        = '\\'
+	doubleEscapeChars = "$`\"\n\\"
+)
+
+// Split splits a string according to /bin/sh's word-splitting rules. It
+// supports backslash-escapes, single-quotes, and double-quotes. Notably it does
+// not support the $'' style of quoting. It also doesn't attempt to perform any
+// other sort of expansion, including brace expansion, shell expansion, or
+// pathname expansion.
+//
+// If the given input has an unterminated quoted string or ends in a
+// backslash-escape, one of UnterminatedSingleQuoteError,
+// UnterminatedDoubleQuoteError, or UnterminatedEscapeError is returned.
+func Split(input string) (words []string, err error) {
+	var buf bytes.Buffer
+	words = make([]string, 0)
+
+	for len(input) > 0 {
+		// skip any splitChars at the start
+		c, l := utf8.DecodeRuneInString(input)
+		if strings.ContainsRune(splitChars, c) {
+			input = input[l:]
+			continue
+		}
+
+		var word string
+		word, input, err = splitWord(input, &buf)
+		if err != nil {
+			return
+		}
+		words = append(words, word)
+	}
+	return
+}
+
+func splitWord(input string, buf *bytes.Buffer) (word string, remainder string, err error) {
+	buf.Reset()
+
+raw:
+	{
+		cur := input
+		for len(cur) > 0 {
+			c, l := utf8.DecodeRuneInString(cur)
+			cur = cur[l:]
+			if c == singleChar {
+				buf.WriteString(input[0 : len(input)-len(cur)-l])
+				input = cur
+				goto single
+			} else if c == doubleChar {
+				buf.WriteString(input[0 : len(input)-len(cur)-l])
+				input = cur
+				goto double
+			} else if c == escapeChar {
+				buf.WriteString(input[0 : len(input)-len(cur)-l])
+				input = cur
+				goto escape
+			} else if strings.ContainsRune(splitChars, c) {
+				buf.WriteString(input[0 : len(input)-len(cur)-l])
+				return buf.String(), cur, nil
+			}
+		}
+		if len(input) > 0 {
+			buf.WriteString(input)
+			input = ""
+		}
+		goto done
+	}
+
+escape:
+	{
+		if len(input) == 0 {
+			return "", "", UnterminatedEscapeError
+		}
+		c, l := utf8.DecodeRuneInString(input)
+		if c == '\n' {
+			// a backslash-escaped newline is elided from the output entirely
+		} else {
+			buf.WriteString(input[:l])
+		}
+		input = input[l:]
+	}
+	goto raw
+
+single:
+	{
+		i := strings.IndexRune(input, singleChar)
+		if i == -1 {
+			return "", "", UnterminatedSingleQuoteError
+		}
+		buf.WriteString(input[0:i])
+		input = input[i+1:]
+		goto raw
+	}
+
+double:
+	{
+		cur := input
+		for len(cur) > 0 {
+			c, l := utf8.DecodeRuneInString(cur)
+			cur = cur[l:]
+			if c == doubleChar {
+				buf.WriteString(input[0 : len(input)-len(cur)-l])
+				input = cur
+				goto raw
+			} else if c == escapeChar {
+				// bash only supports certain escapes in double-quoted strings
+				c2, l2 := utf8.DecodeRuneInString(cur)
+				cur = cur[l2:]
+				if strings.ContainsRune(doubleEscapeChars, c2) {
+					buf.WriteString(input[0 : len(input)-len(cur)-l-l2])
+					if c2 == '\n' {
+						// newline is special, skip the backslash entirely
+					} else {
+						buf.WriteRune(c2)
+					}
+					input = cur
+				}
+			}
+		}
+		return "", "", UnterminatedDoubleQuoteError
+	}
+
+done:
+	return buf.String(), input, nil
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/.gitignore b/Godeps/_workspace/src/github.com/kr/pty/.gitignore
new file mode 100644
index 0000000..1f0a99f
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/.gitignore
@@ -0,0 +1,4 @@
+[568].out
+_go*
+_test*
+_obj
diff --git a/Godeps/_workspace/src/github.com/kr/pty/License b/Godeps/_workspace/src/github.com/kr/pty/License
new file mode 100644
index 0000000..6b7558b
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/License
@@ -0,0 +1,23 @@
+Copyright (c) 2011 Keith Rarick
+
+Permission is hereby granted, free of charge, to any person
+obtaining a copy of this software and associated
+documentation files (the "Software"), to deal in the
+Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall
+be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
+KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
+OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/Godeps/_workspace/src/github.com/kr/pty/README.md b/Godeps/_workspace/src/github.com/kr/pty/README.md
new file mode 100644
index 0000000..7b7900c
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/README.md
@@ -0,0 +1,36 @@
+# pty
+
+Pty is a Go package for using unix pseudo-terminals.
+
+## Install
+
+    go get github.com/kr/pty
+
+## Example
+
+```go
+package main
+
+import (
+	"github.com/kr/pty"
+	"io"
+	"os"
+	"os/exec"
+)
+
+func main() {
+	c := exec.Command("grep", "--color=auto", "bar")
+	f, err := pty.Start(c)
+	if err != nil {
+		panic(err)
+	}
+
+	go func() {
+		f.Write([]byte("foo\n"))
+		f.Write([]byte("bar\n"))
+		f.Write([]byte("baz\n"))
+		f.Write([]byte{4}) // EOT
+	}()
+	io.Copy(os.Stdout, f)
+}
+```
diff --git a/Godeps/_workspace/src/github.com/kr/pty/doc.go b/Godeps/_workspace/src/github.com/kr/pty/doc.go
new file mode 100644
index 0000000..190cfbe
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/doc.go
@@ -0,0 +1,16 @@
+// Package pty provides functions for working with Unix terminals.
+package pty
+
+import (
+	"errors"
+	"os"
+)
+
+// ErrUnsupported is returned if a function is not
+// available on the current platform.
+var ErrUnsupported = errors.New("unsupported")
+
+// Opens a pty and its corresponding tty.
+func Open() (pty, tty *os.File, err error) {
+	return open()
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ioctl.go b/Godeps/_workspace/src/github.com/kr/pty/ioctl.go
new file mode 100644
index 0000000..5b856e8
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ioctl.go
@@ -0,0 +1,11 @@
+package pty
+
+import "syscall"
+
+func ioctl(fd, cmd, ptr uintptr) error {
+	_, _, e := syscall.Syscall(syscall.SYS_IOCTL, fd, cmd, ptr)
+	if e != 0 {
+		return e
+	}
+	return nil
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ioctl_bsd.go b/Godeps/_workspace/src/github.com/kr/pty/ioctl_bsd.go
new file mode 100644
index 0000000..73b12c5
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ioctl_bsd.go
@@ -0,0 +1,39 @@
+// +build darwin dragonfly freebsd netbsd openbsd
+
+package pty
+
+// from <sys/ioccom.h>
+const (
+	_IOC_VOID    uintptr = 0x20000000
+	_IOC_OUT     uintptr = 0x40000000
+	_IOC_IN      uintptr = 0x80000000
+	_IOC_IN_OUT  uintptr = _IOC_OUT | _IOC_IN
+	_IOC_DIRMASK         = _IOC_VOID | _IOC_OUT | _IOC_IN
+
+	_IOC_PARAM_SHIFT = 13
+	_IOC_PARAM_MASK  = (1 << _IOC_PARAM_SHIFT) - 1
+)
+
+func _IOC_PARM_LEN(ioctl uintptr) uintptr {
+	return (ioctl >> 16) & _IOC_PARAM_MASK
+}
+
+func _IOC(inout uintptr, group byte, ioctl_num uintptr, param_len uintptr) uintptr {
+	return inout | (param_len&_IOC_PARAM_MASK)<<16 | uintptr(group)<<8 | ioctl_num
+}
+
+func _IO(group byte, ioctl_num uintptr) uintptr {
+	return _IOC(_IOC_VOID, group, ioctl_num, 0)
+}
+
+func _IOR(group byte, ioctl_num uintptr, param_len uintptr) uintptr {
+	return _IOC(_IOC_OUT, group, ioctl_num, param_len)
+}
+
+func _IOW(group byte, ioctl_num uintptr, param_len uintptr) uintptr {
+	return _IOC(_IOC_IN, group, ioctl_num, param_len)
+}
+
+func _IOWR(group byte, ioctl_num uintptr, param_len uintptr) uintptr {
+	return _IOC(_IOC_IN_OUT, group, ioctl_num, param_len)
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/mktypes.bash b/Godeps/_workspace/src/github.com/kr/pty/mktypes.bash
new file mode 100644
index 0000000..9952c88
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/mktypes.bash
@@ -0,0 +1,19 @@
+#!/usr/bin/env bash
+
+GOOSARCH="${GOOS}_${GOARCH}"
+case "$GOOSARCH" in
+_* | *_ | _)
+	echo 'undefined $GOOS_$GOARCH:' "$GOOSARCH" 1>&2
+	exit 1
+	;;
+esac
+
+GODEFS="go tool cgo -godefs"
+
+$GODEFS types.go |gofmt > ztypes_$GOARCH.go
+
+case $GOOS in
+freebsd)
+	$GODEFS types_$GOOS.go |gofmt > ztypes_$GOOSARCH.go
+	;;
+esac
diff --git a/Godeps/_workspace/src/github.com/kr/pty/pty_darwin.go b/Godeps/_workspace/src/github.com/kr/pty/pty_darwin.go
new file mode 100644
index 0000000..4f4d5ca
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/pty_darwin.go
@@ -0,0 +1,60 @@
+package pty
+
+import (
+	"errors"
+	"os"
+	"syscall"
+	"unsafe"
+)
+
+func open() (pty, tty *os.File, err error) {
+	p, err := os.OpenFile("/dev/ptmx", os.O_RDWR, 0)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	sname, err := ptsname(p)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	err = grantpt(p)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	err = unlockpt(p)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	t, err := os.OpenFile(sname, os.O_RDWR, 0)
+	if err != nil {
+		return nil, nil, err
+	}
+	return p, t, nil
+}
+
+func ptsname(f *os.File) (string, error) {
+	n := make([]byte, _IOC_PARM_LEN(syscall.TIOCPTYGNAME))
+
+	err := ioctl(f.Fd(), syscall.TIOCPTYGNAME, uintptr(unsafe.Pointer(&n[0])))
+	if err != nil {
+		return "", err
+	}
+
+	for i, c := range n {
+		if c == 0 {
+			return string(n[:i]), nil
+		}
+	}
+	return "", errors.New("TIOCPTYGNAME string not NUL-terminated")
+}
+
+func grantpt(f *os.File) error {
+	return ioctl(f.Fd(), syscall.TIOCPTYGRANT, 0)
+}
+
+func unlockpt(f *os.File) error {
+	return ioctl(f.Fd(), syscall.TIOCPTYUNLK, 0)
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/pty_freebsd.go b/Godeps/_workspace/src/github.com/kr/pty/pty_freebsd.go
new file mode 100644
index 0000000..b341bab
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/pty_freebsd.go
@@ -0,0 +1,73 @@
+package pty
+
+import (
+	"errors"
+	"os"
+	"syscall"
+	"unsafe"
+)
+
+func posix_openpt(oflag int) (fd int, err error) {
+	r0, _, e1 := syscall.Syscall(syscall.SYS_POSIX_OPENPT, uintptr(oflag), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = e1
+	}
+	return
+}
+
+func open() (pty, tty *os.File, err error) {
+	fd, err := posix_openpt(syscall.O_RDWR | syscall.O_CLOEXEC)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	p := os.NewFile(uintptr(fd), "/dev/pts")
+	sname, err := ptsname(p)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	t, err := os.OpenFile("/dev/"+sname, os.O_RDWR, 0)
+	if err != nil {
+		return nil, nil, err
+	}
+	return p, t, nil
+}
+
+func isptmaster(fd uintptr) (bool, error) {
+	err := ioctl(fd, syscall.TIOCPTMASTER, 0)
+	return err == nil, err
+}
+
+var (
+	emptyFiodgnameArg fiodgnameArg
+	ioctl_FIODGNAME   = _IOW('f', 120, unsafe.Sizeof(emptyFiodgnameArg))
+)
+
+func ptsname(f *os.File) (string, error) {
+	master, err := isptmaster(f.Fd())
+	if err != nil {
+		return "", err
+	}
+	if !master {
+		return "", syscall.EINVAL
+	}
+
+	const n = _C_SPECNAMELEN + 1
+	var (
+		buf = make([]byte, n)
+		arg = fiodgnameArg{Len: n, Buf: (*byte)(unsafe.Pointer(&buf[0]))}
+	)
+	err = ioctl(f.Fd(), ioctl_FIODGNAME, uintptr(unsafe.Pointer(&arg)))
+	if err != nil {
+		return "", err
+	}
+
+	for i, c := range buf {
+		if c == 0 {
+			return string(buf[:i]), nil
+		}
+	}
+	return "", errors.New("FIODGNAME string not NUL-terminated")
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/pty_linux.go b/Godeps/_workspace/src/github.com/kr/pty/pty_linux.go
new file mode 100644
index 0000000..cb901a2
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/pty_linux.go
@@ -0,0 +1,46 @@
+package pty
+
+import (
+	"os"
+	"strconv"
+	"syscall"
+	"unsafe"
+)
+
+func open() (pty, tty *os.File, err error) {
+	p, err := os.OpenFile("/dev/ptmx", os.O_RDWR, 0)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	sname, err := ptsname(p)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	err = unlockpt(p)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	t, err := os.OpenFile(sname, os.O_RDWR|syscall.O_NOCTTY, 0)
+	if err != nil {
+		return nil, nil, err
+	}
+	return p, t, nil
+}
+
+func ptsname(f *os.File) (string, error) {
+	var n _C_uint
+	err := ioctl(f.Fd(), syscall.TIOCGPTN, uintptr(unsafe.Pointer(&n)))
+	if err != nil {
+		return "", err
+	}
+	return "/dev/pts/" + strconv.Itoa(int(n)), nil
+}
+
+func unlockpt(f *os.File) error {
+	var u _C_int
+	// use TIOCSPTLCK with a zero valued arg to clear the slave pty lock
+	return ioctl(f.Fd(), syscall.TIOCSPTLCK, uintptr(unsafe.Pointer(&u)))
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/pty_unsupported.go b/Godeps/_workspace/src/github.com/kr/pty/pty_unsupported.go
new file mode 100644
index 0000000..898c730
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/pty_unsupported.go
@@ -0,0 +1,11 @@
+// +build !linux,!darwin,!freebsd
+
+package pty
+
+import (
+	"os"
+)
+
+func open() (pty, tty *os.File, err error) {
+	return nil, nil, ErrUnsupported
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/run.go b/Godeps/_workspace/src/github.com/kr/pty/run.go
new file mode 100644
index 0000000..c2bc488
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/run.go
@@ -0,0 +1,32 @@
+package pty
+
+import (
+	"os"
+	"os/exec"
+	"syscall"
+)
+
+// Start assigns a pseudo-terminal tty os.File to c.Stdin, c.Stdout,
+// and c.Stderr, calls c.Start, and returns the File of the tty's
+// corresponding pty.
+func Start(c *exec.Cmd) (pty *os.File, err error) {
+	pty, tty, err := Open()
+	if err != nil {
+		return nil, err
+	}
+	defer tty.Close()
+	c.Stdout = tty
+	c.Stdin = tty
+	c.Stderr = tty
+	if c.SysProcAttr == nil {
+		c.SysProcAttr = &syscall.SysProcAttr{}
+	}
+	c.SysProcAttr.Setctty = true
+	c.SysProcAttr.Setsid = true
+	err = c.Start()
+	if err != nil {
+		pty.Close()
+		return nil, err
+	}
+	return pty, err
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/types.go b/Godeps/_workspace/src/github.com/kr/pty/types.go
new file mode 100644
index 0000000..5aecb6b
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/types.go
@@ -0,0 +1,10 @@
+// +build ignore
+
+package pty
+
+import "C"
+
+type (
+	_C_int  C.int
+	_C_uint C.uint
+)
diff --git a/Godeps/_workspace/src/github.com/kr/pty/types_freebsd.go b/Godeps/_workspace/src/github.com/kr/pty/types_freebsd.go
new file mode 100644
index 0000000..ce3eb95
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/types_freebsd.go
@@ -0,0 +1,15 @@
+// +build ignore
+
+package pty
+
+/*
+#include <sys/param.h>
+#include <sys/filio.h>
+*/
+import "C"
+
+const (
+	_C_SPECNAMELEN = C.SPECNAMELEN /* max length of devicename */
+)
+
+type fiodgnameArg C.struct_fiodgname_arg
diff --git a/Godeps/_workspace/src/github.com/kr/pty/util.go b/Godeps/_workspace/src/github.com/kr/pty/util.go
new file mode 100644
index 0000000..67c52d0
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/util.go
@@ -0,0 +1,35 @@
+package pty
+
+import (
+	"os"
+	"syscall"
+	"unsafe"
+)
+
+// Getsize returns the number of rows (lines) and cols (positions
+// in each line) in terminal t.
+func Getsize(t *os.File) (rows, cols int, err error) {
+	var ws winsize
+	err = windowrect(&ws, t.Fd())
+	return int(ws.ws_row), int(ws.ws_col), err
+}
+
+type winsize struct {
+	ws_row    uint16
+	ws_col    uint16
+	ws_xpixel uint16
+	ws_ypixel uint16
+}
+
+func windowrect(ws *winsize, fd uintptr) error {
+	_, _, errno := syscall.Syscall(
+		syscall.SYS_IOCTL,
+		fd,
+		syscall.TIOCGWINSZ,
+		uintptr(unsafe.Pointer(ws)),
+	)
+	if errno != 0 {
+		return syscall.Errno(errno)
+	}
+	return nil
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ztypes_386.go b/Godeps/_workspace/src/github.com/kr/pty/ztypes_386.go
new file mode 100644
index 0000000..ff0b8fd
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ztypes_386.go
@@ -0,0 +1,9 @@
+// Created by cgo -godefs - DO NOT EDIT
+// cgo -godefs types.go
+
+package pty
+
+type (
+	_C_int  int32
+	_C_uint uint32
+)
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ztypes_amd64.go b/Godeps/_workspace/src/github.com/kr/pty/ztypes_amd64.go
new file mode 100644
index 0000000..ff0b8fd
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ztypes_amd64.go
@@ -0,0 +1,9 @@
+// Created by cgo -godefs - DO NOT EDIT
+// cgo -godefs types.go
+
+package pty
+
+type (
+	_C_int  int32
+	_C_uint uint32
+)
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ztypes_arm.go b/Godeps/_workspace/src/github.com/kr/pty/ztypes_arm.go
new file mode 100644
index 0000000..ff0b8fd
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ztypes_arm.go
@@ -0,0 +1,9 @@
+// Created by cgo -godefs - DO NOT EDIT
+// cgo -godefs types.go
+
+package pty
+
+type (
+	_C_int  int32
+	_C_uint uint32
+)
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ztypes_arm64.go b/Godeps/_workspace/src/github.com/kr/pty/ztypes_arm64.go
new file mode 100644
index 0000000..6c29a4b
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ztypes_arm64.go
@@ -0,0 +1,11 @@
+// Created by cgo -godefs - DO NOT EDIT
+// cgo -godefs types.go
+
+// +build arm64
+
+package pty
+
+type (
+	_C_int  int32
+	_C_uint uint32
+)
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ztypes_freebsd_386.go b/Godeps/_workspace/src/github.com/kr/pty/ztypes_freebsd_386.go
new file mode 100644
index 0000000..d997537
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ztypes_freebsd_386.go
@@ -0,0 +1,13 @@
+// Created by cgo -godefs - DO NOT EDIT
+// cgo -godefs types_freebsd.go
+
+package pty
+
+const (
+	_C_SPECNAMELEN = 0x3f
+)
+
+type fiodgnameArg struct {
+	Len int32
+	Buf *byte
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ztypes_freebsd_amd64.go b/Godeps/_workspace/src/github.com/kr/pty/ztypes_freebsd_amd64.go
new file mode 100644
index 0000000..5fa102f
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ztypes_freebsd_amd64.go
@@ -0,0 +1,14 @@
+// Created by cgo -godefs - DO NOT EDIT
+// cgo -godefs types_freebsd.go
+
+package pty
+
+const (
+	_C_SPECNAMELEN = 0x3f
+)
+
+type fiodgnameArg struct {
+	Len       int32
+	Pad_cgo_0 [4]byte
+	Buf       *byte
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ztypes_freebsd_arm.go b/Godeps/_workspace/src/github.com/kr/pty/ztypes_freebsd_arm.go
new file mode 100644
index 0000000..d997537
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ztypes_freebsd_arm.go
@@ -0,0 +1,13 @@
+// Created by cgo -godefs - DO NOT EDIT
+// cgo -godefs types_freebsd.go
+
+package pty
+
+const (
+	_C_SPECNAMELEN = 0x3f
+)
+
+type fiodgnameArg struct {
+	Len int32
+	Buf *byte
+}
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ztypes_ppc64.go b/Godeps/_workspace/src/github.com/kr/pty/ztypes_ppc64.go
new file mode 100644
index 0000000..4e1af84
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ztypes_ppc64.go
@@ -0,0 +1,11 @@
+// +build ppc64
+
+// Created by cgo -godefs - DO NOT EDIT
+// cgo -godefs types.go
+
+package pty
+
+type (
+	_C_int  int32
+	_C_uint uint32
+)
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ztypes_ppc64le.go b/Godeps/_workspace/src/github.com/kr/pty/ztypes_ppc64le.go
new file mode 100644
index 0000000..e6780f4
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ztypes_ppc64le.go
@@ -0,0 +1,11 @@
+// +build ppc64le
+
+// Created by cgo -godefs - DO NOT EDIT
+// cgo -godefs types.go
+
+package pty
+
+type (
+	_C_int  int32
+	_C_uint uint32
+)
diff --git a/Godeps/_workspace/src/github.com/kr/pty/ztypes_s390x.go b/Godeps/_workspace/src/github.com/kr/pty/ztypes_s390x.go
new file mode 100644
index 0000000..a7452b6
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/kr/pty/ztypes_s390x.go
@@ -0,0 +1,11 @@
+// +build s390x
+
+// Created by cgo -godefs - DO NOT EDIT
+// cgo -godefs types.go
+
+package pty
+
+type (
+	_C_int  int32
+	_C_uint uint32
+)
