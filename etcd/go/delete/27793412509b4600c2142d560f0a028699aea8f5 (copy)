commit 27793412509b4600c2142d560f0a028699aea8f5
Author: Gyu-Ho Lee <gyuhox@gmail.com>
Date:   Thu Apr 7 10:28:03 2016 -0700

    e2e: clean up, return all lines in error
    
    1. change file names
    2. now if sub-command errors, the test will receive all
    lines from stdout and stderr.
    
    Expected output:
    
    ```
    read /dev/ptmx: input/output error (expected key2, got ["key1\r\n" "val1\r\n" ""])
    ```
    
    3. change how we check GRPC timeout (only bypass timeout error when we give 0
    timeout)

diff --git a/e2e/ctl_v2_test.go b/e2e/ctl_v2_test.go
new file mode 100644
index 0000000..76b127f
--- /dev/null
+++ b/e2e/ctl_v2_test.go
@@ -0,0 +1,339 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package e2e
+
+import (
+	"strings"
+	"testing"
+	"time"
+
+	"github.com/coreos/etcd/pkg/fileutil"
+	"github.com/coreos/etcd/pkg/testutil"
+)
+
+func TestCtlV2Set(t *testing.T)          { testCtlV2Set(t, &configNoTLS, false) }
+func TestCtlV2SetQuorum(t *testing.T)    { testCtlV2Set(t, &configNoTLS, true) }
+func TestCtlV2SetClientTLS(t *testing.T) { testCtlV2Set(t, &configClientTLS, false) }
+func TestCtlV2SetPeerTLS(t *testing.T)   { testCtlV2Set(t, &configPeerTLS, false) }
+func TestCtlV2SetTLS(t *testing.T)       { testCtlV2Set(t, &configTLS, false) }
+func testCtlV2Set(t *testing.T, cfg *etcdProcessClusterConfig, quorum bool) {
+	defer testutil.AfterTest(t)
+
+	epc := setupEtcdctlTest(t, cfg, quorum)
+	defer func() {
+		if errC := epc.Close(); errC != nil {
+			t.Fatalf("error closing etcd processes (%v)", errC)
+		}
+	}()
+
+	key, value := "foo", "bar"
+
+	if err := etcdctlSet(epc, key, value); err != nil {
+		t.Fatalf("failed set (%v)", err)
+	}
+
+	if err := etcdctlGet(epc, key, value, quorum); err != nil {
+		t.Fatalf("failed get (%v)", err)
+	}
+}
+
+func TestCtlV2Mk(t *testing.T)       { testCtlV2Mk(t, &configNoTLS, false) }
+func TestCtlV2MkQuorum(t *testing.T) { testCtlV2Mk(t, &configNoTLS, true) }
+func TestCtlV2MkTLS(t *testing.T)    { testCtlV2Mk(t, &configTLS, false) }
+func testCtlV2Mk(t *testing.T, cfg *etcdProcessClusterConfig, quorum bool) {
+	defer testutil.AfterTest(t)
+
+	epc := setupEtcdctlTest(t, cfg, quorum)
+	defer func() {
+		if errC := epc.Close(); errC != nil {
+			t.Fatalf("error closing etcd processes (%v)", errC)
+		}
+	}()
+
+	key, value := "foo", "bar"
+
+	if err := etcdctlMk(epc, key, value, true); err != nil {
+		t.Fatalf("failed mk (%v)", err)
+	}
+	if err := etcdctlMk(epc, key, value, false); err != nil {
+		t.Fatalf("failed mk (%v)", err)
+	}
+
+	if err := etcdctlGet(epc, key, value, quorum); err != nil {
+		t.Fatalf("failed get (%v)", err)
+	}
+}
+
+func TestCtlV2Rm(t *testing.T)    { testCtlV2Rm(t, &configNoTLS) }
+func TestCtlV2RmTLS(t *testing.T) { testCtlV2Rm(t, &configTLS) }
+func testCtlV2Rm(t *testing.T, cfg *etcdProcessClusterConfig) {
+	defer testutil.AfterTest(t)
+
+	epc := setupEtcdctlTest(t, cfg, true)
+	defer func() {
+		if errC := epc.Close(); errC != nil {
+			t.Fatalf("error closing etcd processes (%v)", errC)
+		}
+	}()
+
+	key, value := "foo", "bar"
+
+	if err := etcdctlSet(epc, key, value); err != nil {
+		t.Fatalf("failed set (%v)", err)
+	}
+
+	if err := etcdctlRm(epc, key, value, true); err != nil {
+		t.Fatalf("failed rm (%v)", err)
+	}
+	if err := etcdctlRm(epc, key, value, false); err != nil {
+		t.Fatalf("failed rm (%v)", err)
+	}
+}
+
+func TestCtlV2Ls(t *testing.T)       { testCtlV2Ls(t, &configNoTLS, false) }
+func TestCtlV2LsQuorum(t *testing.T) { testCtlV2Ls(t, &configNoTLS, true) }
+func TestCtlV2LsTLS(t *testing.T)    { testCtlV2Ls(t, &configTLS, false) }
+func testCtlV2Ls(t *testing.T, cfg *etcdProcessClusterConfig, quorum bool) {
+	defer testutil.AfterTest(t)
+
+	epc := setupEtcdctlTest(t, cfg, quorum)
+	defer func() {
+		if errC := epc.Close(); errC != nil {
+			t.Fatalf("error closing etcd processes (%v)", errC)
+		}
+	}()
+
+	key, value := "foo", "bar"
+
+	if err := etcdctlSet(epc, key, value); err != nil {
+		t.Fatalf("failed set (%v)", err)
+	}
+
+	if err := etcdctlLs(epc, key, quorum); err != nil {
+		t.Fatalf("failed ls (%v)", err)
+	}
+}
+
+func TestCtlV2Watch(t *testing.T)                { testCtlV2Watch(t, &configNoTLS, false) }
+func TestCtlV2WatchTLS(t *testing.T)             { testCtlV2Watch(t, &configTLS, false) }
+func TestCtlV2WatchWithProxy(t *testing.T)       { testCtlV2Watch(t, &configWithProxy, false) }
+func TestCtlV2WatchWithProxyNoSync(t *testing.T) { testCtlV2Watch(t, &configWithProxy, true) }
+func testCtlV2Watch(t *testing.T, cfg *etcdProcessClusterConfig, noSync bool) {
+	defer testutil.AfterTest(t)
+
+	epc := setupEtcdctlTest(t, cfg, true)
+	defer func() {
+		if errC := epc.Close(); errC != nil {
+			t.Fatalf("error closing etcd processes (%v)", errC)
+		}
+	}()
+
+	key, value := "foo", "bar"
+	errc := etcdctlWatch(epc, key, value, noSync)
+	if err := etcdctlSet(epc, key, value); err != nil {
+		t.Fatalf("failed set (%v)", err)
+	}
+
+	select {
+	case err := <-errc:
+		if err != nil {
+			t.Fatalf("failed watch (%v)", err)
+		}
+	case <-time.After(5 * time.Second):
+		t.Fatalf("watch timed out")
+	}
+}
+
+func TestCtlV2GetRoleUser(t *testing.T)          { testCtlV2GetRoleUser(t, &configNoTLS) }
+func TestCtlV2GetRoleUserWithProxy(t *testing.T) { testCtlV2GetRoleUser(t, &configWithProxy) }
+
+func testCtlV2GetRoleUser(t *testing.T, cfg *etcdProcessClusterConfig) {
+	defer testutil.AfterTest(t)
+
+	epc := setupEtcdctlTest(t, cfg, true)
+	defer func() {
+		if err := epc.Close(); err != nil {
+			t.Fatalf("error closing etcd processes (%v)", err)
+		}
+	}()
+
+	// wait for the server capabilities to be updated based on the version;
+	// the update loop has a delay of 500ms, so 1s should be enough wait time
+	time.Sleep(time.Second)
+
+	if err := etcdctlRoleAdd(epc, "foo"); err != nil {
+		t.Fatalf("failed to add role (%v)", err)
+	}
+	if err := etcdctlUserAdd(epc, "username", "password"); err != nil {
+		t.Fatalf("failed to add user (%v)", err)
+	}
+	if err := etcdctlUserGrant(epc, "username", "foo"); err != nil {
+		t.Fatalf("failed to grant role (%v)", err)
+	}
+	if err := etcdctlUserGet(epc, "username"); err != nil {
+		t.Fatalf("failed to get user (%v)", err)
+	}
+}
+
+func TestCtlV2UserList(t *testing.T) {
+	defer testutil.AfterTest(t)
+
+	epc := setupEtcdctlTest(t, &configWithProxy, false)
+	defer func() {
+		if err := epc.Close(); err != nil {
+			t.Fatalf("error closing etcd processes (%v)", err)
+		}
+	}()
+
+	if err := etcdctlUserAdd(epc, "username", "password"); err != nil {
+		t.Fatalf("failed to add user (%v)", err)
+	}
+	if err := etcdctlUserList(epc, "username"); err != nil {
+		t.Fatalf("failed to list users (%v)", err)
+	}
+}
+
+func TestCtlV2RoleList(t *testing.T) {
+	defer testutil.AfterTest(t)
+
+	epc := setupEtcdctlTest(t, &configWithProxy, false)
+	defer func() {
+		if err := epc.Close(); err != nil {
+			t.Fatalf("error closing etcd processes (%v)", err)
+		}
+	}()
+
+	if err := etcdctlRoleAdd(epc, "foo"); err != nil {
+		t.Fatalf("failed to add role (%v)", err)
+	}
+	if err := etcdctlRoleList(epc, "foo"); err != nil {
+		t.Fatalf("failed to list roles (%v)", err)
+	}
+}
+
+func etcdctlPrefixArgs(clus *etcdProcessCluster) []string {
+	endpoints := ""
+	if proxies := clus.proxies(); len(proxies) != 0 {
+		endpoints = proxies[0].cfg.acurl
+	} else if backends := clus.backends(); len(backends) != 0 {
+		es := []string{}
+		for _, b := range backends {
+			es = append(es, b.cfg.acurl)
+		}
+		endpoints = strings.Join(es, ",")
+	}
+	cmdArgs := []string{"../bin/etcdctl", "--endpoints", endpoints}
+	if clus.cfg.clientTLS == clientTLS {
+		cmdArgs = append(cmdArgs, "--ca-file", caPath, "--cert-file", certPath, "--key-file", privateKeyPath)
+	}
+	return cmdArgs
+}
+
+func etcdctlSet(clus *etcdProcessCluster, key, value string) error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "set", key, value)
+	return spawnWithExpect(cmdArgs, value)
+}
+
+func etcdctlMk(clus *etcdProcessCluster, key, value string, first bool) error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "mk", key, value)
+	if first {
+		return spawnWithExpect(cmdArgs, value)
+	}
+	return spawnWithExpect(cmdArgs, "Error:  105: Key already exists")
+}
+
+func etcdctlGet(clus *etcdProcessCluster, key, value string, quorum bool) error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "get", key)
+	if quorum {
+		cmdArgs = append(cmdArgs, "--quorum")
+	}
+	return spawnWithExpect(cmdArgs, value)
+}
+
+func etcdctlRm(clus *etcdProcessCluster, key, value string, first bool) error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "rm", key)
+	if first {
+		return spawnWithExpect(cmdArgs, "PrevNode.Value: "+value)
+	}
+	return spawnWithExpect(cmdArgs, "Error:  100: Key not found")
+}
+
+func etcdctlLs(clus *etcdProcessCluster, key string, quorum bool) error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "ls")
+	if quorum {
+		cmdArgs = append(cmdArgs, "--quorum")
+	}
+	return spawnWithExpect(cmdArgs, key)
+}
+
+func etcdctlWatch(clus *etcdProcessCluster, key, value string, noSync bool) <-chan error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "watch", "--after-index 1", key)
+	if noSync {
+		cmdArgs = append(cmdArgs, "--no-sync")
+	}
+	errc := make(chan error, 1)
+	go func() {
+		errc <- spawnWithExpect(cmdArgs, value)
+	}()
+	return errc
+}
+
+func etcdctlRoleAdd(clus *etcdProcessCluster, role string) error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "role", "add", role)
+	return spawnWithExpect(cmdArgs, role)
+}
+
+func etcdctlRoleList(clus *etcdProcessCluster, expectedRole string) error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "role", "list")
+	return spawnWithExpect(cmdArgs, expectedRole)
+}
+
+func etcdctlUserAdd(clus *etcdProcessCluster, user, pass string) error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "user", "add", user+":"+pass)
+	return spawnWithExpect(cmdArgs, "User "+user+" created")
+}
+
+func etcdctlUserGrant(clus *etcdProcessCluster, user, role string) error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "user", "grant", "--roles", role, user)
+	return spawnWithExpect(cmdArgs, "User "+user+" updated")
+}
+
+func etcdctlUserGet(clus *etcdProcessCluster, user string) error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "user", "get", user)
+	return spawnWithExpect(cmdArgs, "User: "+user)
+}
+
+func etcdctlUserList(clus *etcdProcessCluster, expectedUser string) error {
+	cmdArgs := append(etcdctlPrefixArgs(clus), "user", "list")
+	return spawnWithExpect(cmdArgs, expectedUser)
+}
+
+func mustEtcdctl(t *testing.T) {
+	if !fileutil.Exist("../bin/etcdctl") {
+		t.Fatalf("could not find etcdctl binary")
+	}
+}
+
+func setupEtcdctlTest(t *testing.T, cfg *etcdProcessClusterConfig, quorum bool) *etcdProcessCluster {
+	mustEtcdctl(t)
+	if !quorum {
+		cfg = configStandalone(*cfg)
+	}
+	epc, err := newEtcdProcessCluster(cfg)
+	if err != nil {
+		t.Fatalf("could not start etcd process cluster (%v)", err)
+	}
+	return epc
+}
diff --git a/e2e/ctl_v3_test.go b/e2e/ctl_v3_test.go
new file mode 100644
index 0000000..2a9a606
--- /dev/null
+++ b/e2e/ctl_v3_test.go
@@ -0,0 +1,527 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package e2e
+
+import (
+	"fmt"
+	"os"
+	"strings"
+	"testing"
+	"time"
+
+	"github.com/coreos/etcd/pkg/testutil"
+	"github.com/coreos/etcd/version"
+)
+
+func TestCtlV3Put(t *testing.T)          { testCtl(t, putTest) }
+func TestCtlV3PutNoTLS(t *testing.T)     { testCtl(t, putTest, withCfg(configNoTLS)) }
+func TestCtlV3PutClientTLS(t *testing.T) { testCtl(t, putTest, withCfg(configClientTLS)) }
+func TestCtlV3PutPeerTLS(t *testing.T)   { testCtl(t, putTest, withCfg(configPeerTLS)) }
+func TestCtlV3PutTimeout(t *testing.T)   { testCtl(t, putTest, withDialTimeout(0)) }
+
+func TestCtlV3Get(t *testing.T)          { testCtl(t, getTest) }
+func TestCtlV3GetNoTLS(t *testing.T)     { testCtl(t, getTest, withCfg(configNoTLS)) }
+func TestCtlV3GetClientTLS(t *testing.T) { testCtl(t, getTest, withCfg(configClientTLS)) }
+func TestCtlV3GetPeerTLS(t *testing.T)   { testCtl(t, getTest, withCfg(configPeerTLS)) }
+func TestCtlV3GetTimeout(t *testing.T)   { testCtl(t, getTest, withDialTimeout(0)) }
+func TestCtlV3GetQuorum(t *testing.T)    { testCtl(t, getTest, withQuorum()) }
+
+func TestCtlV3Del(t *testing.T)          { testCtl(t, delTest) }
+func TestCtlV3DelNoTLS(t *testing.T)     { testCtl(t, delTest, withCfg(configNoTLS)) }
+func TestCtlV3DelClientTLS(t *testing.T) { testCtl(t, delTest, withCfg(configClientTLS)) }
+func TestCtlV3DelPeerTLS(t *testing.T)   { testCtl(t, delTest, withCfg(configPeerTLS)) }
+func TestCtlV3DelTimeout(t *testing.T)   { testCtl(t, delTest, withDialTimeout(0)) }
+
+func TestCtlV3Watch(t *testing.T)          { testCtl(t, watchTest) }
+func TestCtlV3WatchNoTLS(t *testing.T)     { testCtl(t, watchTest, withCfg(configNoTLS)) }
+func TestCtlV3WatchClientTLS(t *testing.T) { testCtl(t, watchTest, withCfg(configClientTLS)) }
+func TestCtlV3WatchPeerTLS(t *testing.T)   { testCtl(t, watchTest, withCfg(configPeerTLS)) }
+func TestCtlV3WatchTimeout(t *testing.T)   { testCtl(t, watchTest, withDialTimeout(0)) }
+func TestCtlV3WatchInteractive(t *testing.T) {
+	testCtl(t, watchTest, withInteractive())
+}
+func TestCtlV3WatchInteractiveNoTLS(t *testing.T) {
+	testCtl(t, watchTest, withInteractive(), withCfg(configNoTLS))
+}
+func TestCtlV3WatchInteractiveClientTLS(t *testing.T) {
+	testCtl(t, watchTest, withInteractive(), withCfg(configClientTLS))
+}
+func TestCtlV3WatchInteractivePeerTLS(t *testing.T) {
+	testCtl(t, watchTest, withInteractive(), withCfg(configPeerTLS))
+}
+
+func TestCtlV3TxnInteractiveSuccess(t *testing.T) {
+	testCtl(t, txnTestSuccess, withInteractive())
+}
+func TestCtlV3TxnInteractiveSuccessNoTLS(t *testing.T) {
+	testCtl(t, txnTestSuccess, withInteractive(), withCfg(configNoTLS))
+}
+func TestCtlV3TxnInteractiveSuccessClientTLS(t *testing.T) {
+	testCtl(t, txnTestSuccess, withInteractive(), withCfg(configClientTLS))
+}
+func TestCtlV3TxnInteractiveSuccessPeerTLS(t *testing.T) {
+	testCtl(t, txnTestSuccess, withInteractive(), withCfg(configPeerTLS))
+}
+func TestCtlV3TxnInteractiveFail(t *testing.T) {
+	testCtl(t, txnTestFail, withInteractive())
+}
+
+func TestCtlV3Version(t *testing.T)        { testCtl(t, versionTest) }
+func TestCtlV3EpHealthQuorum(t *testing.T) { testCtl(t, epHealthTest, withQuorum()) }
+
+type ctlCtx struct {
+	t   *testing.T
+	cfg etcdProcessClusterConfig
+	epc *etcdProcessCluster
+
+	errc        chan error
+	dialTimeout time.Duration
+
+	quorum      bool // if true, set up 3-node cluster and linearizable read
+	interactive bool
+}
+
+type ctlOption func(*ctlCtx)
+
+func (cx *ctlCtx) applyOpts(opts []ctlOption) {
+	for _, opt := range opts {
+		opt(cx)
+	}
+}
+
+func withCfg(cfg etcdProcessClusterConfig) ctlOption {
+	return func(cx *ctlCtx) { cx.cfg = cfg }
+}
+
+func withDialTimeout(timeout time.Duration) ctlOption {
+	return func(cx *ctlCtx) { cx.dialTimeout = timeout }
+}
+
+func withQuorum() ctlOption {
+	return func(cx *ctlCtx) { cx.quorum = true }
+}
+
+func withInteractive() ctlOption {
+	return func(cx *ctlCtx) { cx.interactive = true }
+}
+
+func setupCtlV3Test(t *testing.T, cfg etcdProcessClusterConfig, quorum bool) *etcdProcessCluster {
+	mustEtcdctl(t)
+	if !quorum {
+		cfg = *configStandalone(cfg)
+	}
+	epc, err := newEtcdProcessCluster(&cfg)
+	if err != nil {
+		t.Fatalf("could not start etcd process cluster (%v)", err)
+	}
+	return epc
+}
+
+func testCtl(t *testing.T, testFunc func(ctlCtx), opts ...ctlOption) {
+	defer testutil.AfterTest(t)
+
+	ret := ctlCtx{
+		t:           t,
+		cfg:         configAutoTLS,
+		errc:        make(chan error, 1),
+		dialTimeout: 7 * time.Second,
+	}
+	ret.applyOpts(opts)
+
+	os.Setenv("ETCDCTL_API", "3")
+	ret.epc = setupCtlV3Test(ret.t, ret.cfg, ret.quorum)
+
+	defer func() {
+		os.Unsetenv("ETCDCTL_API")
+		if errC := ret.epc.Close(); errC != nil {
+			t.Fatalf("error closing etcd processes (%v)", errC)
+		}
+	}()
+
+	go testFunc(ret)
+
+	select {
+	case <-time.After(2*ret.dialTimeout + time.Second):
+		if ret.dialTimeout > 0 {
+			t.Fatalf("test timed out for %v", ret.dialTimeout)
+		}
+	case err := <-ret.errc:
+		if err != nil {
+			t.Fatal(err)
+		}
+	}
+	return
+}
+
+func putTest(cx ctlCtx) {
+	defer close(cx.errc)
+
+	key, value := "foo", "bar"
+
+	if err := ctlV3Put(cx, key, value, ""); err != nil {
+		if cx.dialTimeout > 0 && !isGRPCTimedout(err) {
+			cx.t.Fatalf("putTest ctlV3Put error (%v)", err)
+		}
+	}
+	if err := ctlV3Get(cx, []string{key}, kv{key, value}); err != nil {
+		if cx.dialTimeout > 0 && !isGRPCTimedout(err) {
+			cx.t.Fatalf("putTest ctlV3Get error (%v)", err)
+		}
+	}
+}
+
+func getTest(cx ctlCtx) {
+	defer close(cx.errc)
+
+	var (
+		kvs    = []kv{{"key1", "val1"}, {"key2", "val2"}, {"key3", "val3"}}
+		revkvs = []kv{{"key3", "val3"}, {"key2", "val2"}, {"key1", "val1"}}
+	)
+
+	tests := []struct {
+		args []string
+
+		wkv []kv
+	}{
+		{[]string{"key1"}, []kv{{"key1", "val1"}}},
+		{[]string{"key", "--prefix"}, kvs},
+		{[]string{"key", "--prefix", "--limit=2"}, kvs[:2]},
+		{[]string{"key", "--prefix", "--order=ASCEND", "--sort-by=MODIFY"}, kvs},
+		{[]string{"key", "--prefix", "--order=ASCEND", "--sort-by=VERSION"}, kvs},
+		{[]string{"key", "--prefix", "--order=DESCEND", "--sort-by=CREATE"}, revkvs},
+		{[]string{"key", "--prefix", "--order=DESCEND", "--sort-by=KEY"}, revkvs},
+	}
+
+	for i := range kvs {
+		if err := ctlV3Put(cx, kvs[i].key, kvs[i].val, ""); err != nil {
+			cx.t.Fatalf("getTest #%d: ctlV3Put error (%v)", i, err)
+		}
+	}
+	for i, tt := range tests {
+		if err := ctlV3Get(cx, tt.args, tt.wkv...); err != nil {
+			if cx.dialTimeout > 0 && !isGRPCTimedout(err) {
+				cx.t.Errorf("getTest #%d: ctlV3Get error (%v)", i, err)
+			}
+		}
+	}
+}
+
+func delTest(cx ctlCtx) {
+	defer close(cx.errc)
+
+	tests := []struct {
+		puts []kv
+		args []string
+
+		deletedNum int
+	}{
+		{
+			[]kv{{"this", "value"}},
+			[]string{"that"},
+			0,
+		},
+		{
+			[]kv{{"sample", "value"}},
+			[]string{"sample"},
+			1,
+		},
+		{
+			[]kv{{"key1", "val1"}, {"key2", "val2"}, {"key3", "val3"}},
+			[]string{"key", "--prefix"},
+			3,
+		},
+	}
+
+	for i, tt := range tests {
+		for j := range tt.puts {
+			if err := ctlV3Put(cx, tt.puts[j].key, tt.puts[j].val, ""); err != nil {
+				cx.t.Fatalf("delTest #%d-%d: ctlV3Put error (%v)", i, j, err)
+			}
+		}
+		if err := ctlV3Del(cx, tt.args, tt.deletedNum); err != nil {
+			if cx.dialTimeout > 0 && !isGRPCTimedout(err) {
+				cx.t.Fatalf("delTest #%d: ctlV3Del error (%v)", i, err)
+			}
+		}
+	}
+}
+
+func watchTest(cx ctlCtx) {
+	defer close(cx.errc)
+
+	tests := []struct {
+		puts []kv
+		args []string
+
+		wkv []kv
+	}{
+		{
+			[]kv{{"sample", "value"}},
+			[]string{"sample", "--rev", "1"},
+			[]kv{{"sample", "value"}},
+		},
+		{
+			[]kv{{"key1", "val1"}, {"key2", "val2"}, {"key3", "val3"}},
+			[]string{"key", "--rev", "1", "--prefix"},
+			[]kv{{"key1", "val1"}, {"key2", "val2"}, {"key3", "val3"}},
+		},
+		{
+			[]kv{{"etcd", "revision_1"}, {"etcd", "revision_2"}, {"etcd", "revision_3"}},
+			[]string{"etcd", "--rev", "2"},
+			[]kv{{"etcd", "revision_2"}, {"etcd", "revision_3"}},
+		},
+	}
+
+	for i, tt := range tests {
+		go func() {
+			for j := range tt.puts {
+				if err := ctlV3Put(cx, tt.puts[j].key, tt.puts[j].val, ""); err != nil {
+					cx.t.Fatalf("watchTest #%d-%d: ctlV3Put error (%v)", i, j, err)
+				}
+			}
+		}()
+		if err := ctlV3Watch(cx, tt.args, tt.wkv...); err != nil {
+			if cx.dialTimeout > 0 && !isGRPCTimedout(err) {
+				cx.t.Errorf("watchTest #%d: ctlV3Watch error (%v)", i, err)
+			}
+		}
+	}
+}
+
+func versionTest(cx ctlCtx) {
+	defer close(cx.errc)
+
+	if err := ctlV3Version(cx); err != nil {
+		cx.t.Fatalf("versionTest ctlV3Version error (%v)", err)
+	}
+}
+
+func epHealthTest(cx ctlCtx) {
+	defer close(cx.errc)
+
+	if err := ctlV3EpHealth(cx); err != nil {
+		cx.t.Fatalf("epHealthTest ctlV3EpHealth error (%v)", err)
+	}
+}
+
+func txnTestSuccess(cx ctlCtx) {
+	defer close(cx.errc)
+
+	if err := ctlV3Put(cx, "key1", "value1", ""); err != nil {
+		cx.t.Fatalf("txnTestSuccess ctlV3Put error (%v)", err)
+	}
+	if err := ctlV3Put(cx, "key2", "value2", ""); err != nil {
+		cx.t.Fatalf("txnTestSuccess ctlV3Put error (%v)", err)
+	}
+
+	rqs := txnRequests{
+		compare:  []string{`version("key1") = "1"`, `version("key2") = "1"`},
+		ifSucess: []string{"get key1", "get key2"},
+		ifFail:   []string{`put key1 "fail"`, `put key2 "fail"`},
+		results:  []string{"SUCCESS", "key1", "value1", "key2", "value2"},
+	}
+	if err := ctlV3Txn(cx, rqs); err != nil {
+		cx.t.Fatal(err)
+	}
+}
+
+func txnTestFail(cx ctlCtx) {
+	defer close(cx.errc)
+
+	rqs := txnRequests{
+		compare:  []string{`version("key") < "0"`},
+		ifSucess: []string{`put key "success"`},
+		ifFail:   []string{`put key "fail"`},
+		results:  []string{"FAILURE", "OK"},
+	}
+	if err := ctlV3Txn(cx, rqs); err != nil {
+		cx.t.Fatal(err)
+	}
+}
+
+func ctlV3PrefixArgs(clus *etcdProcessCluster, dialTimeout time.Duration) []string {
+	if len(clus.proxies()) > 0 { // TODO: add proxy check as in v2
+		panic("v3 proxy not implemented")
+	}
+
+	endpoints := ""
+	if backends := clus.backends(); len(backends) != 0 {
+		es := []string{}
+		for _, b := range backends {
+			es = append(es, stripSchema(b.cfg.acurl))
+		}
+		endpoints = strings.Join(es, ",")
+	}
+	cmdArgs := []string{"../bin/etcdctl", "--endpoints", endpoints, "--dial-timeout", dialTimeout.String()}
+	if clus.cfg.clientTLS == clientTLS {
+		cmdArgs = append(cmdArgs, "--cacert", caPath, "--cert", certPath, "--key", privateKeyPath)
+	}
+	return cmdArgs
+}
+
+func ctlV3Put(cx ctlCtx, key, value, leaseID string) error {
+	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "put", key, value)
+	if leaseID != "" {
+		cmdArgs = append(cmdArgs, "--lease", leaseID)
+	}
+	return spawnWithExpect(cmdArgs, "OK")
+}
+
+type kv struct {
+	key, val string
+}
+
+func ctlV3Get(cx ctlCtx, args []string, kvs ...kv) error {
+	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "get")
+	cmdArgs = append(cmdArgs, args...)
+	if !cx.quorum {
+		cmdArgs = append(cmdArgs, "--consistency", "s")
+	}
+	var lines []string
+	for _, elem := range kvs {
+		lines = append(lines, elem.key, elem.val)
+	}
+	return spawnWithExpects(cmdArgs, lines...)
+}
+
+func ctlV3Del(cx ctlCtx, args []string, num int) error {
+	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "del")
+	cmdArgs = append(cmdArgs, args...)
+	return spawnWithExpects(cmdArgs, fmt.Sprintf("%d", num))
+}
+
+func ctlV3Watch(cx ctlCtx, args []string, kvs ...kv) error {
+	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "watch")
+	if cx.interactive {
+		cmdArgs = append(cmdArgs, "--interactive")
+	} else {
+		cmdArgs = append(cmdArgs, args...)
+	}
+
+	proc, err := spawnCmd(cmdArgs)
+	if err != nil {
+		return err
+	}
+
+	if cx.interactive {
+		wl := strings.Join(append([]string{"watch"}, args...), " ") + "\r"
+		if err = proc.Send(wl); err != nil {
+			return err
+		}
+	}
+
+	for _, elem := range kvs {
+		if _, err = proc.Expect(elem.key); err != nil {
+			return err
+		}
+		if _, err = proc.Expect(elem.val); err != nil {
+			return err
+		}
+	}
+	return proc.Stop()
+}
+
+type txnRequests struct {
+	compare  []string
+	ifSucess []string
+	ifFail   []string
+	results  []string
+}
+
+func ctlV3Txn(cx ctlCtx, rqs txnRequests) error {
+	// TODO: support non-interactive mode
+	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "txn")
+	if cx.interactive {
+		cmdArgs = append(cmdArgs, "--interactive")
+	}
+	proc, err := spawnCmd(cmdArgs)
+	if err != nil {
+		return err
+	}
+	_, err = proc.Expect("compares:")
+	if err != nil {
+		return err
+	}
+	for _, req := range rqs.compare {
+		if err = proc.Send(req + "\r"); err != nil {
+			return err
+		}
+	}
+	if err = proc.Send("\r"); err != nil {
+		return err
+	}
+
+	_, err = proc.Expect("success requests (get, put, delete):")
+	if err != nil {
+		return err
+	}
+	for _, req := range rqs.ifSucess {
+		if err = proc.Send(req + "\r"); err != nil {
+			return err
+		}
+	}
+	if err = proc.Send("\r"); err != nil {
+		return err
+	}
+
+	_, err = proc.Expect("failure requests (get, put, delete):")
+	if err != nil {
+		return err
+	}
+	for _, req := range rqs.ifFail {
+		if err = proc.Send(req + "\r"); err != nil {
+			return err
+		}
+	}
+	if err = proc.Send("\r"); err != nil {
+		return err
+	}
+
+	for _, line := range rqs.results {
+		_, err = proc.Expect(line)
+		if err != nil {
+			return err
+		}
+	}
+	return proc.Close()
+}
+
+func ctlV3Version(cx ctlCtx) error {
+	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "version")
+	return spawnWithExpect(cmdArgs, version.Version)
+}
+
+func ctlV3EpHealth(cx ctlCtx) error {
+	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "endpoint-health")
+	lines := make([]string, cx.epc.cfg.clusterSize)
+	for i := range lines {
+		lines[i] = "is healthy"
+	}
+	return spawnWithExpects(cmdArgs, lines...)
+}
+
+func isGRPCTimedout(err error) bool {
+	return strings.Contains(err.Error(), "grpc: timed out trying to connect")
+}
+
+func stripSchema(s string) string {
+	if strings.HasPrefix(s, "http://") {
+		s = strings.Replace(s, "http://", "", -1)
+	}
+	if strings.HasPrefix(s, "https://") {
+		s = strings.Replace(s, "https://", "", -1)
+	}
+	return s
+}
diff --git a/e2e/etcd_test.go b/e2e/etcd_test.go
index d49fe70..5eb57ea 100644
--- a/e2e/etcd_test.go
+++ b/e2e/etcd_test.go
@@ -416,8 +416,7 @@ func (epc *etcdProcessCluster) Close() (err error) {
 }
 
 func spawnCmd(args []string) (*expect.ExpectProcess, error) {
-	// redirect stderr to stdout since expect only uses stdout
-	cmdargs := append([]string{"-c"}, strings.Join(append(args, "2>&1"), " "))
+	cmdargs := append([]string{"-c"}, strings.Join(args, " "))
 	return expect.NewExpect("/bin/sh", cmdargs...)
 }
 
@@ -430,16 +429,31 @@ func spawnWithExpects(args []string, xs ...string) error {
 	if err != nil {
 		return err
 	}
+	// process until either stdout or stderr contains
+	// the expected string
+	var (
+		lines    []string
+		lineFunc = func(txt string) bool { return true }
+	)
 	for _, txt := range xs {
-		_, err = proc.Expect(txt)
-		if err != nil {
-			return err
+		for {
+			l, err := proc.ExpectFunc(lineFunc)
+			if err != nil {
+				return fmt.Errorf("%v (expected %s, got %q)", err, txt, lines)
+			}
+			lines = append(lines, l)
+			if strings.Contains(l, txt) {
+				break
+			}
 		}
 	}
 	perr := proc.Close()
 	if err != nil {
 		return err
 	}
+	if len(xs) == 0 && proc.LineCount() != 0 { // expect no output
+		return fmt.Errorf("unexpected output (got lines %q, line count %d)", lines, proc.LineCount())
+	}
 	return perr
 }
 
diff --git a/e2e/etcdctl_test.go b/e2e/etcdctl_test.go
deleted file mode 100644
index 76b127f..0000000
--- a/e2e/etcdctl_test.go
+++ /dev/null
@@ -1,339 +0,0 @@
-// Copyright 2016 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package e2e
-
-import (
-	"strings"
-	"testing"
-	"time"
-
-	"github.com/coreos/etcd/pkg/fileutil"
-	"github.com/coreos/etcd/pkg/testutil"
-)
-
-func TestCtlV2Set(t *testing.T)          { testCtlV2Set(t, &configNoTLS, false) }
-func TestCtlV2SetQuorum(t *testing.T)    { testCtlV2Set(t, &configNoTLS, true) }
-func TestCtlV2SetClientTLS(t *testing.T) { testCtlV2Set(t, &configClientTLS, false) }
-func TestCtlV2SetPeerTLS(t *testing.T)   { testCtlV2Set(t, &configPeerTLS, false) }
-func TestCtlV2SetTLS(t *testing.T)       { testCtlV2Set(t, &configTLS, false) }
-func testCtlV2Set(t *testing.T, cfg *etcdProcessClusterConfig, quorum bool) {
-	defer testutil.AfterTest(t)
-
-	epc := setupEtcdctlTest(t, cfg, quorum)
-	defer func() {
-		if errC := epc.Close(); errC != nil {
-			t.Fatalf("error closing etcd processes (%v)", errC)
-		}
-	}()
-
-	key, value := "foo", "bar"
-
-	if err := etcdctlSet(epc, key, value); err != nil {
-		t.Fatalf("failed set (%v)", err)
-	}
-
-	if err := etcdctlGet(epc, key, value, quorum); err != nil {
-		t.Fatalf("failed get (%v)", err)
-	}
-}
-
-func TestCtlV2Mk(t *testing.T)       { testCtlV2Mk(t, &configNoTLS, false) }
-func TestCtlV2MkQuorum(t *testing.T) { testCtlV2Mk(t, &configNoTLS, true) }
-func TestCtlV2MkTLS(t *testing.T)    { testCtlV2Mk(t, &configTLS, false) }
-func testCtlV2Mk(t *testing.T, cfg *etcdProcessClusterConfig, quorum bool) {
-	defer testutil.AfterTest(t)
-
-	epc := setupEtcdctlTest(t, cfg, quorum)
-	defer func() {
-		if errC := epc.Close(); errC != nil {
-			t.Fatalf("error closing etcd processes (%v)", errC)
-		}
-	}()
-
-	key, value := "foo", "bar"
-
-	if err := etcdctlMk(epc, key, value, true); err != nil {
-		t.Fatalf("failed mk (%v)", err)
-	}
-	if err := etcdctlMk(epc, key, value, false); err != nil {
-		t.Fatalf("failed mk (%v)", err)
-	}
-
-	if err := etcdctlGet(epc, key, value, quorum); err != nil {
-		t.Fatalf("failed get (%v)", err)
-	}
-}
-
-func TestCtlV2Rm(t *testing.T)    { testCtlV2Rm(t, &configNoTLS) }
-func TestCtlV2RmTLS(t *testing.T) { testCtlV2Rm(t, &configTLS) }
-func testCtlV2Rm(t *testing.T, cfg *etcdProcessClusterConfig) {
-	defer testutil.AfterTest(t)
-
-	epc := setupEtcdctlTest(t, cfg, true)
-	defer func() {
-		if errC := epc.Close(); errC != nil {
-			t.Fatalf("error closing etcd processes (%v)", errC)
-		}
-	}()
-
-	key, value := "foo", "bar"
-
-	if err := etcdctlSet(epc, key, value); err != nil {
-		t.Fatalf("failed set (%v)", err)
-	}
-
-	if err := etcdctlRm(epc, key, value, true); err != nil {
-		t.Fatalf("failed rm (%v)", err)
-	}
-	if err := etcdctlRm(epc, key, value, false); err != nil {
-		t.Fatalf("failed rm (%v)", err)
-	}
-}
-
-func TestCtlV2Ls(t *testing.T)       { testCtlV2Ls(t, &configNoTLS, false) }
-func TestCtlV2LsQuorum(t *testing.T) { testCtlV2Ls(t, &configNoTLS, true) }
-func TestCtlV2LsTLS(t *testing.T)    { testCtlV2Ls(t, &configTLS, false) }
-func testCtlV2Ls(t *testing.T, cfg *etcdProcessClusterConfig, quorum bool) {
-	defer testutil.AfterTest(t)
-
-	epc := setupEtcdctlTest(t, cfg, quorum)
-	defer func() {
-		if errC := epc.Close(); errC != nil {
-			t.Fatalf("error closing etcd processes (%v)", errC)
-		}
-	}()
-
-	key, value := "foo", "bar"
-
-	if err := etcdctlSet(epc, key, value); err != nil {
-		t.Fatalf("failed set (%v)", err)
-	}
-
-	if err := etcdctlLs(epc, key, quorum); err != nil {
-		t.Fatalf("failed ls (%v)", err)
-	}
-}
-
-func TestCtlV2Watch(t *testing.T)                { testCtlV2Watch(t, &configNoTLS, false) }
-func TestCtlV2WatchTLS(t *testing.T)             { testCtlV2Watch(t, &configTLS, false) }
-func TestCtlV2WatchWithProxy(t *testing.T)       { testCtlV2Watch(t, &configWithProxy, false) }
-func TestCtlV2WatchWithProxyNoSync(t *testing.T) { testCtlV2Watch(t, &configWithProxy, true) }
-func testCtlV2Watch(t *testing.T, cfg *etcdProcessClusterConfig, noSync bool) {
-	defer testutil.AfterTest(t)
-
-	epc := setupEtcdctlTest(t, cfg, true)
-	defer func() {
-		if errC := epc.Close(); errC != nil {
-			t.Fatalf("error closing etcd processes (%v)", errC)
-		}
-	}()
-
-	key, value := "foo", "bar"
-	errc := etcdctlWatch(epc, key, value, noSync)
-	if err := etcdctlSet(epc, key, value); err != nil {
-		t.Fatalf("failed set (%v)", err)
-	}
-
-	select {
-	case err := <-errc:
-		if err != nil {
-			t.Fatalf("failed watch (%v)", err)
-		}
-	case <-time.After(5 * time.Second):
-		t.Fatalf("watch timed out")
-	}
-}
-
-func TestCtlV2GetRoleUser(t *testing.T)          { testCtlV2GetRoleUser(t, &configNoTLS) }
-func TestCtlV2GetRoleUserWithProxy(t *testing.T) { testCtlV2GetRoleUser(t, &configWithProxy) }
-
-func testCtlV2GetRoleUser(t *testing.T, cfg *etcdProcessClusterConfig) {
-	defer testutil.AfterTest(t)
-
-	epc := setupEtcdctlTest(t, cfg, true)
-	defer func() {
-		if err := epc.Close(); err != nil {
-			t.Fatalf("error closing etcd processes (%v)", err)
-		}
-	}()
-
-	// wait for the server capabilities to be updated based on the version;
-	// the update loop has a delay of 500ms, so 1s should be enough wait time
-	time.Sleep(time.Second)
-
-	if err := etcdctlRoleAdd(epc, "foo"); err != nil {
-		t.Fatalf("failed to add role (%v)", err)
-	}
-	if err := etcdctlUserAdd(epc, "username", "password"); err != nil {
-		t.Fatalf("failed to add user (%v)", err)
-	}
-	if err := etcdctlUserGrant(epc, "username", "foo"); err != nil {
-		t.Fatalf("failed to grant role (%v)", err)
-	}
-	if err := etcdctlUserGet(epc, "username"); err != nil {
-		t.Fatalf("failed to get user (%v)", err)
-	}
-}
-
-func TestCtlV2UserList(t *testing.T) {
-	defer testutil.AfterTest(t)
-
-	epc := setupEtcdctlTest(t, &configWithProxy, false)
-	defer func() {
-		if err := epc.Close(); err != nil {
-			t.Fatalf("error closing etcd processes (%v)", err)
-		}
-	}()
-
-	if err := etcdctlUserAdd(epc, "username", "password"); err != nil {
-		t.Fatalf("failed to add user (%v)", err)
-	}
-	if err := etcdctlUserList(epc, "username"); err != nil {
-		t.Fatalf("failed to list users (%v)", err)
-	}
-}
-
-func TestCtlV2RoleList(t *testing.T) {
-	defer testutil.AfterTest(t)
-
-	epc := setupEtcdctlTest(t, &configWithProxy, false)
-	defer func() {
-		if err := epc.Close(); err != nil {
-			t.Fatalf("error closing etcd processes (%v)", err)
-		}
-	}()
-
-	if err := etcdctlRoleAdd(epc, "foo"); err != nil {
-		t.Fatalf("failed to add role (%v)", err)
-	}
-	if err := etcdctlRoleList(epc, "foo"); err != nil {
-		t.Fatalf("failed to list roles (%v)", err)
-	}
-}
-
-func etcdctlPrefixArgs(clus *etcdProcessCluster) []string {
-	endpoints := ""
-	if proxies := clus.proxies(); len(proxies) != 0 {
-		endpoints = proxies[0].cfg.acurl
-	} else if backends := clus.backends(); len(backends) != 0 {
-		es := []string{}
-		for _, b := range backends {
-			es = append(es, b.cfg.acurl)
-		}
-		endpoints = strings.Join(es, ",")
-	}
-	cmdArgs := []string{"../bin/etcdctl", "--endpoints", endpoints}
-	if clus.cfg.clientTLS == clientTLS {
-		cmdArgs = append(cmdArgs, "--ca-file", caPath, "--cert-file", certPath, "--key-file", privateKeyPath)
-	}
-	return cmdArgs
-}
-
-func etcdctlSet(clus *etcdProcessCluster, key, value string) error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "set", key, value)
-	return spawnWithExpect(cmdArgs, value)
-}
-
-func etcdctlMk(clus *etcdProcessCluster, key, value string, first bool) error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "mk", key, value)
-	if first {
-		return spawnWithExpect(cmdArgs, value)
-	}
-	return spawnWithExpect(cmdArgs, "Error:  105: Key already exists")
-}
-
-func etcdctlGet(clus *etcdProcessCluster, key, value string, quorum bool) error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "get", key)
-	if quorum {
-		cmdArgs = append(cmdArgs, "--quorum")
-	}
-	return spawnWithExpect(cmdArgs, value)
-}
-
-func etcdctlRm(clus *etcdProcessCluster, key, value string, first bool) error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "rm", key)
-	if first {
-		return spawnWithExpect(cmdArgs, "PrevNode.Value: "+value)
-	}
-	return spawnWithExpect(cmdArgs, "Error:  100: Key not found")
-}
-
-func etcdctlLs(clus *etcdProcessCluster, key string, quorum bool) error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "ls")
-	if quorum {
-		cmdArgs = append(cmdArgs, "--quorum")
-	}
-	return spawnWithExpect(cmdArgs, key)
-}
-
-func etcdctlWatch(clus *etcdProcessCluster, key, value string, noSync bool) <-chan error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "watch", "--after-index 1", key)
-	if noSync {
-		cmdArgs = append(cmdArgs, "--no-sync")
-	}
-	errc := make(chan error, 1)
-	go func() {
-		errc <- spawnWithExpect(cmdArgs, value)
-	}()
-	return errc
-}
-
-func etcdctlRoleAdd(clus *etcdProcessCluster, role string) error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "role", "add", role)
-	return spawnWithExpect(cmdArgs, role)
-}
-
-func etcdctlRoleList(clus *etcdProcessCluster, expectedRole string) error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "role", "list")
-	return spawnWithExpect(cmdArgs, expectedRole)
-}
-
-func etcdctlUserAdd(clus *etcdProcessCluster, user, pass string) error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "user", "add", user+":"+pass)
-	return spawnWithExpect(cmdArgs, "User "+user+" created")
-}
-
-func etcdctlUserGrant(clus *etcdProcessCluster, user, role string) error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "user", "grant", "--roles", role, user)
-	return spawnWithExpect(cmdArgs, "User "+user+" updated")
-}
-
-func etcdctlUserGet(clus *etcdProcessCluster, user string) error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "user", "get", user)
-	return spawnWithExpect(cmdArgs, "User: "+user)
-}
-
-func etcdctlUserList(clus *etcdProcessCluster, expectedUser string) error {
-	cmdArgs := append(etcdctlPrefixArgs(clus), "user", "list")
-	return spawnWithExpect(cmdArgs, expectedUser)
-}
-
-func mustEtcdctl(t *testing.T) {
-	if !fileutil.Exist("../bin/etcdctl") {
-		t.Fatalf("could not find etcdctl binary")
-	}
-}
-
-func setupEtcdctlTest(t *testing.T, cfg *etcdProcessClusterConfig, quorum bool) *etcdProcessCluster {
-	mustEtcdctl(t)
-	if !quorum {
-		cfg = configStandalone(*cfg)
-	}
-	epc, err := newEtcdProcessCluster(cfg)
-	if err != nil {
-		t.Fatalf("could not start etcd process cluster (%v)", err)
-	}
-	return epc
-}
diff --git a/e2e/etcdctlv3_test.go b/e2e/etcdctlv3_test.go
deleted file mode 100644
index 96ed5b6..0000000
--- a/e2e/etcdctlv3_test.go
+++ /dev/null
@@ -1,524 +0,0 @@
-// Copyright 2016 CoreOS, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package e2e
-
-import (
-	"fmt"
-	"os"
-	"strings"
-	"testing"
-	"time"
-
-	"github.com/coreos/etcd/pkg/testutil"
-	"github.com/coreos/etcd/version"
-)
-
-func TestCtlV3Put(t *testing.T)          { testCtl(t, putTest) }
-func TestCtlV3PutNoTLS(t *testing.T)     { testCtl(t, putTest, withCfg(configNoTLS)) }
-func TestCtlV3PutClientTLS(t *testing.T) { testCtl(t, putTest, withCfg(configClientTLS)) }
-func TestCtlV3PutPeerTLS(t *testing.T)   { testCtl(t, putTest, withCfg(configPeerTLS)) }
-func TestCtlV3PutTimeout(t *testing.T)   { testCtl(t, putTest, withDialTimeout(0)) }
-
-func TestCtlV3Get(t *testing.T)          { testCtl(t, getTest) }
-func TestCtlV3GetNoTLS(t *testing.T)     { testCtl(t, getTest, withCfg(configNoTLS)) }
-func TestCtlV3GetClientTLS(t *testing.T) { testCtl(t, getTest, withCfg(configClientTLS)) }
-func TestCtlV3GetPeerTLS(t *testing.T)   { testCtl(t, getTest, withCfg(configPeerTLS)) }
-func TestCtlV3GetTimeout(t *testing.T)   { testCtl(t, getTest, withDialTimeout(0)) }
-func TestCtlV3GetQuorum(t *testing.T)    { testCtl(t, getTest, withQuorum()) }
-
-func TestCtlV3Del(t *testing.T)          { testCtl(t, delTest) }
-func TestCtlV3DelNoTLS(t *testing.T)     { testCtl(t, delTest, withCfg(configNoTLS)) }
-func TestCtlV3DelClientTLS(t *testing.T) { testCtl(t, delTest, withCfg(configClientTLS)) }
-func TestCtlV3DelPeerTLS(t *testing.T)   { testCtl(t, delTest, withCfg(configPeerTLS)) }
-func TestCtlV3DelTimeout(t *testing.T)   { testCtl(t, delTest, withDialTimeout(0)) }
-
-func TestCtlV3Watch(t *testing.T)          { testCtl(t, watchTest) }
-func TestCtlV3WatchNoTLS(t *testing.T)     { testCtl(t, watchTest, withCfg(configNoTLS)) }
-func TestCtlV3WatchClientTLS(t *testing.T) { testCtl(t, watchTest, withCfg(configClientTLS)) }
-func TestCtlV3WatchPeerTLS(t *testing.T)   { testCtl(t, watchTest, withCfg(configPeerTLS)) }
-func TestCtlV3WatchTimeout(t *testing.T)   { testCtl(t, watchTest, withDialTimeout(0)) }
-func TestCtlV3WatchInteractive(t *testing.T) {
-	testCtl(t, watchTest, withInteractive())
-}
-func TestCtlV3WatchInteractiveNoTLS(t *testing.T) {
-	testCtl(t, watchTest, withInteractive(), withCfg(configNoTLS))
-}
-func TestCtlV3WatchInteractiveClientTLS(t *testing.T) {
-	testCtl(t, watchTest, withInteractive(), withCfg(configClientTLS))
-}
-func TestCtlV3WatchInteractivePeerTLS(t *testing.T) {
-	testCtl(t, watchTest, withInteractive(), withCfg(configPeerTLS))
-}
-
-func TestCtlV3TxnInteractiveSuccess(t *testing.T) {
-	testCtl(t, txnTestSuccess, withInteractive())
-}
-func TestCtlV3TxnInteractiveSuccessNoTLS(t *testing.T) {
-	testCtl(t, txnTestSuccess, withInteractive(), withCfg(configNoTLS))
-}
-func TestCtlV3TxnInteractiveSuccessClientTLS(t *testing.T) {
-	testCtl(t, txnTestSuccess, withInteractive(), withCfg(configClientTLS))
-}
-func TestCtlV3TxnInteractiveSuccessPeerTLS(t *testing.T) {
-	testCtl(t, txnTestSuccess, withInteractive(), withCfg(configPeerTLS))
-}
-func TestCtlV3TxnInteractiveFail(t *testing.T) {
-	testCtl(t, txnTestFail, withInteractive())
-}
-
-func TestCtlV3Version(t *testing.T)        { testCtl(t, versionTest) }
-func TestCtlV3EpHealthQuorum(t *testing.T) { testCtl(t, epHealthTest, withQuorum()) }
-
-type ctlCtx struct {
-	t   *testing.T
-	cfg etcdProcessClusterConfig
-	epc *etcdProcessCluster
-
-	errc        chan error
-	dialTimeout time.Duration
-
-	quorum      bool // if true, set up 3-node cluster and linearizable read
-	interactive bool
-}
-
-type ctlOption func(*ctlCtx)
-
-func (cx *ctlCtx) applyOpts(opts []ctlOption) {
-	for _, opt := range opts {
-		opt(cx)
-	}
-}
-
-func withCfg(cfg etcdProcessClusterConfig) ctlOption {
-	return func(cx *ctlCtx) { cx.cfg = cfg }
-}
-
-func withDialTimeout(timeout time.Duration) ctlOption {
-	return func(cx *ctlCtx) { cx.dialTimeout = timeout }
-}
-
-func withQuorum() ctlOption {
-	return func(cx *ctlCtx) { cx.quorum = true }
-}
-
-func withInteractive() ctlOption {
-	return func(cx *ctlCtx) { cx.interactive = true }
-}
-
-func setupCtlV3Test(t *testing.T, cfg etcdProcessClusterConfig, quorum bool) *etcdProcessCluster {
-	mustEtcdctl(t)
-	if !quorum {
-		cfg = *configStandalone(cfg)
-	}
-	epc, err := newEtcdProcessCluster(&cfg)
-	if err != nil {
-		t.Fatalf("could not start etcd process cluster (%v)", err)
-	}
-	return epc
-}
-
-func testCtl(t *testing.T, testFunc func(ctlCtx), opts ...ctlOption) {
-	defer testutil.AfterTest(t)
-
-	ret := ctlCtx{
-		t:           t,
-		cfg:         configAutoTLS,
-		errc:        make(chan error, 1),
-		dialTimeout: 7 * time.Second,
-	}
-	ret.applyOpts(opts)
-
-	os.Setenv("ETCDCTL_API", "3")
-	ret.epc = setupCtlV3Test(ret.t, ret.cfg, ret.quorum)
-
-	defer func() {
-		os.Unsetenv("ETCDCTL_API")
-		if errC := ret.epc.Close(); errC != nil {
-			t.Fatalf("error closing etcd processes (%v)", errC)
-		}
-	}()
-
-	go testFunc(ret)
-
-	select {
-	case <-time.After(2*ret.dialTimeout + time.Second):
-		if ret.dialTimeout > 0 {
-			t.Fatalf("test timed out for %v", ret.dialTimeout)
-		}
-	case err := <-ret.errc:
-		if err != nil {
-			t.Fatal(err)
-		}
-	}
-	return
-}
-
-func putTest(cx ctlCtx) {
-	defer close(cx.errc)
-
-	key, value := "foo", "bar"
-
-	if err := ctlV3Put(cx, key, value); err != nil {
-		if cx.dialTimeout > 0 && isGRPCTimedout(err) {
-			cx.t.Fatalf("putTest ctlV3Put error (%v)", err)
-		}
-	}
-	if err := ctlV3Get(cx, []string{key}, kv{key, value}); err != nil {
-		if cx.dialTimeout > 0 && isGRPCTimedout(err) {
-			cx.t.Fatalf("putTest ctlV3Get error (%v)", err)
-		}
-	}
-}
-
-func getTest(cx ctlCtx) {
-	defer close(cx.errc)
-
-	var (
-		kvs    = []kv{{"key1", "val1"}, {"key2", "val2"}, {"key3", "val3"}}
-		revkvs = []kv{{"key3", "val3"}, {"key2", "val2"}, {"key1", "val1"}}
-	)
-
-	tests := []struct {
-		args []string
-
-		wkv []kv
-	}{
-		{[]string{"key1"}, []kv{{"key1", "val1"}}},
-		{[]string{"key", "--prefix"}, kvs},
-		{[]string{"key", "--prefix", "--limit=2"}, kvs[:2]},
-		{[]string{"key", "--prefix", "--order=ASCEND", "--sort-by=MODIFY"}, kvs},
-		{[]string{"key", "--prefix", "--order=ASCEND", "--sort-by=VERSION"}, kvs},
-		{[]string{"key", "--prefix", "--order=DESCEND", "--sort-by=CREATE"}, revkvs},
-		{[]string{"key", "--prefix", "--order=DESCEND", "--sort-by=KEY"}, revkvs},
-	}
-
-	for i := range kvs {
-		if err := ctlV3Put(cx, kvs[i].key, kvs[i].val); err != nil {
-			cx.t.Fatalf("getTest #%d: ctlV3Put error (%v)", i, err)
-		}
-	}
-	for i, tt := range tests {
-		if err := ctlV3Get(cx, tt.args, tt.wkv...); err != nil {
-			if cx.dialTimeout > 0 && isGRPCTimedout(err) {
-				cx.t.Errorf("getTest #%d: ctlV3Get error (%v)", i, err)
-			}
-		}
-	}
-}
-
-func delTest(cx ctlCtx) {
-	defer close(cx.errc)
-
-	tests := []struct {
-		puts []kv
-		args []string
-
-		deletedNum int
-	}{
-		{
-			[]kv{{"this", "value"}},
-			[]string{"that"},
-			0,
-		},
-		{
-			[]kv{{"sample", "value"}},
-			[]string{"sample"},
-			1,
-		},
-		{
-			[]kv{{"key1", "val1"}, {"key2", "val2"}, {"key3", "val3"}},
-			[]string{"key", "--prefix"},
-			3,
-		},
-	}
-
-	for i, tt := range tests {
-		for j := range tt.puts {
-			if err := ctlV3Put(cx, tt.puts[j].key, tt.puts[j].val); err != nil {
-				cx.t.Fatalf("delTest #%d-%d: ctlV3Put error (%v)", i, j, err)
-			}
-		}
-		if err := ctlV3Del(cx, tt.args, tt.deletedNum); err != nil {
-			if cx.dialTimeout > 0 && isGRPCTimedout(err) {
-				cx.t.Fatalf("delTest #%d: ctlV3Del error (%v)", i, err)
-			}
-		}
-	}
-}
-
-func watchTest(cx ctlCtx) {
-	defer close(cx.errc)
-
-	tests := []struct {
-		puts []kv
-		args []string
-
-		wkv []kv
-	}{
-		{
-			[]kv{{"sample", "value"}},
-			[]string{"sample", "--rev", "1"},
-			[]kv{{"sample", "value"}},
-		},
-		{
-			[]kv{{"key1", "val1"}, {"key2", "val2"}, {"key3", "val3"}},
-			[]string{"key", "--rev", "1", "--prefix"},
-			[]kv{{"key1", "val1"}, {"key2", "val2"}, {"key3", "val3"}},
-		},
-		{
-			[]kv{{"etcd", "revision_1"}, {"etcd", "revision_2"}, {"etcd", "revision_3"}},
-			[]string{"etcd", "--rev", "2"},
-			[]kv{{"etcd", "revision_2"}, {"etcd", "revision_3"}},
-		},
-	}
-
-	for i, tt := range tests {
-		go func() {
-			for j := range tt.puts {
-				if err := ctlV3Put(cx, tt.puts[j].key, tt.puts[j].val); err != nil {
-					cx.t.Fatalf("watchTest #%d-%d: ctlV3Put error (%v)", i, j, err)
-				}
-			}
-		}()
-		if err := ctlV3Watch(cx, tt.args, tt.wkv...); err != nil {
-			if cx.dialTimeout > 0 && isGRPCTimedout(err) {
-				cx.t.Errorf("watchTest #%d: ctlV3Watch error (%v)", i, err)
-			}
-		}
-	}
-}
-
-func versionTest(cx ctlCtx) {
-	defer close(cx.errc)
-
-	if err := ctlV3Version(cx); err != nil {
-		cx.t.Fatalf("versionTest ctlV3Version error (%v)", err)
-	}
-}
-
-func epHealthTest(cx ctlCtx) {
-	defer close(cx.errc)
-
-	if err := ctlV3EpHealth(cx); err != nil {
-		cx.t.Fatalf("epHealthTest ctlV3EpHealth error (%v)", err)
-	}
-}
-
-func txnTestSuccess(cx ctlCtx) {
-	defer close(cx.errc)
-
-	if err := ctlV3Put(cx, "key1", "value1"); err != nil {
-		cx.t.Fatalf("txnTestSuccess ctlV3Put error (%v)", err)
-	}
-	if err := ctlV3Put(cx, "key2", "value2"); err != nil {
-		cx.t.Fatalf("txnTestSuccess ctlV3Put error (%v)", err)
-	}
-
-	rqs := txnRequests{
-		compare:  []string{`version("key1") = "1"`, `version("key2") = "1"`},
-		ifSucess: []string{"get key1", "get key2"},
-		ifFail:   []string{`put key1 "fail"`, `put key2 "fail"`},
-		results:  []string{"SUCCESS", "key1", "value1", "key2", "value2"},
-	}
-	if err := ctlV3Txn(cx, rqs); err != nil {
-		cx.t.Fatal(err)
-	}
-}
-
-func txnTestFail(cx ctlCtx) {
-	defer close(cx.errc)
-
-	rqs := txnRequests{
-		compare:  []string{`version("key") < "0"`},
-		ifSucess: []string{`put key "success"`},
-		ifFail:   []string{`put key "fail"`},
-		results:  []string{"FAILURE", "OK"},
-	}
-	if err := ctlV3Txn(cx, rqs); err != nil {
-		cx.t.Fatal(err)
-	}
-}
-
-func ctlV3PrefixArgs(clus *etcdProcessCluster, dialTimeout time.Duration) []string {
-	if len(clus.proxies()) > 0 { // TODO: add proxy check as in v2
-		panic("v3 proxy not implemented")
-	}
-
-	endpoints := ""
-	if backends := clus.backends(); len(backends) != 0 {
-		es := []string{}
-		for _, b := range backends {
-			es = append(es, stripSchema(b.cfg.acurl))
-		}
-		endpoints = strings.Join(es, ",")
-	}
-	cmdArgs := []string{"../bin/etcdctl", "--endpoints", endpoints, "--dial-timeout", dialTimeout.String()}
-	if clus.cfg.clientTLS == clientTLS {
-		cmdArgs = append(cmdArgs, "--cacert", caPath, "--cert", certPath, "--key", privateKeyPath)
-	}
-	return cmdArgs
-}
-
-func ctlV3Put(cx ctlCtx, key, value string) error {
-	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "put", key, value)
-	return spawnWithExpect(cmdArgs, "OK")
-}
-
-type kv struct {
-	key, val string
-}
-
-func ctlV3Get(cx ctlCtx, args []string, kvs ...kv) error {
-	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "get")
-	cmdArgs = append(cmdArgs, args...)
-	if !cx.quorum {
-		cmdArgs = append(cmdArgs, "--consistency", "s")
-	}
-	var lines []string
-	for _, elem := range kvs {
-		lines = append(lines, elem.key, elem.val)
-	}
-	return spawnWithExpects(cmdArgs, lines...)
-}
-
-func ctlV3Del(cx ctlCtx, args []string, num int) error {
-	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "del")
-	cmdArgs = append(cmdArgs, args...)
-	return spawnWithExpects(cmdArgs, fmt.Sprintf("%d", num))
-}
-
-func ctlV3Watch(cx ctlCtx, args []string, kvs ...kv) error {
-	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "watch")
-	if cx.interactive {
-		cmdArgs = append(cmdArgs, "--interactive")
-	} else {
-		cmdArgs = append(cmdArgs, args...)
-	}
-
-	proc, err := spawnCmd(cmdArgs)
-	if err != nil {
-		return err
-	}
-
-	if cx.interactive {
-		wl := strings.Join(append([]string{"watch"}, args...), " ") + "\r"
-		if err = proc.Send(wl); err != nil {
-			return err
-		}
-	}
-
-	for _, elem := range kvs {
-		if _, err = proc.Expect(elem.key); err != nil {
-			return err
-		}
-		if _, err = proc.Expect(elem.val); err != nil {
-			return err
-		}
-	}
-	return proc.Stop()
-}
-
-type txnRequests struct {
-	compare  []string
-	ifSucess []string
-	ifFail   []string
-	results  []string
-}
-
-func ctlV3Txn(cx ctlCtx, rqs txnRequests) error {
-	// TODO: support non-interactive mode
-	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "txn")
-	if cx.interactive {
-		cmdArgs = append(cmdArgs, "--interactive")
-	}
-	proc, err := spawnCmd(cmdArgs)
-	if err != nil {
-		return err
-	}
-	_, err = proc.Expect("compares:")
-	if err != nil {
-		return err
-	}
-	for _, req := range rqs.compare {
-		if err = proc.Send(req + "\r"); err != nil {
-			return err
-		}
-	}
-	if err = proc.Send("\r"); err != nil {
-		return err
-	}
-
-	_, err = proc.Expect("success requests (get, put, delete):")
-	if err != nil {
-		return err
-	}
-	for _, req := range rqs.ifSucess {
-		if err = proc.Send(req + "\r"); err != nil {
-			return err
-		}
-	}
-	if err = proc.Send("\r"); err != nil {
-		return err
-	}
-
-	_, err = proc.Expect("failure requests (get, put, delete):")
-	if err != nil {
-		return err
-	}
-	for _, req := range rqs.ifFail {
-		if err = proc.Send(req + "\r"); err != nil {
-			return err
-		}
-	}
-	if err = proc.Send("\r"); err != nil {
-		return err
-	}
-
-	for _, line := range rqs.results {
-		_, err = proc.Expect(line)
-		if err != nil {
-			return err
-		}
-	}
-	return proc.Close()
-}
-
-func ctlV3Version(cx ctlCtx) error {
-	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "version")
-	return spawnWithExpect(cmdArgs, version.Version)
-}
-
-func ctlV3EpHealth(cx ctlCtx) error {
-	cmdArgs := append(ctlV3PrefixArgs(cx.epc, cx.dialTimeout), "endpoint-health")
-	lines := make([]string, cx.epc.cfg.clusterSize)
-	for i := range lines {
-		lines[i] = "is healthy"
-	}
-	return spawnWithExpects(cmdArgs, lines...)
-}
-
-func isGRPCTimedout(err error) bool {
-	return strings.Contains(err.Error(), "grpc: timed out trying to connect")
-}
-
-func stripSchema(s string) string {
-	if strings.HasPrefix(s, "http://") {
-		s = strings.Replace(s, "http://", "", -1)
-	}
-	if strings.HasPrefix(s, "https://") {
-		s = strings.Replace(s, "https://", "", -1)
-	}
-	return s
-}
