commit eb3351533a816fbfe5adcc2a9a162bb668720389
Author: Anthony Romano <anthony.romano@coreos.com>
Date:   Wed Mar 30 12:30:03 2016 -0700

    godep: remove gexpect

diff --git a/Godeps/Godeps.json b/Godeps/Godeps.json
index b74aedc..1f8c18d 100644
--- a/Godeps/Godeps.json
+++ b/Godeps/Godeps.json
@@ -38,10 +38,6 @@
 			"Rev": "b5232bb2934f606f9f27a1305f1eea224e8e8b88"
 		},
 		{
-			"ImportPath": "github.com/coreos/gexpect",
-			"Rev": "5173270e159f5aa8fbc999dc7e3dcb50f4098a69"
-		},
-		{
 			"ImportPath": "github.com/coreos/go-semver/semver",
 			"Rev": "568e959cd89871e61434c1143528d9162da89ef2"
 		},
diff --git a/vendor/github.com/coreos/gexpect/LICENCE b/vendor/github.com/coreos/gexpect/LICENCE
deleted file mode 100644
index 50adb0f..0000000
--- a/vendor/github.com/coreos/gexpect/LICENCE
+++ /dev/null
@@ -1,7 +0,0 @@
-Copyright (C) 2014 Thomas Rooney
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff --git a/vendor/github.com/coreos/gexpect/README.md b/vendor/github.com/coreos/gexpect/README.md
deleted file mode 100644
index 2784b01..0000000
--- a/vendor/github.com/coreos/gexpect/README.md
+++ /dev/null
@@ -1,64 +0,0 @@
-# Gexpect
-
-Gexpect is a pure golang expect-like module.
-
-It makes it simpler to create and control other terminal applications.
-
-	child, err := gexpect.Spawn("python")
-	if err != nil {
-		panic(err)
-	}
-	child.Expect(">>>")
-	child.SendLine("print 'Hello World'")
-	child.Interact()
-	child.Close()
-
-## Examples
-
-`Spawn` handles the argument parsing from a string
-
-	child.Spawn("/bin/sh -c 'echo \"my complicated command\" | tee log | cat > log2'")
-	child.ReadLine() // ReadLine() (string, error)
-	child.ReadUntil(' ') // ReadUntil(delim byte) ([]byte, error)
-
-`ReadLine`, `ReadUntil` and `SendLine` send strings from/to `stdout/stdin` respectively
-
-	child := gexpect.Spawn("cat")
-	child.SendLine("echoing process_stdin") //  SendLine(command string) (error)
-	msg, _ := child.ReadLine() // msg = echoing process_stdin
-
-`Wait` and `Close` allow for graceful and ungraceful termination.
-
-	child.Wait() // Waits until the child terminates naturally.
-	child.Close() // Sends a kill command
-
-`AsyncInteractChannels` spawns two go routines to pipe into and from `stdout`/`stdin`, allowing for some usecases to be a little simpler.
-
-	child := gexpect.spawn("sh")
-	sender, reciever := child.AsyncInteractChannels()
-	sender <- "echo Hello World\n" // Send to stdin
-	line, open := <- reciever // Recieve a line from stdout/stderr
-	// When the subprocess stops (e.g. with child.Close()) , receiver is closed
-	if open {
-		fmt.Printf("Received %s", line)]
-	}
-
-`ExpectRegex` uses golang's internal regex engine to wait until a match from the process with the given regular expression (or an error on process termination with no match).
-
-	child := gexpect.Spawn("echo accb")	
-	match, _ := child.ExpectRegex("a..b")
-	// (match=true)
-
-`ExpectRegexFind` allows for groups to be extracted from process stdout. The first element is an array of containing the total matched text, followed by each subexpression group match.
-
-	child := gexpect.Spawn("echo 123 456 789")
-	result, _ := child.ExpectRegexFind("\d+ (\d+) (\d+)")
-	// result = []string{"123 456 789", "456", "789"}
-
-See `gexpect_test.go` and the `examples` folder for full syntax
-
-## Credits
-
-	github.com/kballard/go-shellquote	
-	github.com/kr/pty
-	KMP Algorithm: "http://blog.databigbang.com/searching-for-substrings-in-streams-a-slight-modification-of-the-knuth-morris-pratt-algorithm-in-haxe/"
\ No newline at end of file
diff --git a/vendor/github.com/coreos/gexpect/gexpect.go b/vendor/github.com/coreos/gexpect/gexpect.go
deleted file mode 100644
index ab6287b..0000000
--- a/vendor/github.com/coreos/gexpect/gexpect.go
+++ /dev/null
@@ -1,430 +0,0 @@
-package gexpect
-
-import (
-	"bytes"
-	"errors"
-	"fmt"
-	"io"
-	"os"
-	"os/exec"
-	"regexp"
-	"time"
-	"unicode/utf8"
-
-	shell "github.com/kballard/go-shellquote"
-	"github.com/kr/pty"
-)
-
-type ExpectSubprocess struct {
-	Cmd          *exec.Cmd
-	buf          *buffer
-	outputBuffer []byte
-}
-
-type buffer struct {
-	f       *os.File
-	b       bytes.Buffer
-	collect bool
-
-	collection bytes.Buffer
-}
-
-func (buf *buffer) StartCollecting() {
-	buf.collect = true
-}
-
-func (buf *buffer) StopCollecting() (result string) {
-	result = string(buf.collection.Bytes())
-	buf.collect = false
-	buf.collection.Reset()
-	return result
-}
-
-func (buf *buffer) Read(chunk []byte) (int, error) {
-	nread := 0
-	if buf.b.Len() > 0 {
-		n, err := buf.b.Read(chunk)
-		if err != nil {
-			return n, err
-		}
-		if n == len(chunk) {
-			return n, nil
-		}
-		nread = n
-	}
-	fn, err := buf.f.Read(chunk[nread:])
-	return fn + nread, err
-}
-
-func (buf *buffer) ReadRune() (r rune, size int, err error) {
-	l := buf.b.Len()
-
-	chunk := make([]byte, utf8.UTFMax)
-	if l > 0 {
-		n, err := buf.b.Read(chunk)
-		if err != nil {
-			return 0, 0, err
-		}
-		if utf8.FullRune(chunk) {
-			r, rL := utf8.DecodeRune(chunk)
-			if n > rL {
-				buf.PutBack(chunk[rL:n])
-			}
-			if buf.collect {
-				buf.collection.WriteRune(r)
-			}
-			return r, rL, nil
-		}
-	}
-	// else add bytes from the file, then try that
-	for l < utf8.UTFMax {
-		fn, err := buf.f.Read(chunk[l : l+1])
-		if err != nil {
-			return 0, 0, err
-		}
-		l = l + fn
-
-		if utf8.FullRune(chunk) {
-			r, rL := utf8.DecodeRune(chunk)
-			if buf.collect {
-				buf.collection.WriteRune(r)
-			}
-			return r, rL, nil
-		}
-	}
-	return 0, 0, errors.New("File is not a valid UTF=8 encoding")
-}
-
-func (buf *buffer) PutBack(chunk []byte) {
-	if len(chunk) == 0 {
-		return
-	}
-	if buf.b.Len() == 0 {
-		buf.b.Write(chunk)
-		return
-	}
-	d := make([]byte, 0, len(chunk)+buf.b.Len())
-	d = append(d, chunk...)
-	d = append(d, buf.b.Bytes()...)
-	buf.b.Reset()
-	buf.b.Write(d)
-}
-
-func SpawnAtDirectory(command string, directory string) (*ExpectSubprocess, error) {
-	expect, err := _spawn(command)
-	if err != nil {
-		return nil, err
-	}
-	expect.Cmd.Dir = directory
-	return _start(expect)
-}
-
-func Command(command string) (*ExpectSubprocess, error) {
-	expect, err := _spawn(command)
-	if err != nil {
-		return nil, err
-	}
-	return expect, nil
-}
-
-func (expect *ExpectSubprocess) Start() error {
-	_, err := _start(expect)
-	return err
-}
-
-func Spawn(command string) (*ExpectSubprocess, error) {
-	expect, err := _spawn(command)
-	if err != nil {
-		return nil, err
-	}
-	return _start(expect)
-}
-
-func (expect *ExpectSubprocess) Close() error {
-	return expect.Cmd.Process.Kill()
-}
-
-func (expect *ExpectSubprocess) AsyncInteractChannels() (send chan string, receive chan string) {
-	receive = make(chan string)
-	send = make(chan string)
-
-	go func() {
-		for {
-			str, err := expect.ReadLine()
-			if err != nil {
-				close(receive)
-				return
-			}
-			receive <- str
-		}
-	}()
-
-	go func() {
-		for {
-			select {
-			case sendCommand, exists := <-send:
-				{
-					if !exists {
-						return
-					}
-					err := expect.Send(sendCommand)
-					if err != nil {
-						receive <- "gexpect Error: " + err.Error()
-						return
-					}
-				}
-			}
-		}
-	}()
-
-	return
-}
-
-func (expect *ExpectSubprocess) ExpectRegex(regex string) (bool, error) {
-	return regexp.MatchReader(regex, expect.buf)
-}
-
-func (expect *ExpectSubprocess) expectRegexFind(regex string, output bool) ([]string, string, error) {
-	re, err := regexp.Compile(regex)
-	if err != nil {
-		return nil, "", err
-	}
-	expect.buf.StartCollecting()
-	pairs := re.FindReaderSubmatchIndex(expect.buf)
-	stringIndexedInto := expect.buf.StopCollecting()
-	l := len(pairs)
-	numPairs := l / 2
-	result := make([]string, numPairs)
-	for i := 0; i < numPairs; i += 1 {
-		result[i] = stringIndexedInto[pairs[i*2]:pairs[i*2+1]]
-	}
-	// convert indexes to strings
-
-	if len(result) == 0 {
-		err = fmt.Errorf("ExpectRegex didn't find regex '%v'.", regex)
-	}
-	return result, stringIndexedInto, err
-}
-
-func (expect *ExpectSubprocess) expectTimeoutRegexFind(regex string, timeout time.Duration) (result []string, out string, err error) {
-	t := make(chan bool)
-	go func() {
-		result, out, err = expect.ExpectRegexFindWithOutput(regex)
-		t <- false
-	}()
-	go func() {
-		time.Sleep(timeout)
-		err = fmt.Errorf("ExpectRegex timed out after %v finding '%v'.\nOutput:\n%s", timeout, regex, expect.Collect())
-		t <- true
-	}()
-	<-t
-	return result, out, err
-}
-
-func (expect *ExpectSubprocess) ExpectRegexFind(regex string) ([]string, error) {
-	result, _, err := expect.expectRegexFind(regex, false)
-	return result, err
-}
-
-func (expect *ExpectSubprocess) ExpectTimeoutRegexFind(regex string, timeout time.Duration) ([]string, error) {
-	result, _, err := expect.expectTimeoutRegexFind(regex, timeout)
-	return result, err
-}
-
-func (expect *ExpectSubprocess) ExpectRegexFindWithOutput(regex string) ([]string, string, error) {
-	return expect.expectRegexFind(regex, true)
-}
-
-func (expect *ExpectSubprocess) ExpectTimeoutRegexFindWithOutput(regex string, timeout time.Duration) ([]string, string, error) {
-	return expect.expectTimeoutRegexFind(regex, timeout)
-}
-
-func buildKMPTable(searchString string) []int {
-	pos := 2
-	cnd := 0
-	length := len(searchString)
-
-	var table []int
-	if length < 2 {
-		length = 2
-	}
-
-	table = make([]int, length)
-	table[0] = -1
-	table[1] = 0
-
-	for pos < len(searchString) {
-		if searchString[pos-1] == searchString[cnd] {
-			cnd += 1
-			table[pos] = cnd
-			pos += 1
-		} else if cnd > 0 {
-			cnd = table[cnd]
-		} else {
-			table[pos] = 0
-			pos += 1
-		}
-	}
-	return table
-}
-
-func (expect *ExpectSubprocess) ExpectTimeout(searchString string, timeout time.Duration) (e error) {
-	result := make(chan error)
-	go func() {
-		result <- expect.Expect(searchString)
-	}()
-	select {
-	case e = <-result:
-	case <-time.After(timeout):
-		e = fmt.Errorf("Expect timed out after %v waiting for '%v'.\nOutput:\n%s", timeout, searchString, expect.Collect())
-	}
-	return e
-}
-
-func (expect *ExpectSubprocess) Expect(searchString string) (e error) {
-	chunk := make([]byte, len(searchString)*2)
-	target := len(searchString)
-	if expect.outputBuffer != nil {
-		expect.outputBuffer = expect.outputBuffer[0:]
-	}
-	m := 0
-	i := 0
-	// Build KMP Table
-	table := buildKMPTable(searchString)
-
-	for {
-		n, err := expect.buf.Read(chunk)
-
-		if err != nil {
-			return err
-		}
-		if expect.outputBuffer != nil {
-			expect.outputBuffer = append(expect.outputBuffer, chunk[:n]...)
-		}
-		offset := m + i
-		for m+i-offset < n {
-			if searchString[i] == chunk[m+i-offset] {
-				i += 1
-				if i == target {
-					unreadIndex := m + i - offset
-					if len(chunk) > unreadIndex {
-						expect.buf.PutBack(chunk[unreadIndex:])
-					}
-					return nil
-				}
-			} else {
-				m += i - table[i]
-				if table[i] > -1 {
-					i = table[i]
-				} else {
-					i = 0
-				}
-			}
-		}
-	}
-}
-
-func (expect *ExpectSubprocess) Send(command string) error {
-	_, err := io.WriteString(expect.buf.f, command)
-	return err
-}
-
-func (expect *ExpectSubprocess) Capture() {
-	if expect.outputBuffer == nil {
-		expect.outputBuffer = make([]byte, 0)
-	}
-}
-
-func (expect *ExpectSubprocess) Collect() []byte {
-	collectOutput := make([]byte, len(expect.outputBuffer))
-	copy(collectOutput, expect.outputBuffer)
-	expect.outputBuffer = nil
-	return collectOutput
-}
-
-func (expect *ExpectSubprocess) SendLine(command string) error {
-	_, err := io.WriteString(expect.buf.f, command+"\r\n")
-	return err
-}
-
-func (expect *ExpectSubprocess) Interact() {
-	defer expect.Cmd.Wait()
-	io.Copy(os.Stdout, &expect.buf.b)
-	go io.Copy(os.Stdout, expect.buf.f)
-	go io.Copy(expect.buf.f, os.Stdin)
-}
-
-func (expect *ExpectSubprocess) ReadUntil(delim byte) ([]byte, error) {
-	join := make([]byte, 1, 512)
-	chunk := make([]byte, 255)
-
-	for {
-
-		n, err := expect.buf.Read(chunk)
-
-		if err != nil {
-			return join, err
-		}
-
-		for i := 0; i < n; i++ {
-			if chunk[i] == delim {
-				if len(chunk) > i+1 {
-					expect.buf.PutBack(chunk[i+1:])
-				}
-				return join, nil
-			} else {
-				join = append(join, chunk[i])
-			}
-		}
-	}
-}
-
-func (expect *ExpectSubprocess) Wait() error {
-	return expect.Cmd.Wait()
-}
-
-func (expect *ExpectSubprocess) ReadLine() (string, error) {
-	str, err := expect.ReadUntil('\n')
-	if err != nil {
-		return "", err
-	}
-	return string(str), nil
-}
-
-func _start(expect *ExpectSubprocess) (*ExpectSubprocess, error) {
-	f, err := pty.Start(expect.Cmd)
-	if err != nil {
-		return nil, err
-	}
-	expect.buf.f = f
-
-	return expect, nil
-}
-
-func _spawn(command string) (*ExpectSubprocess, error) {
-	wrapper := new(ExpectSubprocess)
-
-	wrapper.outputBuffer = nil
-
-	splitArgs, err := shell.Split(command)
-	if err != nil {
-		return nil, err
-	}
-	numArguments := len(splitArgs) - 1
-	if numArguments < 0 {
-		return nil, errors.New("gexpect: No command given to spawn")
-	}
-	path, err := exec.LookPath(splitArgs[0])
-	if err != nil {
-		return nil, err
-	}
-
-	if numArguments >= 1 {
-		wrapper.Cmd = exec.Command(path, splitArgs[1:]...)
-	} else {
-		wrapper.Cmd = exec.Command(path)
-	}
-	wrapper.buf = new(buffer)
-
-	return wrapper, nil
-}
